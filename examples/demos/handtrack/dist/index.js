(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var xs = require("xstream").default;
var handTrack = require("handtrackjs/dist/handtrack.min.js"); // copied from v0.0.13
var makeHandTrackDriver = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.model, model = _c === void 0 ? null : _c, _d = _b.modelParams, modelParams = _d === void 0 ? {} : _d;
    modelParams = __assign({ flipHorizontal: true, maxNumBoxes: 2, iouThreshold: 0.5, scoreThreshold: 0.6 }, modelParams);
    var runDetection = function (model, video, canvas, listener) {
        var context = canvas.getContext("2d");
        var runDetectionHelper = function () {
            model.detect(video).then(function (predictions) {
                listener.next(predictions);
                model.renderPredictions(predictions, canvas, context, video);
                requestAnimationFrame(runDetectionHelper);
            });
        };
        runDetectionHelper();
    };
    return function (command$) {
        var output$ = xs.create({
            start: function (listener) {
                command$.addListener({
                    next: function (cmd) {
                        if (cmd.type === "start") {
                            var _a = cmd.elems, video_1 = _a[0], canvas_1 = _a[1];
                            handTrack.startVideo(video_1).then(function (status) {
                                if (status) {
                                    if (!model) {
                                        handTrack.load(modelParams).then(function (model) {
                                            runDetection(model, video_1, canvas_1, listener);
                                        });
                                    }
                                    else {
                                        runDetection(model, video_1, canvas_1, listener);
                                    }
                                }
                                else {
                                    listener.error("Cannot start video");
                                }
                            });
                        }
                    }
                });
            },
            stop: function () { }
        });
        return output$;
    };
};
exports.makeHandTrackDriver = makeHandTrackDriver;

},{"handtrackjs/dist/handtrack.min.js":2,"xstream":5}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate){
(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.handTrack={}))})(this,function(exports){"use strict";/**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */var _Mathpow=Math.pow,_Mathlog=Math.log,_NumberisInteger=Number.isInteger,_StringfromCharCode=String.fromCharCode,_NumberNEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,_Mathsin=Math.sin,_Mathcos=Math.cos,_MathPI=Math.PI,_Mathabs=Math.abs,_Mathceil=Math.ceil,_NumberMAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER,_NumberMIN_SAFE_INTEGER=Number.MIN_SAFE_INTEGER,_Mathround=Math.round,_Mathfloor=Math.floor,_Mathsqrt=Math.sqrt,_Mathexp=Math.exp,_Mathmax=Math.max,_Mathmin=Math.min;function __extends(a,e){function t(){this.constructor=a}extendStatics(a,e),a.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}function __awaiter(p,e,t,l){return new(t||(t=Promise))(function(n,r){function a(t){try{s(l.next(t))}catch(t){r(t)}}function o(t){try{s(l.throw(t))}catch(t){r(t)}}function s(r){r.done?n(r.value):new t(function(e){e(r.value)}).then(a,o)}s((l=l.apply(p,e||[])).next())})}function __generator(p,e){function t(t){return function(a){return function(t){if(l)throw new TypeError("Generator is already executing.");for(;s;)try{if(l=1,d&&(u=2&t[0]?d.return:t[0]?d.throw||((u=d.return)&&u.call(d),0):d.next)&&!(u=u.call(d,t[1])).done)return u;switch(d=0,u&&(t=[2&t[0],u.value]),t[0]){case 0:case 1:u=t;break;case 4:return s.label++,{value:t[1],done:!1};case 5:s.label++,d=t[1],t=[0];continue;case 7:t=s.ops.pop(),s.trys.pop();continue;default:if(!(u=0<(u=s.trys).length&&u[u.length-1])&&(6===t[0]||2===t[0])){s=0;continue}if(3===t[0]&&(!u||t[1]>u[0]&&t[1]<u[3])){s.label=t[1];break}if(6===t[0]&&s.label<u[1]){s.label=u[1],u=t;break}if(u&&s.label<u[2]){s.label=u[2],s.ops.push(t);break}u[2]&&s.ops.pop(),s.trys.pop();continue;}t=e.call(p,s)}catch(a){t=[6,a],d=0}finally{l=u=0}if(5&t[0])throw t[1];return{value:t[0]?t[1]:void 0,done:!0}}([t,a])}}var s={label:0,sent:function(){if(1&u[0])throw u[1];return u[1]},trys:[],ops:[]},l,d,u,c;return c={next:t(0),throw:t(1),return:t(2)},"function"==typeof Symbol&&(c[Symbol.iterator]=function(){return this}),c}function getWebGLContext(a){a in contexts||(document.createElement("canvas").addEventListener("webglcontextlost",function(e){e.preventDefault(),delete contexts[a]},!1),contexts[a]=getWebGLRenderingContext(a));var e=contexts[a];return e.isContextLost()?(delete contexts[a],getWebGLContext(a)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),contexts[a])}function getWebGLRenderingContext(a){if(1!==a&&2!==a)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var e=document.createElement("canvas");return 1===a?e.getContext("webgl",WEBGL_ATTRIBUTES)||e.getContext("experimental-webgl",WEBGL_ATTRIBUTES):e.getContext("webgl2",WEBGL_ATTRIBUTES)}function isMobile(){var t=navigator.userAgent||navigator.vendor||window.opera;return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}function shuffle(a){for(var e=a.length,o=0,s=0;0<e;)s=0|Math.random()*e,o=a[--e],a[e]=a[s],a[s]=o}function clamp(a,e,t){return _Mathmax(a,_Mathmin(e,t))}function nearestLargerEven(t){return 0==t%2?t:t+1}function sum(a){for(var e=0,n=0;n<a.length;n++)e+=a[n];return e}function randUniform(a,e){var t=Math.random();return e*t+(1-t)*a}function distSquared(a,e){for(var t=0,s=0,i;s<a.length;s++)i=+a[s]-+e[s],t+=i*i;return t}function assert(a,e){if(!a)throw new Error("string"==typeof e?e:e())}function assertShapesMatch(a,e,t){void 0===t&&(t=""),assert(arraysEqual(a,e),t+" Shapes "+a+" and "+e+" must match")}function assertNonNull(t){assert(null!=t,"The input to the tensor constructor must be a non-null value.")}function flatten(a,e){if(void 0===e&&(e=[]),Array.isArray(a))for(var n=0;n<a.length;++n)flatten(a[n],e);else e.push(a);return e}function sizeFromShape(a){if(0===a.length)return 1;for(var e=a[0],n=1;n<a.length;n++)e*=a[n];return e}function isScalarShape(t){return 0===t.length}function arraysEqual(a,e){if(a===e)return!0;if(null==a||null==e)return!1;if(a.length!==e.length)return!1;for(var t=0;t<a.length;t++)if(a[t]!==e[t])return!1;return!0}function isInt(t){return 0==t%1}function tanh(a){var e=Math.tanh;if(null!=e)return e(a);if(a===1/0)return 1;if(a===-1/0)return-1;var n=_Mathexp(2*a);return(n-1)/(n+1)}function sizeToSquarishShape(a){for(var e=_Mathfloor(_Mathsqrt(a));1<e;--e)if(0==a%e)return[e,a/e];return[1,a]}function createShuffledIndices(a){for(var e=new Uint32Array(a),t=0;t<a;++t)e[t]=t;return shuffle(e),e}function rightPad(a,e){return e<=a.length?a:a+" ".repeat(e-a.length)}function repeatedTry(p,e,n){return void 0===e&&(e=function(){return 0}),new Promise(function(t,r){var o=0,l=function(){if(p())t();else{var a=e(++o);null!=n&&o>=n?r():setTimeout(l,a)}};l()})}function inferFromImplicitShape(s,e){for(var t=1,i=-1,p=0;p<s.length;++p)if(0<=s[p])t*=s[p];else if(-1===s[p]){if(-1!=i)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+i+" and dim "+p);i=p}else if(0>s[p])throw Error("Shapes can not be < 0. Found "+s[p]+" at dim "+p);if(-1==i){if(0<e&&e!==t)throw Error("Size("+e+") must match the product of shape "+s);return s}if(0===t)throw Error("Cannot infer the missing size in ["+s+"] when there are 0 elements");if(0!=e%t)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+t);var l=s.slice();return l[i]=e/t,l}function squeezeShape(s,e){for(var t=[],r=[],n=0,i=0;i<s.length;++i){if(null!=e){if(e[n]===i&&1!==s[i])throw new Error("Can't squeeze axis "+i+" since its dim '"+s[i]+"' is not 1");(null==e[n]||e[n]>i)&&1===s[i]&&(t.push(s[i]),r.push(i)),e[n]<=i&&n++}1!==s[i]&&(t.push(s[i]),r.push(i))}return{newShape:t,keptDims:r}}function getTypedArrayFromDType(a,e){var t=null;if(null==a||"float32"===a)t=new Float32Array(e);else if("int32"===a)t=new Int32Array(e);else{if("bool"!==a)throw new Error("Unknown data type "+a);t=new Uint8Array(e)}return t}function checkComputationForNaN(a,e,t){if("float32"===e)for(var r=0;r<a.length;r++)if(isNaN(a[r]))throw Error("The result of the '"+t+"' has NaNs.")}function checkConversionForNaN(a,e){if("float32"!==e)for(var t=0;t<a.length;t++)if(isNaN(a[t]))throw Error("NaN is not a valid value for dtype: '"+e+"'.")}function hasEncodingLoss(a,e){return"complex64"!==e&&("float32"!==e||"complex64"===a)&&("int32"!==e||"float32"===a||"complex64"===a)&&("bool"!==e||"bool"!==a)}function copyTypedArray(a,e,t){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(a);if("int32"===e)return t&&checkConversionForNaN(a,e),new Int32Array(a);if("bool"===e){for(var r=new Uint8Array(a.length),n=0;n<r.length;++n)0!==_Mathround(a[n])&&(r[n]=1);return r}throw new Error("Unknown data type "+e)}function isTypedArray(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function bytesPerElement(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function isFunction(t){return!!(t&&t.constructor&&t.call&&t.apply)}function nearestDivisor(a,e){for(var t=e;t<a;++t)if(0==a%t)return t;return a}function computeStrides(a){var e=a.length;if(2>e)return[];var t=Array(e-1);t[e-2]=a[e-1];for(var r=e-3;0<=r;--r)t[r]=t[r+1]*a[r+1];return t}function toTypedArray(a,n,t){return noConversionNeeded(a,n)?a:(Array.isArray(a)&&(a=flatten(a)),copyTypedArray(a,n,t))}function noConversionNeeded(a,e){return a instanceof Float32Array&&"float32"===e||a instanceof Int32Array&&"int32"===e||a instanceof Uint8Array&&"bool"===e}function makeOnesTypedArray(a,e){for(var t=makeZerosTypedArray(a,e),r=0;r<t.length;r++)t[r]=1;return t}function makeZerosTypedArray(a,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(a);if("int32"===e)return new Int32Array(a);if("bool"===e)return new Uint8Array(a);throw new Error("Unknown data type "+e)}function now(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")}function tensorToString(p,e,t,r){var n=computeStrides(e),o=computeMaxSizePerColumn(p,e,t,n),a=e.length,i=subTensorToString(p,e,t,n,o),s=["Tensor"];return r&&(s.push("  dtype: "+t),s.push("  rank: "+a),s.push("  shape: ["+e+"]"),s.push("  values:")),s.push(i.map(function(t){return"    "+t}).join("\n")),s.join("\n")}function computeMaxSizePerColumn(d,e,t,r){var n=sizeFromShape(e),o=r[r.length-1],a=Array(o).fill(0),i=e.length,s="complex64"===t?createComplexTuples(d):d;if(1<i)for(var u=0;u<n/o;u++)for(var m=u*o,c=0;c<o;c++)a[c]=_Mathmax(a[c],valToString(s[m+c],0).length);return a}function valToString(a,e){return rightPad(Array.isArray(a)?parseFloat(a[0].toFixed(7))+" + "+parseFloat(a[1].toFixed(7))+"j":parseFloat(a.toFixed(7)).toString(),e)}function subTensorToString(l,e,t,r,n,o){void 0===o&&(o=!0);var b="complex64"===t?2:1,i=e[0],s=e.length;if(0===s)return"complex64"===t?[valToString(createComplexTuples(l)[0],0)]:[l[0].toString()];if(1===s){if(20<i){var u=Array.from(l.subarray(0,3*b)),N=Array.from(l.subarray(i-3*b,i));return"complex64"===t&&(u=createComplexTuples(u),N=createComplexTuples(N)),["["+u.map(function(a,e){return valToString(a,n[e])}).join(", ")+", ..., "+N.map(function(a,e){return valToString(a,n[i-3+e])}).join(", ")+"]"]}return["["+("complex64"===t?createComplexTuples(l):Array.from(l)).map(function(a,e){return valToString(a,n[e])}).join(", ")+"]"]}var I=e.slice(1),d=r.slice(1),h=r[0]*b,f=[];if(i>20){for(var m=0,S;m<3;m++)S=(C=m*h)+h,f.push.apply(f,subTensorToString(l.subarray(C,S),I,t,d,n,!1));for(f.push("..."),m=i-3;m<i;m++)S=(C=m*h)+h,f.push.apply(f,subTensorToString(l.subarray(C,S),I,t,d,n,m==i-1))}else for(m=0;m<i;m++){var C;S=(C=m*h)+h,f.push.apply(f,subTensorToString(l.subarray(C,S),I,t,d,n,m==i-1))}var k=2===s?",":"";for(f[0]="["+f[0]+k,m=1;m<f.length-1;m++)f[m]=" "+f[m]+k;var x=",\n";for(m=2;m<s;m++)x+="\n";return f[f.length-1]=" "+f[f.length-1]+"]"+(o?"":x),f}function createComplexTuples(a){for(var e=[],t=0;t<a.length;t+=2)e.push([a[t],a[t+1]]);return e}function setTensorTracker(t){trackerFn=t}function setOpHandler(t){opHandler=t}function getFilteredNodesXToY(y,e,t){for(var r={},n={},o=0;o<e.length;o++)r[e[o].id]=!0;for(o=0;o<y.length;o++){var b=(h=y[o]).inputs;for(var x in b){for(var N=b[x],u=!1,I=0;I<e.length;I++)if(r[N.id]){h.outputs.forEach(function(t){return r[t.id]=!0}),u=!0,n[h.id]=!0;break}if(u)break}}var S={};S[t.id]=!0;var p={};for(o=y.length-1;0<=o;o--)for(b=(h=y[o]).inputs,I=0;I<h.outputs.length;I++)if(S[h.outputs[I].id]){for(var x in b)S[b[x].id]=!0,p[h.id]=!0;break}var d=[];for(o=0;o<y.length;o++){var h;if(n[(h=y[o]).id]&&p[h.id]){var C={};for(var x in h.inputs){var m=h.inputs[x];r[m.id]&&(C[x]=m)}var g=Object.assign({},h);g.inputs=C,g.outputs=h.outputs,d.push(g)}}return d}function backpropagateGradients(p,e){for(var t=function(t){var r=e[t],d=[];if(r.outputs.forEach(function(e){var t=p[e.id];if(null!=t)d.push(t);else{var a=Tensor.make(e.shape,{values:makeZerosTypedArray(e.size,e.dtype)},e.dtype);d.push(a)}}),null==r.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+r.name+".");var n=r.gradient(1===r.outputs.length?d[0]:d);for(var a in r.inputs){if(!(a in n))throw new Error("Cannot backprop through input "+a+". Available gradients found: "+Object.keys(n)+".");var o=n[a](),s=r.inputs[a];if(!arraysEqual(o.shape,s.shape))throw new Error("Error in gradient for op "+r.name+". The gradient of input '"+a+"' has shape '"+o.shape+"', which does not match the shape of the input '"+s.shape+"'");if(null==p[s.id])p[s.id]=o;else{var i=p[s.id];p[s.id]=i.add(o),i.dispose()}}},a=e.length-1;0<=a;a--)t(a)}function assertTypesMatch(a,e){assert(a.dtype===e.dtype,"The dtypes of the first("+a.dtype+") and second("+e.dtype+") input must match")}function isTensorInList(a,e){for(var t=0;t<e.length;t++)if(e[t].id===a.id)return!0;return!1}function getTensorsInContainer(a){var e=[];return walkTensorContainer(a,e,new Set),e}function walkTensorContainer(s,e,t){if(null!=s)if(s instanceof Tensor)e.push(s);else if(isIterable(s)){var r=s;for(var n in r){var o=r[n];t.has(o)||(t.add(o),walkTensorContainer(o,e,t))}}}function isIterable(t){return Array.isArray(t)||"object"==typeof t}function ones(a){var e=makeOnesTypedArray(sizeFromShape(a),"float32");return Tensor.make(a,{values:e})}function isWebGLVersionEnabled(t){try{if(null!=getWebGLContext(t))return!0}catch(t){return!1}return!1}function getWebGLMaxTextureSize(a){if(null==MAX_TEXTURE_SIZE){var e=getWebGLContext(a);MAX_TEXTURE_SIZE=e.getParameter(e.MAX_TEXTURE_SIZE)}return MAX_TEXTURE_SIZE}function getWebGLDisjointQueryTimerVersion(a){if(0===a)return 0;var e=getWebGLContext(a);return hasExtension(e,"EXT_disjoint_timer_query_webgl2")&&2===a?2:hasExtension(e,"EXT_disjoint_timer_query")?1:0}function isRenderToFloatTextureEnabled(a){if(0===a)return!1;var e=getWebGLContext(a);if(1===a){if(!hasExtension(e,"OES_texture_float"))return!1;}else if(!hasExtension(e,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(e,a)}function isDownloadFloatTextureEnabled(a){if(0===a)return!1;var e=getWebGLContext(a);if(1===a){if(!hasExtension(e,"OES_texture_float"))return!1;if(!hasExtension(e,"WEBGL_color_buffer_float"))return!1}else if(!hasExtension(e,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(e,a)}function isWebGLFenceEnabled(t){return 2===t&&null!=getWebGLContext(t).fenceSync}function isChrome(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}function getFeaturesFromURL(){var a={};if("undefined"==typeof window||void 0===window.location||void 0===window.location.search)return a;var e=getQueryParams(window.location.search);if("tfjsflags"in e){var s={};e.tfjsflags.split(",").forEach(function(a){var e=a.split(":"),t=e[0],n=e[1];s[t]=n}),URL_PROPERTIES.forEach(function(e){e.name in s&&(console.log("Setting feature override from URL "+e.name+": "+s[e.name]),e.type===Type.NUMBER?a[e.name]=+s[e.name]:e.type===Type.BOOLEAN?a[e.name]="true"===s[e.name]:e.type===Type.STRING?a[e.name]=s[e.name]:console.warn("Unknown URL param: "+e.name+"."))})}return a}function hasExtension(a,e){return null!=a.getExtension(e)}function createFloatTextureAndBindToFramebuffer(s,e){var t=s.createFramebuffer(),r=s.createTexture();s.bindTexture(s.TEXTURE_2D,r);var n=2===e?s.RGBA32F:s.RGBA;s.texImage2D(s.TEXTURE_2D,0,n,1,1,0,s.RGBA,s.FLOAT,null),s.bindFramebuffer(s.FRAMEBUFFER,t),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,r,0);var o=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(r),s.deleteFramebuffer(t),o}function getQueryParams(a){var e={};return a.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(){for(var t=[],a=1;a<arguments.length;a++)t[a-1]=arguments[a];return decodeParam(e,t[0],t[1]),t.join("=")}),e}function decodeParam(a,e,t){a[decodeURIComponent(e)]=decodeURIComponent(t||"")}function getGlobalNamespace(){var t;if("undefined"!=typeof window)t=window;else{if("undefined"==typeof process)throw new Error("Could not find a global object");t=process}return t}function getOrMakeEnvironment(){var t=getGlobalNamespace();return null==t.ENV&&(t.ENV=new Environment(getFeaturesFromURL()),setTensorTracker(function(){return t.ENV.engine})),t.ENV}function variableGrads(p,e){if(assert(isFunction(p),"The f passed in variableGrads(f) must be a function"),assert(null==e||Array.isArray(e)&&e.every(function(t){return t instanceof Variable}),"The varList passed in variableGrads(f, varList) must be an array of variables"),null==e)for(var l in e=[],ENV.engine.registeredVariables)e.push(ENV.engine.registeredVariables[l]);var r=e.length;assert(0<(e=e.filter(function(t){return t.trainable})).length,"variableGrads() expects at least one of the input variables to be trainable, but none of the "+r+" variables is trainable.");var n=ENV.engine.gradients(p,e,null,!0),o=n.value,a=n.grads;assert(a.some(function(t){return null!=t}),"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),assert(0===o.rank,"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+o.rank+" tensor");var i={};return e.forEach(function(n,e){null!=a[e]&&(i[n.name]=a[e])}),{value:o,grads:i}}function customGrad(t){return ENV.engine.customGrad(t)}function warn(){for(var a=[],e=0;e<arguments.length;e++)a[e]=arguments[e];ENV.get("IS_TEST")||console.warn.apply(console,a)}function getReshaped(s,e,t,r){void 0===r&&(r=!0);var p=[];if(r)(p=p.concat(e.slice(0))).push(s[0]/t),p=p.concat(s.slice(1));else{p=p.concat(s[0]);for(var l=e.length,a=0;a<l;++a)p=p.concat([s[a+1]/e[a],e[a]]);p=p.concat(s.slice(l+1))}return p}function getPermuted(s,e,t){void 0===t&&(t=!0);var p=[];if(t){p.push(e);for(var n=e+1;n<s;++n)n<=2*e?(p.push(n),p.push(n-(e+1))):p.push(n)}else{var l=[],a=[];for(n=1;n<s;++n)n>=2*e+1||1==n%2?a.push(n):l.push(n);p.push.apply(p,l),p.push(0),p.push.apply(p,a)}return p}function getReshapedPermuted(s,e,t,r){void 0===r&&(r=!0);var i=[];r?i.push(s[0]/t):i.push(s[0]*t);for(var o=1;o<s.length;++o)o<=e.length?r?i.push(e[o-1]*s[o]):i.push(s[o]/e[o-1]):i.push(s[o]);return i}function getSliceBeginCoords(a,e){for(var t=[0],r=0;r<e;++r)t.push(a[r][0]);return t}function getSliceSize(a,e,t){for(var r=a.slice(0,1),n=0;n<t;++n)r.push(a[n+1]-e[n][0]-e[n][1]);return r}function axesAreInnerMostDims(a,e){for(var t=0;t<a.length;++t)if(a[a.length-t-1]!==e-1-t)return!1;return!0}function combineLocations(p,e,t){for(var r=p.length+e.length,n=[],o=0,l=0,d=0;d<r;d++)-1===t.indexOf(d)?n.push(p[o++]):n.push(e[l++]);return n}function computeOutAndReduceShapes(a,e){for(var t=[],r=a.length,n=0;n<r;n++)-1===e.indexOf(n)&&t.push(a[n]);return[t,e.map(function(e){return a[e]})]}function expandShapeToKeepDim(a,e){return combineLocations(a,e.map(function(){return 1}),e)}function parseAxisParam(a,n){var t=n.length;return assert((a=null==a?n.map(function(a,e){return e}):[].concat(a)).every(function(a){return a>=-t&&a<t}),"All values in axis param must be in range [-"+t+", "+t+") but got axis "+a),assert(a.every(function(t){return isInt(t)}),"All values in axis param must be integers but got axis "+a),a.map(function(a){return 0>a?t+a:a})}function assertAxesAreInnerMostDims(a,e,t){assert(axesAreInnerMostDims(e,t),a+" supports only inner-most axes for now. Got axes "+e+" and rank-"+t+" input.")}function getAxesPermutation(a,e){if(axesAreInnerMostDims(a,e))return null;for(var t=[],r=0;r<e;++r)-1===a.indexOf(r)&&t.push(r);return a.forEach(function(a){return t.push(a)}),t}function getUndoAxesPermutation(t){return t.map(function(a,e){return[e,a]}).sort(function(a,e){return a[1]-e[1]}).map(function(t){return t[0]})}function getInnerMostAxes(a,e){for(var t=[],r=e-a;r<e;++r)t.push(r);return t}function assertParamsConsistent(a,s){var i=a[0].length;a.forEach(function(a,e){assert(a.length===i,"Error in concat"+i+"D: rank of tensors["+e+"] must be the same as the rank of the rest ("+i+")")}),assert(0<=s&&s<i,"Error in concat"+i+"D: axis must be between 0 and "+(i-1)+".");var t=a[0];a.forEach(function(n,e){for(var r=0;r<i;r++)assert(r===s||n[r]===t[r],"Error in concat"+i+"D: Shape of tensors["+e+"] ("+n+") does not match the shape of the rest ("+t+") along the non-concatenated axis "+e+".")})}function computeOutShape(a,e){for(var t=a[0].slice(),r=1;r<a.length;r++)t[e]+=a[r][e];return t}function prepareAndValidate(p,e){if(1>p.rank)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+p.rank+".");if(1>e.rank)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.shape[e.rank-1]>p.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+e.shape[e.rank-1]+" vs. "+p.rank);if(0===p.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+p.shape+".");for(var t=e.shape,r=t[t.length-1],n=1,d=0;d<t.length-1;++d)n*=t[d];var c=p.shape,i=t.slice();i.pop();var s=1;for(d=r;d<p.rank;++d)s*=c[d],i.push(c[d]);var m=computeStrides(p.shape).map(function(t){return t/s}).concat([1]).slice(0,r);return[i,n,s,m]}function computeOptimalWindowSize(t){return t<=30?t:nearestDivisor(t,_Mathfloor(_Mathsqrt(t)))}function validateUpdateShape(s,e,t){var r=1<e.rank?e.shape[e.rank-1]:1,n=1<e.rank?e.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+t.shape+", indices.shape: "+e.shape+", shape: "+s+", sliceDim: "+r+", and batchDim: "+n+".";if(t.rank<n)throw new Error(o+" update.rank < "+n+". ");if(s.length<r+(t.rank-n))throw new Error(o+" Output shape length < "+(r+(t.rank-n)));if(t.rank!==n+s.length-r)throw new Error(o+" update.rank != "+(n+s.length-r));for(var a=0;a<n;++a)if(t.shape[a]!==e.shape[a])throw new Error(o+" updates.shape["+a+"] ("+t.shape[a]+") != indices.shape["+a+"] ("+e.shape[a]+").");for(a=0;a<t.rank-n;++a)if(t.shape[a+n]!==s[a+r])throw new Error(o+" updates.shape["+(a+n)+"] ("+t.shape[a+n]+") != shape["+(a+n)+"] ("+s[a+n]+")")}function validateInput(a,e,t){if(1>e.rank)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if(1>a.rank)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+a.rank+".");if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(1>t.length)throw new Error("Output rank must be greater or equal to 1, but got shape: "+t);if(0===t.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===a.size)throw new Error("Updates specified for empty output. updates shape: "+a.shape)}validateUpdateShape(t,e,a)}function calculateShapes(p,e,t){for(var r=1<e.rank?e.shape[e.rank-1]:1,n=t.length,o=1,d=r;d<n;++d)o*=t[d];var c=1>r?1:r,s=e.size/c,u=computeStrides(t).concat([1]);return{sliceRank:r,numUpdates:s,sliceSize:o,strides:u.slice(u.length-r,u.length),outputSize:sizeFromShape(t)}}function segOpComputeOptimalWindowSize(a,e){var t=!1,o;for(a<=30?(o=a,t=!0):o=nearestDivisor(a,_Mathfloor(_Mathsqrt(a)));!t;){if(o>e||o===a){t=!0;break}o=nearestDivisor(a,o+1)}return o}function computeOutShape$1(s,e,t){for(var r=[],n=s.length,o=0;o<n;o++)o===e?r.push(t):r.push(s[o]);return r}function assertParamsValid(a,e,t){assert(a.rank===e.length,"Error in slice"+a.rank+"D: Length of begin "+e+" must match the rank of the array ("+a.rank+")."),assert(a.rank===t.length,"Error in slice"+a.rank+"D: Length of size "+t+" must match the rank of the array ("+a.rank+").");for(var r=0;r<a.rank;++r)assert(e[r]+t[r]<=a.shape[r],"Error in slice"+a.rank+"D: begin["+r+"] + size["+r+"] ("+(e[r]+t[r])+") would overflow input.shape["+r+"] ("+a.shape[r]+")")}function getStridedSlicedInfo(m,e,t,r,n,g,f,y,b){if(void 0===n&&(n=0),void 0===g&&(g=0),void 0===f&&(f=0),void 0===y&&(y=0),void 0===b&&(b=0),0!==f)throw new Error("ellipsis mask is not yet supported");if(0!==y)throw new Error("new axis mask is not yet supported");for(var x=[],l=[],c=[],p=0;p<m.length;p++)x[p]=startForAxis(n,e,r,m,p),l[p]=stopForAxis(g,t,r,m,p),b&1<<p&&(l[p]=x[p]+1,c.push(p));var N=Array(m.length).fill(0);return N=N.map(function(a,e){for(var t=0,n=x[e];0<r[e]?!(n>=l[e]):!(n<=l[e]);n+=r[e])t+=1;return t}),[x,N,c]}function startForAxis(s,e,t,r,n){var o=e[n];s&1<<n&&(o=0<t[n]?_NumberMIN_SAFE_INTEGER:_NumberMAX_SAFE_INTEGER);var p=r[n];return 0>o&&(o+=p),o=clamp(0,o,p-1)}function stopForAxis(s,e,t,r,n){var o=e[n];s&1<<n&&(o=0<t[n]?_NumberMAX_SAFE_INTEGER:_NumberMIN_SAFE_INTEGER);var p=r[n];return 0>o&&(o+=p),o=0<t[n]?clamp(0,o,p):clamp(-1,o,p-1)}function inferShape(a){var e=a;if(isTypedArray(a))return[a.length];if(!Array.isArray(a))return[];for(var n=[];e instanceof Array;)n.push(e.length),e=e[0];return a instanceof Array&&ENV.get("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(a,n,[]),n}function deepAssertShapeConsistency(a,e,t){if(t=t||[],a instanceof Array){assert(0<e.length,function(){return"Element arr["+t.join("][")+"] should be a primitive, but is an array of "+a.length+" elements"}),assert(a.length===e[0],function(){return"Element arr["+t.join("][")+"] should have "+e[0]+" elements, but has "+a.length+" elements"});for(var s=e.slice(1),n=0;n<a.length;++n)deepAssertShapeConsistency(a[n],s,t.concat(n))}else assert(0===e.length,function(){return"Element arr["+t.join("][")+"] is a primitive, but should be an array of "+e[0]+" elements"})}function convertToTensor(a,s,t,r){if(void 0===r&&(r="float32"),r=r||"float32",a instanceof Tensor)return a;if(!isTypedArray(a)&&!Array.isArray(a)&&"number"!=typeof a&&"boolean"!=typeof a)throw new Error("Argument '"+s+"' passed to '"+t+"' must be a Tensor or TensorLike, but got "+a.constructor.name);var i=inferShape(a);return isTypedArray(a)||Array.isArray(a)||(a=[a]),Tensor.make(i,{values:toTypedArray(a,r,ENV.get("DEBUG"))},r)}function convertToTensorArray(a,o,t){if(!Array.isArray(a))throw new Error("Argument "+o+" passed to "+t+" must be a `Tensor[]` or `TensorLike[]`");return a.map(function(a,e){return convertToTensor(a,o+"["+e+"]",t)})}function op(a){var e=Object.keys(a);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");var s=e[0],t=a[s];s.endsWith("_")&&(s=s.substring(0,s.length-1));var n=function(){for(var a=[],e=0;e<arguments.length;e++)a[e]=arguments[e];ENV.engine.startScope(s);try{var n=t.apply(void 0,a);return n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),ENV.engine.endScope(n),n}catch(t){throw ENV.engine.endScope(null),t}};return Object.defineProperty(n,"name",{value:s,configurable:!0}),n}function softmax_(a,o){void 0===o&&(o=-1);var e=convertToTensor(a,"logits","softmax");if(-1===o&&(o=e.rank-1),o!==e.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+e.rank+" and dim was "+o);return customGrad(function(t){var e=t.logSumExp([o],!0),a=t.toFloat().sub(e).exp();return{value:a,gradFunc:function(t){var e=t.mul(a);return e.sub(e.sum([o],!0).mul(a))}}})(e)}function logSoftmax_(a,s){void 0===s&&(s=-1);var e=convertToTensor(a,"logits","logSoftmax");if(-1===s&&(s=e.rank-1),s!==e.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+e.rank+" and axis was "+s);return customGrad(function(t){var e=t.max(s,!0),a=t.sub(e),n=a.toFloat().sub(a.exp().sum(s,!0).log());return{value:n,gradFunc:function(t){var e=n.exp();return t.sub(t.sum(s,!0).mul(e))}}})(e)}function complex_(a,e){var t=convertToTensor(a,"real","complex"),r=convertToTensor(e,"imag","complex");return assertShapesMatch(t.shape,r.shape,"real and imag shapes, "+t.shape+" and "+r.shape+", must match in call to tf.complex()."),ENV.engine.runKernel(function(a){return a.complex(t,r)},{$real:t,$imag:r})}function real_(a){var n=convertToTensor(a,"input","real");return ENV.engine.runKernel(function(t){return t.real(n)},{$input:n})}function imag_(a){var n=convertToTensor(a,"input","imag");return ENV.engine.runKernel(function(t){return t.imag(n)},{$input:n})}function tensor(a,o,s){if(void 0===s&&(s="float32"),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!isTypedArray(a)&&!Array.isArray(a)&&"number"!=typeof a&&"boolean"!=typeof a)throw new Error("values passed to tensor(values) must be an array of numbers or booleans, or a TypedArray");var i=inferShape(a);return null!=o&&1!==i.length&&assertShapesMatch(o,i,"Error creating a new Tensor. Inferred shape ("+i+") does not match the provided shape ("+o+"). "),isTypedArray(a)||Array.isArray(a)||(a=[a]),o=o||i,Tensor.make(o,{values:toTypedArray(a,s,ENV.get("DEBUG"))},s)}function scalar(a,e){if(void 0===e&&(e="float32"),(isTypedArray(a)||Array.isArray(a))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean)");return tensor(a,[],e)}function tensor1d(a,e){void 0===e&&(e="float32"),assertNonNull(a);var n=inferShape(a);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return tensor(a,n,e)}function tensor2d(a,e,o){if(void 0===o&&(o="float32"),assertNonNull(a),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");var s=inferShape(a);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return tensor(a,e=e||s,o)}function tensor3d(a,e,o){if(void 0===o&&(o="float32"),assertNonNull(a),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");var s=inferShape(a);if(3!==s.length&&1!==s.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return tensor(a,e=e||s,o)}function tensor4d(a,e,o){if(void 0===o&&(o="float32"),assertNonNull(a),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");var s=inferShape(a);if(4!==s.length&&1!==s.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return tensor(a,e=e||s,o)}function tensor5d(a,e,o){if(void 0===o&&(o="float32"),assertNonNull(a),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");var s=inferShape(a);if(5!==s.length&&1!==s.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return tensor(a,e=e||s,o)}function tensor6d(a,e,o){if(void 0===o&&(o="float32"),assertNonNull(a),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");var s=inferShape(a);if(6!==s.length&&1!==s.length)throw new Error("tensor6d() requires values to be number[][][][] or flat/TypedArray");if(1===s.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return tensor(a,e=e||s,o)}function ones$1(a,e){if(void 0===e&&(e="float32"),"complex64"===e){var s=ones$1(a,"float32"),r=ones$1(a,"float32");return complex(s,r)}var n=makeOnesTypedArray(sizeFromShape(a),e);return Tensor.make(a,{values:n},e)}function zeros(a,e){if(void 0===e&&(e="float32"),"complex64"===e){var s=zeros(a,"float32"),r=zeros(a,"float32");return complex(s,r)}var n=makeZerosTypedArray(sizeFromShape(a),e);return Tensor.make(a,{values:n},e)}function fill(a,e,t){void 0===t&&(t="float32");var o=getTypedArrayFromDType(t,sizeFromShape(a));return o.fill(e),Tensor.make(a,{values:o},t)}function onesLike_(a){var e=convertToTensor(a,"x","onesLike");return ones$1(e.shape,e.dtype)}function zerosLike_(a){var e=convertToTensor(a,"x","zerosLike");return zeros(e.shape,e.dtype)}function linspace(n,e,t){if(0===t)throw new Error("Cannot request zero samples");var r=makeZerosTypedArray(t,"float32");r[0]=n;for(var o=1;o<r.length;o++)r[o]=r[o-1]+(e-n)/(t-1);return tensor1d(r,"float32")}function range(s,e,t,i){if(void 0===t&&(t=1),void 0===i&&(i="float32"),0===t)throw new Error("Cannot have a step of zero");if(s===e||s<e&&0>t||e<s&&1<t)return zeros([0],i);var p=makeZerosTypedArray(_Mathabs(_Mathceil((e-s)/t)),i);e<s&&1===t&&(t=-1),p[0]=s;for(var o=1;o<p.length;o++)p[o]=p[o-1]+t;return tensor1d(p,i)}function upcastType(a,e){return upcastTypeMap[a][e]}function sumOutType(t){return upcastType(t,"int32")}function castTensor(p,e,t){if("complex64"===e){if("complex64"===p.dtype)return p.clone();var r=zeros(p.shape),n=p.toFloat(),o=t.complex(n,r);return r.dispose(),n.dispose(),o}if(!hasEncodingLoss(p.dtype,e))return Tensor.make(p.shape,{dataId:p.dataId},e);if("complex64"===p.dtype){var l=t.real(p);return o=l.cast(e),l.dispose(),o}if("int32"===e)return t.int(p);if("bool"===e){var i=scalar(0,p.dtype);return o=t.notEqual(p,i),i.dispose(),o}throw new Error("Error in Cast: unknown dtype argument ("+e+")")}function reshapeTensor(a,e){return Tensor.make(e,{dataId:a.dataId},a.dtype)}function mergeRealAndImagArrays(a,e){if(a.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+a.length+", imag: "+e.length+".");for(var t=new Float32Array(2*a.length),r=0;r<t.length;r+=2)t[r]=a[r/2],t[r+1]=e[r/2];return t}function splitRealAndImagArrays(a){for(var e=new Float32Array(a.length/2),t=new Float32Array(a.length/2),r=0;r<a.length;r+=2)e[r/2]=a[r],t[r/2]=a[r+1];return{real:e,imag:t}}function complexWithEvenIndex(a){for(var e=_Mathceil(a.length/4),t=new Float32Array(e),r=new Float32Array(e),n=0;n<a.length;n+=4)t[_Mathfloor(n/4)]=a[n],r[_Mathfloor(n/4)]=a[n+1];return{real:t,imag:r}}function complexWithOddIndex(a){for(var e=_Mathfloor(a.length/4),t=new Float32Array(e),r=new Float32Array(e),n=2;n<a.length;n+=4)t[_Mathfloor(n/4)]=a[n],r[_Mathfloor(n/4)]=a[n+1];return{real:t,imag:r}}function getComplexWithIndex(a,e){return{real:a[2*e],imag:a[2*e+1]}}function assignToTypedArray(a,e,t,r){a[2*r]=e,a[2*r+1]=t}function exponents(s,e){for(var t=new Float32Array(s/2),r=new Float32Array(s/2),n=0,i;n<_Mathceil(s/2);n++)i=(e?2:-2)*_MathPI*(n/s),t[n]=_Mathcos(i),r[n]=_Mathsin(i);return{real:t,imag:r}}function exponent(a,e,t){var r=(t?2:-2)*_MathPI*(a/e);return{real:_Mathcos(r),imag:_Mathsin(r)}}function nonMaxSuppressionImpl(m,e,t,r,n){for(var o=Array.from(e).map(function(a,e){return{score:a,boxIndex:e}}).filter(function(t){return t.score>n}).sort(function(a,e){return e.score-a.score}),a=[],i=0;i<o.length;i++){var h=o[i],u=h.score,l=h.boxIndex;if(u<n)break;for(var c=!1,g=a.length-1;0<=g;--g)if(intersectionOverUnion(m,l,a[g])>=r){c=!0;break}if(!c&&(a.push(l),a.length>=t))break}return tensor1d(a,"int32")}function intersectionOverUnion(b,e,t){var r=b.subarray(4*e,4*e+4),n=b.subarray(4*t,4*t+4),o=_Mathmin(r[0],r[2]),a=_Mathmin(r[1],r[3]),i=_Mathmax(r[0],r[2]),s=_Mathmax(r[1],r[3]),u=_Mathmin(n[0],n[2]),l=_Mathmin(n[1],n[3]),c=_Mathmax(n[0],n[2]),p=_Mathmax(n[1],n[3]),d=(i-o)*(s-a),h=(c-u)*(p-l);if(0>=d||0>=h)return 0;var f=_Mathmax(o,u),m=_Mathmax(a,l),g=_Mathmin(i,c),N=_Mathmin(s,p),y=_Mathmax(g-f,0)*_Mathmax(N-m,0);return y/(d+h-y)}function split(s,e,i){var r=Array(s.rank).fill(0),n=s.shape.slice();return e.map(function(e){n[i]=e;var t=s.slice(r,n);return r[i]+=e,t})}function topkImpl(o,e,t,r){for(var n=e[e.length-1],a=[o.length/n,n],i=a[0],s=a[1],u=getTypedArrayFromDType(t,i*r),l=getTypedArrayFromDType("int32",i*r),c=0;c<i;c++){for(var b=c*s,d=o.subarray(b,b+s),h=[],f=0;f<d.length;f++)h.push({value:d[f],index:f});h.sort(function(a,e){return e.value-a.value});var N=c*r,g=u.subarray(N,N+r),I=l.subarray(N,N+r);for(f=0;f<r;f++)g[f]=h[f].value,I[f]=h[f].index}var y=e.slice();return y[y.length-1]=r,[tensor(u,y,t),tensor(l,y,"int32")]}function getBroadcastDims(s,e){for(var t=s.length,r=[],n=0;n<t;n++){var p=t-1-n,a=s[p]||1;1<(e[e.length-1-n]||1)&&1===a&&r.unshift(p)}return r}function getReductionAxes(s,e){for(var t=[],r=0;r<e.length;r++){var p=s[s.length-r-1],o=e.length-r-1,a=e[o];(null==p||1===p&&1<a)&&t.unshift(o)}return t}function broadcastDimsAreOuter(a){for(var e=0;e<a.length;e++)if(a[e]!==e)return!1;return!0}function assertAndGetBroadcastShape(s,e){for(var t=[],r=_Mathmax(s.length,e.length),n=0,p;n<r;n++){p=s[s.length-n-1],null==p&&(p=1);var l=e[e.length-n-1];if(null==l&&(l=1),1==p)t.unshift(l);else if(1===l)t.unshift(p);else{if(p!==l)throw Error("Operands could not be broadcast together with shapes "+s+" and "+e+".");t.unshift(p)}}return t}function broadcastSample(a,e){var t="get"+a.charAt(0).toUpperCase()+a.slice(1);return 1===e?"\n      vec4 "+a+"Sample = "+t+"(rc.w);\n      vec4 "+a+" = vec4("+a+"Sample.xy, "+a+"Sample.xy);\n    ":"vec4 "+a+" = "+t+"(rc.x, rc.y, rc.z, rc.w)"}function getLogicalCoordinatesFromFlatIndex(a,e,s){void 0===s&&(s="index");var i=computeStrides(e);return i.map(function(e,t){return"int "+a[t]+" = "+s+" / "+e+"; "+(t===i.length-1?"int "+a[t+1]+" = "+s+" - "+a[t]+" * "+e:"index -= "+a[t]+" * "+e)+";"}).join("")}function buildVec(t){return 1===t.length?""+t[0]:"vec"+t.length+"("+t.join(",")+")"}function dotify(p,e){if(p.length!==e.length)throw new Error("Vectors to be dotted must be of the same length -got "+p.length+" and "+e.length);for(var t=[],r=_Mathfloor(p.length/4),n=p.length%4,o=0;o<r;o++){var l=p.slice(4*o,4*o+4),d=e.slice(4*o,4*o+4);t.push(buildVec(l)+", "+buildVec(d))}return 0!=n&&(l=p.slice(4*r),d=e.slice(4*r),1===l.length&&(l=l.map(function(t){return"float("+t+")"}),d=d.map(function(t){return"float("+t+")"})),t.push(buildVec(l)+", "+buildVec(d))),t.map(function(t){return"dot("+t+")"}).join("+")}function makeShader(p,d,e,t,n){var r=p.map(function(a){var e=sizeFromShape(a.shapeInfo.logicalShape);return a.shapeInfo.isUniform?"uniform float "+a.name+(1<e?"["+e+"]":"")+";":"uniform sampler2D "+a.name+";"});r=r.join("\n");var o=p.map(function(a){return getInputSamplingSnippet(a,d,t)}).join("\n"),u=d.texShape,l=SHADER_PREFIX,m,h;return d.isPacked?(m=getPackedOutputSamplingSnippet(d.logicalShape,u),h=FLOAT_TEXTURE_SET_RGBA_SNIPPET):(m=getOutputSamplingSnippet(d.logicalShape,u),h=FLOAT_TEXTURE_SET_R_SNIPPET),n&&(l+=SHADER_PACKED_PREFIX),[l,FLOAT_TEXTURE_SAMPLE_SNIPPET,h,r,m,o,e].join("\n")}function getSamplerFromInInfo(a){var e=a.shapeInfo.logicalShape;switch(e.length){case 0:return getSamplerScalar(a);case 1:return getSampler1D(a);case 2:return getSampler2D(a);case 3:return getSampler3D(a);case 4:return getSampler4D(a);case 5:return getSampler5D(a);case 6:return getSampler6D(a);default:throw new Error(e.length+"-D input sampling is not yet supported");}}function getPackedSamplerFromInInfo(a){var e=a.shapeInfo.logicalShape;switch(e.length){case 1:return getPackedSampler1D(a);case 2:return getPackedSampler2D(a);case 3:return getPackedSampler3D(a);case 4:return getPackedSampler4D(a);default:throw new Error("Packed "+e.length+"-D input sampling is not yet supported");}}function getInputSamplingSnippet(a,e,t){var r=getSamplerFlat(a);return r+=a.shapeInfo.isPacked?getPackedSamplerFromInInfo(a):getSamplerFromInInfo(a),(t||arraysEqual(a.shapeInfo.logicalShape,e.logicalShape))&&(r+=getSamplerAtOutputCoords(a,e,t)),r}function getPackedOutputSamplingSnippet(a,e){switch(a.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(a,e);case 2:return getOutputPacked2DCoords(a,e);case 3:return getOutputPacked3DCoords(a,e);case 4:return getOutputPacked4DCoords(a,e);default:throw new Error(a.length+"-D packed output coordinate fetching is not yet supported");}}function getOutputSamplingSnippet(a,e){switch(a.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(a,e);case 2:return getOutput2DCoords(a,e);case 3:return getOutput3DCoords(a,e);case 4:return getOutput4DCoords(a,e);case 5:return getOutput5DCoords(a,e);case 6:return getOutput6DCoords(a,e);default:throw new Error(a.length+"-D output sampling is not yet supported");}}function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function getOutputPacked1DCoords(a,e){var t=[_Mathceil(e[0]/2),_Mathceil(e[1]/2)];return 1===e[0]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+t[1]+".0);\n      }\n    ":1===e[1]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+t[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n      return resTexRC.x * "+t[1]+" + resTexRC.y;\n    }\n  "}function getOutput1DCoords(a,e){return 1===e[0]?"\n      int getOutputCoords() {\n        return int(resultUV.x * "+e[1]+".0);\n      }\n    ":1===e[1]?"\n      int getOutputCoords() {\n        return int(resultUV.y * "+e[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return resTexRC.x * "+e[1]+" + resTexRC.y;\n    }\n  "}function getOutputPacked3DCoords(a,e){var t=[_Mathceil(e[0]/2),_Mathceil(e[1]/2)],r=_Mathceil(a[2]/2),n=r*_Mathceil(a[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n\n      int b = index / "+n+";\n      index -= b * "+n+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  "}function getOutput3DCoords(a,e){var t=getLogicalCoordinatesFromFlatIndex(["r","c","d"],a);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      "+t+"\n      return ivec3(r, c, d);\n    }\n  "}function getOutputPacked4DCoords(s,e){var t=[_Mathceil(e[0]/2),_Mathceil(e[1]/2)],r=_Mathceil(s[3]/2),n=r*_Mathceil(s[2]/2),o=n*s[1];return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n\n      int b2 = index / "+o+";\n      index -= b2 * "+o+";\n\n      int b = index / "+n+";\n      index -= b * "+n+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  "}function getOutput4DCoords(a,e){var t=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],a);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      "+t+"\n      return ivec4(r, c, d, d2);\n    }\n  "}function getOutput5DCoords(a,e){var t=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],a);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+e[0]+",\n                             "+e[1]+"));\n\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+t+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}function getOutput6DCoords(a,e){var t=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],a);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+t+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}function getOutputPacked2DCoords(a,e){var t=[_Mathceil(e[0]/2),_Mathceil(e[1]/2)];if(arraysEqual(a,e))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+t[0]+", "+t[1]+"));\n      }\n    ";var r=_Mathceil(a[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}function getOutput2DCoords(a,e){return arraysEqual(a,e)?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+e[0]+", "+e[1]+"));\n      }\n    ":1===a[1]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":1===a[0]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      int r = index / "+a[1]+";\n      int c = index - r * "+a[1]+";\n      return ivec2(r, c);\n    }\n  "}function getSamplerScalar(a){var e=a.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1);return a.shapeInfo.isUniform?"float "+t+"() {return "+e+";}":"\n    float "+t+"() {\n      return sampleTexture("+e+", halfCR);\n    }\n  "}function getPackedSampler1D(a){var e=a.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=a.shapeInfo.texShape,n=[_Mathceil(r[0]/2),_Mathceil(r[1]/2)];return"\n    vec4 "+t+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+n[0]+", "+n[1]+", index);\n      return texture2D("+e+", uv);\n    }\n  "}function getSampler1D(a){var e=a.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1);return"\n    float "+t+"(int index) {\n      return "+t+"Flat(index);\n    }\n  "}function getPackedSampler2D(p){var e=p.shapeInfo.logicalShape,t=p.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=p.shapeInfo.texShape,o=n[0],a=n[1];if(null!=n&&arraysEqual(e,n))return"\n      vec4 "+r+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+a+".0, "+o+".0);\n\n        return texture2D("+t+", uv);\n      }\n    ";var i=[_Mathceil(n[0]/2),_Mathceil(n[1]/2)];return"\n    vec4 "+r+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+_Mathceil(e[1]/2)+", "+i[0]+", "+i[1]+", row, col);\n      return texture2D("+t+", uv);\n    }\n  "}function getSampler2D(d){var e=d.shapeInfo.logicalShape,t=d.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=d.shapeInfo.texShape;if(null!=n&&arraysEqual(e,n)){var o=n[0];return"\n    float "+r+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+n[1]+".0, "+o+".0);\n      return sampleTexture("+t+", uv);\n    }\n  "}var a=squeezeShape(e),i=a.newShape,s=a.keptDims,u=i;if(u.length<e.length)return"\n      "+getSamplerFromInInfo(squeezeInputInfo(d,u))+"\n      float "+r+"(int row, int col) {\n        return "+r+"("+getSqueezedParams(["row","col"],s)+");\n      }\n    ";if(d.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col) {\n        float index = dot(vec2(row, col), vec2("+e[1]+", 1));\n        return "+r+"Flat(round(index));\n      }\n    ";var l=n[0],c=n[1];return 1===c?"\n    float "+r+"(int row, int col) {\n      float index = dot(vec2(row, col), vec2("+e[1]+", 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+l+".0);\n      return sampleTexture("+t+", uv);\n    }\n  ":1===l?"\n    float "+r+"(int row, int col) {\n      float index = dot(vec2(row, col), vec2("+e[1]+", 1));\n      vec2 uv = vec2((index + 0.5) / "+c+".0, 0.5);\n      return sampleTexture("+t+", uv);\n    }\n  ":"\n  float "+r+"(int row, int col) {\n    vec2 uv = UVfrom2D("+l+", "+c+", "+e[1]+", row, col);\n    return sampleTexture("+t+", uv);\n  }\n"}function getPackedSampler3D(p){var e=p.shapeInfo.logicalShape,t=p.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=p.shapeInfo.texShape,o=[_Mathceil(n[0]/2),_Mathceil(n[1]/2)];if(1===e[0])return"\n        "+getPackedSamplerFromInInfo(squeezeInputInfo(p,e.slice(1)))+"\n        vec4 "+r+"(int b, int row, int col) {\n          return "+r+"("+getSqueezedParams(["b","row","col"],[1,2])+");\n        }\n      ";var a=o[0],i=o[1],s=_Mathceil(e[2]/2);return"\n    vec4 "+r+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+a+", "+i+", "+s*_Mathceil(e[1]/2)+", "+s+", b, row, col);\n      return texture2D("+t+", uv);\n    }\n  "}function getSampler3D(m){var e=m.shapeInfo.logicalShape,t=m.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=e[1]*e[2],o=e[2],a=squeezeShape(e),i=a.newShape,s=a.keptDims,u=i;if(u.length<e.length)return"\n        "+getSamplerFromInInfo(squeezeInputInfo(m,u))+"\n        float "+r+"(int row, int col, int depth) {\n          return "+r+"("+getSqueezedParams(["row","col","depth"],s)+");\n        }\n      ";if(m.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth) {\n        float index = dot(vec3(row, col, depth),\n                          vec3("+n+", "+o+", 1));\n        return "+r+"Flat(round(index));\n      }\n    ";var l=m.shapeInfo.texShape,c=l[0],p=l[1];return p===n?"\n        float "+r+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+o+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+p+".0, "+c+".0);\n          return sampleTexture("+t+", uv);\n        }\n      ":p===o?"\n    float "+r+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+e[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+p+".0, "+c+".0);\n      return sampleTexture("+t+", uv);\n    }\n  ":"\n      float "+r+"(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            "+c+", "+p+", "+n+", "+o+", row, col, depth);\n        return sampleTexture("+t+", uv);\n      }\n  "}function getPackedSampler4D(p){var e=p.shapeInfo.logicalShape,t=p.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=p.shapeInfo.texShape,o=[_Mathceil(n[0]/2),_Mathceil(n[1]/2)],a=o[0],i=o[1],s=_Mathceil(e[3]/2),d=s*_Mathceil(e[2]/2);return"\n    vec4 "+r+"(int b2, int b, int row, int col) {\n      vec2 uv = packedUVfrom4D(\n        "+a+", "+i+", "+d*e[1]+",\n        "+d+", "+s+", b2, b, row, col);\n      return texture2D("+t+", uv);\n    }\n  "}function getSampler4D(m){var e=m.shapeInfo.logicalShape,t=m.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=e[3],o=e[2]*n,a=e[1]*o,i=squeezeShape(e),s=i.newShape,u=i.keptDims;if(s.length<e.length)return"\n      "+getSamplerFromInInfo(squeezeInputInfo(m,s))+"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        return "+r+"("+getSqueezedParams(["row","col","depth","depth2"],u)+");\n      }\n    ";if(m.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float index = dot(vec4(row, col, depth, depth2),\n                          vec4("+a+", "+o+", "+n+", 1));\n        return "+r+"Flat(round(index));\n      }\n    ";var l=m.shapeInfo.texShape,c=l[0],p=l[1];return p===a?"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2), vec3("+o+", "+n+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+p+".0, "+c+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ":p===n?"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+e[1]*e[2]+", "+e[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+p+".0, "+c+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ":"\n    float "+r+"(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D("+c+", "+p+", "+a+", "+o+",\n          "+n+", row, col, depth, depth2);\n      return sampleTexture("+t+", uv);\n    }\n  "}function getSampler5D(m){var e=m.shapeInfo.logicalShape,t=m.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=e[4],o=e[3]*n,a=e[2]*o,i=e[1]*a,s=squeezeShape(e),u=s.newShape,l=s.keptDims;if(u.length<e.length)return"\n      "+getSamplerFromInInfo(squeezeInputInfo(m,u))+"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+r+"("+getSqueezedParams(["row","col","depth","depth2","depth3"],l)+");\n      }\n    ";if(m.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+i+", "+a+", "+o+", "+n+")) +\n          depth3;\n        return "+r+"Flat(index);\n      }\n    ";var c=m.shapeInfo.texShape,p=c[0],d=c[1];return d===i?"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4("+a+", "+o+", "+n+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+d+".0, "+p+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ":d===n?"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]+", "+e[2]*e[3]+",\n            "+e[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+d+".0, "+p+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ":"\n    float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D("+p+", "+d+", "+i+", "+a+",\n          "+o+", "+n+", row, col, depth, depth2, depth3);\n      return sampleTexture("+t+", uv);\n    }\n  "}function getSampler6D(m){var e=m.shapeInfo.logicalShape,t=m.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),n=e[5],o=e[4]*n,a=e[3]*o,i=e[2]*a,s=e[1]*i,u=squeezeShape(e),l=u.newShape,c=u.keptDims;if(l.length<e.length)return"\n      "+getSamplerFromInInfo(squeezeInputInfo(m,l))+"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+r+"("+getSqueezedParams(["row","col","depth","depth2","depth3","depth4"],c)+");\n      }\n    ";if(m.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+i+", "+a+", "+o+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+n+", 1));\n        return "+r+"Flat(index);\n      }\n    ";var p=m.shapeInfo.texShape,d=p[0],h=p[1];return h===s?"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4("+i+", "+a+", "+o+", "+n+")) + depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+h+".0, "+d+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ":h===n?"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]*e[4]+",\n               "+e[2]*e[3]*e[4]+",\n               "+e[3]*e[4]+",\n               "+e[4]+")) + depth3;\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+h+".0, "+d+".0);\n        return sampleTexture("+t+", uv);\n      }\n    ":"\n    float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      vec2 uv = UVfrom6D("+d+", "+h+", "+s+", "+i+",\n          "+a+", "+o+", "+n+"\n          ,row, col, depth, depth2, depth3, depth4);\n      return sampleTexture("+t+", uv);\n    }\n  "}function getSamplerFlat(s){var e=s.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1)+"Flat",r=sizeFromShape(s.shapeInfo.logicalShape);if(s.shapeInfo.isUniform)return 1===r?"float "+t+"(int index) {return "+e+";}":"\n      float "+t+"(int index) {\n        for (int i = 0; i < "+r+"; i++) {\n          if (i == index) {\n            return "+e+"[i];\n          }\n        }\n      }\n    ";var n=s.shapeInfo.texShape,o=n[0],a=n[1];return 1===a&&1===o?"\n      float "+t+"(int index) {\n        return sampleTexture("+e+", halfCR);\n      }\n    ":1===a?"\n      float "+t+"(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / "+o+".0);\n        return sampleTexture("+e+", uv);\n      }\n    ":1===o?"\n      float "+t+"(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / "+a+".0, 0.5);\n        return sampleTexture("+e+", uv);\n      }\n    ":"\n    float "+t+"(int index) {\n      vec2 uv = UVfrom1D("+o+", "+a+", index);\n      return sampleTexture("+e+", uv);\n    }\n  "}function getBroadcastOutputCoordsSampler(p,e,t,r){var n=p.shapeInfo.logicalShape.length,o=e.logicalShape.length,a="int";2===o?a="ivec2":3===o?a="ivec3":4===o&&(a="ivec4");var l=getBroadcastDims(p.shapeInfo.logicalShape,e.logicalShape),s=o-n;return"\n    float "+r+"() {\n      "+a+" coords = getOutputCoords();\n      "+(0===n?"":2>o&&1<=l.length?"coords = 0;":l.map(function(t){return"coords["+(t+s)+"] = 0;"}).join("\n"))+"\n      return get"+t+"("+(2>o&&0<n?"coords":p.shapeInfo.logicalShape.map(function(a,e){return"coords["+(e+s)+"]"}).join(", "))+");\n    }\n  "}function getSamplerAtOutputCoords(g,e,t){var r=g.name,n=r.charAt(0).toUpperCase()+r.slice(1),o="get"+n+"AtOutCoords",a=getBroadcastDims(g.shapeInfo.logicalShape,e.logicalShape),i=g.shapeInfo.logicalShape.length,s=e.logicalShape.length,u=t&&(s>i||0<a.length),l=broadcastDimsAreOuter(a),c=g.shapeInfo.isUniform;if(u&&!l)return getBroadcastOutputCoordsSampler(g,e,n,o);var p=sizeFromShape(g.shapeInfo.logicalShape),d="";u&&l&&(d="\n        int mainPart = index / "+p+";\n        index -= mainPart * "+p+";\n      ");var y=e.texShape;if(c)return 1===p?"float "+o+"() {return "+r+";}":"\n      float "+o+"() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                              vec2("+y[0]+", "+y[1]+"));\n        int index = resTexRC.x * "+y[1]+" + resTexRC.y;\n        "+d+"\n        return get"+n+"Flat(index);\n      }\n    ";var f=g.shapeInfo.texShape;return arraysEqual(f,y)?"\n      float "+o+"() {\n        return sampleTexture("+r+", resultUV);\n      }\n    ":"\n    float "+o+"() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+y[0]+", "+y[1]+"));\n      int index = resTexRC.x * "+y[1]+" + resTexRC.y;\n      "+d+"\n      int texR = index / "+f[1]+";\n      int texC = index - texR * "+f[1]+";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2("+f[1]+".0, "+f[0]+".0);\n\n      return sampleTexture("+r+", uv);\n    }\n  "}function getCoordsDataType(t){if(1>=t)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank "+t+" is not yet supported")}function squeezeInputInfo(a,e){var t=JSON.parse(JSON.stringify(a));return t.shapeInfo.logicalShape=e,t}function getSqueezedParams(a,e){return e.map(function(e){return a[e]}).join(", ")}function getCoords(a,e){if(1===a)return""+e;if(2===a)return e+".x, "+e+".y";if(3===a)return e+".x, "+e+".y, "+e+".z";if(4===a)return e+".x, "+e+".y, "+e+".z, "+e+".w";throw Error("Cumulative sum for rank "+a+" is not yet supported")}function getFinalCoord(a,e){if(1===a)return""+e;if(2===a)return e+".y";if(3===a)return e+".z";if(4===a)return e+".w";throw Error("Cumulative sum for rank "+a+" is not yet supported")}function getSourceCoords(s,e){var t=s.length;if(4<t)throw Error("Gather for rank "+t+" is not yet supported");if(1===t)return"int(getIndices(resRC))";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[],o=0;o<s.length;o++)o===e?n.push("int(getIndices("+r[o]+"))"):n.push(""+r[o]);return n.join()}function getUnpackedMatrixTextureShapeWidthHeight(a,e){return[e,a]}function getUnpackedArraySizeFromMatrixSize(a,e){return a*e}function getMatrixSizeFromUnpackedArraySize(a,e){if(0!=a%e)throw new Error("unpackedSize ("+a+") must be a multiple of "+e);return a/e}function encodeMatrixToUnpackedArray(s,e,t){var r=getUnpackedArraySizeFromMatrixSize(s.length,t);if(e.length<r)throw new Error("unpackedArray length ("+e.length+") must be >= "+r);for(var n=0,i=0;i<s.length;++i)e[n]=s[i],n+=t}function decodeMatrixFromUnpackedArray(s,e,t){var r=getMatrixSizeFromUnpackedArraySize(s.length,t);if(e.length<r)throw new Error("matrix length ("+e.length+") must be >= "+r);for(var n=0,i=0;i<s.length;i+=t)e[n++]=s[i]}function getPackedMatrixTextureShapeWidthHeight(a,e){return[_Mathceil(e/2),_Mathceil(a/2)]}function getPackedRGBAArraySizeFromMatrixShape(a,e){var t=getPackedMatrixTextureShapeWidthHeight(a,e);return 4*(t[0]*t[1])}function encodeMatrixToPackedRGBA(b,e,t,r,n){var o=getPackedRGBAArraySizeFromMatrixShape(t,r);if(n.length<o)throw new Error("packedRGBA length ("+n.length+") must be >=\n        "+o);for(var a=1==r%2,i=1==t%2,s=_Mathfloor(r/2),u=_Mathfloor(t/2),l=_Mathceil(r/2),c=l*_Mathceil(t/2),p=nearestLargerEven(t)*nearestLargerEven(r),d=0;d<e;d++){for(var N=d*t*r,f=d*p,m=a?4:0,I=r,v=f,S=0;S<u;++S){for(var C=2*S*r,k=0,T;k<s;++k)T=N+C+2*k,n[v]=b[T],n[v+1]=b[T+1],n[v+2]=b[T+I],n[v+3]=b[T+I+1],v+=4;v+=m}if(a){T=N+r-1,v=f+4*(l-1);for(m=4*l,S=0;S<u;++S)n[v]=b[T],n[v+2]=b[T+r],T+=2*r,v+=m}if(i){for(T=N+(t-1)*r,v=f+4*(c-l),k=0;k<s;++k)n[v++]=b[T++],n[v++]=b[T++],v+=2;a&&i&&(n[f+p-4]=b[T])}}return n}function decodeMatrixFromPackedRGBA(s,e,t,r,n){var o=t*r;if(n.length<o)throw new Error("matrix length ("+n.length+") must be >= "+o);for(var a=1==r%2,i=_Mathfloor(r/2),u=_Mathfloor(t/2),l=_Mathceil(r/2),c=l*_Mathceil(t/2),p=nearestLargerEven(t)*nearestLargerEven(r),d=0;d<e;d++){for(var b=d*t*r,f=d*p,m=a?4:0,N=r+(a?1:0),I=f,C=b,k=b+r,R=0;R<u;++R){for(var D=0;D<i;++D)n[C++]=s[I++],n[C++]=s[I++],n[k++]=s[I++],n[k++]=s[I++];I+=m,C+=N,k+=N}if(a){I=f+4*(l-1);var P=b+r-1;for(m=4*l,N=2*r,R=0;R<u;++R)n[P]=s[I],n[P+r]=s[I+2],I+=m,P+=N}if(1==t%2){for(I=f+4*(c-l),P=b+(t-1)*r,D=0;D<i;++D)n[P++]=s[I++],n[P++]=s[I++],I+=2;a&&(n[b+t*r-1]=s[I])}}return n}function callAndCheck(a,e){var t=e();return checkWebGLError(a),t}function enableDebugWebGLErrorChecking(t){webGLDebugErrorCheckingEnabled=t}function checkWebGLError(a){if(webGLDebugErrorCheckingEnabled){var e=a.getError();if(e!==a.NO_ERROR)throw new Error("WebGL Error: "+getWebGLErrorMessage(a,e))}}function getWebGLErrorMessage(a,e){return e===a.NO_ERROR?"NO_ERROR":e===a.INVALID_ENUM?"INVALID_ENUM":e===a.INVALID_VALUE?"INVALID_VALUE":e===a.INVALID_OPERATION?"INVALID_OPERATION":e===a.INVALID_FRAMEBUFFER_OPERATION?"INVALID_FRAMEBUFFER_OPERATION":e===a.OUT_OF_MEMORY?"OUT_OF_MEMORY":e===a.CONTEXT_LOST_WEBGL?"CONTEXT_LOST_WEBGL":"Unknown error code "+e}function getExtensionOrThrow(a,e){return throwIfNull(a,function(){return a.getExtension(e)},"Extension \""+e+"\" not supported on this browser.")}function createVertexShader(a,e){var t=throwIfNull(a,function(){return a.createShader(a.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(callAndCheck(a,function(){return a.shaderSource(t,e)}),callAndCheck(a,function(){return a.compileShader(t)}),!1===a.getShaderParameter(t,a.COMPILE_STATUS))throw console.log(a.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function createFragmentShader(a,e){var t=throwIfNull(a,function(){return a.createShader(a.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(callAndCheck(a,function(){return a.shaderSource(t,e)}),callAndCheck(a,function(){return a.compileShader(t)}),!1===a.getShaderParameter(t,a.COMPILE_STATUS))throw logShaderSourceAndInfoLog(e,a.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}function logShaderSourceAndInfoLog(d,e){var t=lineNumberRegex.exec(e);if(null==t)return console.log("Couldn't parse line number in error: "+e),void console.log(d);for(var r=+t[1],n=d.split("\n"),o=n.length.toString().length+2,a=n.map(function(a,e){return rightPad((e+1).toString(),o)+a}),i=0,m=0;m<a.length;m++)i=_Mathmax(a[m].length,i);var h=a.slice(0,r-1),l=a.slice(r-1,r),c=a.slice(r);console.log(h.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+rightPad(l[0],i),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function createProgram(t){return throwIfNull(t,function(){return t.createProgram()},"Unable to create WebGLProgram.")}function linkProgram(a,e){if(callAndCheck(a,function(){return a.linkProgram(e)}),!1===a.getProgramParameter(e,a.LINK_STATUS))throw console.log(a.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function validateProgram(a,e){if(callAndCheck(a,function(){return a.validateProgram(e)}),!1===a.getProgramParameter(e,a.VALIDATE_STATUS))throw console.log(a.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function createStaticVertexBuffer(a,e){var t=throwIfNull(a,function(){return a.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(a,function(){return a.bindBuffer(a.ARRAY_BUFFER,t)}),callAndCheck(a,function(){return a.bufferData(a.ARRAY_BUFFER,e,a.STATIC_DRAW)}),t}function createStaticIndexBuffer(a,e){var t=throwIfNull(a,function(){return a.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(a,function(){return a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,t)}),callAndCheck(a,function(){return a.bufferData(a.ELEMENT_ARRAY_BUFFER,e,a.STATIC_DRAW)}),t}function getNumChannels(){return 2===ENV.get("WEBGL_VERSION")?1:4}function createTexture(t){return throwIfNull(t,function(){return t.createTexture()},"Unable to create WebGLTexture.")}function validateTextureSize(a,e){var t=ENV.get("WEBGL_MAX_TEXTURE_SIZE");if(0>=a||0>=e){var r="["+a+"x"+e+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(a>t||e>t)throw r="["+a+"x"+e+"]",new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+("["+t+"x"+t+"]."))}function createFramebuffer(t){return throwIfNull(t,function(){return t.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(p,e,t,r,n,o,a){var i=p.getAttribLocation(e,t);return-1!==i&&(callAndCheck(p,function(){return p.bindBuffer(p.ARRAY_BUFFER,r)}),callAndCheck(p,function(){return p.vertexAttribPointer(i,n,p.FLOAT,!1,o,a)}),callAndCheck(p,function(){return p.enableVertexAttribArray(i)}),!0)}function bindTextureUnit(a,e,t){validateTextureUnit(a,t),callAndCheck(a,function(){return a.activeTexture(a.TEXTURE0+t)}),callAndCheck(a,function(){return a.bindTexture(a.TEXTURE_2D,e)})}function unbindTextureUnit(a,e){validateTextureUnit(a,e),callAndCheck(a,function(){return a.activeTexture(a.TEXTURE0+e)}),callAndCheck(a,function(){return a.bindTexture(a.TEXTURE_2D,null)})}function getProgramUniformLocationOrThrow(a,e,t){return throwIfNull(a,function(){return a.getUniformLocation(e,t)},"uniform \""+t+"\" not present in program.")}function getProgramUniformLocation(a,e,t){return a.getUniformLocation(e,t)}function bindTextureToProgramUniformSampler(a,e,t,r,n){callAndCheck(a,function(){return bindTextureUnit(a,t,n)}),callAndCheck(a,function(){return a.uniform1i(r,n)})}function bindCanvasToFramebuffer(t){callAndCheck(t,function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)}),callAndCheck(t,function(){return t.viewport(0,0,t.canvas.width,t.canvas.height)}),callAndCheck(t,function(){return t.scissor(0,0,t.canvas.width,t.canvas.height)})}function bindColorTextureToFramebuffer(a,e,t){callAndCheck(a,function(){return a.bindFramebuffer(a.FRAMEBUFFER,t)}),callAndCheck(a,function(){return a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0)})}function unbindColorTextureFromFramebuffer(a,e){callAndCheck(a,function(){return a.bindFramebuffer(a.FRAMEBUFFER,e)}),callAndCheck(a,function(){return a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,null,0)})}function validateFramebuffer(a){var e=a.checkFramebufferStatus(a.FRAMEBUFFER);if(e!==a.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+getFramebufferErrorMessage(a,e))}function getFramebufferErrorMessage(a,e){return e===a.FRAMEBUFFER_INCOMPLETE_ATTACHMENT?"FRAMEBUFFER_INCOMPLETE_ATTACHMENT":e===a.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT?"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT":e===a.FRAMEBUFFER_INCOMPLETE_DIMENSIONS?"FRAMEBUFFER_INCOMPLETE_DIMENSIONS":e===a.FRAMEBUFFER_UNSUPPORTED?"FRAMEBUFFER_UNSUPPORTED":"unknown error "+e}function throwIfNull(a,e,t){var r=callAndCheck(a,function(){return e()});if(null==r)throw new Error(t);return r}function validateTextureUnit(a,e){var t=a.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+a.TEXTURE0;if(r<a.TEXTURE0||r>t)throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE"+t+"].")}function getTextureShapeFromLogicalShape(a,s){void 0===s&&(s=!1);var i=ENV.get("WEBGL_MAX_TEXTURE_SIZE");if(s&&(i*=2,a=a.map(function(e,t){return t>=a.length-2?nearestLargerEven(a[t]):a[t]})),2!==a.length){var p=squeezeShape(a);a=p.newShape}var n=sizeFromShape(a);return 1>=a.length&&n<=i?[n,1]:2===a.length&&a[0]<=i&&a[1]<=i?a:3===a.length&&a[0]*a[1]<=i&&a[2]<=i?[a[0]*a[1],a[2]]:3===a.length&&a[0]<=i&&a[1]*a[2]<=i?[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=i&&a[3]<=i?[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=i&&a[1]*a[2]*a[3]<=i?[a[0],a[1]*a[2]*a[3]]:sizeToSquarishShape(n)}function isEven(t){return 0==t%2}function isReshapeFree(a,n){if(arraysEqual(a=a.slice(-2),n=n.slice(-2)))return!0;if(!a.length||!n.length)return!0;if(0===a[0]||0===a[1]||0===n[0]||0===n[1])return!0;if(a.length!==n.length){if(arraysEqual(squeezeShape(a).newShape,squeezeShape(n).newShape))return!0;}else if(isEven(a[0])&&isEven(n[0])){if(isEven(a[1])&&isEven(n[1]))return!0;if(a[1]===n[1])return!0}return!1}function createVertexShader$1(t){return createVertexShader(t,"\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function createVertexBuffer(t){return createStaticVertexBuffer(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function createIndexBuffer(t){return createStaticIndexBuffer(t,new Uint16Array([0,1,2,2,1,3]))}function getTextureConfig(p,e){var t=p,l,d,c,m,h,g,f;return 2===ENV.get("WEBGL_VERSION")?(l=t.R32F,d=t.R16F,c=t.RGBA32F,m=t.RED,h=4,g=1,f=t.HALF_FLOAT):(l=p.RGBA,d=p.RGBA,c=t.RGBA,m=p.RGBA,h=4,g=4,f=null==e?null:e.HALF_FLOAT_OES),{internalFormatFloat:l,internalFormatHalfFloat:d,internalFormatPackedFloat:c,textureFormatFloat:m,downloadTextureFormat:p.RGBA,downloadUnpackNumChannels:h,defaultNumChannels:g,textureTypeHalfFloat:f}}function createAndConfigureTexture(p,e,t,r,n,o){validateTextureSize(e,t);var a=createTexture(p),i=p.TEXTURE_2D;return callAndCheck(p,function(){return p.bindTexture(i,a)}),callAndCheck(p,function(){return p.texParameteri(i,p.TEXTURE_WRAP_S,p.CLAMP_TO_EDGE)}),callAndCheck(p,function(){return p.texParameteri(i,p.TEXTURE_WRAP_T,p.CLAMP_TO_EDGE)}),callAndCheck(p,function(){return p.texParameteri(i,p.TEXTURE_MIN_FILTER,p.NEAREST)}),callAndCheck(p,function(){return p.texParameteri(i,p.TEXTURE_MAG_FILTER,p.NEAREST)}),callAndCheck(p,function(){return p.texImage2D(i,0,r,e,t,0,n,o,null)}),callAndCheck(p,function(){return p.bindTexture(p.TEXTURE_2D,null)}),a}function createFloat32MatrixTexture(a,e,t,r){var n=getUnpackedMatrixTextureShapeWidthHeight(e,t);return createAndConfigureTexture(a,n[0],n[1],r.internalFormatFloat,r.textureFormatFloat,a.FLOAT)}function createFloat16MatrixTexture(a,e,t,r){var n=getUnpackedMatrixTextureShapeWidthHeight(e,t);return createAndConfigureTexture(a,n[0],n[1],r.internalFormatFloat,r.textureFormatFloat,r.textureTypeHalfFloat)}function createUnsignedBytesMatrixTexture(a,e,t){var n=getUnpackedMatrixTextureShapeWidthHeight(e,t);return createAndConfigureTexture(a,n[0],n[1],a.RGBA,a.RGBA,a.UNSIGNED_BYTE)}function createPackedMatrixTexture(a,e,t,r){var n=getPackedMatrixTextureShapeWidthHeight(e,t);return createAndConfigureTexture(a,n[0],n[1],r.internalFormatPackedFloat,a.RGBA,a.FLOAT)}function createFloat16PackedMatrixTexture(a,e,t,r){var n=getPackedMatrixTextureShapeWidthHeight(e,t);return createAndConfigureTexture(a,n[0],n[1],r.internalFormatHalfFloat,a.RGBA,r.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(a,e,t){return callAndCheck(a,function(){return a.bindBuffer(a.ARRAY_BUFFER,t)}),bindVertexBufferToProgramAttribute(a,e,"clipSpacePos",t,3,20,0)&&bindVertexBufferToProgramAttribute(a,e,"uv",t,2,20,12)}function uploadPixelDataToTexture(a,e,t){callAndCheck(a,function(){return a.bindTexture(a.TEXTURE_2D,e)}),callAndCheck(a,function(){return a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,t)}),callAndCheck(a,function(){return a.bindTexture(a.TEXTURE_2D,null)})}function uploadDataToTexture(s,e,t,r,n,o){validateTextureSize(t,r),callAndCheck(s,function(){return s.bindTexture(s.TEXTURE_2D,e)}),callAndCheck(s,function(){return s.texSubImage2D(s.TEXTURE_2D,0,0,0,t,r,o,s.FLOAT,n)}),callAndCheck(s,function(){return s.bindTexture(s.TEXTURE_2D,null)})}function uploadMatrixToTexture(p,e,t,r,n,o,a){var i=getUnpackedMatrixTextureShapeWidthHeight(t,r),d=i[0],l=i[1],u;1===a.defaultNumChannels?u=n:encodeMatrixToUnpackedArray(n,u=new Float32Array(getUnpackedArraySizeFromMatrixSize(n.length,o)),o),uploadDataToTexture(p,e,d,l,u,a.textureFormatFloat)}function uploadMatrixToPackedTexture(i,e,t,r,n,o){var a=getPackedMatrixTextureShapeWidthHeight(r,n),s=a[0],p=a[1],l=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(r,n));encodeMatrixToPackedRGBA(o,t,r,n,l),uploadDataToTexture(i,e,s,p,l,i.RGBA)}function maybeCreateBufferFromOutputTexture(p,e,t,r,n){var o=e;if(2===ENV.get("WEBGL_VERSION")){var l=p,i=l.createBuffer();callAndCheck(p,function(){return p.bindBuffer(l.PIXEL_PACK_BUFFER,i)});var s=4*getUnpackedArraySizeFromMatrixSize(t*r,n.downloadUnpackNumChannels);callAndCheck(p,function(){return p.bufferData(l.PIXEL_PACK_BUFFER,s,p.STATIC_DRAW)}),callAndCheck(p,function(){return l.readPixels(0,0,r,t,p.RGBA,p.FLOAT,0)}),callAndCheck(p,function(){return p.bindBuffer(l.PIXEL_PACK_BUFFER,null)}),o=i}return o}function downloadFloat32MatrixFromBuffer(p,e,t,r,n){var o=p,a=new Float32Array(getUnpackedArraySizeFromMatrixSize(t*r,n.downloadUnpackNumChannels));o.bindBuffer(p.ARRAY_BUFFER,e),o.getBufferSubData(p.ARRAY_BUFFER,0,a),o.bindBuffer(p.ARRAY_BUFFER,null);var i=new Float32Array(t*r);return decodeMatrixFromUnpackedArray(a,i,n.downloadUnpackNumChannels),i}function downloadFloat32MatrixFromOutputTexture(p,e,t,r){var n=getUnpackedMatrixTextureShapeWidthHeight(e,t),o=n[0],a=n[1],i=new Float32Array(getUnpackedArraySizeFromMatrixSize(e*t,r.downloadUnpackNumChannels));callAndCheck(p,function(){return p.readPixels(0,0,o,a,r.downloadTextureFormat,p.FLOAT,i)});var s=new Float32Array(e*t);return decodeMatrixFromUnpackedArray(i,s,r.downloadUnpackNumChannels),s}function downloadByteEncodedFloatMatrixFromOutputTexture(p,e,t,r){var n=getUnpackedMatrixTextureShapeWidthHeight(e,t),o=n[0],a=n[1],i=new Uint8Array(getUnpackedArraySizeFromMatrixSize(e*t,4));return callAndCheck(p,function(){return p.readPixels(0,0,o,a,r.downloadTextureFormat,p.UNSIGNED_BYTE,i)}),new Float32Array(i.buffer)}function downloadMatrixFromPackedOutputTexture(i,e,t,r,n,o){var a=getPackedMatrixTextureShapeWidthHeight(n,o),s=a[0],d=a[1],l=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(n,o));callAndCheck(i,function(){return i.readPixels(0,0,s,d,i.RGBA,i.FLOAT,l)});var u=new Float32Array(sizeFromShape([e,t,r]));return decodeMatrixFromPackedRGBA(l,e,t,r,u)}function binSearchLastTrue(a){for(var e=0,s=a.length-1,i=-1,p;e<=s;)p=e+s>>1,a[p]()?(i=p,e=p+1):s=p-1;return i}function compileProgram(m,h,e,t){for(var n=h.userCode,r=e.map(function(t,e){var a={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked};return{name:h.variableNames[e],shapeInfo:a}}),a=r.map(function(t){return t.shapeInfo}),o={logicalShape:t.shape,texShape:t.texData.texShape,isUniform:!1,isPacked:t.texData.isPacked},s=makeShader(r,o,n,!0===h.supportsBroadcasting,h.usesPackedTextures),i=m.createProgram(s),l={},u=0,c;u<h.variableNames.length;u++)c=h.variableNames[u],l[c]=m.getUniformLocation(i,c,!1);return{program:h,source:s,webGLProgram:i,uniformLocations:l,gpgpu:m,inShapeInfos:a,outShapeInfo:o}}function validateBinaryAndProgram(a,p){if(a.length!==p.length)throw Error("Binary was compiled with "+a.length+" inputs, but was executed with "+p.length+" inputs");a.forEach(function(t,e){var r=t.logicalShape,n=p[e],o=n.shape;if(!arraysEqual(r,o))throw Error("Binary was compiled with different shapes than the current args. Shapes "+r+" and "+o+" must match");if(!t.isUniform||!n.isUniform){var a=t.texShape,i=n.isUniform?null:n.texData.texShape;if(!arraysEqual(a,i))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+a+" and "+i+" must match")}})}function runProgram(p,e,t,r){validateBinaryAndProgram(p.inShapeInfos,e),validateBinaryAndProgram([p.outShapeInfo],[t]);var n=t.texData.texture,o=t.texData.texShape,l=p.gpgpu;t.texData.isPacked?l.setOutputPackedMatrixTexture(n,o[0],o[1]):l.setOutputMatrixTexture(n,o[0],o[1]),l.setProgram(p.webGLProgram),e.forEach(function(e,t){var r=p.program.variableNames[t],n=p.uniformLocations[r];if(null!=n){if(e.isUniform){if(1===sizeFromShape(e.shape))l.gl.uniform1f(n,e.uniformValues[0]);else{var o=e.uniformValues;o instanceof Float32Array||(o=new Float32Array(o)),l.gl.uniform1fv(n,o)}return}var i=e.texData.texture;l.setInputMatrixTexture(i,n,t)}}),null!=r&&r(l,p.webGLProgram),l.executeProgram()}function makeShaderKey(s,e,t){var r="";e.concat(t).forEach(function(t){r+=t.shape+"_"+(t.isUniform?"uniform":t.texData.texShape)});var p=s.userCode,o=(!0===s.supportsBroadcasting).toString(),a=s.constructor.name;return a+="_"+o+"_"+r+"_"+p}function getVecChannels(a,e){return["x","y","z","w","u","v"].slice(0,e).map(function(e){return a+"."+e})}function getChannels(a,e){return 1===e?[a]:getVecChannels(a,e)}function getSourceCoords$1(a,e){if(1===a)return"rc";for(var t="",o=0;o<a;o++)t+=e[o],o<a-1&&(t+=",");return t}function getSourceCoordsArr(s,e){for(var t=[],r=0;1>=r;r++)for(var p=0;1>=p;p++){for(var l=(0==r?"r":"rp1")+", "+(0==p?"c":"cp1"),d=2;d<s;d++)l=e[e.length-1-d]+","+l;t.push(l)}return t}function getOutOfBoundsCondition(a,e,t){if(1===a)return"rc > "+e[0];for(var r="",s=a-2;s<a;s++)r+=t[s]+" >= "+e[s],s<a-1&&(r+="||");return r}function getSetup(a,e,t,r){if(1===a)return"";var n=r.slice(-2);return"\n    int r = "+n[0]+";\n    int c = "+n[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+e+";\n    bool rEdge = rp1 >= "+t+";\n  "}function getOutput(a,e){var t=a.length,r=getSourceCoordsArr(t,e);return 1===t?"getA(rc),\n            rc + 1 >= "+a[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")"}function getFlatIndex(t){return"\n    int getFlatIndex(ivec3 coords) {\n      return round("+dotify(["coords.x","coords.y","coords.z"],computeStrides(t).map(function(t){return t.toString()}).concat(["1."]))+");\n    }\n  "}function getReshapedInputCoords(t){return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+getLogicalCoordinatesFromFlatIndex(["r","c","d"],t)+"\n      return ivec3(r, c, d);\n    }\n  "}function getCoords$1(t){if(1===t)return"sourceLoc";if(2===t)return"sourceLoc.x, sourceLoc.y";if(3===t)return"sourceLoc.x, sourceLoc.y, sourceLoc.z";if(4===t)return"sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w";throw Error("Slicing for rank "+t+" is not yet supported")}function getPhysicalFromLogicalTextureType(a,e){if(e)return ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.PACKED_2X2_FLOAT16;if(a===TextureUsage.DOWNLOAD||a===TextureUsage.PIXELS)return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;if(a===TextureUsage.UPLOAD)return PhysicalTextureType.UNPACKED_FLOAT32;if(a===TextureUsage.RENDER)return ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")?PhysicalTextureType.UNPACKED_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT16;throw new Error("Unknown logical texture type "+a)}function getKeyFromTextureShape(a,e,t){return a[0]+"_"+a[1]+"_"+e+"_"+t}function getSourceCoords$2(a){var e=a.length;if(5<e)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"imod(resRC, "+a[0]+")";for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],n=0;n<a.length;n++)r.push("imod("+t[n]+", "+a[n]+")");return r.join()}function getSwitchedCoords(a){var e=a.length;if(6<e)throw Error("Transpose for rank "+e+" is not yet supported");for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=Array(e),n=0;n<a.length;n++)r[a[n]]=t[n];return r.join()}function STEP(t){return void 0===t&&(t=0),"if (isNaN(x)) return x;\n    return x > 0.0 ? 1.0 : float("+t+");\n  "}function concat1d_(t){return concat(t,0)}function concat2d_(a,e){return concat(a,e)}function concat3d_(a,e){return concat(a,e)}function concat4d_(a,e){return concat(a,e)}function concat_(s,i){void 0===i&&(i=0),assert(1<=s.length,"Pass at least one tensor to concat");var p=convertToTensorArray(s,"tensors","concat");i=parseAxisParam(i,p[0].shape)[0];var e=computeOutShape(p.map(function(t){return t.shape}),i);if(0===sizeFromShape(e))return tensor([],e);if(1===(p=p.filter(function(t){return 0<t.size})).length)return p[0];var n=p.map(function(t){return t.shape});assertParamsConsistent(n,i);var o=p;return ENV.engine.runKernel(function(t){return t.concat(p,i)},o,function(t){var e=n.map(function(t){return t[i]});return split$1(t,e,i).map(function(t){return function(){return t}})})}function split_(a,e,t){void 0===t&&(t=0);var s=convertToTensor(a,"x","split"),o;return t=parseAxisParam(t,s.shape)[0],"number"==typeof e?(assert(0==s.shape[t]%e,"Number of splits must evenly divide the axis."),o=Array(e).fill(s.shape[t]/e)):(assert(s.shape[t]===e.reduce(function(a,e){return a+e}),"The sum of sizes must match the size of the axis dimension."),o=e),ENV.engine.runKernel(function(a){return a.split(s,o,t)},{$x:s},function(a){return{$x:function(){return concat(a,t)}}})}function createCommonjsModule(a,e){return a(e={exports:{}},e.exports),e.exports}function clone_(a){var e=convertToTensor(a,"x","clone");return ENV.engine.runKernel(function(){return Tensor.make(e.shape,{dataId:e.dataId},e.dtype)},{$x:e},function(t){return{$x:function(){return t.toFloat()}}})}function eye_(p,e,l,r){void 0===r&&(r="float32"),null==e&&(e=p);for(var d=buffer([p,e],r),o=p<=e?p:e,a=0;a<o;++a)d.set(1,a,a);var u=d.toTensor().as2D(p,e);if(null==l)return u;if(1===l.length)return tile(expandDims(u,0),[l[0],1,1]);if(2===l.length)return tile(expandDims(expandDims(u,0),0),[l[0],l[1],1,1]);if(3===l.length)return tile(expandDims(expandDims(expandDims(u,0),0),0),[l[0],l[1],l[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+l.length+"D.")}function randomNormal_(p,e,l,d,n){if(void 0===e&&(e=0),void 0===l&&(l=1),null!=d&&"bool"===d)throw new Error("Unsupported data type "+d);for(var o=new MPRandGauss(e,l,d,!1,n),a=buffer(p,d),i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}function truncatedNormal_(p,e,l,d,n){if(void 0===e&&(e=0),void 0===l&&(l=1),null!=d&&"bool"===d)throw new Error("Unsupported data type "+d);for(var o=new MPRandGauss(e,l,d,!0,n),a=buffer(p,d),i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}function randomUniform_(s,e,i,p){void 0===e&&(e=0),void 0===i&&(i=1),void 0===p&&(p="float32");for(var l=buffer(s,p),o=0;o<l.values.length;o++)l.values[o]=randUniform(e,i);return l.toTensor()}function rand_(s,e,t){var r=sizeFromShape(s),n=null;if(null==t||"float32"===t)n=new Float32Array(r);else if("int32"===t)n=new Int32Array(r);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(r)}for(var i=0;i<r;i++)n[i]=e();return Tensor.make(s,{values:n},t)}function multinomial_(p,l,t,d){void 0===d&&(d=!1);var e=convertToTensor(p,"logits","multinomial"),o=e.size,a=e.rank;if(2>o)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+o+".");if(2<a)throw new Error("Rank of probabilities must be 1 or 2, but is "+a);t=t||Math.random();var i=1===a?e.as2D(1,-1):e,s=ENV.engine.runKernel(function(a){return a.multinomial(i,d,l,t)},{logits2D:i});return 1===a?s.as1D():s}function oneHot_(a,s,t,i){void 0===t&&(t=1),void 0===i&&(i=0);var p=convertToTensor(a,"indices","oneHot","int32");if(assert("int32"===p.dtype,"Indices must be of dtype `int32`"),2>s)throw new Error("Error in oneHot: depth must be >=2, but it is "+s);return ENV.engine.runKernel(function(a){return a.oneHot(p,s,t,i)},{$indices:p},function(){return{$indices:function(){return zerosLike(p)}}})}function fromPixels_(a,e){if(void 0===e&&(e=3),4<e)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return ENV.engine.fromPixels(a,e)}function toPixels(b,e){return __awaiter(this,void 0,void 0,function(){var t,N,I,S,C,k,R,D,P,A,_,O,L,z,M,F,B,V,U,W;return __generator(this,function(a){switch(a.label){case 0:if(2!==(t=convertToTensor(b,"img","toPixels","int32")).rank&&3!==t.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+t.rank+".");if(N=t.shape.slice(0,2),I=N[0],S=N[1],4<(C=2===t.rank?1:t.shape[2])||2===C)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+C);return k=t.min(),R=t.max(),[4,k.data()];case 1:return D=a.sent()[0],[4,R.data()];case 2:if(!(P=a.sent()[0],k.dispose(),R.dispose(),"float32"===t.dtype)){if("int32"!==t.dtype)throw new Error("Unsupported type for toPixels: "+t.dtype+". Please use float32 or int32 tensors.");if(0>D||255<P)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+D+" - "+P+"].")}else if(0>D||1<P)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+D+" - "+P+"].");return[4,t.data()];case 3:for(A=a.sent(),_="float32"===t.dtype?255:1,O=new Uint8ClampedArray(4*(S*I)),L=0;L<I*S;++L)z=void 0,M=void 0,F=void 0,B=void 0,1===C?(z=A[L]*_,M=A[L]*_,F=A[L]*_,B=255):3===C?(z=A[3*L]*_,M=A[3*L+1]*_,F=A[3*L+2]*_,B=255):4===C&&(z=A[4*L]*_,M=A[4*L+1]*_,F=A[4*L+2]*_,B=A[4*L+3]*_),O[(V=4*L)+0]=_Mathround(z),O[V+1]=_Mathround(M),O[V+2]=_Mathround(F),O[V+3]=_Mathround(B);return null!=e&&(e.width=S,e.height=I,U=e.getContext("2d"),W=new ImageData(O,S,I),U.putImageData(W,0,0)),t!==b&&t.dispose(),[2,O];}})})}function reshape_(a,n){var o=convertToTensor(a,"x","reshape");return n=inferFromImplicitShape(n,o.size),assert(o.size===sizeFromShape(n),"new shape and old shape must have the same number of elements."),ENV.engine.runKernel(function(t){return t.reshape(o,n)},{$x:o},function(t){return{$x:function(){return t.reshape(o.shape)}}})}function squeeze_(a,e){var t=convertToTensor(a,"x","squeeze");return reshape(t,squeezeShape(t.shape,e).newShape)}function cast_(a,n){var t=convertToTensor(a,"x","cast");return ENV.engine.runKernel(function(a){return a.cast(t,n)},{$x:t},function(t){return{$x:function(){return t.clone()}}})}function tile_(a,p){var t=convertToTensor(a,"x","tile");return assert(t.rank===p.length,"Error in transpose: rank of input "+t.rank+" must match length of reps "+p+"."),ENV.engine.runKernel(function(a){return a.tile(t,p)},{$x:t},function(r){return{$x:function(){var e=zerosLike(t);if(1===t.rank)for(var l=0;l<p[0];++l)e=e.add(r.slice([l*t.shape[0]],[t.shape[0]]));else if(2===t.rank)for(l=0;l<p[0];++l)for(var d=0;d<p[1];++d)e=e.add(r.slice([l*t.shape[0],d*t.shape[1]],[t.shape[0],t.shape[1]]));else if(3===t.rank)for(l=0;l<p[0];++l)for(d=0;d<p[1];++d)for(var u=0;u<p[2];++u)e=e.add(r.slice([l*t.shape[0],d*t.shape[1],u*t.shape[2]],[t.shape[0],t.shape[1],t.shape[2]]));else{if(4!==t.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+t.rank+" tensors yet.");for(l=0;l<p[0];++l)for(d=0;d<p[1];++d)for(u=0;u<p[2];++u)for(var c=0;c<p[3];++c)e=e.add(r.slice([l*t.shape[0],d*t.shape[1],u*t.shape[2],c*t.shape[3]],[t.shape[0],t.shape[1],t.shape[2],t.shape[3]]))}return e}}})}function pad1d_(a,e,t){return void 0===t&&(t=0),assert(2===e.length,"Invalid number of paddings. Must be length of 2."),pad(a,[e],t)}function pad2d_(a,e,t){return void 0===t&&(t=0),assert(2===e.length&&2===e[0].length&&2===e[1].length,"Invalid number of paddings. Must be length of 2 each."),pad(a,e,t)}function pad3d_(a,e,t){return void 0===t&&(t=0),assert(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,"Invalid number of paddings. Must be length of 2 each."),pad(a,e,t)}function pad4d_(a,e,t){return void 0===t&&(t=0),assert(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,"Invalid number of paddings. Must be length of 2 each."),pad(a,e,t)}function pad_(a,s,t){void 0===t&&(t=0);var i=convertToTensor(a,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var n=s.map(function(t){return t[0]});return ENV.engine.runKernel(function(a){return a.pad(i,s,t)},{$x:i},function(t){return{$x:function(){return t.slice(n,i.shape)}}})}function stack_(s,p){void 0===p&&(p=0);var e=convertToTensorArray(s,"tensors","stack");if(assert(1<=e.length,"Pass at least one tensor to tf.stack"),1===e.length)return e[0].expandDims(p);var r=e[0].rank,n=e[0].shape,o=e[0].dtype;assert(p<=r,"Axis must be <= rank of the tensor"),e.forEach(function(t){assertShapesMatch(n,t.shape,"All tensors passed to stack must have matching shapes")}),e.forEach(function(t){assert(o===t.dtype,"All tensors passed to stack must have matching dtypes")});var a=e.map(function(t){return t.expandDims(p)});return concat(a,p)}function batchToSpaceND_(a,s,t){var r=convertToTensor(a,"x","batchToSpaceND"),e=s.reduce(function(a,e){return a*e});return assert(r.rank>=1+s.length,"input rank is "+r.rank+" but should be > than blockShape.length "+s.length),assert(t.length===s.length,"crops.length is "+t.length+" but should be equal to blockShape.length  "+s.length),assert(0==r.shape[0]%e,"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+s.join(" * ")+" === "+e),ENV.engine.runKernel(function(a){return a.batchToSpaceND(r,s,t)},{$x:r},function(a){return{$x:function(){return a.spaceToBatchND(s,t)}}})}function spaceToBatchND_(a,s,t){var r=convertToTensor(a,"x","spaceToBatchND");return assert(r.rank>=1+s.length,"input rank "+r.rank+" should be > than [blockShape] "+s.length),assert(t.length===s.length,"paddings.shape[0] "+t.length+" must be equal to [blockShape] "+s.length),assert(r.shape.reduce(function(a,e,n){return 0<n&&n<=s.length?a&&0==(e+t[n-1][0]+t[n-1][1])%s[n-1]:a},!0),"input spatial dimensions "+r.shape.slice(1)+" with paddings "+t.toString()+" must be divisible by blockShapes "+s.toString()),ENV.engine.runKernel(function(a){return a.spaceToBatchND(r,s,t)},{$x:r},function(a){return{$x:function(){return a.batchToSpaceND(s,t)}}})}function unstack_(p,d){void 0===d&&(d=0);for(var c=convertToTensor(p,"x","unstack"),e=c.shape[d],n=Array(c.rank-1).fill(0),a=0,o=0,m;o<c.rank;o++)o!==d&&(n[a]=c.shape[o],a++);m=Array(e).fill(1);var h=Array(c.rank).fill(0),u=c.shape.slice();return m.map(function(t){u[d]=t;var e=c.slice(h,u);return h[d]+=t,e.reshape(n)})}function cumsum_(p,l,d,c){void 0===l&&(l=0),void 0===d&&(d=!1),void 0===c&&(c=!1);var e=convertToTensor(p,"x","cumsum"),o=getAxesPermutation([l|=0],e.rank),a=e;null!=o&&(a=e.transpose(o));var m=getInnerMostAxes(1,e.rank)[0],s=ENV.engine.runKernel(function(t){return t.cumsum(a,m,d,c)},{permutedX:a},function(t){return{permutedX:function(){return t.cumsum(l,d,!c)}}});return null!=o&&(s=s.transpose(o)),s}function expandDims_(a,e){void 0===e&&(e=0);var o=convertToTensor(a,"x","expandDims");assert(e<=o.rank,"Axis must be <= rank of the tensor");var r=o.shape.slice();return 0>e&&(assert(-(o.rank+1)<=e,"Axis must be in the interval ["+-(o.rank+1)+", "+o.rank+"]"),e=o.rank+e+1),r.splice(e,0,1),reshape(o,r)}function depthToSpace_(s,p,t){void 0===t&&(t="NHWC");var l=convertToTensor(s,"x","depthToSpace"),e="NHWC"===t?l.shape[1]:l.shape[2],n="NHWC"===t?l.shape[2]:l.shape[3],a="NHWC"===t?l.shape[3]:l.shape[1];return assert(0<=e*p,"Negative dimension size caused by overflow when multiplying\n      "+e+" and "+p+"  for depthToSpace with input shape\n      "+l.shape),assert(0<=n*p,"Negative dimension size caused by overflow when multiplying\n      "+n+" and "+p+" for depthToSpace with input shape\n          "+l.shape),assert(0==a%(p*p),"Dimension size must be evenly divisible by "+p*p+" but is "+a+" for depthToSpace with input shape "+l.shape),ENV.engine.runKernel(function(a){return a.depthToSpace(l,p,t)},{$x:l})}function setdiff1dAsync_(m,e){return __awaiter(this,void 0,void 0,function(){var t,h,g,f,y,b,x,N,I,d;return __generator(this,function(a){switch(a.label){case 0:return t=convertToTensor(m,"x","setdiff1d"),h=convertToTensor(e,"y","setdiff1d"),assert(t.dtype===h.dtype,"x and y should have the same dtype, but got x ("+t.dtype+") and y ("+h.dtype+")."),assert(1===t.rank,"x should be 1D tensor, but got x ("+t.shape+")."),assert(1===h.rank,"y should be 1D tensor, but got y ("+h.shape+")."),[4,t.data()];case 1:return g=a.sent(),[4,h.data()];case 2:for(f=a.sent(),y=new Set(f),b=0,I=0;I<g.length;I++)y.has(g[I])||b++;for(x=new TensorBuffer([b],t.dtype),N=new TensorBuffer([b],"int32"),I=0,d=0;I<g.length;I++)y.has(g[I])||(x.values[d]=g[I],N.values[d]=I,d++);return[2,[x.toTensor(),N.toTensor()]];}})})}function buffer(a,e,n){return void 0===e&&(e="float32"),new TensorBuffer(a,e,n)}function print(a,e){void 0===e&&(e=!1),console.log(a.toString(e))}function whereImpl(p,e){for(var t=[],r=0;r<e.length;r++)e[r]&&t.push(r);var l=buffer(p,"int32"),o=buffer([t.length,p.length],"int32");for(r=0;r<t.length;r++){var a=l.indexToLoc(t[r]),i=r*p.length;o.values.set(a,i)}return o.toTensor()}function float32ToTypedArray(a,e){if("float32"===e||"complex64"===e)return a;if("int32"===e||"bool"===e){for(var t="int32"===e?new Int32Array(a.length):new Uint8Array(a.length),r=0;r<t.length;++r)t[r]=_Mathround(a[r]);return t}throw new Error("Unknown dtype "+e)}function typedArrayToFloat32(t){return t instanceof Float32Array?t:new Float32Array(t)}function neg_(a){var n=convertToTensor(a,"x","neg");return ENV.engine.runKernel(function(t){return t.neg(n)},{$x:n},function(t){return{$x:function(){return t.neg()}}})}function ceil_(a){var n=convertToTensor(a,"x","ceil");return ENV.engine.runKernel(function(t){return t.ceil(n)},{$x:n},function(t){return{$x:function(){return zerosLike(t)}}})}function floor_(a){var n=convertToTensor(a,"x","floor");return ENV.engine.runKernel(function(t){return t.floor(n)},{$x:n},function(t){return{$x:function(){return zerosLike(t)}}})}function sign_(a){var n=convertToTensor(a,"x","sign");return ENV.engine.runKernel(function(t){return t.sign(n)},{$x:n},function(t){return{$x:function(){return zerosLike(t)}}})}function round_(a){var n=convertToTensor(a,"x","round");return ENV.engine.runKernel(function(t){return t.round(n)},{$x:n},function(t){return{$x:function(){return zerosLike(t)}}})}function exp_(a){var n=convertToTensor(a,"x","exp");return ENV.engine.runKernel(function(t,e){return e(t.exp(n))},{$x:n},function(a,e){var t=e[0];return{$x:function(){return a.mulStrict(t)}}})}function expm1_(a){var n=convertToTensor(a,"x","expm1");return ENV.engine.runKernel(function(t){return t.expm1(n)},{$x:n},function(t){return{$x:function(){return t.mulStrict(n.exp())}}})}function log_(a){var n=convertToTensor(a,"x","log");return ENV.engine.runKernel(function(t){return t.log(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(n.toFloat())}}})}function log1p_(a){var n=convertToTensor(a,"x","log1p");return ENV.engine.runKernel(function(t){return t.log1p(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(n.add(scalar(1)))}}})}function sqrt_(a){var n=convertToTensor(a,"x","sqrt");return ENV.engine.runKernel(function(t){return t.sqrt(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(n.toFloat().sqrt().mul(scalar(2)))}}})}function rsqrt_(a){var n=convertToTensor(a,"x","rsqrt");return ENV.engine.runKernel(function(t){return t.rsqrt(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(n.pow(scalar(1.5)).mul(scalar(2))).neg()}}})}function square_(a){var n=convertToTensor(a,"x","square");return ENV.engine.runKernel(function(t){return t.square(n)},{$x:n},function(t){return{$x:function(){return t.mulStrict(n.toFloat().mul(scalar(2)))}}})}function reciprocal_(a){var n=convertToTensor(a,"x","reciprocal");return ENV.engine.runKernel(function(t){return t.reciprocal(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(n.square().neg())}}})}function abs_(a){var n=convertToTensor(a,"x","abs");return"complex64"===n.dtype?ENV.engine.runKernel(function(t){return t.complexAbs(n)},{$x:n}):ENV.engine.runKernel(function(t){return t.abs(n)},{$x:n},function(t){return{$x:function(){return t.mulStrict(n.toFloat().step(-1))}}})}function clipByValue_(a,o,t){var r=convertToTensor(a,"x","clipByValue");return assert(o<=t,"Error in clip: min ("+o+") must be less than or equal to max ("+t+")."),ENV.engine.runKernel(function(a){return a.clip(r,o,t)},{$x:r},function(a){return{$x:function(){return a.where(r.greaterEqual(scalar(o)).logicalAnd(r.lessEqual(scalar(t))),zerosLike(a))}}})}function sigmoid_(a){var n=convertToTensor(a,"x","sigmoid");return ENV.engine.runKernel(function(t,e){return e(t.sigmoid(n))},{$x:n},function(a,e){var t=e[0];return{$x:function(){return a.mulStrict(t.mul(scalar(1).sub(t)))}}})}function logSigmoid_(a){var n=convertToTensor(a,"x","logSigmoid");return ENV.engine.runKernel(function(t){return t.softplus(n.neg()).neg()},{$x:n},function(t){return{$x:function(){return t.mulStrict(n.neg().sigmoid())}}})}function softplus_(a){var n=convertToTensor(a,"x","softplus");return ENV.engine.runKernel(function(t){return t.softplus(n)},{$x:n},function(t){return{$x:function(){return t.mulStrict(n.sigmoid())}}})}function sin_(a){var n=convertToTensor(a,"x","sin");return ENV.engine.runKernel(function(t){return t.sin(n)},{$x:n},function(t){return{$x:function(){return n.toFloat().cos().mulStrict(t)}}})}function cos_(a){var n=convertToTensor(a,"x","cos");return ENV.engine.runKernel(function(t){return t.cos(n)},{$x:n},function(t){return{$x:function(){return n.toFloat().sin().neg().mulStrict(t)}}})}function tan_(a){var n=convertToTensor(a,"x","tan");return ENV.engine.runKernel(function(t){return t.tan(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(n.cos().square())}}})}function asin_(a){var n=convertToTensor(a,"x","asin");return ENV.engine.runKernel(function(t){return t.asin(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(scalar(1).sub(n.toFloat().square()).sqrt())}}})}function acos_(a){var n=convertToTensor(a,"x","acos");return ENV.engine.runKernel(function(t){return t.acos(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(scalar(1).sub(n.toFloat().square()).sqrt()).neg()}}})}function atan_(a){var n=convertToTensor(a,"x","atan");return ENV.engine.runKernel(function(t){return t.atan(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(scalar(1).add(n.toFloat().square()))}}})}function sinh_(a){var n=convertToTensor(a,"x","sinh");return ENV.engine.runKernel(function(t){return t.sinh(n)},{$x:n},function(t){return{$x:function(){return n.toFloat().cosh().mulStrict(t)}}})}function cosh_(a){var n=convertToTensor(a,"x","cosh");return ENV.engine.runKernel(function(t){return t.cosh(n)},{$x:n},function(t){return{$x:function(){return n.toFloat().sinh().mulStrict(t)}}})}function tanh_(a){var n=convertToTensor(a,"x","tanh");return ENV.engine.runKernel(function(t,e){return e(t.tanh(n))},{$x:n},function(a,e){var t=e[0];return{$x:function(){return scalar(1).sub(t.square()).mulStrict(a)}}})}function asinh_(a){var n=convertToTensor(a,"x","asinh");return ENV.engine.runKernel(function(t){return t.asinh(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(scalar(1).add(n.toFloat().square()).sqrt())}}})}function acosh_(a){var n=convertToTensor(a,"x","acosh");return ENV.engine.runKernel(function(t){return t.acosh(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(n.toFloat().square().sub(scalar(1)).sqrt())}}})}function atanh_(a){var n=convertToTensor(a,"x","atanh");return ENV.engine.runKernel(function(t){return t.atanh(n)},{$x:n},function(t){return{$x:function(){return t.divStrict(scalar(1).sub(n.toFloat().square()))}}})}function erf_(a){var n=convertToTensor(a,"x","erf");return assert("int32"===n.dtype||"float32"===n.dtype,"Input dtype must be `int32` or `float32`."),"int32"===n.dtype&&(n=n.toFloat()),ENV.engine.runKernel(function(t){return t.erf(n)},{$x:n},function(t){return{$x:function(){return t.mulStrict(scalar(2/_Mathsqrt(Math.PI)).mul(n.square().neg().exp()))}}})}function step_(a,n){void 0===n&&(n=0);var o=convertToTensor(a,"x","step");return ENV.engine.runKernel(function(t){return t.step(o,n)},{$x:o},function(t){return{$x:function(){return zerosLike(t)}}})}function batchNormalization2d_(p,e,t,r,d,o){void 0===r&&(r=.001);var a=convertToTensor(p,"x","batchNormalization"),u=convertToTensor(e,"mean","batchNormalization"),l=convertToTensor(t,"variance","batchNormalization"),c,m;return null!=d&&(c=convertToTensor(d,"scale","batchNormalization")),null!=o&&(m=convertToTensor(o,"offset","batchNormalization")),assert(2===a.rank,"Error in batchNormalization3D: x must be rank 3 but got rank "+a.rank+"."),assert(2===u.rank||1===u.rank,"Error in batchNormalization2D: mean must be rank 2 or rank 1 but got rank "+u.rank+"."),assert(2===l.rank||1===l.rank,"Error in batchNormalization2D: variance must be rank 2 or rank 1 but got rank "+l.rank+"."),null!=c&&assert(2===c.rank||1===c.rank,"Error in batchNormalization2D: scale must be rank 2 or rank 1 but got rank "+c.rank+"."),null!=m&&assert(2===m.rank||1===m.rank,"Error in batchNormalization2D: offset must be rank 2 or rank 1 but got rank "+m.rank+"."),batchNormalization(a,u,l,r,c,m)}function batchNormalization3d_(p,e,t,r,d,o){void 0===r&&(r=.001);var a=convertToTensor(p,"x","batchNormalization"),u=convertToTensor(e,"mean","batchNormalization"),l=convertToTensor(t,"variance","batchNormalization"),c,m;return null!=d&&(c=convertToTensor(d,"scale","batchNormalization")),null!=o&&(m=convertToTensor(o,"offset","batchNormalization")),assert(3===a.rank,"Error in batchNormalization3D: x must be rank 3 but got rank "+a.rank+"."),assert(3===u.rank||1===u.rank,"Error in batchNormalization3D: mean must be rank 3 or rank 1 but got rank "+u.rank+"."),assert(3===l.rank||1===l.rank,"Error in batchNormalization3D: variance must be rank 3 or rank 1 but got rank "+l.rank+"."),null!=c&&assert(3===c.rank||1===c.rank,"Error in batchNormalization3D: scale must be rank 3 or rank 1 but got rank "+c.rank+"."),null!=m&&assert(3===m.rank||1===m.rank,"Error in batchNormalization3D: offset must be rank 3 or rank 1 but got rank "+m.rank+"."),batchNormalization(a,u,l,r,c,m)}function batchNormalization4d_(p,e,t,r,d,o){void 0===r&&(r=.001);var a=convertToTensor(p,"x","batchNormalization"),u=convertToTensor(e,"mean","batchNormalization"),l=convertToTensor(t,"variance","batchNormalization"),c,m;return null!=d&&(c=convertToTensor(d,"scale","batchNormalization")),null!=o&&(m=convertToTensor(o,"offset","batchNormalization")),assert(4===a.rank,"Error in batchNormalization4D: x must be rank 4 but got rank "+a.rank+"."),assert(4===u.rank||1===u.rank,"Error in batchNormalization4D: mean must be rank 4 or rank 1 but got rank "+u.rank+"."),assert(4===l.rank||1===l.rank,"Error in batchNormalization4D: variance must be rank 4 or rank 1 but got rank "+l.rank+"."),null!=c&&assert(4===c.rank||1===c.rank,"Error in batchNormalization4D: scale must be rank 4 or rank 1 but got rank "+c.rank+"."),null!=m&&assert(4===m.rank||1===m.rank,"Error in batchNormalization4D: offset must be rank 4 or rank 1 but got rank "+m.rank+"."),batchNormalization(a,u,l,r,c,m)}function batchNormalization_(d,e,t,m,r,o){void 0===m&&(m=.001);var g=convertToTensor(d,"x","batchNormalization"),l=convertToTensor(e,"mean","batchNormalization"),c=convertToTensor(t,"variance","batchNormalization"),p,a,y;return null!=r&&(p=convertToTensor(r,"scale","batchNormalization")),null!=o&&(a=convertToTensor(o,"offset","batchNormalization")),assert(l.rank===c.rank,"Batch normalization gradient requires mean and variance to have equal ranks."),assert(null==a||l.rank===a.rank,"Batch normalization gradient requires mean and offset to have equal ranks."),assert(null==p||l.rank===p.rank,"Batch normalization gradient requires mean and scale to have equal ranks."),y=0===g.rank||1===g.rank?g.as4D(1,1,1,g.size):2===g.rank?g.as4D(1,1,g.shape[0],g.shape[1]):3===g.rank?g.as4D(1,g.shape[0],g.shape[1],g.shape[2]):g,ENV.engine.runKernel(function(t){return t.batchNormalization(y,batchnormReshape4D(l),batchnormReshape4D(c),m,batchnormReshape4D(p),batchnormReshape4D(a))},{$x:g,$mean:l,$variance:c,$scale:p,$offset:a},function(i){var e=null==p?scalar(1):p,u=getReductionAxes(l.shape,y.shape),t=[];if(1===l.rank){for(var n=0;n<y.shape.length-1;++n)t.push(y.shape[n]);t.push(1)}var r=g.sub(l),o=i.mul(e),s=rsqrt(c.add(scalar(m))),d=s.mul(s).mul(s).mul(scalar(-.5));return{$x:function(){return 1===l.rank?i.mul(tile(s.as4D(1,1,1,l.shape[0]),t)).mul(e).reshape(g.shape):i.mul(s).mul(e).reshape(g.shape)},$mean:function(){var t=s.mul(scalar(-1)).mul(o);return 1===l.rank&&(t=t.sum(u)),t.reshape(l.shape)},$variance:function(){var t=d.mul(r).mul(o);return 1===l.rank&&(t=t.sum(u)),t.reshape(l.shape)},$scale:function(){var e=r.mul(s),t=i.mul(e);return 1===l.rank&&(t=t.sum(u)),t.reshape(l.shape)},$offset:function(){var e=i;return 1===l.rank&&(e=e.sum(u)),e.reshape(l.shape)}}}).reshape(g.shape)}function batchnormReshape4D(t){return null==t?null:0===t.rank?t.as1D():1===t.rank?t:2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t}function computePool2DInfo(p,e,t,r,n,o,a){void 0===a&&(a="channelsLast");var d=parseTupleParam(e),u=d[0],l=d[1],c;if("channelsLast"===a)c=[u,l,p[3],p[3]];else{if("channelsFirst"!==a)throw new Error("Unknown dataFormat "+a);c=[u,l,p[1],p[1]]}return computeConv2DInfo(p,c,t,r,n,o,!1,a)}function computeConv2DInfo(I,e,t,r,n,o,a,k){void 0===a&&(a=!1),void 0===k&&(k="channelsLast");var D=[-1,-1,-1,-1],u=D[0],P=D[1],O=D[2],L=D[3];if("channelsLast"===k)u=I[0],P=I[1],O=I[2],L=I[3];else{if("channelsFirst"!==k)throw new Error("Unknown dataFormat "+k);u=I[0],L=I[1],P=I[2],O=I[3]}var z=e[0],f=e[1],m=e[3],g=parseTupleParam(t),v=g[0],y=g[1],x=parseTupleParam(r),T=x[0],E=x[1],w=getEffectiveFilterSize(z,T),S=getEffectiveFilterSize(f,E),b=getPadAndOutInfo(n,P,O,v,y,w,S,o),C=b.padInfo,_=b.outHeight,A=b.outWidth,N=a?m*L:m,R;return"channelsFirst"===k?R=[u,N,_,A]:"channelsLast"==k&&(R=[u,_,A,N]),{batchSize:u,dataFormat:k,inHeight:P,inWidth:O,inChannels:L,outHeight:_,outWidth:A,outChannels:N,padInfo:C,strideHeight:v,strideWidth:y,filterHeight:z,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:S,dilationHeight:T,dilationWidth:E,inShape:I,outShape:R,filterShape:e}}function computeOutputShape3D(p,e,t,r,n,d){null==n&&(n=computeDefaultPad(p,e,r));var a=p[0],i=p[1],s=conditionalRound((a-e+2*n)/r+1,d);assert(isInt(s),"The output # of rows ("+s+") must be an integer. Change the stride and/or zero pad parameters");var u=conditionalRound((i-e+2*n)/r+1,d);return assert(isInt(u),"The output # of columns ("+u+") must be an integer. Change the stride and/or zero pad parameters"),[s,u,t]}function computeDefaultPad(a,e,t,r){void 0===r&&(r=1);var s=getEffectiveFilterSize(e,r);return _Mathfloor((a[0]*(t-1)-t+s)/2)}function parseTupleParam(t){return"number"==typeof t?[t,t]:t}function getEffectiveFilterSize(a,e){return 1>=e?a:a+(a-1)*(e-1)}function getPadAndOutInfo(m,e,t,r,n,o,a,i){var s,y,b;if("number"==typeof m){s={top:m,bottom:m,left:m,right:m,type:0===m?"VALID":"NUMBER"};var x=computeOutputShape3D([e,t,1],o,1,r,m,i);y=x[0],b=x[1]}else if("same"===m){var p=((y=_Mathceil(e/r))-1)*r+o-e,d=((b=_Mathceil(t/n))-1)*n+a-t,h=_Mathfloor(p/2),f=_Mathfloor(d/2);s={top:h,bottom:p-h,left:f,right:d-f,type:"SAME"}}else{if("valid"!==m)throw Error("Unknown padding parameter: "+m);s={top:0,bottom:0,left:0,right:0,type:"VALID"},y=_Mathceil((e-o+1)/r),b=_Mathceil((t-a+1)/n)}return{padInfo:s,outHeight:y,outWidth:b}}function conditionalRound(a,e){if(!e)return a;switch(e){case"round":return _Mathround(a);case"ceil":return _Mathceil(a);case"floor":return _Mathfloor(a);default:throw new Error("Unknown roundingMode "+e);}}function tupleValuesAreOne(a){var e=parseTupleParam(a),t=e[0],r=e[1];return 1===t&&1===r}function eitherStridesOrDilationsAreOne(a,e){return tupleValuesAreOne(a)||tupleValuesAreOne(e)}function matMul_(y,e,t,b){void 0===t&&(t=!1),void 0===b&&(b=!1);var x=convertToTensor(y,"a","matMul"),o=convertToTensor(e,"b","matMul"),a=t?x.shape[x.rank-2]:x.shape[x.rank-1],i=b?o.shape[o.rank-1]:o.shape[o.rank-2],s=t?x.shape[x.rank-1]:x.shape[x.rank-2],u=b?o.shape[o.rank-2]:o.shape[o.rank-1],l=x.shape.slice(0,-2),c=o.shape.slice(0,-2),p=sizeFromShape(l),d=sizeFromShape(c);assert(2<=x.rank&&2<=o.rank&&x.rank===o.rank,"Error in matMul: inputs must have the same rank of at least 2, got ranks "+x.rank+" and "+o.rank+"."),assert(arraysEqual(l,c),"Error in matMul: outer dimensions ("+l+") and ("+c+") of Tensors with shapes "+x.shape+" and "+o.shape+" must match."),assert(a===i,"Error in matMul: inner shapes ("+a+") and ("+i+") of Tensors with shapes "+x.shape+" and "+o.shape+" and transposeA="+t+" and transposeB="+b+" must match.");var h=x.shape.slice(0,-2).concat([s,u]),f=t?x.as3D(p,a,s):x.as3D(p,s,a),m=b?o.as3D(d,u,i):o.as3D(d,i,u);return ENV.engine.runKernel(function(a){return a.batchMatMul(f,m,t,b)},{$a:f,$b:m},function(a){return t||b?!t&&b?{$a:function(){return a.matMul(m.toFloat(),!1,!1)},$b:function(){return a.matMul(f.toFloat(),!0,!1)}}:t&&!b?{$a:function(){return m.toFloat().matMul(a,!1,!0)},$b:function(){return f.toFloat().matMul(a,!1,!1)}}:{$a:function(){return m.toFloat().matMul(a,!0,!0)},$b:function(){return a.matMul(f.toFloat(),!0,!0)}}:{$a:function(){return a.matMul(m.toFloat(),!1,!0)},$b:function(){return f.toFloat().matMul(a,!0,!1)}}}).reshape(h)}function outerProduct_(a,e){var t=convertToTensor(a,"v1","outerProduct"),r=convertToTensor(e,"v2","outerProduct");return assert(1===t.rank&&1===r.rank,"Error in outerProduct: inputs must be rank 1, but got ranks "+t.rank+" and "+r.rank+"."),t.as2D(-1,1).matMul(r.as2D(1,-1))}function dot_(s,e){var t=convertToTensor(s,"t1","dot"),r=convertToTensor(e,"t2","dot");assert((1===t.rank||2===t.rank)&&(1===r.rank||2===r.rank),"Error in dot: inputs must all be rank 1 or 2, but got ranks "+t.rank+" and "+r.rank+".");var n=1===t.rank?t.size:t.shape[1],o=1===r.rank?r.size:r.shape[0];return assert(n===o,"Error in dot: inner dimensions of inputs must match, but got "+n+" and "+o+"."),1===t.rank&&1===r.rank?t.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():1===t.rank&&2===r.rank?t.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():2===t.rank&&1===r.rank?t.matMul(r.as2D(-1,1)).as1D():t.matMul(r.as2D(r.shape[0],r.shape[1]))}function conv1d_(m,e,t,r,n,g,f){void 0===n&&(n="NWC"),void 0===g&&(g=1);var i=convertToTensor(m,"x","conv1d"),s=convertToTensor(e,"filter","conv1d"),u=i,y=!1;2===i.rank&&(y=!0,u=i.as3D(1,i.shape[0],i.shape[1])),assert(3===u.rank,"Error in conv1d: input must be rank 3, but got rank "+u.rank+"."),assert(3===s.rank,"Error in conv1d: filter must be rank 3, but got rank "+s.rank+"."),null!=f&&assert(isInt(r),"Error in conv1d: pad must be an integer when using, dimRoundingMode "+f+" but got pad "+r+"."),assert(u.shape[2]===s.shape[1],"Error in conv1d: depth of input ("+u.shape[2]+") must match input depth for filter "+s.shape[1]+"."),assert(eitherStridesOrDilationsAreOne(t,g),"Error in conv1D: Either stride or dilation must be 1. Got stride "+t+" and dilation '"+g+"'"),assert("NWC"===n,"Error in conv1d: got dataFormat of "+n+" but only NWC is currently supported.");var b=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),p=u.as4D(u.shape[0],1,u.shape[1],u.shape[2]),d=conv2d(p,b,[1,t],r,"NHWC",[1,g],f);return y?d.as2D(d.shape[2],d.shape[3]):d.as3D(d.shape[0],d.shape[2],d.shape[3])}function conv2d_(m,e,t,r,n,g,y){void 0===n&&(n="NHWC"),void 0===g&&(g=[1,1]);var i=convertToTensor(m,"x","conv2d"),s=convertToTensor(e,"filter","conv2d"),u=i,b=!1;3===i.rank&&(b=!0,u=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(4===u.rank,"Error in conv2d: input must be rank 4, but got rank "+u.rank+"."),assert(4===s.rank,"Error in conv2d: filter must be rank 4, but got rank "+s.rank+"."),null!=y&&assert(isInt(r),"Error in conv2d: pad must be an integer when using, dimRoundingMode "+y+" but got pad "+r+"."),assert(u.shape[3]===s.shape[2],"Error in conv2d: depth of input ("+u.shape[3]+") must match input depth for filter "+s.shape[2]+"."),assert(eitherStridesOrDilationsAreOne(t,g),"Error in conv2D: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+g+"'"),assert("NHWC"===n,"Error in conv2d: got dataFormat of "+n+" but only NHWC is currently supported.");var x=computeConv2DInfo(u.shape,s.shape,t,g,r,y),d;if(1!==x.filterHeight||1!==x.filterWidth||1!==x.dilationHeight||1!==x.dilationWidth||1!==x.strideHeight||1!==x.strideWidth||"SAME"!==x.padInfo.type&&"VALID"!==x.padInfo.type)d=ENV.engine.runKernel(function(t){return t.conv2d(u,s,x)},{x:u,$filter:s},function(a){return assert(tupleValuesAreOne(g),"Error in gradient of conv2D: dilation rates greater than 1 are notyet supported in gradients. Got dilations '"+g+"'"),{x:function(){return conv2dDerInput_(u.shape,a,s,t,r)},$filter:function(){return conv2dDerFilter_(u,a,s.shape,t,r)}}});else{var N=u.reshape([-1,x.inChannels]),h=s.reshape([x.inChannels,x.outChannels]);d=matMul(N,h).reshape(x.outShape)}return b?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function conv2dDerInput_(m,e,t,r,n,o){assert(m.length===e.rank,"Length of inShape ("+m.length+") and rank of dy ("+e.rank+") must match");var a=m,h=e,g=!1;3===e.rank&&(g=!0,h=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]),a=[1,m[0],m[1],m[2]]);var f=a[3],l=h.shape[3];assert(4===a.length,"Error in conv2dDerInput: inShape must be length 4, but got length "+a.length+"."),assert(4===h.rank,"Error in conv2dDerInput: dy must be rank 4, but got rank "+h.rank),assert(4===t.rank,"Error in conv2dDerInput: filter must be rank 4, but got rank "+t.rank),assert(f===t.shape[2],"Error in conv2dDerInput: depth of input ("+f+") must match input depth for filter "+t.shape[2]+"."),assert(l===t.shape[3],"Error in conv2dDerInput: depth of output ("+l+") must match output depth for filter "+t.shape[3]+"."),null!=o&&assert(isInt(n),"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+n+".");var c=computeConv2DInfo(a,t.shape,r,1,n,o),p=ENV.engine.runKernel(function(a){return a.conv2dDerInput(h,t,c)},{dy4D:h,filter:t},function(a){return{dy4D:function(){return conv2d(a,t,r,n,"NHWC",1,o)},filter:function(){return conv2dDerFilter(a,h,t.shape,r,n,o)}}});return g?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function conv2dDerFilter_(p,e,t,r,n,o){var a=p;3===p.rank&&(a=p.as4D(1,p.shape[0],p.shape[1],p.shape[2]));var l=e;3===l.rank&&(l=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),assert(4===a.rank,"Error in conv2dDerFilter: input must be rank 4, but got shape "+a.shape+"."),assert(4===l.rank,"Error in conv2dDerFilter: dy must be rank 4, but got shape "+l.shape+"."),assert(4===t.length,"Error in conv2dDerFilter: filterShape must be length 4, but got "+t+"."),assert(a.shape[3]===t[2],"Error in conv2dDerFilter: depth of input "+a.shape[3]+") must match input depth in filter ("+t[2]+"."),assert(l.shape[3]===t[3],"Error in conv2dDerFilter: depth of dy ("+l.shape[3]+") must match output depth for filter ("+t[3]+")."),null!=o&&assert(isInt(n),"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+n+".");var d=computeConv2DInfo(a.shape,t,r,1,n,o);return ENV.engine.runKernel(function(t){return t.conv2dDerFilter(a,l,d)},{x4D:a,dy4D:l})}function conv2dTranspose_(s,e,t,r,n,o){return conv2dDerInput_(t,convertToTensor(s,"x","conv2dTranspose"),convertToTensor(e,"filter","conv2dTranspose"),r,n,o)}function depthwiseConv2d_(m,e,t,r,n,h,g){void 0===n&&(n="NHWC"),void 0===h&&(h=[1,1]);var i=convertToTensor(m,"x","depthwiseConv2d"),s=convertToTensor(e,"filter","depthwiseConv2d"),u=i,f=!1;3===i.rank&&(f=!0,u=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(4===u.rank,"Error in depthwiseConv2d: input must be rank 4, but got rank "+u.rank+"."),assert(4===s.rank,"Error in depthwiseConv2d: filter must be rank 4, but got rank "+s.rank+"."),assert(u.shape[3]===s.shape[2],"Error in depthwiseConv2d: number of input channels ("+u.shape[3]+") must match the inChannels dimension in filter "+s.shape[2]+"."),null==h&&(h=[1,1]),assert(eitherStridesOrDilationsAreOne(t,h),"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+h+"'"),null!=g&&assert(isInt(r),"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+g+" but got pad "+r+".");var y=computeConv2DInfo(u.shape,s.shape,t,h,r,g,!0),p=ENV.engine.runKernel(function(t){return t.depthwiseConv2D(u,s,y)},{x:u,$filter:s},function(t){return assert(tupleValuesAreOne(h),"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+h+"'"),{x:function(){return depthwiseConv2dDerInput(u.shape,t,s,y)},$filter:function(){return depthwiseConv2dDerFilter(u,t,s.shape,y)}}});return f?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function separableConv2d_(g,e,t,r,n,o,y){void 0===o&&(o=[1,1]),void 0===y&&(y="NHWC");var b=convertToTensor(g,"x","separableConv2d"),s=convertToTensor(e,"depthwiseFilter","separableConv2d"),u=convertToTensor(t,"pointwiseFilter","separableConv2d"),l=b,x=!1;if(3===b.rank&&(x=!0,l=b.as4D(1,b.shape[0],b.shape[1],b.shape[2])),"NCHW"===y)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");assert(4===l.rank,"Error in separableConv2d: input must be rank 4, but got rank "+l.rank+"."),assert(4===s.rank,"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+s.rank+"."),assert(4===u.rank,"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+s.rank+"."),assert(1===u.shape[0],"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+u.shape[0]+"."),assert(1===u.shape[1],"Error in separableConv2d: the second dimension of pointwise filter  must be 1, but got "+u.shape[1]+".");var N=s.shape[2],d=s.shape[3];assert(u.shape[2]===N*d,"Error in separableConv2d: the third dimension of pointwise filter must be "+N*d+", but got "+u.shape[2]+".");var h=depthwiseConv2d(l,s,r,n,y,o),f=conv2d(h,u,1,"valid",y);return x?f.as3D(f.shape[1],f.shape[2],f.shape[3]):f}function depthwiseConv2dDerInput(s,e,t,r){var n=e,p=!1;3===e.rank&&(p=!0,n=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var l=ENV.engine.runKernel(function(a){return a.depthwiseConv2DDerInput(n,t,r)},{dy4D:n});return p?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}function depthwiseConv2dDerFilter(s,e,t,r){var n=s;3===s.rank&&(n=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]));var i=e;return 3===i.rank&&(i=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),ENV.engine.runKernel(function(t){return t.depthwiseConv2DDerFilter(n,i,r)},{x4D:n,dy4D:i})}function reverse1d_(a){var e=convertToTensor(a,"x","reverse");return assert(1===e.rank,"Error in reverse1D: x must be rank 1 but got\n             rank "+e.rank+"."),reverse(e,0)}function reverse2d_(a,e){var t=convertToTensor(a,"x","reverse");return assert(2===t.rank,"Error in reverse2D: x must be rank 2 but got\n             rank "+t.rank+"."),reverse(t,e)}function reverse3d_(a,e){var t=convertToTensor(a,"x","reverse");return assert(3===t.rank,"Error in reverse3D: x must be rank 3 but got\n             rank "+t.rank+"."),reverse(t,e)}function reverse4d_(a,e){var t=convertToTensor(a,"x","reverse");return assert(4===t.rank,"Error in reverse4D: x must be rank 4 but got\n             rank "+t.rank+"."),reverse(t,e)}function reverse_(a,e){var t=convertToTensor(a,"x","reverse");if(0===t.rank)return t.clone();var r=parseAxisParam(e,t.shape);return ENV.engine.runKernel(function(a){return a.reverse(t,r)},{$x:t},function(t){return{$x:function(){return t.reverse(r)}}}).reshapeAs(t)}function maxPoolImpl_(p,d,t,r,m,e){var a=convertToTensor(p,"x","maxPool"),o=a,i=!1;3===a.rank&&(i=!0,o=a.as4D(1,a.shape[0],a.shape[1],a.shape[2])),null==r&&(r=[1,1]),assert(4===o.rank,"Error in maxPool: input must be rank 4 but got rank "+o.rank+"."),assert(eitherStridesOrDilationsAreOne(t,r),"Error in maxPool: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+r+"'"),null!=e&&assert(isInt(m),"Error in maxPool: pad must be an integer when using, dimRoundingMode "+e+" but got pad "+m+".");var h=computePool2DInfo(o.shape,d,t,r,m,e),l=ENV.engine.runKernel(function(a,e){return e(a.maxPool(o,h))},{x:o},function(n,e){var a=e[0];return{x:function(){return maxPoolBackprop(n,o,a,d,t,r,m)}}});return i?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}function maxPool_(a,e,t,r,n){return maxPoolImpl_(a,e,t,1,r,n)}function avgPoolImpl_(p,d,t,r,m,e){var a=convertToTensor(p,"x","avgPool");assert("float32"===a.dtype,"The input dtype to avgPool must be float32"),null==r&&(r=[1,1]),assert(eitherStridesOrDilationsAreOne(t,r),"Error in avgPool: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+r+"'");var o=a,i=!1;3===a.rank&&(i=!0,o=a.as4D(1,a.shape[0],a.shape[1],a.shape[2])),assert(4===o.rank,"Error in avgPool: x must be rank 4 but got rank "+o.rank+"."),null!=e&&assert(isInt(m),"Error in avgPool: pad must be an integer when using, dimRoundingMode "+e+" but got pad "+m+".");var h=computePool2DInfo(o.shape,d,t,r,m),l=ENV.engine.runKernel(function(t){return t.avgPool(o,h)},{x:o},function(a){return{x:function(){return avgPoolBackprop(a,o,d,t,r,m)}}});return l=l.cast(a.dtype),i?l.as3D(l.shape[1],l.shape[2],l.shape[3]):l}function avgPool_(a,e,t,r,n){return avgPoolImpl_(a,e,t,1,r,n)}function pool_(b,e,t,r,N,I){null==N&&(N=[1,1]),null==I&&(I=1),0===r&&(r="valid");var S=convertToTensor(b,"x","maxPool"),i=S,C=!1;3===S.rank&&(C=!0,i=S.as4D(1,S.shape[0],S.shape[1],S.shape[2])),assert(eitherStridesOrDilationsAreOne(I,N),"Error in pool: Either strides or dilations must be 1. Got strides "+I+" and dilations '"+N+"'");var k=computePool2DInfo(i.shape,e,I,N,r),c=[k.dilationHeight,k.dilationWidth],p;p="same"===r?withSpaceToBatchBasePaddings([k.filterHeight,k.filterWidth],c):[[0,0],[0,0]];var T=1===c[0]&&1===c[1],d=requiredSpaceToBatchPaddings([k.inHeight,k.inWidth],c,p),h=d[0],f=d[1],m=T?r:"valid",g=T?i:spaceToBatchND(i,c,h),v=("avg"===t?function(){return avgPoolImpl_(g,e,I,1,m)}:function(){return maxPoolImpl_(g,e,I,1,m)})(),y=T?v:batchToSpaceND(v,c,f);return C?y.as3D(y.shape[1],y.shape[2],y.shape[3]):y}function maxPoolBackprop(d,e,t,r,n,o,m,i){var s=convertToTensor(d,"dy","maxPoolBackprop"),u=convertToTensor(e,"input","maxPoolBackprop"),l=convertToTensor(t,"output","maxPoolBackprop");assert(u.rank===s.rank,"Rank of input ("+u.rank+") does not match rank of dy ("+s.rank+")"),null==o&&(o=[1,1]),assert(eitherStridesOrDilationsAreOne(n,o),"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+o+"'"),assert(4===s.rank,"Error in maxPoolBackprop: dy must be rank 4 but got rank "+s.rank+"."),assert(4===u.rank,"Error in maxPoolBackprop: input must be rank 4 but got rank "+u.rank+"."),null!=i&&assert(isInt(m),"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+m+".");var c=computePool2DInfo(u.shape,r,n,o,m,i);return ENV.engine.runKernel(function(t){return t.maxPoolBackprop(s,u,l,c)},{$dy:s,$input:u})}function avgPoolBackprop(m,e,t,r,n,h){var a=convertToTensor(m,"dy","avgPoolBackprop"),i=convertToTensor(e,"input","avgPoolBackprop");assert(i.rank===a.rank,"Rank of input ("+i.rank+") does not match rank of dy ("+a.rank+")"),null==n&&(n=[1,1]),assert(eitherStridesOrDilationsAreOne(r,n),"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+n+"'");var s=i,g=a,f=!1;3===i.rank&&(f=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2]),g=a.as4D(1,a.shape[0],a.shape[1],a.shape[2])),assert(4===g.rank,"Error in avgPoolBackprop: dy must be rank 4 but got rank "+g.rank+"."),assert(4===s.rank,"Error in avgPoolBackprop: input must be rank 4 but got rank "+s.rank+".");var y=computePool2DInfo(s.shape,t,r,n,h),p=ENV.engine.runKernel(function(t){return t.avgPoolBackprop(g,s,y)},{dy4D:g,input4D:s});return f?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function requiredSpaceToBatchPaddings(p,e,t){var r=t.map(function(t){return t[0]}),n=t.map(function(t){return t[1]}),o=p.concat(r,n),a=e.map(function(a,e){return(a-o[e]%a)%a}),i=n.map(function(n,e){return n+a[e]});return[e.map(function(a,e){return[r[e],i[e]]}),e.map(function(n,e){return[0,a[e]]})]}function withSpaceToBatchBasePaddings(a,s){var e=a.map(function(t,e){return t+(t-1)*(s[e]-1)}).map(function(t){return t-1}),r=e.map(function(t){return _Mathfloor(t/2)}),n=e.map(function(a,e){return a-r[e]});return e.map(function(a,e){return[r[e],n[e]]})}function slice1d_(a,e,t){var r=convertToTensor(a,"x","slice1d");return assert(1===r.rank,"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"),slice(r,[e],[t])}function slice2d_(a,e,t){var r=convertToTensor(a,"x","slice2d");return assert(2===r.rank,"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"),slice(r,e,t)}function slice3d_(a,e,t){var r=convertToTensor(a,"x","slice3d");return assert(3===r.rank,"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"),slice(r,e,t)}function slice4d_(a,e,t){var r=convertToTensor(a,"x","slice4d");return assert(4===r.rank,"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"),slice(r,e,t)}function slice_(s,e,t){var r=convertToTensor(s,"x","slice"),a,p;if(0===r.rank)throw new Error("Slicing scalar is not possible");a="number"==typeof e?[e].concat(Array(r.rank-1).fill(0)):e.length<r.rank?e.concat(Array(r.rank-e.length).fill(0)):e.slice(),p=(p=null==t?Array(r.rank).fill(-1):"number"==typeof t?[t].concat(Array(r.rank-1).fill(-1)):t.length<r.rank?t.concat(Array(r.rank-t.length).fill(-1)):t).map(function(n,e){return 0<=n?n:(assert(-1==n,"Bad value in size"),r.shape[e]-a[e])}),assertParamsValid(r,a,p);var l=r.shape;return ENV.engine.runKernel(function(t){return t.slice(r,a,p)},{$x:r},function(n){for(var e=[],t=0;t<n.rank;t++)e.push([a[t],l[t]-a[t]-p[t]]);return{$x:function(){return n.pad(e)}}})}function logSumExp_(p,e,l){void 0===e&&(e=null),void 0===l&&(l=!1);var d=convertToTensor(p,"x","logSumExp"),n=parseAxisParam(e,d.shape),o=d.max(n,!0),a=d.sub(o).exp().sum(n).log(),i=o.reshape(a.shape).add(a);if(l){var s=expandShapeToKeepDim(i.shape,n);return i.reshape(s)}return i}function sum_(a,e,p){void 0===e&&(e=null),void 0===p&&(p=!1);var s=convertToTensor(a,"x","sum");"bool"===s.dtype&&(s=s.toInt());var l=parseAxisParam(e,s.shape);return customGrad(function(o){var e=getAxesPermutation(l,o.rank),t=l,r=o;null!=e&&(r=o.transpose(e),t=getInnerMostAxes(t.length,o.rank));var d=ENV.engine.runKernel(function(a){return a.sum(r,t)},{permutedX:r});if(p){var u=expandShapeToKeepDim(d.shape,l);d=d.reshape(u)}return{value:d,gradFunc:function(e){var t=o.shape.slice();return l.forEach(function(a){t[a]=1}),e.reshape(t).mul(ones$1(o.shape,"float32"))}}})(s)}function prod_(p,e,d){void 0===e&&(e=null),void 0===d&&(d=!1);var c=convertToTensor(p,"x","prod");"bool"===c.dtype&&(c=c.toInt());var m=parseAxisParam(e,c.shape),o=getAxesPermutation(m,c.rank),a=m,h=c;null!=o&&(h=c.transpose(o),a=getInnerMostAxes(a.length,c.rank));var g=ENV.engine.runKernel(function(t){return t.prod(h,a)},{permutedX:h});if(d){var f=expandShapeToKeepDim(g.shape,m);g=g.reshape(f)}return g}function mean_(s,i,p){void 0===i&&(i=null),void 0===p&&(p=!1);var e=convertToTensor(s,"x","mean"),l=parseAxisParam(i,e.shape),o=sizeFromShape(computeOutAndReduceShapes(e.shape,l)[1]);return customGrad(function(a){var e=scalar(o);return{value:(e.dtype===a.dtype?a:a.cast(e.dtype)).div(e).sum(i,p),gradFunc:function(n){var t=a.shape.slice();return l.forEach(function(a){t[a]=1}),n.reshape(t).mul(ones$1(a.shape,"float32")).div(e)}}})(e)}function gradForMinAndMax(s,i,p,t,n){var r=i[0];return r.rank<p.rank&&(r=r.reshape(expandShapeToKeepDim(r.shape,t))),s.rank<p.rank&&(s=s.reshape(expandShapeToKeepDim(s.shape,t))),{$x:function(){var e=s.mul(p.equal(r).cast(s.dtype));return null==n?e:e.transpose(n)}}}function min_(p,e,d){void 0===e&&(e=null),void 0===d&&(d=!1);var c=convertToTensor(p,"x","min"),m=c,o=parseAxisParam(e,c.shape),a=o,h=getAxesPermutation(a,c.rank);null!=h&&(c=c.transpose(h),a=getInnerMostAxes(a.length,c.rank));var s=ENV.engine.runKernel(function(n,e){return e(n.min(c,a))},{$x:c},function(a,e){return gradForMinAndMax(a,e,m,o,h)});if(d){var g=expandShapeToKeepDim(s.shape,o);s=s.reshape(g)}return s}function max_(p,e,d){void 0===e&&(e=null),void 0===d&&(d=!1);var c=convertToTensor(p,"x","max"),m=c,o=parseAxisParam(e,c.shape),a=o,h=getAxesPermutation(a,c.rank);null!=h&&(c=c.transpose(h),a=getInnerMostAxes(a.length,c.rank));var s=ENV.engine.runKernel(function(n,e){return e(n.max(c,a))},{$x:c},function(a,e){return gradForMinAndMax(a,e,m,o,h)});if(d){var g=expandShapeToKeepDim(s.shape,o);s=s.reshape(g)}return s}function argMin_(a,e){void 0===e&&(e=0);var s=convertToTensor(a,"x","argMin");null==e&&(e=0);var i=parseAxisParam(e,s.shape),p=getAxesPermutation(i,s.rank);return null!=p&&(s=s.transpose(p),i=getInnerMostAxes(i.length,s.rank)),ENV.engine.runKernel(function(t){return t.argMin(s,i[0])},{$x:s},function(){return{$x:function(){return zerosLike(s)}}})}function argMax_(a,e){void 0===e&&(e=0);var s=convertToTensor(a,"x","argMax");null==e&&(e=0);var i=parseAxisParam(e,s.shape),p=getAxesPermutation(i,s.rank);return null!=p&&(s=s.transpose(p),i=getInnerMostAxes(i.length,s.rank)),ENV.engine.runKernel(function(t){return t.argMax(s,i[0])},{$x:s},function(){return{$x:function(){return zerosLike(s)}}})}function all_(p,e,l){void 0===e&&(e=null),void 0===l&&(l=!1);var d=convertToTensor(p,"x","all","bool");assert("bool"===d.dtype,"Error Tensor must be of type bool. Got: "+d.dtype);var c=parseAxisParam(e,d.shape),o=c,m=getAxesPermutation(o,d.rank);null!=m&&(d=d.transpose(m),o=getInnerMostAxes(o.length,d.rank));var i=ENV.engine.runKernel(function(t){return t.all(d,o)},{$x:d});if(l){var s=expandShapeToKeepDim(i.shape,c);return i.reshape(s)}return i}function any_(p,e,l){void 0===e&&(e=null),void 0===l&&(l=!1);var d=convertToTensor(p,"x","any","bool");assert("bool"===d.dtype,"Error Tensor must be of type bool. Got: "+d.dtype);var c=parseAxisParam(e,d.shape),o=c,m=getAxesPermutation(o,d.rank);null!=m&&(d=d.transpose(m),o=getInnerMostAxes(o.length,d.rank));var i=ENV.engine.runKernel(function(t){return t.any(d,o)},{$x:d});if(l){var s=expandShapeToKeepDim(i.shape,c);return i.reshape(s)}return i}function moments_(s,i,p){void 0===i&&(i=null),void 0===p&&(p=!1);var l=parseAxisParam(i,(s=convertToTensor(s,"x","moments")).shape),n=s.mean(l,p),o=n.shape;return p||(o=expandShapeToKeepDim(n.shape,l)),{mean:n,variance:s.toFloat().sub(n.reshape(o)).square().mean(l,p)}}function notEqual_(a,e){var t=convertToTensor(a,"a","notEqual"),r=convertToTensor(e,"b","notEqual");return assertTypesMatch(t,r),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.notEqual(t,r)},{$a:t,$b:r})}function notEqualStrict_(a,e){var t=convertToTensor(a,"a","notEqualStrict"),r=convertToTensor(e,"b","notEqualStrict");return assertShapesMatch(t.shape,r.shape,"Error in notEqualStrict: "),t.notEqual(r)}function less_(a,e){var t=convertToTensor(a,"a","less"),r=convertToTensor(e,"b","less");return assertTypesMatch(t,r),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.less(t,r)},{$a:t,$b:r})}function lessStrict_(a,e){var t=convertToTensor(a,"a","lessStrict"),r=convertToTensor(e,"b","lessStrict");return assertShapesMatch(t.shape,r.shape,"Error in lessStrict: "),t.less(r)}function equal_(a,e){var t=convertToTensor(a,"a","equal"),r=convertToTensor(e,"b","equal");return assertTypesMatch(t,r),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.equal(t,r)},{$a:t,$b:r})}function equalStrict_(a,e){var t=convertToTensor(a,"a","equalStrict"),r=convertToTensor(e,"b","equalStrict");return assertShapesMatch(t.shape,r.shape,"Error in equalStrict: "),t.equal(r)}function lessEqual_(a,e){var t=convertToTensor(a,"a","lessEqual"),r=convertToTensor(e,"b","lessEqual");return assertTypesMatch(t,r),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.lessEqual(t,r)},{$a:t,$b:r})}function lessEqualStrict_(a,e){var t=convertToTensor(a,"a","lessEqualStrict"),r=convertToTensor(e,"b","lessEqualStrict");return assertShapesMatch(t.shape,r.shape,"Error in lessEqualStrict: "),t.lessEqual(r)}function greater_(a,e){var t=convertToTensor(a,"a","greater"),r=convertToTensor(e,"b","greater");return assertTypesMatch(t,r),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.greater(t,r)},{$a:t,$b:r})}function greaterStrict_(a,e){var t=convertToTensor(a,"a","greaterStrict"),r=convertToTensor(e,"b","greaterStrict");return assertShapesMatch(t.shape,r.shape,"Error in greaterStrict: "),t.greater(r)}function greaterEqual_(a,e){var t=convertToTensor(a,"a","greaterEqual"),r=convertToTensor(e,"b","greaterEqual");return assertTypesMatch(t,r),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.greaterEqual(t,r)},{$a:t,$b:r},function(){return{$a:function(){return zerosLike(t)},$b:function(){return zerosLike(r)}}})}function greaterEqualStrict_(a,e){var t=convertToTensor(a,"a","greaterEqualStrict"),r=convertToTensor(e,"b","greaterEqualStrict");return assertShapesMatch(t.shape,r.shape,"Error in greaterEqualStrict: "),t.greaterEqual(r)}function add_(a,e){var s=convertToTensor(a,"a","add"),i=convertToTensor(e,"b","add");assertTypesMatch(s,i);var p=assertAndGetBroadcastShape(s.shape,i.shape);return ENV.engine.runKernel(function(t){return t.add(s,i)},{$a:s,$b:i},function(a){return{$a:function(){var e=a,r=getReductionAxes(s.shape,p);return 0<r.length&&(e=e.sum(r)),e.reshape(s.shape)},$b:function(){var e=a,n=getReductionAxes(i.shape,p);return 0<n.length&&(e=e.sum(n)),e.reshape(i.shape)}}})}function addN_(a){assert(Array.isArray(a),function(){return"The argument passed to tf.addN() must be a list of tensors"}),assert(1<=a.length,function(){return"Must pass at least one tensor to tf.addN(), but got "+a.length});var n=a.map(function(a,e){return convertToTensor(a,"tensors"+e,"addN")}),t=n[0];n.forEach(function(a){if(a.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(function(a){if(!arraysEqual(a.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});return ENV.engine.runKernel(function(t){return t.addN(n)},n,function(t){var e={};return n.forEach(function(a,r){e[r]=function(){return t.clone()}}),e})}function addStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in addStrict: "),a.add(e)}function sub_(a,e){var s=convertToTensor(a,"a","sub"),i=convertToTensor(e,"b","sub");assertTypesMatch(s,i);var p=assertAndGetBroadcastShape(s.shape,i.shape);return ENV.engine.runKernel(function(t){return t.subtract(s,i)},{$a:s,$b:i},function(a){return{$a:function(){var e=a,r=getReductionAxes(s.shape,p);return 0<r.length&&(e=e.sum(r)),e.reshape(s.shape)},$b:function(){var e=a,n=getReductionAxes(i.shape,p);return 0<n.length&&(e=e.sum(n)),e.neg().reshape(i.shape)}}})}function subStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in subStrict: "),a.sub(e)}function pow_(a,s){var p=convertToTensor(a,"base","pow"),r=convertToTensor(s,"exp","pow"),n=assertAndGetBroadcastShape(p.shape,r.shape);return a=p.cast(upcastType(p.dtype,r.dtype)),s=r.cast(upcastType(p.dtype,r.dtype)),ENV.engine.runKernel(function(a,e){return e(a.pow(p,r))},{$base:p,$exp:r},function(o,e){var s=e[0];return{$base:function(){var e=r.toFloat(),t=o.mul(e.mul(p.pow(e.sub(scalar(1))))),s=getReductionAxes(p.shape,n);return 0<s.length&&(t=t.sum(s)),t.reshape(p.shape)},$exp:function(){var e=o.mul(s.mul(p.log()).toFloat()),a=getReductionAxes(r.shape,n);return 0<a.length&&(e=e.sum(a)),e.reshape(r.shape)}}})}function powStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in powStrict: "),a.pow(e)}function mul_(a,e){var s=convertToTensor(a,"a","mul"),r=convertToTensor(e,"b","mul");assertTypesMatch(s,r);var n=assertAndGetBroadcastShape(s.shape,r.shape);return ENV.engine.runKernel(function(t){return t.multiply(s,r)},{$a:s,$b:r},function(o){return{$a:function(){var e=o.mul(r.toFloat()),t=getReductionAxes(s.shape,n);return 0<t.length?e.sum(t).reshape(s.shape):e},$b:function(){var e=o.mul(s.toFloat()),t=getReductionAxes(r.shape,n);return 0<t.length?e.sum(t).reshape(r.shape):e}}})}function mulStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in multiplyStrict: "),a.mul(e)}function div_(s,e){var p=convertToTensor(s,"a","div"),n=convertToTensor(e,"b","div"),t;if(assertTypesMatch(p,n),"int32"===p.dtype&&"int32"===n.dtype)return floorDiv(p,n);t=function(t){return t.realDivide(p,n)};var o=assertAndGetBroadcastShape(p.shape,n.shape);return ENV.engine.runKernel(t,{$a:p,$b:n},function(a){return{$a:function(){var e=a.div(n.toFloat()),t=getReductionAxes(p.shape,o);return 0<t.length?e.sum(t).reshape(p.shape):e},$b:function(){var e=a.mul(p.toFloat()),s=getReductionAxes(n.shape,o);0<s.length&&(e=e.sum(s).reshape(n.shape));var r=n.square();return e.div(r.toFloat()).neg()}}})}function floorDiv_(a,e){var s=convertToTensor(a,"a","floorDiv"),r=convertToTensor(e,"b","floorDiv");assertTypesMatch(s,r);var n=assertAndGetBroadcastShape(s.shape,r.shape);return ENV.engine.runKernel(function(t){return t.floorDiv(s,r)},{$a:s,$b:r},function(o){return{$a:function(){var e=o.div(r.toFloat()),t=getReductionAxes(s.shape,n);return 0<t.length?e.sum(t).reshape(s.shape):e},$b:function(){var e=o.mul(s.toFloat()),p=getReductionAxes(r.shape,n);0<p.length&&(e=e.sum(p).reshape(r.shape));var a=r.square();return e.div(a.toFloat()).neg()}}})}function divStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in divideStrict: "),a.div(e)}function mod_(a,e){var s=convertToTensor(a,"a","mod"),r=convertToTensor(e,"b","mod");assertTypesMatch(s,r);var n=assertAndGetBroadcastShape(s.shape,r.shape);return ENV.engine.runKernel(function(t){return t.mod(s,r)},{$a:s,$b:r},function(o){return{$a:function(){var e=getReductionAxes(s.shape,n);return 0<e.length?o.sum(e).reshape(s.shape):o},$b:function(){var e=o.mul(s.div(r).floor().neg()),t=getReductionAxes(r.shape,n);return 0<t.length?e.sum(t).reshape(r.shape):e}}})}function modStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in modStrict: "),a.mod(e)}function minimum_(a,e){var t=convertToTensor(a,"a","minimum"),o=convertToTensor(e,"b","minimum");return assertTypesMatch(t,o),"bool"===t.dtype&&(t=t.toInt()),"bool"===o.dtype&&(o=o.toInt()),assertAndGetBroadcastShape(t.shape,o.shape),ENV.engine.runKernel(function(a){return a.minimum(t,o)},{$a:t,$b:o},function(a){return{$a:function(){return a.mul(t.lessEqual(o).toFloat())},$b:function(){return a.mul(t.greater(o).toFloat())}}})}function minimumStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in minimumStrict: "),a.minimum(e)}function maximum_(a,e){var t=convertToTensor(a,"a","maximum"),o=convertToTensor(e,"b","maximum");return assertTypesMatch(t,o),"bool"===t.dtype&&(t=t.toInt()),"bool"===o.dtype&&(o=o.toInt()),assertAndGetBroadcastShape(t.shape,o.shape),ENV.engine.runKernel(function(a){return a.maximum(t,o)},{$a:t,$b:o},function(a){return{$a:function(){return a.mul(t.greaterEqual(o).toFloat())},$b:function(){return a.mul(t.less(o).toFloat())}}})}function maximumStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in maximumStrict: "),a.maximum(e)}function squaredDifference_(a,e){var o=convertToTensor(a,"a","squaredDifference"),r=convertToTensor(e,"b","squaredDifference");return assertTypesMatch(o,r),assertAndGetBroadcastShape(o.shape,r.shape),ENV.engine.runKernel(function(t){return t.squaredDifference(o,r)},{$a:o,$b:r},function(a){var e=scalar(2);return{$a:function(){return a.mul(o.sub(r).mul(e))},$b:function(){return a.mul(r.sub(o).mul(e))}}})}function squaredDifferenceStrict_(a,e){return assertShapesMatch(a.shape,e.shape,"Error in squaredDifferenceStrict: "),a.squaredDifference(e)}function atan2_(a,e){var s=convertToTensor(a,"a","atan2"),r=convertToTensor(e,"b","atan2");assertTypesMatch(s,r);var n=assertAndGetBroadcastShape(s.shape,r.shape);return ENV.engine.runKernel(function(t){return t.atan2(s,r)},{$a:s,$b:r},function(o){return{$a:function(){var e=add(s.square(),r.square()),t=o.mul(r.div(e)),p=getReductionAxes(s.shape,n);return 0<p.length&&(t=t.sum(p)),t.reshape(s.shape)},$b:function(){var e=add(s.square(),r.square()),t=neg(o.mul(s.div(e))),p=getReductionAxes(r.shape,n);return 0<p.length&&(t=t.sum(p)),t.reshape(r.shape)}}})}function logicalNot_(a){var n=convertToTensor(a,"x","logicalNot","bool");return assert("bool"===n.dtype,"Error Array must be of type bool."),ENV.engine.runKernel(function(t){return t.logicalNot(n)},{$x:n})}function logicalAnd_(a,e){var t=convertToTensor(a,"a","logicalAnd","bool"),r=convertToTensor(e,"b","logicalAnd","bool");return assert("bool"===t.dtype&&"bool"===r.dtype,"Error Array must be of type bool."),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.logicalAnd(t,r)},{$a:t,$b:r})}function logicalOr_(a,e){var t=convertToTensor(a,"a","logicalOr","bool"),r=convertToTensor(e,"b","logicalOr","bool");return assert("bool"===t.dtype&&"bool"===r.dtype,"Error Array must be of type bool."),assertAndGetBroadcastShape(t.shape,r.shape),ENV.engine.runKernel(function(a){return a.logicalOr(t,r)},{$a:t,$b:r})}function logicalXor_(a,e){var t=convertToTensor(a,"a","logicalXor","bool"),r=convertToTensor(e,"b","logicalXor","bool");return assert("bool"===t.dtype&&"bool"===r.dtype,"Error Array must be of type bool."),assertAndGetBroadcastShape(t.shape,r.shape),logicalOr(a,e).logicalAnd(logicalAnd(a,e).logicalNot())}function where_(s,e,t){var r=convertToTensor(e,"a","where"),n=convertToTensor(t,"b","where"),o=convertToTensor(s,"condition","where","bool");return assert("bool"===o.dtype,"Error Condition must be of type bool."),assertShapesMatch(r.shape,n.shape,"Error in where: "),1===o.rank?assert(o.shape[0]===r.shape[0],"The first dimension of `a` must match the size of `condition`."):assertShapesMatch(o.shape,n.shape,"Error in where: "),ENV.engine.runKernel(function(t){return t.select(o,r,n)},{$condition:o,$a:r,$b:n},function(t){return{$condition:function(){return zerosLike(o)},$a:function(){return t.mul(o.cast(r.dtype))},$b:function(){return t.mul(o.logicalNot().cast(n.dtype))}}})}function whereAsync_(a){return __awaiter(this,void 0,void 0,function(){var e,s,i;return __generator(this,function(t){switch(t.label){case 0:return assert("bool"===(e=convertToTensor(a,"condition","where","bool")).dtype,"Condition must be of type bool."),[4,e.data()];case 1:return s=t.sent(),i=whereImpl(e.shape,s),a!==e&&e.dispose(),[2,i];}})})}function relu_(a){var n=convertToTensor(a,"x","relu");return"bool"===n.dtype?n.toInt():ENV.engine.runKernel(function(t){return t.relu(n)},{$x:n},function(t){var e=n.step();return{$x:function(){return t.mulStrict(e.toFloat())}}})}function elu_(a){var n=convertToTensor(a,"x","elu");return ENV.engine.runKernel(function(t,e){return e(t.elu(n))},{$x:n},function(a,e){var n=e[0];return{$x:function(){return ENV.engine.runKernel(function(e){return e.eluDer(a,n)},{dy:a,y:n})}}})}function selu_(a){var s=convertToTensor(a,"x","selu");return ENV.engine.runKernel(function(t){return t.selu(s)},{$x:s},function(t){return{$x:function(){var e=s.greater(scalar(0)),r=scalar(SELU_SCALEALPHA),n=scalar(SELU_SCALE),o=t.mul(n),a=t.mul(r).mul(s.toFloat().exp());return where(e,o,a)}}})}function leakyRelu_(a,e){void 0===e&&(e=.2);var n=convertToTensor(a,"x","leakyRelu");return maximum(scalar(e).mul(n),n)}function prelu_(a,e){var t=convertToTensor(a,"x","prelu"),r=convertToTensor(e,"alpha","prelu"),n=scalar(0);return maximum(n,t).add(r.mul(minimum(n,t)))}function transpose_(a,n){var o=convertToTensor(a,"x","transpose");return(null==n&&(n=o.shape.map(function(a,e){return e}).reverse()),assert(o.rank===n.length,"Error in transpose: rank of input "+o.rank+" must match length of perm "+n+"."),n.forEach(function(t){assert(0<=t&&t<o.rank,"All entries in 'perm' must be between 0 and "+(o.rank-1)+" but got "+n)}),1>=o.rank)?o.clone():ENV.engine.runKernel(function(t){return t.transpose(o,n)},{$x:o},function(t){var e=getUndoAxesPermutation(n);return{$x:function(){return t.transpose(e)}}})}function localResponseNormalization_(p,l,d,c,m){void 0===l&&(l=5),void 0===d&&(d=1),void 0===c&&(c=1),void 0===m&&(m=.5);var e=convertToTensor(p,"x","localResponseNormalization");assert(4===e.rank||3===e.rank,"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+e.rank+"."),assert(isInt(l),"Error in localResponseNormalization: depthRadius must be an integer\n                     but got depthRadius "+l+".");var h=e,a=!1;3===e.rank&&(a=!0,h=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var g=ENV.engine.runKernel(function(t,e){return e(t.localResponseNormalization4D(h,l,d,c,m))},{x4D:h},function(t,e){var n=e[0];return{x4D:function(){return ENV.engine.runKernel(function(e){return e.LRNGrad(t,h,n,l,d,c,m)},{})}}});return a?g.as3D(g.shape[1],g.shape[2],g.shape[3]):g}function norm_(s,p,l,d){void 0===p&&(p="euclidean"),void 0===l&&(l=null),void 0===d&&(d=!1);var u=normImpl(s=convertToTensor(s,"x","norm"),p,l),o=u.shape;if(d){var c=parseAxisParam(l,s.shape);o=expandShapeToKeepDim(u.shape,c)}return u.reshape(o)}function normImpl(a,e,t){if(void 0===t&&(t=null),0===a.rank)return a.abs();if(1!==a.rank&&null===t)return normImpl(a.reshape([-1]),e,t);if(1===a.rank||"number"==typeof t||t instanceof Array&&1===t.length){if(1===e)return a.abs().sum(t);if(e===1/0)return a.abs().max(t);if(e===-1/0)return a.abs().min(t);if("euclidean"===e||2===e)return a.abs().pow(scalar(2,"int32")).sum(t).sqrt();throw new Error("Error in norm: invalid ord value: "+e)}if(t instanceof Array&&2===t.length){if(1===e)return a.abs().sum(t[0]).max(t[1]-1);if(e===1/0)return a.abs().sum(t[1]).max(t[0]);if(e===-1/0)return a.abs().sum(t[1]).min(t[0]);if("fro"===e||"euclidean"===e)return a.square().sum(t).sqrt();throw new Error("Error in norm: invalid ord value: "+e)}throw new Error("Error in norm: invalid axis: "+t)}function unsortedSegmentSum_(a,e,t){var r=convertToTensor(a,"x","unsortedSegmentSum"),n=convertToTensor(e,"segmentIds","unsortedSegmentSum","int32");return assert("int32"===n.dtype,"segmentIds must be of dtype `int32`"),assert(isInt(t),"numSegments must be of dtype int"),ENV.engine.runKernel(function(a){return a.unsortedSegmentSum(r,n,t)},{$x:r},function(t){return{$x:function(){return gatherDropNegatives(t,n)}}})}function gather_(a,e,b){void 0===b&&(b=0);var x=convertToTensor(a,"x","gather"),n=convertToTensor(e,"indices","gather","int32");return assert("int32"===n.dtype,"Indices must be of dtype `int32`"),b=parseAxisParam(b,x.shape)[0],ENV.engine.runKernel(function(t){return t.gather(x,n,b)},{$x:x},function(r){return{$x:function(){if(0===b)return unsortedSegmentSum(r,n,x.shape[b]);var e=x.shape,t=n.size,a=e.slice(0,b),o=a.length,s=e.slice(b,e.length).slice(1),i=s.length,l=arrayRange(0,o),u=arrayRange(o+1,o+1+i),p=arrayConcat([a,[t],s]),d=r.reshape(p),c=n.reshape([t]),h=arrayConcat([[o],l,u]),m=d.transpose(h),g=unsortedSegmentSum(m,c,x.shape[b]),f=getUndoAxesPermutation(h);return g=g.transpose(f)}}})}function arrayRange(a,e){for(var t=[],r=a;r<e;++r)t.push(r);return t}function arrayConcat(a){for(var e=[],t=0;t<a.length;++t)for(var o=0;o<a[t].length;++o)e.push(a[t][o]);return e}function gatherDropNegatives(p,e){for(var t=maximum(e,zerosLike(e)),r=gather(p,t),n=greaterEqual(e,scalar(0,"int32")),l=r.rank-n.rank,a=0;a<l;++a)n=expandDims(n,a+1);n=logicalAnd(n,ones$1(r.shape,"bool"));var d=zerosLike(r);return where(n,r,d)}function multiRNNCell_(m,e,t,r){for(var n=convertToTensor(e,"data","multiRNNCell"),o=convertToTensorArray(t,"c","multiRNNCell"),a=convertToTensorArray(r,"h","multiRNNCell"),i=n,h=[],u=0,g;u<m.length;u++)g=m[u](i,o[u],a[u]),h.push(g[0]),h.push(g[1]),i=g[1];var f=[],p=[];for(u=0;u<h.length;u+=2)f.push(h[u]),p.push(h[u+1]);return[f,p]}function basicLSTMCell_(b,e,t,r,n,o){var a=convertToTensor(b,"forgetBias","basicLSTMCell"),i=convertToTensor(e,"lstmKernel","basicLSTMCell"),s=convertToTensor(t,"lstmBias","basicLSTMCell"),u=convertToTensor(r,"data","basicLSTMCell"),l=convertToTensor(n,"c","basicLSTMCell"),c=convertToTensor(o,"h","basicLSTMCell"),p=u.concat(c,1).matMul(i).add(s),d=p.shape[0],h=p.shape[1]/4,f=[d,h],m=p.slice([0,0],f),g=p.slice([0,h],f),N=p.slice([0,2*h],f),y=p.slice([0,3*h],f),x=m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(a.add(N).sigmoid()));return[x,x.tanh().mulStrict(y.sigmoid())]}function movingAverage_(d,e,t,r,n){void 0===n&&(n=!0);var m=convertToTensor(d,"v","movingAverage"),a=convertToTensor(e,"x","movingAverage"),i=convertToTensor(t,"decay","movingAverage");assertTypesMatch(m,a),assert(arraysEqual(m.shape,a.shape),"Shape mismatch in v and x");var s=scalar(1),u=s.sub(i),l=a.sub(m).mul(u);if(n){assert(null!=r,"When using zeroDebias: true, step is required.");var h=convertToTensor(r,"step","movingAverage");l=l.div(s.sub(pow(i,h)))}return m.add(l)}function stridedSlice_(p,d,t,r,n,c,m,h,g){if(void 0===n&&(n=0),void 0===c&&(c=0),void 0===m&&(m=0),void 0===h&&(h=0),void 0===g&&(g=0),0!==m)throw new Error("ellipsis mask is not yet supported");if(0!==h)throw new Error("new axis mask is not yet supported");var f=convertToTensor(p,"x","stridedSlice");return ENV.engine.runKernel(function(a){return a.stridedSlice(f,d,t,r,n,c,m,h,g)},{$x:f})}function topk_(s,i,p){void 0===i&&(i=1),void 0===p&&(p=!0);var l=convertToTensor(s,"x","topk");if(0===l.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var e=l.shape[l.shape.length-1];if(i>e)throw new Error("'k' passed to topk() must be <= the last dimension ("+e+") but got "+i);var n=ENV.engine.runKernel(function(t){return t.topk(l,i,p)},{$x:l});return{values:n[0],indices:n[1]}}function scatterND_(a,e,t){var r=convertToTensor(a,"indices","scatterND","int32"),n=convertToTensor(e,"updates","scatterND");return validateInput(n,r,t),ENV.engine.runKernel(function(a){return a.scatterND(r,n,t)},{$indices:r,$updates:n})}function fft_(a){assert("complex64"===a.dtype,"The dtype for tf.spectral.fft() must be complex64 but got "+a.dtype+".");var e=a.shape[a.shape.length-1],t=a.size/e,r=a.as2D(t,e);return ENV.engine.runKernel(function(t){return t.fft(r)},{input:a}).reshape(a.shape)}function ifft_(a){assert("complex64"===a.dtype,"The dtype for tf.spectral.ifft() must be complex64 but got "+a.dtype+".");var e=a.shape[a.shape.length-1],t=a.size/e,r=a.as2D(t,e);return ENV.engine.runKernel(function(t){return t.ifft(r)},{input:a}).reshape(a.shape)}function rfft_(d){assert("float32"===d.dtype,"The dtype for rfft() must be real value but\n    got "+d.dtype);var e=d.shape[d.shape.length-1],t=d.size/e,r=d.zerosLike(),n=complex(d,r).as2D(t,e),o=ENV.engine.runKernel(function(t){return t.fft(n)},{complexInput:n}),a=_Mathfloor(e/2)+1,i=real(o),s=imag(o),u=i.split([a,e-a],i.shape.length-1),l=s.split([a,e-a],s.shape.length-1),c=d.shape.slice();return c[d.shape.length-1]=a,complex(u[0],l[0]).reshape(c)}function validateInput$1(s,e,t,r){if("int32"!==s.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+s.dtype+".");if(2<s.rank)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+s.shape+".");var n=0<s.rank?s.shape[0]:1,o=1<s.rank?s.shape[1]:1;if(t.length!==o)throw new Error("outputShape has incorrect number of elements:, "+t.length+", should be: "+o+".");var a=e.size;if(0!==e.rank&&(1!==e.rank||a!==n))throw new Error("sparseValues has incorrect shape "+e.shape+", should be [] or ["+n+"]");if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function sparseToDense_(s,e,t,r){var n=convertToTensor(s,"sparseIndices","sparseToDense","int32"),o=convertToTensor(e,"sparseValues","sparseToDense"),a=convertToTensor(r,"defaultValue","sparseToDense",o.dtype);return validateInput$1(n,o,t,a),ENV.engine.runKernel(function(r){return r.sparseToDense(n,o,t,a)},{$sparseIndices:n,$sparseValues:o,$defaultValue:a})}function gatherND_(a,e){var t=convertToTensor(e,"indices","gatherND","int32"),r=convertToTensor(a,"x","gatherND");return ENV.engine.runKernel(function(a){return a.gatherND(r,t)},{$x:r,$indices:t})}function computeWeightedLoss_(p,e,t){void 0===t&&(t=Reduction.SUM_BY_NONZERO_WEIGHTS);var l=convertToTensor(p,"losses","computeWeightedLoss"),n=null;null!=e&&(n=convertToTensor(e,"weights","computeWeightedLoss"));var d=null==n?l:l.mul(n);if(t===Reduction.NONE)return d;if(t===Reduction.SUM)return d.sum();if(t===Reduction.MEAN){if(null==n)return d.mean();var a=sizeFromShape(l.shape)/sizeFromShape(n.shape),i=d.sum().div(n.sum());return 1<a?i.div(scalar(a)):i}if(t===Reduction.SUM_BY_NONZERO_WEIGHTS){if(null==n)return d.sum().div(scalar(l.size));var s=n.mul(ones$1(l.shape)).notEqual(scalar(0)).sum().toFloat();return d.sum().div(s)}throw Error("Unknown reduction: "+t)}function absoluteDifference_(p,e,t,r){void 0===r&&(r=Reduction.SUM_BY_NONZERO_WEIGHTS);var l=convertToTensor(p,"labels","absoluteDifference"),o=convertToTensor(e,"predictions","absoluteDifference"),a=null;null!=t&&(a=convertToTensor(t,"weights","absoluteDifference")),assertShapesMatch(l.shape,o.shape,"Error in absoluteDifference: ");var d=l.sub(o).abs();return computeWeightedLoss(d,a,r)}function meanSquaredError_(p,e,t,r){void 0===r&&(r=Reduction.SUM_BY_NONZERO_WEIGHTS);var l=convertToTensor(p,"labels","meanSquaredError"),o=convertToTensor(e,"predictions","meanSquaredError"),a=null;null!=t&&(a=convertToTensor(t,"weights","meanSquaredError")),assertShapesMatch(l.shape,o.shape,"Error in meanSquaredError: ");var d=l.squaredDifference(o);return computeWeightedLoss(d,a,r)}function cosineDistance_(p,e,t,r,n){void 0===n&&(n=Reduction.SUM_BY_NONZERO_WEIGHTS);var l=convertToTensor(p,"labels","cosineDistance"),a=convertToTensor(e,"predictions","cosineDistance"),i=null;null!=r&&(i=convertToTensor(r,"weights","cosineDistance")),assertShapesMatch(l.shape,a.shape,"Error in cosineDistance: ");var d=scalar(1).sub(l.mul(a).sum(t,!0));return computeWeightedLoss(d,i,n)}function hingeLoss_(p,e,t,r){void 0===r&&(r=Reduction.SUM_BY_NONZERO_WEIGHTS);var l=convertToTensor(p,"labels","hingeLoss"),d=convertToTensor(e,"predictions","hingeLoss"),a=null;null!=t&&(a=convertToTensor(t,"weights","hingeLoss")),assertShapesMatch(l.shape,d.shape,"Error in hingeLoss: ");var c=scalar(1);l=scalar(2).mul(l).sub(c);var s=c.sub(l.mul(d)).relu();return computeWeightedLoss(s,a,r)}function logLoss_(p,e,t,r,d){void 0===r&&(r=1e-7),void 0===d&&(d=Reduction.SUM_BY_NONZERO_WEIGHTS);var m=convertToTensor(p,"labels","logLoss"),a=convertToTensor(e,"predictions","logLoss"),i=null;null!=t&&(i=convertToTensor(t,"weights","logLoss")),assertShapesMatch(m.shape,a.shape,"Error in logLoss: ");var h=scalar(1),u=scalar(r),l=m.mul(a.add(u).log()).neg().sub(h.sub(m).mul(h.sub(a).add(u).log()));return computeWeightedLoss(l,i,d)}function sigmoidCrossEntropyWithLogits_(s,e){var t=convertToTensor(s,"labels","sigmoidCrossEntropyWithLogits"),r=convertToTensor(e,"logits","sigmoidCrossEntropyWithLogits");assertShapesMatch(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");var n=r.relu(),o=r.mul(t),a=r.abs().neg().exp().log1p();return n.sub(o).add(a)}function sigmoidCrossEntropy_(d,e,t,r,m){void 0===r&&(r=0),void 0===m&&(m=Reduction.SUM_BY_NONZERO_WEIGHTS);var h=convertToTensor(d,"multiClassLabels","sigmoidCrossEntropy"),g=convertToTensor(e,"logits","sigmoidCrossEntropy"),i=null;if(null!=t&&(i=convertToTensor(t,"weights","sigmoidCrossEntropy")),assertShapesMatch(h.shape,g.shape,"Error in sigmoidCrossEntropy: "),0<r){var f=scalar(r),u=scalar(1),l=scalar(.5);h=h.mul(u.sub(f)).add(l.mul(f))}var c=sigmoidCrossEntropyWithLogits_(h,g);return computeWeightedLoss(c,i,m)}function huberLoss_(m,e,t,r,h){void 0===r&&(r=1),void 0===h&&(h=Reduction.SUM_BY_NONZERO_WEIGHTS);var g=convertToTensor(m,"labels","huberLoss"),a=convertToTensor(e,"predictions","huberLoss"),i=null;null!=t&&(i=convertToTensor(t,"weights","huberLoss")),assertShapesMatch(g.shape,a.shape,"Error in huberLoss: ");var f=scalar(r),u=a.sub(g).abs(),l=minimum(u,f),c=u.sub(l),p=scalar(.5).mul(l.square()).add(f.mul(c));return computeWeightedLoss(p,i,h)}function softmaxCrossEntropyWithLogits_(a,e,s){if(void 0===s&&(s=-1),-1===s&&(s=e.rank-1),s!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+e.rank+" and dim was "+s);return customGrad(function(a,e){var t=e.logSumExp([s],!0),r=e.toFloat().sub(t);return{value:r.mul(a).neg().sum([s]),gradFunc:function(e){var t=expandShapeToKeepDim(e.shape,[s]);return[e.reshape(t).mul(a.toFloat().sub(r.exp())),e.reshape(t).mul(r.exp().sub(a.toFloat()))]}}})(a,e)}function softmaxCrossEntropy_(d,e,t,r,m){void 0===r&&(r=0),void 0===m&&(m=Reduction.SUM_BY_NONZERO_WEIGHTS);var h=convertToTensor(d,"onehotLabels","softmaxCrossEntropy"),g=convertToTensor(e,"logits","softmaxCrossEntropy"),i=null;if(null!=t&&(i=convertToTensor(t,"weights","softmaxCrossEntropy")),assertShapesMatch(h.shape,g.shape,"Error in softmaxCrossEntropy: "),0<r){var f=scalar(r),u=scalar(1),l=scalar(h.shape[1]);h=h.mul(u.sub(f)).add(f.div(l))}var c=softmaxCrossEntropyWithLogits_(h,g);return computeWeightedLoss(c,i,m)}function gramSchmidt_(s){var p;if(Array.isArray(s)){p=!1,assert(null!=s&&0<s.length,"Gram-Schmidt process: input must not be null, undefined, or empty");for(var l=s[0].shape[0],r=1;r<s.length;++r)assert(s[r].shape[0]===l,"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+s[r].shape[0]+" vs. "+l+")")}else p=!0,s=split$1(s,s.shape[0],0).map(function(t){return squeeze(t,[0])});assert(s.length<=s[0].shape[0],"Gram-Schmidt: Number of vectors ("+s.length+") exceeds number of dimensions ("+s[0].shape[0]+").");var d=[],o=s,a=function(a){d.push(ENV.engine.tidy(function(){var e=o[a];if(0<a)for(var s=0,i;s<a;++s)i=sum$1(d[s].mulStrict(e)).mul(d[s]),e=e.sub(i);return e.div(norm(e,"euclidean"))}))};for(r=0;r<s.length;++r)a(r);return p?stack(d,0):d}function qr_(a,s){if(void 0===s&&(s=!1),2>a.rank)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+a.rank);if(2===a.rank)return qr2d(a,s);var e=a.shape.slice(0,a.shape.length-2).reduce(function(a,e){return a*e}),p=[],n=[];return unstack(a.reshape([e,a.shape[a.shape.length-2],a.shape[a.shape.length-1]]),0).forEach(function(t){var e=qr2d(t,s),r=e[0],a=e[1];p.push(r),n.push(a)}),[stack(p,0).reshape(a.shape),stack(n,0).reshape(a.shape)]}function qr2d(p,e){return void 0===e&&(e=!1),ENV.engine.tidy(function(){if(2!==p.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+p.shape.length+"D Tensor.");for(var y=p.shape[0],r=p.shape[1],n=eye(y),b=p.clone(),x=tensor2d([[1]],[1,1]),i=x.clone(),t=y>=r?r:y,d=function(a){var e=b,o=i,s=n,p;p=ENV.engine.tidy(function(){var e=b.slice([a,a],[y-a,1]),t=e.norm(),o=b.slice([a,a],[1,1]),s=o.sign().neg(),l=o.sub(s.mul(t)),p=e.div(l);i=1===p.shape[0]?x.clone():x.concat(p.slice([1,0],[p.shape[0]-1,p.shape[1]]),0);var d=s.matMul(l).div(t).neg(),u=b.slice([a,0],[y-a,r]),c=d.mul(i);b=0===a?u.sub(c.matMul(i.transpose().matMul(u))):b.slice([0,0],[a,r]).concat(u.sub(c.matMul(i.transpose().matMul(u))),0);var m=n.slice([0,a],[y,n.shape[1]-a]);return n=0===a?m.sub(m.matMul(i).matMul(c.transpose())):n.slice([0,0],[y,a]).concat(m.sub(m.matMul(i).matMul(c.transpose())),1),[i,b,n]}),i=p[0],b=p[1],n=p[2],dispose([e,o,s])},l=0;l<t;++l)d(l);return!e&&y>r&&(n=n.slice([0,0],[y,r]),b=b.slice([0,0],[r,r])),[n,b]})}function resizeBilinear_(p,e,l){void 0===l&&(l=!1);var t=convertToTensor(p,"images","resizeBilinear");assert(3===t.rank||4===t.rank,"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+t.rank+"."),assert(2===e.length,"Error in resizeBilinear: new shape must 2D, but got shape "+e+".");var n=t,d=!1;3===t.rank&&(d=!0,n=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var c=e[0],i=e[1],s=ENV.engine.runKernel(function(t){return t.resizeBilinear(n,c,i,l)},{batchImages:n},function(a){return{batchImages:function(){return ENV.engine.runKernel(function(e){return e.resizeBilinearBackprop(a,n,l)},{})}}});return d?s.as3D(s.shape[1],s.shape[2],s.shape[3]):s}function resizeNearestNeighbor_(p,e,l){void 0===l&&(l=!1);var t=convertToTensor(p,"images","resizeNearestNeighbor");assert(3===t.rank||4===t.rank,"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+t.rank+"."),assert(2===e.length,"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."),assert("float32"===t.dtype||"int32"===t.dtype,"`images` must have `int32` or `float32` as dtype");var n=t,d=!1;3===t.rank&&(d=!0,n=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var c=e[0],i=e[1],s=ENV.engine.runKernel(function(t){return t.resizeNearestNeighbor(n,c,i,l)},{batchImages:n},function(a){return{batchImages:function(){return ENV.engine.runKernel(function(e){return e.resizeNearestNeighborBackprop(a,n,l)},{})}}});return d?s.as3D(s.shape[1],s.shape[2],s.shape[3]):s}function nonMaxSuppression_(p,e,t,l,d){void 0===l&&(l=.5),void 0===d&&(d=_NumberNEGATIVE_INFINITY);var u=convertToTensor(p,"boxes","nonMaxSuppression"),a=convertToTensor(e,"scores","nonMaxSuppression"),i=nonMaxSuppSanityCheck(u,a,t,l,d);return t=i.maxOutputSize,l=i.iouThreshold,d=i.scoreThreshold,ENV.engine.runKernel(function(n){return n.nonMaxSuppression(u,a,t,l,d)},{$boxes:u})}function nonMaxSuppressionAsync_(d,e,t,m,h){return void 0===m&&(m=.5),void 0===h&&(h=_NumberNEGATIVE_INFINITY),__awaiter(this,void 0,void 0,function(){var n,r,o,g,f,y;return __generator(this,function(a){switch(a.label){case 0:return n=convertToTensor(d,"boxes","nonMaxSuppressionAsync"),r=convertToTensor(e,"scores","nonMaxSuppressionAsync"),o=nonMaxSuppSanityCheck(n,r,t,m,h),t=o.maxOutputSize,m=o.iouThreshold,h=o.scoreThreshold,[4,n.data()];case 1:return g=a.sent(),[4,r.data()];case 2:return f=a.sent(),y=nonMaxSuppressionImpl(g,f,t,m,h),n!==d&&n.dispose(),r!==e&&r.dispose(),[2,y];}})})}function nonMaxSuppSanityCheck(s,e,t,i,p){null==i&&(i=.5),null==p&&(p=_NumberNEGATIVE_INFINITY);var l=s.shape[0];return t=_Mathmin(t,l),assert(0<=i&&1>=i,"iouThreshold must be in [0, 1], but was '"+i+"'"),assert(2===s.rank,"boxes must be a 2D tensor, but was of rank '"+s.rank+"'"),assert(4===s.shape[1],"boxes must have 4 columns, but 2nd dimension was "+s.shape[1]),assert(1===e.rank,"scores must be a 1D tensor"),assert(e.shape[0]===l,"scores has incompatible shape with boxes. Expected "+l+", but was "+e.shape[0]),{maxOutputSize:t,iouThreshold:i,scoreThreshold:p}}function cropAndResize_(p,e,t,r,n,d){var c=convertToTensor(p,"image","cropAndResize","float32"),i=convertToTensor(e,"boxes","cropAndResize","float32"),s=convertToTensor(t,"boxInd","cropAndResize","int32");n=n||"bilinear",d=d||0;var u=i.shape[0];return assert(4===c.rank,"Error in cropAndResize: image must be rank 4,but got rank "+c.rank+"."),assert(2===i.rank&&4===i.shape[1],"Error in cropAndResize: boxes must be have size ["+u+",4] but had shape "+i.shape+"."),assert(1===s.rank&&s.shape[0]===u,"Error in cropAndResize: boxInd must be have size ["+u+"] but had shape "+i.shape+"."),assert("int32"===s.dtype,"Error in cropAndResize: boxInd must be of dtype int32, but got dtype "+s.dtype+"."),assert(2===r.length,"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."),assert(1<=r[0]&&1<=r[1],"cropSize must be atleast [1,1], but was "+r),assert("bilinear"===n||"nearest"===n,"method must be bilinear or nearest, but was "+n),ENV.engine.runKernel(function(t){return t.cropAndResize(c,i,s,r,n,d)},{$image:c,$boxes:i})}function nextFrame(){return new Promise(function(t){return delayCallback(function(){return t()})})}function encodeWeights(a){return __awaiter(this,void 0,void 0,function(){var e,s,i,p;return __generator(this,function(t){switch(t.label){case 0:for(i in e=[],s=[],a){if("float32"!==(p=a[i]).dtype&&"int32"!==p.dtype&&"bool"!==p.dtype)throw new Error("Unsupported dtype in weight '"+i+"': "+p.dtype);e.push({name:i,shape:p.shape,dtype:p.dtype}),s.push(p.data())}return[4,Promise.all(s)];case 1:return[2,{data:concatenateTypedArrays(t.sent()),specs:e}];}})})}function decodeWeights(u,e){for(var m={},r=0,t=function(e){var t=e.name,n=e.dtype,a=e.shape,o=sizeFromShape(a),s;if(("quantization"in e)){var i=e.quantization;if("uint8"!==i.dtype&&"uint16"!==i.dtype)throw new Error("Weight "+e.name+" has unknown quantization dtype "+i.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var l=DTYPE_VALUE_SIZE_MAP[i.dtype],c=u.slice(r,r+o*l),g="uint8"===i.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===n)s=Float32Array.from(g,function(t){return t*i.scale+i.min});else{if("int32"!==n)throw new Error("Unsupported dtype in weight '"+t+"': "+n);s=Int32Array.from(g,function(t){return _Mathround(t*i.scale+i.min)})}r+=o*l}else{var d=DTYPE_VALUE_SIZE_MAP[n];if(c=u.slice(r,r+o*d),"float32"===n)s=new Float32Array(c);else if("int32"===n)s=new Int32Array(c);else{if("bool"!==n)throw new Error("Unsupported dtype in weight '"+t+"': "+n);s=new Uint8Array(c)}r+=o*d}var h;if("float32"===n)h=tensor(s,a,"float32");else if("int32"===n)h=tensor(s,a,"int32");else{if("bool"!==n)throw new Error("Unsupported dtype in weight '"+t+"': "+n);h=tensor(s,a,"bool")}m[t]=h},o=0,s=e;o<s.length;o++)t(s[o]);return m}function concatenateTypedArrays(a){if(null===a)throw new Error("Invalid input value: "+JSON.stringify(a));var s=0,i=[];a.forEach(function(t){if(s+=t.byteLength,i.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)});var r=new Uint8Array(s),n=0;return i.forEach(function(t){r.set(new Uint8Array(t.buffer),n),n+=t.byteLength}),r.buffer}function stringByteLength(t){return useNodeBuffer?Buffer.byteLength(t):new Blob([t]).size}function arrayBufferToBase64String(t){return useNodeBuffer?Buffer.from(t).toString("base64"):btoa(_StringfromCharCode.apply(null,new Uint8Array(t)))}function base64StringToArrayBuffer(a){if(useNodeBuffer){var e=Buffer.from(a,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}for(var t=atob(a),r=new Uint8Array(t.length),n=0;n<t.length;++n)r.set([t.charCodeAt(n)],n);return r.buffer}function concatenateArrayBuffers(a){var o=0;a.forEach(function(t){o+=t.byteLength});var s=new Uint8Array(o),r=0;return a.forEach(function(t){s.set(new Uint8Array(t),r),r+=t.byteLength}),s.buffer}function basename(a){for(a=a.trim();a.endsWith("/");)a=a.slice(0,a.length-1);var n=a.split("/");return n[n.length-1]}function getModelArtifactsInfoForJSON(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:stringByteLength(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:stringByteLength(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function parseURL(t){if(-1===t.indexOf("://"))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+ModelStoreManagerRegistry.getSchemes().join(","));return{scheme:t.split("://")[0],path:t.split("://")[1]}}function cloneModelInternal(m,e,t){return void 0===t&&(t=!1),__awaiter(this,void 0,void 0,function(){var r,h,g,f,y,b,x,N,I;return __generator(this,function(a){switch(a.label){case 0:return assert(m!==e,"Old path and new path are the same: '"+m+"'"),assert(0<(r=IORouterRegistry.getLoadHandlers(m)).length,"Copying failed because no load handler is found for source URL "+m+"."),assert(2>r.length,"Copying failed because more than one ("+r.length+") load handlers for source URL "+m+"."),h=r[0],assert(0<(g=IORouterRegistry.getSaveHandlers(e)).length,"Copying failed because no save handler is found for destination URL "+e+"."),assert(2>g.length,"Copying failed because more than one ("+r.length+") save handlers for destination URL "+e+"."),f=g[0],y=parseURL(m).scheme,b=parseURL(m).path,x=y===parseURL(m).scheme,[4,h.load()];case 1:return N=a.sent(),t&&x?[4,ModelStoreManagerRegistry.getManager(y).removeModel(b)]:[3,3];case 2:a.sent(),a.label=3;case 3:return[4,f.save(N)];case 4:return I=a.sent(),!t||x?[3,6]:[4,ModelStoreManagerRegistry.getManager(y).removeModel(b)];case 5:a.sent(),a.label=6;case 6:return[2,I.modelArtifactsInfo];}})})}function listModels(){return __awaiter(this,void 0,void 0,function(){var p,l,d,u,c,m,h;return __generator(this,function(e){switch(e.label){case 0:p=ModelStoreManagerRegistry.getSchemes(),l={},d=0,u=p,e.label=1;case 1:return d<u.length?(c=u[d],[4,ModelStoreManagerRegistry.getManager(c).listModels()]):[3,4];case 2:for(h in m=e.sent())l[c+"://"+h]=m[h];e.label=3;case 3:return d++,[3,1];case 4:return[2,l];}})})}function removeModel(a){return __awaiter(this,void 0,void 0,function(){var e;return __generator(this,function(t){switch(t.label){case 0:return e=parseURL(a),[4,ModelStoreManagerRegistry.getManager(e.scheme).removeModel(e.path)];case 1:return[2,t.sent()];}})})}function copyModel(a,e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return[4,cloneModelInternal(a,e,!1)];case 1:return[2,t.sent()];}})})}function moveModel(a,e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return[4,cloneModelInternal(a,e,!0)];case 1:return[2,t.sent()];}})})}function getIndexedDBFactory(){if(!ENV.get("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var a=window,e=a.indexedDB||a.mozIndexedDB||a.webkitIndexedDB||a.msIndexedDB||a.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function setUpDatabase(a){var e=a.result;e.createObjectStore("models_store",{keyPath:"modelPath"}),e.createObjectStore("model_info_store",{keyPath:"modelPath"})}function browserIndexedDB(t){return new BrowserIndexedDB(t)}function maybeStripScheme(t){return t.startsWith(BrowserIndexedDB.URL_SCHEME)?t.slice(BrowserIndexedDB.URL_SCHEME.length):t}function getModelKeys(t){return{info:["tensorflowjs_models",t,"info"].join("/"),topology:["tensorflowjs_models",t,"model_topology"].join("/"),weightSpecs:["tensorflowjs_models",t,"weight_specs"].join("/"),weightData:["tensorflowjs_models",t,"weight_data"].join("/")}}function getModelPathFromKey(a){var e=a.split("/");if(3>e.length)throw new Error("Invalid key format: "+a);return e.slice(1,e.length-1).join("/")}function maybeStripScheme$1(t){return t.startsWith(BrowserLocalStorage.URL_SCHEME)?t.slice(BrowserLocalStorage.URL_SCHEME.length):t}function browserLocalStorage(t){return new BrowserLocalStorage(t)}function browserDownloads(t){return void 0===t&&(t="model"),new BrowserDownloads(t)}function browserFiles(t){return new BrowserFiles(t)}function loadWeightsAsArrayBuffer(a,n){return __awaiter(this,void 0,void 0,function(){var e,t;return __generator(this,function(n){switch(n.label){case 0:return e=a.map(function(t){return fetch(t,n)}),[4,Promise.all(e)];case 1:return t=n.sent(),[4,Promise.all(t.map(function(t){return t.arrayBuffer()}))];case 2:return[2,n.sent()];}})})}function loadWeights(m,a,g,e){return void 0===a&&(a=""),__awaiter(this,void 0,void 0,function(){var r,y,n,b,t,x,N,I,v,S;return __generator(this,function(o){switch(o.label){case 0:if(r=m.map(function(){return!1}),y={},n=null==g?[]:g.map(function(){return!1}),b=[],m.forEach(function(a,o){var t=0;a.weights.forEach(function(a){var e="quantization"in a?a.quantization.dtype:a.dtype,n=DTYPE_VALUE_SIZE_MAP[e]*sizeFromShape(a.shape),s=function(){r[o]=!0,null==y[o]&&(y[o]=[]),y[o].push({manifestEntry:a,groupOffset:t,sizeBytes:n})};null==g?s():g.forEach(function(e,t){e===a.name&&(s(),n[t]=!0)}),b.push(a.name),t+=n})}),!n.every(function(t){return t}))throw t=g.filter(function(a,e){return!n[e]}),new Error("Could not find weights in manifest with names: "+t.join(", ")+". \nManifest JSON has weights with names: "+b.join(", ")+".");return x=r.reduce(function(a,e,t){return e&&a.push(t),a},[]),N=[],x.forEach(function(e){m[e].paths.forEach(function(t){var e=a+(a.endsWith("/")?"":"/")+t;N.push(e)})}),[4,loadWeightsAsArrayBuffer(N,e)];case 1:return I=o.sent(),v={},S=0,x.forEach(function(e){for(var t=m[e].paths.length,a=0,r=0;r<t;r++)a+=I[S+r].byteLength;for(var p=new ArrayBuffer(a),i=new Uint8Array(p),s=0,d=0,h;d<t;d++)h=new Uint8Array(I[S+d]),i.set(h,s),s+=h.byteLength;y[e].forEach(function(a){var e=decodeWeights(p.slice(a.groupOffset,a.groupOffset+a.sizeBytes),[a.manifestEntry]);for(var t in e)v[t]=e[t]}),S+=t}),[2,v];}})})}function parseUrl(a){var e=a.lastIndexOf("/"),t=a.lastIndexOf("?");return[a.substring(0,e)+"/",t>e?a.substring(t):""]}function isHTTPScheme(t){return null!=t.match(BrowserHTTPRequest.URL_SCHEME_REGEX)}function browserHTTPRequest(a,e,t){return new BrowserHTTPRequest(a,e,t)}function fromMemory(a,e,t){return new PassthroughLoader(a,e,t)}function withSaveHandler(t){return new PassthroughSaver(t)}function confusionMatrix_(s,e,t){var r=convertToTensor(s,"label","confusionMatrix","int32"),n=convertToTensor(e,"label","confusionMatrix","int32");assert(null==t||0<t&&_NumberisInteger(t),"If provided, numClasses must be a positive integer, but got "+t),assert(1===r.rank,"Expected the rank of labels to be 1, but got "+r.rank),assert(1===n.rank,"Expected the rank of predictions to be 1, but got "+n.rank),assert(r.shape[0]===n.shape[0],"Mismatch in the number of examples: "+r.shape[0]+" vs. "+n.shape[0]+". Labels and predictions should have the same number of elements."),assert(0<t&&_NumberisInteger(t),"numClasses is required to be a positive integer, but got "+t);var o=oneHot(r.asType("int32"),t),a=oneHot(n.asType("int32"),t);return o.transpose().matMul(a).asType("int32")}function registerClass(t){assert(null!=t.className,"Class being registered does not have the static className property defined."),assert("string"==typeof t.className,"className is required to be a string, but got type "+typeof t.className),assert(0<t.className.length,"Class being registered has an empty-string as its className, which is disallowed."),SerializationMap.register(t)}function expectArraysClose(p,e,t){if(!(null==t&&(t=ENV.get("TEST_EPSILON")),p instanceof Tensor||e instanceof Tensor)){var d=p.constructor.name,n=e.constructor.name;if(d!==n)throw new Error("Arrays are of different type actual: "+d+" vs expected: "+n)}else if(p instanceof Tensor&&e instanceof Tensor){if(p.dtype!==e.dtype)throw new Error("Arrays are of different type actual: "+p.dtype+" vs expected: "+e.dtype+".");if(!arraysEqual(p.shape,e.shape))throw new Error("Arrays are of different shape actual: "+p.shape+" vs expected: "+e.shape+".")}var o,c;if(o=p instanceof Tensor?p.dataSync():p,c=e instanceof Tensor?e.dataSync():e,o.length!==c.length)throw new Error("Arrays have different lengths actual: "+o.length+" vs expected: "+c.length+".\nActual:   "+o+".\nExpected: "+c+".");for(var m=0;m<c.length;++m){var h=o[m],u=c[m];if(!areClose(h,+u,t))throw new Error("Arrays differ: actual["+m+"] = "+h+", expected["+m+"] = "+u+".\nActual:   "+o+".\nExpected: "+c+".")}}function expectPromiseToFail(a,e){a().then(function(){return e.fail()},function(){return e()})}function expectArraysEqual(a,e){return expectArraysClose(a,e,0)}function expectNumbersClose(a,e,t){if(null==t&&(t=ENV.get("TEST_EPSILON")),!areClose(a,e,t))throw new Error("Numbers differ: actual === "+a+", expected === "+e)}function areClose(a,e,t){return isNaN(a)&&isNaN(e)||!(isNaN(a)||isNaN(e)||_Mathabs(a-e)>t)}function expectValuesInRange(a,e,t){var r=a instanceof Tensor?a.dataSync():a;for(var n=0;n<r.length;n++)if(r[n]<e||r[n]>t)throw new Error("Value out of range:"+r[n]+" low: "+e+", high: "+t)}function expectArrayBuffersEqual(a,e){expect(new Float32Array(a)).toEqual(new Float32Array(e))}function __extends$1(a,e){function t(){this.constructor=a}extendStatics$1(a,e),a.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}function __awaiter$1(p,e,t,d){return new(t||(t=Promise))(function(n,r){function a(t){try{s(d.next(t))}catch(t){r(t)}}function o(t){try{s(d.throw(t))}catch(t){r(t)}}function s(r){r.done?n(r.value):new t(function(e){e(r.value)}).then(a,o)}s((d=d.apply(p,e||[])).next())})}function __generator$1(p,e){function t(t){return function(a){return function(t){if(l)throw new TypeError("Generator is already executing.");for(;s;)try{if(l=1,d&&(u=2&t[0]?d.return:t[0]?d.throw||((u=d.return)&&u.call(d),0):d.next)&&!(u=u.call(d,t[1])).done)return u;switch(d=0,u&&(t=[2&t[0],u.value]),t[0]){case 0:case 1:u=t;break;case 4:return s.label++,{value:t[1],done:!1};case 5:s.label++,d=t[1],t=[0];continue;case 7:t=s.ops.pop(),s.trys.pop();continue;default:if(!(u=0<(u=s.trys).length&&u[u.length-1])&&(6===t[0]||2===t[0])){s=0;continue}if(3===t[0]&&(!u||t[1]>u[0]&&t[1]<u[3])){s.label=t[1];break}if(6===t[0]&&s.label<u[1]){s.label=u[1],u=t;break}if(u&&s.label<u[2]){s.label=u[2],s.ops.push(t);break}u[2]&&s.ops.pop(),s.trys.pop();continue;}t=e.call(p,s)}catch(a){t=[6,a],d=0}finally{l=u=0}if(5&t[0])throw t[1];return{value:t[0]?t[1]:void 0,done:!0}}([t,a])}}var s={label:0,sent:function(){if(1&u[0])throw u[1];return u[1]},trys:[],ops:[]},l,d,u,c;return c={next:t(0),throw:t(1),return:t(2)},"function"==typeof Symbol&&(c[Symbol.iterator]=function(){return this}),c}function epsilon(){return _epsilon}function imageDataFormat(){return"channelsLast"}function getNextUniqueTensorId(){return _nextUniqueTensorId++}function getUid(t){return void 0===t&&(t=""),t in _uidPrefixes||(_uidPrefixes[t]=0),_uidPrefixes[t]+=1,t+_uidPrefixes[t].toString()}function getScalar(a,e){return void 0===e&&(e="float32"),null==scalarCache[e][a]&&(scalarCache[e][a]=scalar(a,e),keep(scalarCache[e][a])),scalarCache[e][a]}function pyListRepeat(a,e){if(Array.isArray(a)){for(var t=[],o=0;o<e;o++)t=t.concat(a);return t}return(t=Array(e)).fill(a),t}function assert$1(a,e){if(!a)throw new AssertionError(e)}function count(a,e){for(var t=0,o=0,s=a;o<s.length;o++)s[o]===e&&t++;return t}function singletonOrArray(t){return 1===t.length?t[0]:t}function toList(t){return Array.isArray(t)?t:[t]}function toSnakeCase(a){var e=a.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"===e[0]?"private"+e:e}function toCamelCase(t){return 1>=t.length?t:-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,function(a,e){return e.toUpperCase()})}function serializeKerasObject(t){return null===t||void 0===t?null:{className:t.getClassName(),config:t.getConfig()}}function deserializeKerasObject(x,e,C,k){if(void 0===e&&(e={}),void 0===C&&(C={}),void 0===k&&(k="object"),"string"==typeof x){var T=x,i;if(T in C)i=C[T];else if(T in _GLOBAL_CUSTOM_OBJECTS)i=_GLOBAL_CUSTOM_OBJECTS[T];else if(null==(i=e[T]))throw new ValueError("Unknown "+k+": "+x+". This may be due to one of the following reasons:\n1. The "+k+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+k+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");return i}var E=x;if(null==E.className||null==E.config)throw new ValueError(k+": Improper config format: "+JSON.stringify(E)+".\n'className' and 'config' must set.");var o=E.className,s,R;if(o in C?(s=(z=C.get(o))[0],R=z[1]):o in _GLOBAL_CUSTOM_OBJECTS?(s=(B=_GLOBAL_CUSTOM_OBJECTS.className)[0],R=B[1]):o in e&&(s=(V=e[o])[0],R=V[1]),null==s)throw new ValueError("Unknown "+k+": "+o+". This may be due to one of the following reasons:\n1. The "+k+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+k+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");if(null!=R){for(var D={},c=0,P=Object.keys(_GLOBAL_CUSTOM_OBJECTS);c<P.length;c++)D[y=P[c]]=_GLOBAL_CUSTOM_OBJECTS[y];for(var h=0,A=Object.keys(C);h<A.length;h++)D[y=A[h]]=C[y];E.config.customObjects=D;for(var f=__assign$1({},_GLOBAL_CUSTOM_OBJECTS),_=0,O=Object.keys(C),y;_<O.length;_++)y=O[_],_GLOBAL_CUSTOM_OBJECTS[y]=C[y];var L=R(s,E.config);return _GLOBAL_CUSTOM_OBJECTS=__assign$1({},f),L}f=__assign$1({},_GLOBAL_CUSTOM_OBJECTS);for(var M=0,F=Object.keys(C);M<F.length;M++)y=F[M],_GLOBAL_CUSTOM_OBJECTS[y]=C[y];var z,B,V;return L=new s(E.config),_GLOBAL_CUSTOM_OBJECTS=__assign$1({},f),L}function numberCompare(a,e){return a<e?-1:a>e?1:0}function reverseNumberCompare(a,e){return-1*numberCompare(a,e)}function stringToDType(t){switch(t){case"float32":return"float32";default:throw new ValueError("Invalid dtype: "+t);}}function unique(a){if(null==a)return a;for(var e=[],t=0,o=a,r;t<o.length;t++)r=o[t],-1===e.indexOf(r)&&e.push(r);return e}function isObjectEmpty(a){if(null==a)throw new ValueError("Invalid value in obj: "+JSON.stringify(a));for(var e in a)if(a.hasOwnProperty(e))return!1;return!0}function checkStringTypeUnionValue(a,e,t){if(null!=t&&0>a.indexOf(t))throw new ValueError(t+" is not a valid "+e+".  Valid values are "+a+" or null/undefined.")}function checkArrayTypeAndLength(a,o,e,t){return void 0===e&&(e=0),void 0===t&&(t=1/0),assert$1(0<=e),assert$1(t>=e),Array.isArray(a)&&a.length>=e&&a.length<=t&&a.every(function(t){return typeof t===o})}function calcL2Norms(a,e){return tidy(function(){return sqrt(sum$1(mulStrict(a,a),e,!0))})}function serializeConstraint(t){return serializeKerasObject(t)}function deserializeConstraint(a,e){return void 0===e&&(e={}),deserializeKerasObject(a,serialization.SerializationMap.getMap().classNameMap,e,"constraint")}function getConstraint(t){return null==t?null:"string"==typeof t?deserializeConstraint({className:t in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[t]:t,config:{}}):t instanceof Constraint?t:deserializeConstraint(t)}function maxNorm(t){return new MaxNorm(t)}function unitNorm(t){return new UnitNorm(t)}function nonNeg(){return new NonNeg}function minMaxNorm(t){return new MinMaxNorm(t)}function checkDataFormat(t){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",t)}function checkPaddingMode(t){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",t)}function checkPoolMode(t){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",t)}function nameScope(a,e){_nameScopeStack.push(a);try{var t=e();return _nameScopeStack.pop(),t}catch(t){throw _nameScopeStack.pop(),t}}function currentNameScopePrefix(){return 0===_nameScopeStack.length?"":_nameScopeStack.join("/")+"/"}function getScopedTensorName(t){if(!isValidTensorName(t))throw new Error("Not a valid tensor name: '"+t+"'");return currentNameScopePrefix()+t}function getUniqueTensorName(a){if(!isValidTensorName(a))throw new Error("Not a valid tensor name: '"+a+"'");nameMap.has(a)||nameMap.set(a,0);var e=nameMap.get(a);if(nameMap.set(a,nameMap.get(a)+1),0<e){var t=a+"_"+e;return nameMap.set(t,1),t}return a}function isValidTensorName(t){return!!t.match(tensorNameRegex)}function isInteger(t){return t===parseInt(t.toString(),10)}function arrayProd(a,e,o){null==e&&(e=0),null==o&&(o=a.length);for(var s=1,p=e;p<o;++p)s*=a[p];return s}function toArray1D(t){return t=Array.isArray(t)?new Float32Array(t):t,tensor1d(t)}function min$1(t){return min(toArray1D(t)).dataSync()[0]}function max$1(t){return max(toArray1D(t)).dataSync()[0]}function range$1(a,e){if(e<a)throw new ValueError("end ("+e+") < begin ("+a+") is forbidden.");for(var t=[],n=a;n<e;++n)t.push(n);return t}function cast$1(a,e){return a.asType(e)}function expandDims$1(a,e){void 0===e&&(e=-1);var r=a.shape.slice();return 0>e&&(e=r.length+e+1),r.splice(e,0,1),a.reshape(r)}function repeat(a,e){return tidy(function(){if(2!==a.shape.length)throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-"+a.shape.length+" tensor.");return tile$1(expandDims$1(a,1),[1,e,1])})}function flatten$1(a){var e=[arrayProd(a.shape)];return a.reshape(e)}function batchFlatten(a){if(1>=a.rank)throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: "+a.rank+".");var e=[a.shape[0],arrayProd(a.shape,1)];return a.reshape(e)}function sliceAlongFirstAxis(a,e,t){return tidy(function(){switch(a.rank){case 1:return slice1d(a,e,t);case 2:return slice2d(a,[e,0],[t,a.shape[1]]);case 3:return slice3d(a,[e,0,0],[t,a.shape[1],a.shape[2]]);case 4:return slice4d(a,[e,0,0,0],[t,a.shape[1],a.shape[2],a.shape[3]]);default:throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: "+a.rank);}})}function sliceAlongLastAxis(a,e,t){return tidy(function(){switch(a.rank){case 1:return slice1d(a,e,t);case 2:return slice2d(a,[0,e],[a.shape[0],t]);case 3:return slice3d(a,[0,0,e],[a.shape[0],a.shape[1],t]);case 4:return slice4d(a,[0,0,0,e],[a.shape[0],a.shape[1],a.shape[2],t]);default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+a.rank);}})}function sliceAlongAxis(a,e,t,n){return tidy(function(){switch(a.rank){case 1:return slice1d(a,e,t);case 2:switch(n){case 1:return sliceAlongFirstAxis(a,e,t);case 2:return sliceAlongLastAxis(a,e,t);default:throw new ValueError("The axis is not within the rank of the tensor "+n);}case 3:switch(n){case 1:return sliceAlongFirstAxis(a,e,t);case 2:return slice3d(a,[0,e,0],[a.shape[0],t,a.shape[2]]);case 3:return sliceAlongLastAxis(a,e,t);default:throw new ValueError("The axis is not within the rank of the tensor "+n);}case 4:switch(n){case 1:return sliceAlongFirstAxis(a,e,t);case 2:return slice4d(a,[0,e,0,0],[a.shape[0],t,a.shape[2],a.shape[3]]);case 3:return slice4d(a,[0,0,e,0],[a.shape[0],a.shape[1],t,a.shape[3]]);case 4:return sliceAlongLastAxis(a,e,t);default:throw new ValueError("The axis is not within the rank of the tensor "+n);}default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+a.rank);}})}function concatenate(a,e){var r;return void 0===e&&(e=-1),0>e&&(e=0===(r=a[0].rank)?0:r),e===a[0].rank&&(e=-1),concat(a,e)}function concatAlongFirstAxis(a,e){switch(a.rank){case 1:return concat1d([a,e]);case 2:return concat2d([a,e],0);case 3:return concat3d([a,e],0);case 4:return concat4d([a,e],0);default:throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: "+a.rank);}}function tile$1(a,e){if(Array.isArray(e)||(e=[e]),a.rank!==e.length)throw new ValueError("The length of input n ("+e.length+") does not match the number of dimensions in input x ("+a.rank+")");return tile(a,e)}function randomNormal$1(a,e,o,s,r){return void 0===e&&(e=0),void 0===o&&(o=1),randomNormal(a,e,o,s,r)}function dot$1(p,d){if(2>p.rank||2>d.rank)throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = "+p.shape+" and y shape = "+d.shape);if(3<=d.rank&&(n=p.shape.slice(-1)[0])!==(a=d.shape.slice(-2)[0]))throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = "+p.shape+" and  y shape = "+d.shape);if(2===p.rank&&2===d.rank)return matMul(p,d);var c=p.shape.slice(),n=c.pop();p=p.reshape([-1,n]);var m=d.shape.slice(),i=m.pop(),a=m.pop(),h=m.concat([i]),s=Array.from({length:d.rank},function(t,e){return 0===e?d.rank-2:e<=d.rank-2?e-1:e});d=d.transpose(s).reshape([a,-1]);var l=c.concat(h);return matMul(p,d).reshape(l)}function gather$1(a,e,r){return tidy(function(){return e=Array.isArray(e)?tensor1d(e,"int32"):e.toInt(),gather(a,e,r)})}function square$1(t){return mulStrict(t,t)}function biasAdd(a,e,t){return tidy(function(){if(null==t&&(t=imageDataFormat()),checkDataFormat(t),1!==e.rank&&e.rank!==a.rank)throw new ValueError("Unexpected bias dimensions: "+e.rank+"; expected it to be 1 or "+a.rank);var n=e.shape,o;if(5===a.rank)"channelsFirst"===t?o=1===n.length?a.add(e.reshape([1,n[0],1,1,1])):a.add(e.reshape([1,n[3],n[0],n[1],n[2]])):"channelsLast"===t&&(o=1===n.length?a.add(e.reshape([1,1,1,1,n[0]])):a.add(e.reshape([1].concat(n))));else if(4===a.rank)"channelsFirst"===t?o=1===n.length?a.add(e.reshape([1,n[0],1,1])):a.add(e.reshape([1,n[2],n[0],n[1]])):"channelsLast"===t&&(o=1===n.length?a.add(e.reshape([1,1,1,n[0]])):a.add(e.reshape([1].concat(n))));else if(3===a.rank)"channelsFirst"===t?o=1===n.length?a.add(e.reshape([1,n[0],1])):a.add(e.reshape([1,n[1],n[0]])):"channelsLast"===t&&(o=1===n.length?a.add(e.reshape([1,1,n[0]])):a.add(e.reshape([1].concat(n))));else{if(!(3>a.rank))throw new ValueError("Unsupported input rank by biasAdd: "+a.rank);o=a.add(e)}return o})}function elu$1(a,e){if(void 0===e&&(e=1),1!==e)throw new NotImplementedError("Support for alpha values other than 1 ("+e+") is not implemented yet.");return elu(a)}function softsign(t){return tidy(function(){return div(t,add(getScalar(1),abs(t)))})}function dropout(a,e,t,n){return tidy(function(){if(null!=t&&!util.arraysEqual(a.shape,t))throw new NotImplementedError("Non-default noise shape is not implemented yet: "+JSON.stringify(t));if(null!=n)throw new NotImplementedError("seed is not implemented for dropout yet.");var r=step(add(neg(e),randomUniform(a.shape,0,1,"float32")));return r=mul(div(getScalar(1),sub(getScalar(1),e)),r),mul(a,r)})}function hardSigmoid(a){return tidy(function(){var e=add(getScalar(.5),mul(getScalar(.2),a));return clipByValue(e,0,1)})}function inTrainPhase(a,e,t){return void 0===t&&(t=!1),t?a():e()}function checkFanMode(t){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",t)}function checkDistribution(t){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",t)}function computeFans(o,e){var s,p;if(void 0===e&&(e="channelsLast"),checkDataFormat(e),2===o.length)s=o[0],p=o[1];else if(!(-1!==[3,4,5].indexOf(o.length))){var l=arrayProd(o);s=_Mathsqrt(l),p=_Mathsqrt(l)}else if("channelsFirst"===e){var a=arrayProd(o,2);s=o[1]*a,p=o[0]*a}else"channelsLast"===e&&(a=arrayProd(o,0,o.length-2),s=o[o.length-2]*a,p=o[o.length-1]*a);return[s,p]}function deserializeInitializer(a,e){return void 0===e&&(e={}),deserializeKerasObject(a,serialization.SerializationMap.getMap().classNameMap,e,"initializer")}function serializeInitializer(t){return serializeKerasObject(t)}function getInitializer(a){if("string"==typeof a){var e=a in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[a]:a;return"GlorotUniform"===e?new GlorotUniform:"GlorotNormal"===e?new GlorotNormal:"HeNormal"===e?new HeNormal:"LeCunNormal"===e?new LeCunNormal:deserializeInitializer({className:e,config:{}})}return a instanceof Initializer?a:deserializeInitializer(a)}function zeros$1(){return new Zeros}function ones$1$1(){return new Ones}function constant(t){return new Constant(t)}function randomUniform$1(t){return new RandomUniform(t)}function randomNormal$2(t){return new RandomNormal(t)}function truncatedNormal$1(t){return new TruncatedNormal(t)}function identity(t){return new Identity(t)}function varianceScaling(t){return new VarianceScaling(t)}function glorotUniform(t){return new GlorotUniform(t)}function glorotNormal(t){return new GlorotNormal(t)}function heNormal(t){return new HeNormal(t)}function leCunNormal(t){return new LeCunNormal(t)}function orthogonal(t){return new Orthogonal(t)}function isArrayOfShapes(t){return Array.isArray(t)&&Array.isArray(t[0])}function normalizeShapeList(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function getExactlyOneTensor(a){var e;if(Array.isArray(a)){if(1!==a.length)throw new ValueError("Expected Tensor length to be 1; got "+a.length);e=a[0]}else e=a;return e}function getExactlyOneShape(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new ValueError("Expected exactly 1 Shape; got "+t.length)}return t}function countParamsInWeights(a){for(var e=0,o=0,s=a,r;o<s.length;o++)r=s[o],e+=0===r.shape.length?1:r.shape.reduce(function(a,e){return a*e});return e}function checkShapesMatch(a,e){if(a.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(a.shape)+" vs. "+JSON.stringify(e.shape))}function batchGetValue(t){return t.map(function(t){return t.read()})}function batchSetValue(t){t.map(function(t){t[0].write(t[1])})}function collectInputShape(a){for(var o=[],t=0,s=a=toList(a),r;t<s.length;t++)r=s[t],o.push(r.shape);return singletonOrArray(o)}function guessOutputDType(){return"float32"}function getSourceInputs(p,e,d){if((null==e||null!=d&&0<d)&&(e=p.sourceLayer,d=p.nodeIndex),0===e.inboundNodes.length)return[p];var u=e.inboundNodes[d];if(0===u.inboundLayers.length)return u.inputTensors;for(var r=[],i=0;i<u.inboundLayers.length;i++)for(var c=0,m=getSourceInputs(u.inputTensors[i],u.inboundLayers[i],u.nodeIndices[i]),s;c<m.length;c++)s=m[c],-1===r.indexOf(s)&&r.push(s);return r}function Input(a){if(null==a.batchShape&&null==a.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=a.batchShape&&null!=a.shape)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var e=a.batchShape;null!=a.shape&&null==e&&(e=[null].concat(a.shape));var r=a.dtype;return null==r&&(r="float32"),new InputLayer({batchInputShape:e,name:a.name,dtype:r,sparse:a.sparse}).inboundNodes[0].outputTensors[0]}function resolveScalarsInLogs(p){return __awaiter$1(this,void 0,void 0,function(){var e,d,c,u,m,h,g,f;return __generator$1(this,function(t){switch(t.label){case 0:if(null==p)return[2];for(u in e=[],d=[],c=[],p)"number"!=typeof(m=p[u])&&(h=m,e.push(h.data()),d.push(u),c.push(h));return[4,Promise.all(e)];case 1:for(g=t.sent(),f=0;f<g.length;++f)p[d[f]]=g[f][0];return dispose(c),[2];}})})}function disposeTensorsInLogs(a){if(null!=a)for(var e in a){var t=a[e];"number"!=typeof t&&t.dispose()}}function standardizeCallbacks(t){return null==t?null:t instanceof BaseCallback?[t]:Array.isArray(t)&&t[0]instanceof BaseCallback?t:toList(t).map(function(t){return new CustomCallback(t)})}function configureCallbacks(d,e,t,n,r,i,a,o,s,l){var u=new History,c=[new BaseLogger(e)].concat(CallbackConstructorRegistry.createCallbacks(t));null!=d&&c.push.apply(c,d),c.push(u);var p=new CallbackList(c);return p.setParams({epochs:n,initialEpoch:r,samples:i,steps:a,batchSize:o,verbose:t,doValidation:s,metrics:l}),{callbackList:p,history:u}}function l2Normalize(a,e){return tidy(function(){var t=sum$1(square$1(a),e,!0),n=mul(scalar(epsilon()),onesLike(a)),r=sqrt(maximum(t,n));return div(a,r)})}function meanSquaredError$1(a,e){return tidy(function(){return mean(square$1(sub(e,a)),-1)})}function meanAbsoluteError(a,e){return tidy(function(){return mean(abs(sub(e,a)),-1)})}function meanAbsolutePercentageError(a,e){return tidy(function(){var t=sub(a,e),n=clipByValue(abs(a),epsilon(),Number.MAX_VALUE),r=abs(div(t,n));return mul(getScalar(100),mean(r,-1))})}function meanSquaredLogarithmicError(s,e){return tidy(function(){var t=getScalar(1),n=clipByValue(e,epsilon(),Number.MAX_VALUE),r=log$1(add(t,n)),i=clipByValue(s,epsilon(),Number.MAX_VALUE),a=log$1(add(t,i));return mean(square$1(sub(r,a)),-1)})}function squaredHinge(a,e){return tidy(function(){var t=getScalar(0),n=getScalar(1),r=maximum(t,sub(n,mul(a,e)));return mean(square$1(r),-1)})}function hinge(a,e){return tidy(function(){var t=getScalar(0),n=getScalar(1),r=maximum(t,sub(n,mul(a,e)));return mean(r,-1)})}function categoricalHinge(o,e){return tidy(function(){var t=getScalar(0),n=getScalar(1),r=sum$1(mul(o,e),-1),s=max(mul(sub(n,o),e),-1);return maximum(t,add(n,sub(s,r)))})}function logcosh(a,e){return tidy(function(){var t=getScalar(_Mathlog(2)),n=sub(e,a),r=sub(add(n,softplus(mul(getScalar(-2),n))),t);return mean(r,-1)})}function categoricalCrossentropy(a,e,o){return void 0===o&&(o=!1),tidy(function(){if(o)e=softmax(e);else{var t=sum$1(e,e.shape.length-1,!0);e=div(e,t)}return e=clipByValue(e,epsilon(),1-epsilon()),neg(sum$1(mul(a.toFloat(),log$1(e)),e.shape.length-1))})}function sparseCategoricalCrossentropy(a,e,t){return void 0===t&&(t=!1),tidy(function(){var n=floor(flatten$1(a)).toInt(),r=e.shape;return categoricalCrossentropy(oneHot(n,r[r.length-1]).reshape(r),e,t)})}function sigmoidCrossEntropyWithLogits(a,e){return tidy(function(){var t=maximum(e,zerosLike(e)),n=mul(e,a),r=log$1(add(getScalar(1),exp(neg(abs(e)))));return add(sub(t,n),r)})}function binaryCrossentropy(a,e){return tidy(function(){var t;return t=clipByValue(e,epsilon(),1-epsilon()),t=log$1(div(t,sub(onesLike(t),t))),mean(sigmoidCrossEntropyWithLogits(a,t),-1)})}function kullbackLeiblerDivergence(a,e){return tidy(function(){var t=clipByValue(a,epsilon(),1),n=clipByValue(e,epsilon(),1);return sum$1(mul(a,log$1(div(t,n))),-1)})}function poisson(a,e){return tidy(function(){var t=log$1(add(getScalar(epsilon()),e));return mean(sub(e,mul(a,t)),-1)})}function cosineProximity(a,e){return tidy(function(){var t=l2Normalize(a,-1),n=l2Normalize(e,-1),r=mul(t,n);return neg(sum$1(r,-1))})}function get(a){var e={meanSquaredError:meanSquaredError$1,meanAbsoluteError:meanAbsoluteError,meanAbsolutePercentageError:meanAbsolutePercentageError,meanSquaredLogarithmicError:meanSquaredLogarithmicError,squaredHinge:squaredHinge,hinge:hinge,categoricalHinge:categoricalHinge,logcosh:logcosh,categoricalCrossentropy:categoricalCrossentropy,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy,binaryCrossentropy:binaryCrossentropy,kullbackLeiblerDivergence:kullbackLeiblerDivergence,poisson:poisson,cosineProximity:cosineProximity};if("string"==typeof a){if(a in e)return e[a];var t="Unknown loss "+a;throw a.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss "+a+". Use \"categoricalCrossentropy\" as the string name for tf.losses.softmaxCrossEntropy"),new ValueError(t)}return a}function binaryAccuracy(a,e){return tidy(function(){var t=mul(getScalar(.5),onesLike(e)),n=cast$1(greater(e,t),a.dtype);return mean(equal(a,n),-1)})}function categoricalAccuracy(a,e){return tidy(function(){return cast$1(equal(argMax(a,-1),argMax(e,-1)),"float32")})}function truePositives(a,e){return tidy(function(){var t=getScalar(1);return logicalAnd(a.equal(t),e.equal(t)).sum().cast("float32")})}function falseNegatives(a,e){return tidy(function(){var t=getScalar(1),n=getScalar(0);return logicalAnd(a.equal(t),e.equal(n)).sum().cast("float32")})}function falsePositives(a,e){return tidy(function(){var t=getScalar(1),n=getScalar(0);return logicalAnd(a.equal(n),e.equal(t)).sum().cast("float32")})}function precision(o,e){return tidy(function(){var t=getScalar(0),n=truePositives(o,e),r=falsePositives(o,e),s=n.add(r);return where(greater(s,t),n.div(s),t).cast("float32")})}function recall(o,e){return tidy(function(){var t=getScalar(0),n=truePositives(o,e),r=falseNegatives(o,e),s=n.add(r);return where(greater(s,t),n.div(s),t).cast("float32")})}function binaryCrossentropy$1(a,e){return binaryCrossentropy(a,e)}function sparseCategoricalAccuracy(){throw new NotImplementedError}function get$1(a){var e={binaryAccuracy:binaryAccuracy,categoricalAccuracy:categoricalAccuracy,precision:precision,categoricalCrossentropy:categoricalCrossentropy$1,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy$1,mse:mse$1,MSE:MSE$1,mae:mae$1,MAE:MAE$1,mape:mape$1,MAPE:MAPE$1,cosine:cosine$1};if("string"==typeof a&&a in e)return e[a];if("string"!=typeof a&&null!=a)return a;throw new ValueError("Unknown metric "+a)}function getOptimizer(a){var e={Adagrad:function(){return train.adagrad(.01)},Adadelta:function(){return train.adadelta(1,.95,epsilon())},Adam:function(){return train.adam(.001,.9,.999,epsilon())},Adamax:function(){return train.adamax(.002,.9,.999,epsilon(),0)},RMSProp:function(){return train.rmsprop(.001,.9,0,epsilon())},SGD:function(){return train.sgd(.01)}};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,a in e)return e[a]();throw new ValueError("Unknown Optimizer "+a)}function printSummary(d,m,e,h){void 0===h&&(h=console.log);var g=isModelSequentialLike(d),a=["Layer (type)","Output shape","Param #"],o;if(g?(m=m||65,e=e||[.45,.85,1]):(m=m||98,e=e||[.33,.55,.67,1]),1>=e[e.length-1]&&(e=e.map(function(t){return _Mathfloor(m*t)})),!g)for(var f in a.push("Receives inputs"),o=[],d.nodesByDepth)o.push.apply(o,d.nodesByDepth[f]);h("_".repeat(m)),printRow(a,e,h),h("=".repeat(m));for(var s=d.layers,l=0;l<s.length;++l)g?printLayerSummary(s[l],e,h):printLayerSummaryWithConnections(s[l],e,o,h),h((l==s.length-1?"=":"_").repeat(m));d.checkTrainableWeightsConsistency();var y=countTrainableParams(d),c=countParamsInWeights(d.nonTrainableWeights);h("Total params: "+(y+c)),h("Trainable params: "+y),h("Non-trainable params: "+c),h("_".repeat(m))}function countTrainableParams(t){return null==t.collectedTrainableWeights?countParamsInWeights(t.trainableWeights):countParamsInWeights(t.collectedTrainableWeights)}function isModelSequentialLike(m){var e=!0,g=[],n=[];for(var r in m.nodesByDepth)g.push(m.nodesByDepth[r]);for(var i=0,f=g,o;i<f.length;i++){if(o=f[i],1<o.length||1===o.length&&1<o[0].inboundLayers.length){e=!1;break}n.push.apply(n,o)}if(e)for(var y=0,b=m.layers;y<b.length;y++){for(var u=!1,x=0,N=b[y].inboundNodes,h;x<N.length;x++)if(h=N[x],-1!==n.indexOf(h)){if(u){e=!1;break}u=!0}if(!e)break}return e}function printRow(a,e,t){void 0===t&&(t=console.log);for(var o="",s=0;s<a.length;++s)0<s&&(o=o.slice(0,o.length-1)+" "),o=(o+=a[s]).slice(0,e[s]),o+=" ".repeat(e[s]-o.length);t(o)}function printLayerSummary(a,e,t){var n;try{n=JSON.stringify(a.outputShape)}catch(t){n="multiple"}printRow([a.name+" ("+a.getClassName()+")",n,a.countParams().toString()],e,t)}function printLayerSummaryWithConnections(m,e,t,n){var r;try{r=JSON.stringify(m.outputShape)}catch(t){r="multiple"}for(var y=[],a=0,b=m.inboundNodes,s;a<b.length;a++)if(s=b[a],!(null!=t&&0<t.length&&-1===t.indexOf(s)))for(var x=0;x<s.inboundLayers.length;++x){var N=s.inboundLayers[x].name,c=s.nodeIndices[x],p=s.tensorIndices[x];y.push(N+"["+c+"]["+p+"]")}var h=m.name,d=m.getClassName(),f=0===y.length?"":y[0];for(printRow([h+" ("+d+")",r,m.countParams().toString(),f],e,n),x=1;x<y.length;++x)printRow(["","","",y[x]],e,n)}function deserialize(a,e){return void 0===e&&(e={}),deserializeKerasObject(a,serialization.SerializationMap.getMap().classNameMap,e,"layer")}function isArrayItemInputOrOutputName(a,e,t){return("inboundNodes"===a||"outputLayers"===a||"inputLayers"===a)&&0===e&&"string"==typeof t}function convertPythonicToTs(d,e){if(null===d)return null;if("string"==typeof d)return toCamelCase(d);if("number"==typeof d||"boolean"==typeof d)return d;if(d instanceof Array){for(var t=[],n=d.length,r=0,m;r<n;++r)m=d[r],isArrayItemInputOrOutputName(e,r,m)?t.push(m):t.push(convertPythonicToTs(m,e));return t}for(var h={},o=0,g=Object.keys(d);o<g.length;o++){var l=g[o],u=d[l];if("name"===l&&"string"==typeof u)h[l]=u;else{var c=toCamelCase(l);h[c]=convertPythonicToTs(u,c)}}return h}function convertTsToPythonic(d,e){if(null===d||void 0===d)return null;if("string"==typeof d)return toSnakeCase(d);if("number"==typeof d||"boolean"==typeof d)return d;if(d instanceof Array){for(var t=[],n=d.length,r=0,m;r<n;++r)m=d[r],isArrayItemInputOrOutputName(e,r,m)?t.push(m):t.push(convertTsToPythonic(m,e));return t}for(var h={},o=0,g=Object.keys(d);o<g.length;o++){var l=g[o],u=d[l],c=toSnakeCase(l);h[c]="name"!==l&&"className"!==l||"string"!=typeof u?convertTsToPythonic(u,l):u}return h}function preprocessWeightsForLoading(a,e,t){if(!t.startsWith("2."))throw new ValueError("Unsupported Keras version in weights being loaded: "+t);return e}function loadTensor(a,e,t){var n=stringToDType(a);return Tensor.make(e,{values:0===e.length?t:util.flatten(t)},n)}function loadWeightsFromJson(x,e,t){void 0===t&&(t=!1);for(var N=x.keras_version,r=x.backend,i=e.map(function(t){return t.name}),a={},o=0,I=e;o<I.length;o++)null!=(D=I[o]).name&&(null==a[D.name]&&(a[D.name]=[]),a[D.name].push(D));for(var l=x.weights,u=[],c=0;c<i.length;++c){var S=i[c],h=l[S];null==h&&(h=[]);for(var C=[],k=0,T;k<h.length;++k)T=h[k],C.push(new LayerVariable(loadTensor(T.dtype,T.shape,T.value)));for(var E=0,R=a[S];E<R.length;E++){var v=(D=R[E]).weights,D;if((C=preprocessWeightsForLoading(D,C,N,r)).length!==v.length){if(!t)throw new ValueError("Layer #"+c+" (named \""+D.name+"\") expects "+v.length+" weight(s), but the saved weights have "+C.length+" element(s).");console.warn("Skipping loading of weights of layer "+D.name+" due to mismatch in number of weights: ("+C.length+" vs "+v.length+").")}for(var w=0;w<C.length;++w)!t||util.arraysEqual(v[w].shape,C[w].shape)?u.push([v[w],C[w].read()]):console.warn("Skipping loading of weights for layer "+D.name+" due to mismatch in shape ("+v[w].shape+" vs "+C[w].shape+")")}}batchSetValue(u)}function loadWeightsFromNamedTensorMap(m,e,t){void 0===t&&(t=!0);for(var g={},r=0,f=0,y=e;f<y.length;f++)for(var o=0,b=y[f].weights,l;o<b.length;o++){if(l=b[o],null!=g[l.originalName])throw new ValueError("Duplicate weight name: "+l.originalName);g[l.originalName]=l,r++}var x=[];for(var c in m){if(null!=g[c])x.push([g[c],m[c]]);else if(t)throw new ValueError("Provided weight data has no target variable: "+c);delete g[c]}if(t){var p=[];for(var h in g)p.push(h);if(0<p.length)throw new ValueError(p.length+" of "+r+" weights are not set: "+p)}batchSetValue(x)}function assertFeedCompatibility(a,e){if(null!=a.shape){if(a.shape.length!==e.shape.length)throw new ValueError("The rank of feed ("+e.shape.length+") does not match the rank of the key ("+a.shape.length+").");for(var t=0;t<a.shape.length;++t)if(null!=a.shape[t]&&a.shape[t]!==e.shape[t])throw new ValueError("The "+t+"-th dimension of the feed ("+e.shape[t]+") is incompatible with that of the key ("+a.shape[t]+").")}if(null==a.dtype||a.dtype===e.dtype)return e;try{return cast(e,a.dtype)}catch(t){throw new ValueError("The dtype of the feed ("+e.dtype+") can not be cast to the dtype of the key '"+a.name+"' ("+a.dtype+").")}}function execute(p,e,t){for(var n=Array.isArray(p),r=n?p:[p],i=[],a=new FeedDict(e),o=0,d=r,l;o<d.length;o++)l=d[o],i.push(executeInternal(l,a,t));return n?i:i[0]}function executeInternal(p,e,t){if(e.hasKey(p))return e.getValue(p);if(p.sourceLayer instanceof InputLayer)throw new ValueError("Missing a feed value for SymbolicTensor from InputLayer '"+InputLayer.name+"'");for(var n=[],r=0,d=p.inputs,a;r<d.length;r++)a=executeInternal(d[r],e,t),n.push(a);var m=p.sourceLayer.apply(n,t);Array.isArray(m)||(m=[m]);for(var h=getNodeOutputs(p),l=Array.isArray(h)?h:[h],u=0;u<l.length;++u)e.add(l[u],m[u]);return 1===m.length?m[0]:m[p.outputTensorIndex]}function getNodeOutputs(o){var e;if(1===o.sourceLayer.inboundNodes.length)e=o.sourceLayer.output;else{for(var s=null,p=0;p<o.sourceLayer.inboundNodes.length;++p)for(var l=0,d=o.sourceLayer.inboundNodes[p].outputTensors;l<d.length;l++)if(d[l].id===o.id){s=p;break}e=o.sourceLayer.getOutputAt(s)}return e}function standardizeDataIteratorOutput(p,e){if(1<p.outputs.length)throw new NotImplementedError("Support for training a model with multiple output tensors with a dataset object is not implemented yet.");util.assert(Array.isArray(e)&&2===e.length,"Dataset iterator for fitDataset() is expected to generate an Array of length 2: `[xs, ys]`, but instead generates "+e);var d=(e=e)[1],n=e[0];if(n instanceof Tensor)return util.assert(1===p.inputs.length,"Model has multiple "+p.inputs.length+" inputs, hence it expects the input dataset to generate a dictionary of tensors  (with keys "+JSON.stringify(p.inputNames)+", but received a single tensor."),util.assert(n.shape[0]===d.shape[0],"Mismatch in batch size between x and y tensors ("+n.shape[0]+" vs. "+d.shape[0]+")"),[n,d];var u;n=n;for(var c=[],a=0,m=p.inputNames,s;a<m.length;a++){if(s=m[a],null==n[s])throw new ValueError("The feature data generated by the dataset lacks the required input key '"+s+"'.");c.push(n[s]),null==u?u=n[s].shape[0]:util.assert(n[s].shape[0]===u,"Mismatch in batch size between x and y tensors ("+n[s].shape[0]+" vs. "+d.shape[0]+")")}return c.concat(d)}function standardizeTensorValidationData(t){if(3===t.length)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}function fitDataset(x,e,t){return __awaiter$1(this,void 0,void 0,function(){var n,T,R,D,P,O,L,M,F,B,V,U,W,G,q,H,j,$,k,K,X,Y,Z,Q,J,ee;return __generator$1(this,function(a){switch(a.label){case 0:if(n=null!=t.batchesPerEpoch,util.assert(null!=x.optimizer,"You must compile a model before training/testing. Use Model.compile(modelCompileConfig)."),util.assert(null!=t,"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),util.assert(null!=t.epochs&&0<t.epochs&&_NumberisInteger(t.epochs),"For fitDataset(), config.epochs is expected to be a positive integer, but got "+t.epochs),util.assert(!n||0<t.batchesPerEpoch&&_NumberisInteger(t.batchesPerEpoch),"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+t.batchesPerEpoch),util.assert(null==t.validationSplit,"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),x.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");x.isTraining=!0,a.label=1;case 1:return a.trys.push([1,,21,22]),T=null!=t.validationData,R=void 0,D=void 0,T&&(isDatasetObject(t.validationData)?util.assert(null==t.validationBatches||0<t.validationBatches&&_NumberisInteger(t.validationBatches),"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+t.validationBatches):(P=standardizeTensorValidationData(t.validationData),R=P.xs,D=P.ys)),O=x.makeTrainFunction(),L=x.getDedupedMetricsNames(),M=void 0,M=T?L.slice().concat(L.map(function(t){return"val_"+t})):L.slice(),F=standardizeCallbacks(t.callbacks),B=configureCallbacks(F,t.yieldEvery,t.verbose,t.epochs,null,null,t.batchesPerEpoch,null,T,M),V=B.callbackList,U=B.history,x.history=U,[4,V.onTrainBegin()];case 2:return a.sent(),W=null==t.initialEpoch?0:t.initialEpoch,G={},[4,e.iterator()];case 3:q=a.sent(),a.label=4;case 4:return W<t.epochs?[4,V.onEpochBegin(W)]:[3,18];case 5:return a.sent(),H=0,j=0,n?[3,7]:[4,e.iterator()];case 6:q=a.sent(),a.label=7;case 7:return!n||H<t.batchesPerEpoch?[4,q.next()]:[3,16];case 8:if($=a.sent(),n&&$.done)return console.warn("You provided `batchesPerEpoch` as "+t.batchesPerEpoch+", but your dataset iterator ran out of data after "+H+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+t.batchesPerEpoch*t.epochs+" batches). You may need to use the repeat() function when building your dataset."),[3,16];if(null==$.value)return[3,10];for(k=standardizeDataIteratorOutput(x,$.value),(K={}).batch=j,K.size=k[0].shape[0],V.onBatchBegin(j,K),X=O(k),dispose(k),ee=0;ee<L.length;++ee)Y=L[ee],Z=X[ee],K[Y]=Z,keep(Z);return[4,V.onBatchEnd(j,K)];case 9:a.sent(),disposeTensorsInLogs(K),j++,H++,a.label=10;case 10:return(n?H>=t.batchesPerEpoch:$.done)?T?(Q=void 0,isDatasetObject(t.validationData)?(J=toList,[4,x.evaluateDataset(t.validationData,{batches:t.validationBatches})]):[3,12]):[3,14]:[3,15];case 11:return Q=J.apply(void 0,[a.sent()]),[3,13];case 12:Q=toList(x.evaluate(R,D,{batchSize:null==t.validationBatchSize?32:t.validationBatchSize,verbose:0})),a.label=13;case 13:for(ee=0;ee<x.metricsNames.length;++ee)G["val_"+x.metricsNames[ee]]=Q[ee];a.label=14;case 14:return[3,16];case 15:return x.stopTraining_?[3,16]:[3,7];case 16:return[4,V.onEpochEnd(W,G)];case 17:return a.sent(),W++,x.stopTraining_?[3,18]:[3,4];case 18:return[4,V.onTrainEnd()];case 19:return a.sent(),[4,x.history.syncData()];case 20:return a.sent(),[2,x.history];case 21:return x.isTraining=!1,[7];case 22:return[2];}})})}function isDatasetObject(t){return"function"==typeof t.iterator}function isLazyIteratorObject(t){return"function"==typeof t.next}function evaluateDataset(m,e,g){return __awaiter$1(this,void 0,void 0,function(){var n,t,f,y,b,x,N,I,d,v;return __generator$1(this,function(a){switch(a.label){case 0:if(n=null!=g.batches,t=m.testFunction,f=[],0<g.verbose)throw new NotImplementedError("Verbose mode is not implemented yet.");return util.assert(!n||0<g.batches&&_NumberisInteger(g.batches),"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(g.batches)),isLazyIteratorObject(e)?(b=e,[3,3]):[3,1];case 1:return[4,e.iterator()];case 2:b=a.sent(),a.label=3;case 3:y=b,x=0,N=0,I=function(){var e,a,r,o,i,l;return __generator$1(this,function(t){switch(t.label){case 0:return[4,y.next()];case 1:if((e=t.sent()).value){if(a=standardizeDataIteratorOutput(m,e.value),r=tidy(function(){return t(a)}),dispose(a),0===N)for(l=0;l<r.length;++l)f.push(getScalar(0));for(o=a[0].shape[0],i=function(a){var e=r[a],t=f[a];f[a]=tidy(function(){return add(f[a],mul(getScalar(o),e))}),0<N&&dispose(t)},l=0;l<r.length;++l)i(l);dispose(r),x+=o,++N}return e.done?(n&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+g.batches+" batches). You may need to use the repeat() function when building your dataset."),[2,"break"]):[2];}})},a.label=4;case 4:return!n||N<g.batches?[5,I()]:[3,6];case 5:return"break"===a.sent()?[3,6]:[3,4];case 6:for(d=function(a){var e=f[a];f[a]=tidy(function(){return div(f[a],getScalar(x))}),dispose(e)},v=0;v<f.length;++v)d(v);return[2,singletonOrArray(f)];}})})}function checkBatchSize(t){util.assert(0<t&&_NumberisInteger(t),"batchSize is required to be a positive integer, but got "+t)}function sliceArrays(a,r,t){return null==a?[null]:Array.isArray(a)?a.map(function(a){return sliceAlongFirstAxis(a,r,t-r)}):sliceAlongFirstAxis(a,r,t-r)}function sliceArraysByIndices(a,n){return tidy(function(){return null==a?null:Array.isArray(a)?a.map(function(t){return sliceArraysByIndices(t,n)}):gather$1(a,"int32"===n.dtype?n:n.toInt())})}function makeBatches(a,e){for(var t=[],n=0,o=null;n<a;)(o=n+e)>=a&&(o=a),t.push([n,o]),n=o;return t}function fitLoop(x,e,t,n,r,C,k,T,s,l,u,E,p,R,d,f){return __awaiter$1(this,void 0,void 0,function(){var i,c,D,a,P,o,h,g;return __generator$1(this,function(m){switch(m.label){case 0:if(null==r&&(r=32),null==C&&(C=1),null==u&&(u=!0),null==p&&(p=0),i=!1,null!=s&&null!=l&&(i=!0),null!=d&&(i=!0,null==R))throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");return null!=(c=x.checkNumSamples(t,r,R,"steps_per_epoch"))&&(D=range$1(0,c)),null==k&&(k=1),a=configureCallbacks(T,f,k,C,p,c,R,r,i,E),P=a.callbackList,o=a.history,P.setModel(x),x.history=o,[4,P.onTrainBegin()];case 1:m.sent(),x.stopTraining_=!1,h=function(d){var a,m,N,y,b;return __generator$1(this,function(o){switch(o.label){case 0:return[4,P.onEpochBegin(d)];case 1:if(o.sent(),a={},null==R)return[3,2];throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===u)throw new NotImplementedError("batch shuffling is not implemneted yet");u&&util.shuffle(D),m=tensor1d(D),N=makeBatches(c,r),y=function(o){var p;return __generator$1(this,function(d){switch(d.label){case 0:return p={},[4,P.onBatchBegin(o,p)];case 1:return d.sent(),tidy(function(){var u=N[o][0],c=N[o][1],d=sliceAlongFirstAxis(m,u,c-u);p.batch=o,p.size=c-u;for(var h=sliceArraysByIndices(t,d),g=e(h),f=0;f<n.length;++f){var y=n[f],I=g[f];p[y]=I,keep(I)}if(o===N.length-1&&i){var S=x.testLoop(s,l,r);for(f=0;f<n.length;++f)y=n[f],I=S[f],keep(I),a["val_"+y]=I}}),[4,P.onBatchEnd(o,p)];case 2:return d.sent(),disposeTensorsInLogs(p),x.stopTraining_?[2,"break"]:[2];}})},b=0,o.label=3;case 3:return b<N.length?[5,y(b)]:[3,6];case 4:if("break"===o.sent())return[3,6];o.label=5;case 5:return++b,[3,3];case 6:m.dispose(),o.label=7;case 7:return[4,P.onEpochEnd(d,a)];case 8:return o.sent(),x.stopTraining_?[2,"break"]:[2];}})},g=p,m.label=2;case 2:return g<C?[5,h(g)]:[3,5];case 3:if("break"===m.sent())return[3,5];m.label=4;case 4:return++g,[3,2];case 5:return[4,P.onTrainEnd()];case 6:return m.sent(),[4,x.history.syncData()];case 7:return m.sent(),[2,x.history];}})})}function fitTensors(x,e,t,n){return void 0===n&&(n={}),__awaiter$1(this,void 0,void 0,function(){var r,C,k,T,E,R,D,P,A,_,N,O,L,M,F,B,V,U,W,G;return __generator$1(this,function(a){switch(a.label){case 0:if(x.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");x.isTraining=!0,a.label=1;case 1:if(a.trys.push([1,,3,4]),checkBatchSize(D=null==n.batchSize?32:n.batchSize),P=x.standardizeUserData(e,t,!1,D),r=P[0],C=P[1],A=!1,_=void 0,null!=n.validationData&&0<n.validationData.length){if(A=!0,2!==n.validationData.length)throw 3===n.validationData.length?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+n.validationData+" is invalid.");k=n.validationData[0],T=n.validationData[1],N=x.standardizeUserData(k,T,!0,D),E=N[0],R=N[1],_=E.concat(R)}else null!=n.validationSplit&&0<n.validationSplit&&1>n.validationSplit?(A=!0,O=_Mathfloor(r[0].shape[0]*(1-n.validationSplit)),L=r[0].shape[0],E=sliceArrays(r,O,L),r=sliceArrays(r,0,O),R=sliceArrays(C,O,L),C=sliceArrays(C,0,O),_=E.concat(R)):null!=n.validationSteps&&(A=!0);return M=r.concat(C),x.checkTrainableWeightsConsistency(),F=x.makeTrainFunction(),B=x.getDedupedMetricsNames(),V=void 0,U=void 0,A?(x.makeTestFunction(),V=x.testFunction,U=B.slice().concat(B.map(function(t){return"val_"+t}))):(V=null,_=[],U=B.slice()),W=standardizeCallbacks(n.callbacks),[4,fitLoop(x,F,M,B,D,n.epochs,n.verbose,W,V,_,n.shuffle,U,n.initialEpoch,null,null,n.yieldEvery)];case 2:return G=a.sent(),x.isTraining=!1,[2,G];case 3:return x.isTraining=!1,disposeNewTensors(r,e),disposeNewTensors(C,t),disposeNewTensors(E,k),disposeNewTensors(R,T),[7];case 4:return[2];}})})}function ensureTensorsRank2OrHigher(a){var o=[];a instanceof Tensor&&(a=[a]);for(var t=0,s;t<a.length;++t)if(s=a[t],1===s.rank)o.push(expandDims$1(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");o.push(s)}return o}function disposeNewTensors(p,e){if(null!=p){var t=[];if(e instanceof Tensor)t.push(e.id);else if(Array.isArray(e))e.forEach(function(a){return t.push(a.id)});else if(null!=e)for(var n in e){var r=e[n];t.push(r.id)}var i=[];if(p instanceof Tensor)-1===t.indexOf(p.id)&&i.push(p);else if(Array.isArray(p))p.forEach(function(a){-1===t.indexOf(a.id)&&i.push(a)});else if(null!=p)for(var a in p){var o=p[a];-1===t.indexOf(o.id)&&i.push(o)}i.forEach(function(t){t.isDisposed||t.dispose()})}}function isDataTensor(t){return t instanceof Tensor}function isDataArray(t){return Array.isArray(t)}function isDataDict(t){return!isDataTensor(t)&&!isDataArray(t)}function standardizeInputData(m,y,t,n,b){if(void 0===n&&(n=!0),void 0===b&&(b=""),null==y||0===y.length){if(null!=m){var x=!1;if(isDataArray(m)&&0<m.length)x=!0;else if(isDataDict(m)){for(var N in m)if(m.hasOwnProperty(N)){x=!0;break}}else x=!0;if(x)throw new ValueError("Error when checking model "+b+" expected no data, but got "+m)}return[]}if(null==m)return y.map(function(){return null});var o;if(isDataDict(m)){m=m,o=[];for(var I=0,v=y,u;I<v.length;I++){if(u=v[I],null==m[u])throw new ValueError("No data provided for \""+u+"\". Need data for each key in: "+y);o.push(m[u])}}else if(isDataArray(m)){if((m=m).length!==y.length)throw new ValueError("Error when checking model "+b+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+y.length+" Tensor(s), but instead got the following list of Tensor(s): "+m);o=m}else{if(m=m,1<y.length)throw new ValueError("The model "+b+" expects "+y.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+m.shape);o=[m]}if(o=ensureTensorsRank2OrHigher(o),null!=t)for(var S=0;S<y.length;++S)if(null!=t[S]){var C=o[S];if(C.shape.length!==t[S].length)throw new ValueError("Error when checking "+b+": expected "+y[S]+" to have "+t[S].length+" dimension(s). but got array with shape "+C.shape);for(var h=0;h<t[S].length;++h)if(0!=h||n){var k=C.shape[h],f=t[S][h];if(null!=f&&0<=f&&k!==f)throw new ValueError("Error when checking "+b+": expected "+y[S]+" to have shape ["+t[S]+"], but got array with shape ["+C.shape+"].")}}return o}function checkArrayLengths(a,e){var t=unique(a.map(function(t){return t.shape[0]}));t.sort();var n=unique(e.map(function(t){return t.shape[0]}));if(n.sort(),1<t.length)throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(a.map(function(t){return t.shape})));if(1<n.length)throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(e.map(function(t){return t.shape})));if(0<t.length&&0<n.length&&!util.arraysEqual(t,n))throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found "+t[0]+" input sample(s) and "+n[0]+" target sample(s).")}function checkLossAndTargetCompatibility(d,e,t){for(var n=[meanSquaredError$1,binaryCrossentropy,categoricalCrossentropy],r=0;r<d.length;++r){var m=d[r],a=e[r],o=t[r];if(null!=a){if(a===categoricalCrossentropy&&1===m.shape[m.shape.length-1])throw new ValueError("You are passing a target array of shape "+m.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==n.indexOf(a))for(var s=m.shape.slice(1),l=o.slice(1),u=0;u<s.length;++u){var g=s[u],p=l[u];if(null!=p&&g!==p)throw new ValueError("A target Tensor with shape "+m.shape+" was passed for an output of shape "+o+", while using a loss function that expects targets to have the same shape as the output.")}}}}function checkInputData(p,e,t,n,d){var m;if(void 0===n&&(n=!0),void 0===d&&(d=""),Array.isArray(p)){if(p.length!==e.length)throw new ValueError("Error when checking model "+d+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+e.length+" Tensor(s), but instead got "+p.length+" Tensors(s).");m=p}else{if(1<e.length)throw new ValueError("The model expects "+e.length+" "+d+" Tensors, but only received one Tensor. Found: array with shape "+JSON.stringify(p.shape)+".");m=[p]}if(null!=t)for(var h=0;h<e.length;++h)if(null!=t[h]){var g=m[h];if(g.shape.length!==t[h].length)throw new ValueError("Error when checking "+d+": expected "+e[h]+" to have "+t[h].length+" dimension(s), but got array with shape "+JSON.stringify(g.shape));for(var s=0;s<t[h].length;++s)if(0!=s||n){var f=g.shape[s],u=t[h][s];if(null!=u&&u!==f)throw new ValueError("Error when checking "+d+": expected "+e[h]+" to have shape "+JSON.stringify(t[h])+" but got array with shape "+JSON.stringify(g.shape)+".")}}}function collectMetrics(s,e){if(null==s||Array.isArray(s)&&0===s.length)return e.map(function(){return[]});if(Array.isArray(s))return e.map(function(){return s});if(null!=s){for(var t=[],n=0,p=e;n<p.length;n++){var i=p[n],a=s.hasOwnProperty(i)?s[i]:[];Array.isArray(a)||(a=[a]),t.push(a)}return t}throw new TypeError("Type of metrics argument not understood. Expected an Array or Object, found: "+s)}function modelFromJSON(d,m){return __awaiter$1(this,void 0,void 0,function(){var e,t,g,f,y,b,x,N,I,v;return __generator$1(this,function(a){switch(a.label){case 0:return"modelTopology"in d||(d={modelTopology:d}),null!=(e=(d=d).modelTopology).model_config&&(e=e.model_config),t=convertPythonicToTs(e),g=deserialize(t,m),null==d.weightsManifest?[3,2]:[4,io.loadWeights(d.weightsManifest,d.pathPrefix,g.weights.map(function(t){return t.originalName}))];case 1:for(f=a.sent(),y={},b=0,x=g.weights;b<x.length;b++)N=x[b],y[N.originalName]=f[N.originalName];I=null,v=!0,g.loadWeights(y,I,v),a.label=2;case 2:return[2,g];}})})}function input(t){return Input(t)}function serializeActivation(t){return t.getClassName()}function deserializeActivation(a,e){return void 0===e&&(e={}),deserializeKerasObject(a,serialization.SerializationMap.getMap().classNameMap,e,"activation")}function getActivation(t){return null==t?deserializeActivation({className:"linear",config:{}}):"string"==typeof t?deserializeActivation({className:t,config:{}}):t instanceof Activation?t:deserializeActivation(t)}function l1(t){return new L1L2({l1:null==t?null:t.l1,l2:0})}function l2(t){return new L1L2({l2:null==t?null:t.l2,l1:0})}function serializeRegularizer(t){return serializeKerasObject(t)}function deserializeRegularizer(a,e){return void 0===e&&(e={}),deserializeKerasObject(a,serialization.SerializationMap.getMap().classNameMap,e,"regularizer")}function getRegularizer(t){return null==t?null:"string"==typeof t?deserializeRegularizer({className:t in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[t]:t,config:{}}):t instanceof Regularizer?t:deserializeRegularizer(t)}function normalizeArray(a,e,t){if("number"==typeof a)return pyListRepeat(a,e);if(a.length!==e)throw new ValueError("The "+t+" argument must be a tuple of "+e+" integers. Received: "+a.length+" elements.");for(var n=0,o;n<e;++n)if(o=a[n],!isInteger(o))throw new ValueError("The "+t+" argument must be a tuple of "+e+" integers. Received: "+JSON.stringify(a)+" including a non-integer number "+o);return a}function convOutputLength(o,e,t,n,r){return void 0===r&&(r=1),null==o?o:(s="same"===t?o:o-(e+(e-1)*(r-1))+1,_Mathfloor((s+n-1)/n));var s}function deconvLength(a,o,t,n){if(null==a)return null;if("valid"===n)a=a*o+max$1([t-o,0]);else{if("same"!==n)throw new ValueError("Unsupport padding mode: "+n+".");a*=o}return a}function preprocessConv2DInput(a,e){return tidy(function(){return checkDataFormat(e),"channelsFirst"===e?transpose(a,[0,2,3,1]):a})}function conv1dWithBias(p,l,t,n,d,u,c){return void 0===n&&(n=1),void 0===d&&(d="valid"),void 0===c&&(c=1),tidy(function(){if(null==u&&(u=imageDataFormat()),checkDataFormat(u),3!==p.shape.length)throw new ValueError("The input of a conv1dWithBias operation should be 3, but is "+p.shape.length+" instead.");if(3!==l.shape.length)throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is "+l.shape.length+" instead");if(null!=t&&1!==t.shape.length)throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is "+l.shape.length+" instead");if("channelsFirst"===u&&(p=transpose(p,[0,2,1])),"causal"===d)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var e=conv1d(p,l,n,"same"===d?"same":"valid","NWC",c);return null!=t&&(e=biasAdd(e,t)),e})}function conv2dWithBias(p,e,t,n,l,d,u){return void 0===n&&(n=[1,1]),void 0===l&&(l="valid"),tidy(function(){if(null==d&&(d=imageDataFormat()),checkDataFormat(d),3!==p.rank&&4!==p.rank)throw new ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received "+p.rank+".");if(3!==e.rank&&4!==e.rank)throw new ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received "+p.rank+".");var a=preprocessConv2DInput(p,d);if("causal"===l)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return a=conv2d(a,e,n,"same"===l?"same":"valid","NHWC",u),null!=t&&(a=biasAdd(a,t)),"channelsFirst"===d&&(a=transpose(a,[0,3,1,2])),a})}function depthwiseConv2d$1(s,e,t,p,l,d){return void 0===t&&(t=[1,1]),void 0===p&&(p="valid"),tidy(function(){null==l&&(l=imageDataFormat()),checkDataFormat(l);var a=preprocessConv2DInput(s,l);if(4!==s.rank)throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead "+s.rank+"-D");if(4!==e.rank)throw new ValueError("depthwiseKernel is required to be 4-D, but is instead "+e.rank+"-D");return a=depthwiseConv2d(a,e,t,"same"===p?"same":"valid","NHWC",d),"channelsFirst"===l&&(a=transpose(a,[0,3,1,2])),a})}function interpretAxis(a,n){for(;0>a;)a+=n;return a}function batchDot(d,m,o){if(3<d.shape.length||3<m.shape.length)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(util.assert(2<=d.shape.length,"batchDot requires the rank of x to be >= 2, but got "+d.shape.length),util.assert(2<=d.shape.length,"batchDot requires the rank of y to be >= 2, but got "+m.shape.length),"number"==typeof o&&(o=[o,o]),"complex64"===d.dtype||"complex64"===m.dtype)throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");var g=d.shape.length,r=m.shape.length;null==o&&(o=[g-1,r-2]);var i=o;return tidy(function(){var e,t;if(g>r){e=g-r;for(var a=[],f=0;f<e;++f)a.push(1);m=m.reshape(m.shape.concat(a))}else if(r>g){for(e=r-g,a=[],f=0;f<e;++f)a.push(1);d=d.reshape(d.shape.concat(a))}else e=0;if(2===d.shape.length&&2===m.shape.length)t=i[0]===i[1]?d.mulStrict(m).sum(i[0]):d.transpose([1,0]).mulStrict(m).sum(i[1]);else{var y=i[0]!==d.shape.length-1||null,u=i[1]===m.shape.length-1||null;t=d.matMul(m,y,u)}if(0<e){var c=[],h;for(f=h=g>r?g+r-3:g-1;f<h+e;++f)c.push(f);t=t.squeeze(c)}return 1===t.shape.length&&(t=t.expandDims(1)),t})}function batchNormalization$1(s,e,t,n,r,i){var p;if(void 0===i&&(i=.001),2===s.rank)p=batchNormalization2d(s,e,t,i,r,n);else if(3===s.rank)p=batchNormalization3d(s,e,t,i,r,n);else{if(4!==s.rank)throw new NotImplementedError("batchNormalization is not implemented for array of rank "+s.rank+" yet");p=batchNormalization4d(s,e,t,i,r,n)}return p}function regularNormalizeBatchInTraining(p,e,t,n,r){return void 0===r&&(r=.001),tidy(function(){var i=moments(p,n),a=i.mean,o=i.variance;return[batchNormalization$1(p,a,o,t,e,r),a,o]})}function broadcastNormalizeBatchInTraining(m,e,t,n,r){return void 0===r&&(r=.001),tidy(function(){for(var i=moments(m,n),a=i.mean,o=i.variance,s=[],l=0,y=range$1(0,m.rank),c;l<y.length;l++)c=y[l],-1===n.indexOf(c)?s.push(m.shape[c]):s.push(1);var b=a.reshape(s),h=o.reshape(s),d=null==e?null:e.reshape(s),f=null==t?null:t.reshape(s);return[batchNormalization$1(m,b,h,f,d,r),a,o]})}function normalizeBatchInTraining(a,e,t,n,r){return void 0===r&&(r=.001),util.arraysEqual(n.slice().sort(),range$1(0,a.rank-1))?regularNormalizeBatchInTraining(a,e,t,n,r):broadcastNormalizeBatchInTraining(a,e,t,n,r)}function spatial2dPadding(a,e,o){return tidy(function(){if(4!==a.rank)throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a "+a.rank+"-D tensor.");if(null==e&&(e=[[1,1],[1,1]]),2!==e.length||2!==e[0].length||2!==e[1].length)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==o&&(o=imageDataFormat()),"channelsLast"!==o&&"channelsFirst"!==o)throw new ValueError("Unknown data format: "+o+". Supported data formats are 'channelsLast' and 'channelsFirst.");var t;return t="channelsFirst"===o?[[0,0],[0,0],e[0],e[1]]:[[0,0],e[0],e[1],[0,0]],pad(a,t)})}function pool2d(p,l,t,d,u,c){return tidy(function(){var e;checkDataFormat(u),checkPoolMode(c),checkPaddingMode(d),null==t&&(t=[1,1]),null==d&&(d="valid"),null==u&&(u=imageDataFormat()),null==c&&(c="max"),p=preprocessConv2DInput(p,u);var a="same"===d?"same":"valid";return e="max"===c?maxPool(p,l,t,a):avgPool(p,l,t,a),"channelsFirst"===u&&(e=transpose(e,[0,3,1,2])),e})}function standardizeArgs(a,o,s,p){function r(t){return null==t||Array.isArray(t)?t:[t]}if(Array.isArray(a)){if(null!=o||null!=s)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");null!=p&&(s=a.slice(a.length-p,a.length),a=a.slice(0,a.length-p)),1<a.length&&(o=a.slice(1,a.length)),a=a[0]}return{inputs:a,initialState:o=r(o),constants:s=r(s)}}function rnn(m,e,y,n,b,i,a,x){void 0===n&&(n=!1),void 0===a&&(a=!1),void 0===x&&(x=!1);var N=e.shape.length;if(3>N)throw new ValueError("Input should be at least 3D, but is "+N+"D.");var l=[1,0].concat(range$1(2,N)),p,I;if(e=transpose(e,l),null!=b)throw new NotImplementedError("The rnn() function of the deeplearn.js backend does not support masking yet.");if(null!=i)throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),n&&(e=reverse(e,0));for(var v=y,S=e.shape[0],d=function(t){var n=sliceAlongFirstAxis(e,t,1);n=n.reshape(n.shape.slice(1));var o=tidy(function(){return m(n,v)});if(I=o[0],x)if(0===t)p=I.expandDims(1);else{var s=concat([p,I.expandDims(1)],1);p.dispose(),p=s}v=o[1]},f=0;f<S;++f)d(f);return[I,p,v]}function generateDropoutMask(s,e,t,p){function l(){return dropout(s(),getScalar(e))}if(void 0===t&&(t=null),void 0===p&&(p=1),1<p){for(var i=[],a=0;a<p;a++)i.push(inTrainPhase(l,s,t));return i.forEach(function(t){return keep(t)}),i}return keep(inTrainPhase(l,s,t))}function checkBidirectionalMergeMode(t){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",t)}function inputLayer(t){return new InputLayer(t)}function elu$2(t){return new ELU$1(t)}function reLU(t){return new ReLU(t)}function leakyReLU(t){return new LeakyReLU(t)}function softmax$1(t){return new Softmax$1(t)}function thresholdedReLU(t){return new ThresholdedReLU(t)}function conv1d$2(t){return new Conv1D(t)}function conv2d$2(t){return new Conv2D(t)}function conv2dTranspose$1(t){return new Conv2DTranspose(t)}function separableConv2d$1(t){return new SeparableConv2D(t)}function cropping2D(t){return new Cropping2D(t)}function upSampling2d(t){return new UpSampling2D(t)}function depthwiseConv2d$2(t){return new DepthwiseConv2D(t)}function activation(t){return new Activation$1(t)}function dense(t){return new Dense(t)}function dropout$1(t){return new Dropout(t)}function flatten$1$1(t){return new Flatten(t)}function repeatVector(t){return new RepeatVector(t)}function reshape$1(t){return new Reshape(t)}function permute(t){return new Permute(t)}function embedding(t){return new Embedding(t)}function add$2(t){return new Add(t)}function average$1(t){return new Average(t)}function concatenate$2(t){return new Concatenate(t)}function maximum$2(t){return new Maximum(t)}function minimum$2(t){return new Minimum(t)}function multiply$1(t){return new Multiply(t)}function dot$1$1(t){return new Dot(t)}function batchNormalization$1$1(t){return new BatchNormalization(t)}function zeroPadding2d(t){return new ZeroPadding2D(t)}function averagePooling1d(t){return new AveragePooling1D(t)}function avgPool1d(t){return averagePooling1d(t)}function avgPooling1d(t){return averagePooling1d(t)}function averagePooling2d(t){return new AveragePooling2D(t)}function avgPool2d(t){return averagePooling2d(t)}function avgPooling2d(t){return averagePooling2d(t)}function globalAveragePooling1d(t){return new GlobalAveragePooling1D(t)}function globalAveragePooling2d(t){return new GlobalAveragePooling2D(t)}function globalMaxPooling1d(t){return new GlobalMaxPooling1D(t)}function globalMaxPooling2d(t){return new GlobalMaxPooling2D(t)}function maxPooling1d(t){return new MaxPooling1D(t)}function maxPooling2d(t){return new MaxPooling2D(t)}function gru(t){return new GRU(t)}function gruCell(t){return new GRUCell(t)}function lstm(t){return new LSTM(t)}function lstmCell(t){return new LSTMCell(t)}function simpleRNN(t){return new SimpleRNN(t)}function simpleRNNCell(t){return new SimpleRNNCell(t)}function rnn$1(t){return new RNN(t)}function stackedRNNCells(t){return new StackedRNNCells(t)}function bidirectional(t){return new Bidirectional(t)}function timeDistributed(t){return new TimeDistributed(t)}function binaryAccuracy$1(a,e){return binaryAccuracy(a,e)}function binaryCrossentropy$2(a,e){return binaryCrossentropy$1(a,e)}function categoricalAccuracy$1(a,e){return categoricalAccuracy(a,e)}function categoricalCrossentropy$2(a,e){return categoricalCrossentropy$1(a,e)}function precision$1(a,e){return precision(a,e)}function recall$1(a,e){return recall(a,e)}function cosineProximity$1(a,e){return cosineProximity(a,e)}function meanAbsoluteError$1(a,e){return meanAbsoluteError(a,e)}function meanAbsolutePercentageError$1(a,e){return meanAbsolutePercentageError(a,e)}function MAPE$2(a,e){return meanAbsolutePercentageError(a,e)}function mape$2(a,e){return meanAbsolutePercentageError(a,e)}function meanSquaredError$1$1(a,e){return meanSquaredError$1(a,e)}function MSE$2(a,e){return meanSquaredError$1(a,e)}function mse$2(a,e){return meanSquaredError$1(a,e)}function l1l2(t){return new L1L2(t)}function l1$1(t){return l1(t)}function l2$1(t){return l2(t)}function __awaiter$2(l,e,t,d){return new(t||(t=Promise))(function(a,n){function r(t){try{s(d.next(t))}catch(t){n(t)}}function o(t){try{s(d.throw(t))}catch(t){n(t)}}function s(n){n.done?a(n.value):new t(function(e){e(n.value)}).then(r,o)}s((d=d.apply(l,e||[])).next())})}function __generator$2(p,e){function t(t){return function(a){return function(t){if(l)throw new TypeError("Generator is already executing.");for(;i;)try{if(l=1,d&&(u=d[2&t[0]?"return":t[0]?"throw":"next"])&&!(u=u.call(d,t[1])).done)return u;switch(d=0,u&&(t=[0,u.value]),t[0]){case 0:case 1:u=t;break;case 4:return i.label++,{value:t[1],done:!1};case 5:i.label++,d=t[1],t=[0];continue;case 7:t=i.ops.pop(),i.trys.pop();continue;default:if(!(u=0<(u=i.trys).length&&u[u.length-1])&&(6===t[0]||2===t[0])){i=0;continue}if(3===t[0]&&(!u||t[1]>u[0]&&t[1]<u[3])){i.label=t[1];break}if(6===t[0]&&i.label<u[1]){i.label=u[1],u=t;break}if(u&&i.label<u[2]){i.label=u[2],i.ops.push(t);break}u[2]&&i.ops.pop(),i.trys.pop();continue;}t=e.call(p,i)}catch(a){t=[6,a],d=0}finally{l=u=0}if(5&t[0])throw t[1];return{value:t[0]?t[1]:void 0,done:!0}}([t,a])}}var i={label:0,sent:function(){if(1&u[0])throw u[1];return u[1]},trys:[],ops:[]},l,d,u,c;return c={next:t(0),throw:t(1),return:t(2)},"function"==typeof Symbol&&(c[Symbol.iterator]=function(){return this}),c}function createCommonjsModule$1(a,e){return a(e={exports:{}},e.exports),e.exports}function asPromise(s,e){for(var t=Array(arguments.length-1),a=0,i=2,p=!0;i<arguments.length;)t[a++]=arguments[i++];return new Promise(function(r,n){t[a]=function(o){if(p)if(p=!1,o)n(o);else{for(var e=Array(arguments.length-1),t=0;t<e.length;)e[t++]=arguments[t];r.apply(null,e)}};try{s.apply(e||null,t)}catch(t){p&&(p=!1,n(t))}})}function EventEmitter(){this._listeners={}}function factory(p){var l=Math.LN2;return"undefined"==typeof Float32Array?function(){function e(s,e,i,a){var r=0>e?1:0;if(r&&(e=-e),0===e)s(0<1/e?0:2147483648,i,a);else if(isNaN(e))s(2143289344,i,a);else if(34028234663852886e22<e)s((2139095040|r<<31)>>>0,i,a);else if(11754943508222875e-54>e)s((r<<31|_Mathround(e/1401298464324817e-60))>>>0,i,a);else{var n=_Mathfloor(_Mathlog(e)/l);s((r<<31|n+127<<23|8388607&_Mathround(8388608*(e*_Mathpow(2,-n))))>>>0,i,a)}}function t(i,e,t){var a=i(e,t),r=2*(a>>31)+1,n=255&a>>>23,o=8388607&a;return 255==n?o?NaN:r*(1/0):0==n?1401298464324817e-60*r*o:r*_Mathpow(2,n-150)*(o+8388608)}p.writeFloatLE=e.bind(null,writeUintLE),p.writeFloatBE=e.bind(null,writeUintBE),p.readFloatLE=t.bind(null,readUintLE),p.readFloatBE=t.bind(null,readUintBE)}():function(){function e(a,e,r){i[0]=a,e[r]=t[0],e[r+1]=t[1],e[r+2]=t[2],e[r+3]=t[3]}function n(a,e,r){i[0]=a,e[r]=t[3],e[r+1]=t[2],e[r+2]=t[1],e[r+3]=t[0]}function o(a,e){return t[0]=a[e],t[1]=a[e+1],t[2]=a[e+2],t[3]=a[e+3],i[0]}function s(a,e){return t[3]=a[e],t[2]=a[e+1],t[1]=a[e+2],t[0]=a[e+3],i[0]}var i=new Float32Array([-0]),t=new Uint8Array(i.buffer),a=128===t[3];p.writeFloatLE=a?e:n,p.writeFloatBE=a?n:e,p.readFloatLE=a?o:s,p.readFloatBE=a?s:o}(),"undefined"==typeof Float64Array?function(){function e(d,e,t,a,u,n){var o=0>a?1:0;if(o&&(a=-a),0===a)d(0,u,n+e),d(0<1/a?0:2147483648,u,n+t);else if(isNaN(a))d(0,u,n+e),d(2146959360,u,n+t);else if(17976931348623157e292<a)d(0,u,n+e),d((2146435072|o<<31)>>>0,u,n+t);else{var s;if(22250738585072014e-324>a)d((s=a/5e-324)>>>0,u,n+e),d((o<<31|s/4294967296)>>>0,u,n+t);else{var c=_Mathfloor(_Mathlog(a)/l);1024===c&&(c=1023),d(4503599627370496*(s=a*_Mathpow(2,-c))>>>0,u,n+e),d((o<<31|c+1023<<20|1048575&1048576*s)>>>0,u,n+t)}}}function t(l,e,t,a,r){var n=l(a,r+e),o=l(a,r+t),s=2*(o>>31)+1,i=2047&o>>>20,p=4294967296*(1048575&o)+n;return 2047==i?p?NaN:s*(1/0):0==i?5e-324*s*p:s*_Mathpow(2,i-1075)*(p+4503599627370496)}p.writeDoubleLE=e.bind(null,writeUintLE,0,4),p.writeDoubleBE=e.bind(null,writeUintBE,4,0),p.readDoubleLE=t.bind(null,readUintLE,0,4),p.readDoubleBE=t.bind(null,readUintBE,4,0)}():function(){function e(a,e,r){i[0]=a,e[r]=t[0],e[r+1]=t[1],e[r+2]=t[2],e[r+3]=t[3],e[r+4]=t[4],e[r+5]=t[5],e[r+6]=t[6],e[r+7]=t[7]}function n(a,e,r){i[0]=a,e[r]=t[7],e[r+1]=t[6],e[r+2]=t[5],e[r+3]=t[4],e[r+4]=t[3],e[r+5]=t[2],e[r+6]=t[1],e[r+7]=t[0]}function o(a,e){return t[0]=a[e],t[1]=a[e+1],t[2]=a[e+2],t[3]=a[e+3],t[4]=a[e+4],t[5]=a[e+5],t[6]=a[e+6],t[7]=a[e+7],i[0]}function s(a,e){return t[7]=a[e],t[6]=a[e+1],t[5]=a[e+2],t[4]=a[e+3],t[3]=a[e+4],t[2]=a[e+5],t[1]=a[e+6],t[0]=a[e+7],i[0]}var i=new Float64Array([-0]),t=new Uint8Array(i.buffer),a=128===t[7];p.writeDoubleLE=a?e:n,p.writeDoubleBE=a?n:e,p.readDoubleLE=a?o:s,p.readDoubleBE=a?s:o}(),p}function writeUintLE(n,e,t){e[t]=255&n,e[t+1]=255&n>>>8,e[t+2]=255&n>>>16,e[t+3]=n>>>24}function writeUintBE(n,e,t){e[t]=n>>>24,e[t+1]=255&n>>>16,e[t+2]=255&n>>>8,e[t+3]=255&n}function readUintLE(a,e){return(a[e]|a[e+1]<<8|a[e+2]<<16|a[e+3]<<24)>>>0}function readUintBE(a,e){return(a[e]<<24|a[e+1]<<16|a[e+2]<<8|a[e+3])>>>0}function inquire(moduleName){try{var mod$$1=eval("quire".replace(/^/,"re"))(moduleName);if(mod$$1&&(mod$$1.length||Object.keys(mod$$1).length))return mod$$1}catch(t){}return null}function pool$1(n,e,t){var p=t||8192,r=null,l=p;return function(t){if(1>t||t>p>>>1)return n(t);l+t>p&&(r=n(p),l=0);var a=e.call(r,l,l+=t);return 7&l&&(l=1+(7|l)),a}}function LongBits(a,e){this.lo=a>>>0,this.hi=e>>>0}function Op(n,e,t){this.fn=n,this.len=e,this.next=void 0,this.val=t}function noop(){}function State(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function Writer(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}function writeByte(n,e,t){e[t]=255&n}function writeVarint32(n,r,t){for(;127<n;)r[t++]=128|127&n,n>>>=7;r[t]=n}function VarintOp(a,e){this.len=a,this.next=void 0,this.val=e}function writeVarint64(n,e,t){for(;n.hi;)e[t++]=128|127&n.lo,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;127<n.lo;)e[t++]=128|127&n.lo,n.lo>>>=7;e[t++]=n.lo}function writeFixed32(n,e,t){e[t]=255&n,e[t+1]=255&n>>>8,e[t+2]=255&n>>>16,e[t+3]=n>>>24}function BufferWriter$1(){writer.call(this)}function writeStringBuffer(n,e,t){40>n.length?minimal.utf8.write(n,e,t):e.utf8Write(n,t)}function indexOutOfRange(a,e){return RangeError("index out of range: "+a.pos+" + "+(e||1)+" > "+a.len)}function Reader(t){this.buf=t,this.pos=0,this.len=t.length}function readLongVarint(){var a=new LongBits$2(0,0),e=0;if(!(4<this.len-this.pos)){for(;3>e;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(a.lo=(a.lo|(127&this.buf[this.pos])<<7*e)>>>0,128>this.buf[this.pos++])return a}return a.lo=(a.lo|(127&this.buf[this.pos++])<<7*e)>>>0,a}for(;4>e;++e)if(a.lo=(a.lo|(127&this.buf[this.pos])<<7*e)>>>0,128>this.buf[this.pos++])return a;if(a.lo=(a.lo|(127&this.buf[this.pos])<<28)>>>0,a.hi=(a.hi|(127&this.buf[this.pos])>>4)>>>0,128>this.buf[this.pos++])return a;if(e=0,4<this.len-this.pos){for(;5>e;++e)if(a.hi=(a.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,128>this.buf[this.pos++])return a;}else for(;5>e;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(a.hi=(a.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,128>this.buf[this.pos++])return a}throw Error("invalid varint encoding")}function readFixed32_end(a,e){return(a[e-4]|a[e-3]<<8|a[e-2]<<16|a[e-1]<<24)>>>0}function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits$2(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}function BufferReader$1(t){reader.call(this,t)}function Service(n,e,t){if("function"!=typeof n)throw TypeError("rpcImpl must be a function");minimal.EventEmitter.call(this),this.rpcImpl=n,this.requestDelimited=!!e,this.responseDelimited=!!t}function getParamValue(s,e,t,a){var r=e.params[s];if(r&&void 0!==r.inputIndex){if("tensor"===r.type)return getTensor(e.inputNames[r.inputIndex],t,a);if("tensors"===r.type)return(0===r.inputIndex?0===r.inputParamLength?e.inputNames:e.inputNames.slice(r.inputIndex,-r.inputParamLength):e.inputNames.splice(r.inputIndex)).map(function(n){return getTensor(n,t,a)});var n=Array.prototype.slice.call(getTensor(e.inputNames.slice(r.inputIndex)[0],t,a).dataSync());return"number"===r.type?n[0]:n}return r&&r.value}function getTensor(i,p,e){var t=parseNodeName(i),a=t[0],n=t[1],r=e.currentContextIds.find(function(t){return!!p[getNodeNameWithContextId(a,t)]});return void 0===r?void 0:p[getNodeNameWithContextId(a,r)][n]}function getTensorsForCurrentContenxt(n,e,t){return e[getNodeNameWithContextId(n,t.currentContextId)]}function getNodeNameAndIndex(o,e){var t=parseNodeName(o),a=t[0],r=t[1];return[getNodeNameWithContextId(a,e&&e.currentContextId),r]}function getNodeNameWithContextId(a,e){return e?a+"-"+e:a}function parseNodeName(a){var e=a.lastIndexOf(":");return-1===e?[a,0]:[a.substring(0,e),+a.substring(e+1)]}function split$1$1(n,e){for(var t=[],a=0;a<n.length;a+=e)t.push(n.slice(a,a+e));return t}function executeOp$2(z,M,t){return __awaiter$2(this,void 0,void 0,function(){var e,a,F,B,U,W,G,q,H,K,X,Y,Z,Q,J,ee,te,ae,ne,re,oe,se,ie,pe,le,de,ue,ce,me,he,ge,fe,ye,be,xe;return __generator$2(this,function(n){switch(n.label){case 0:switch(z.op){case"loopCond":return[3,1];case"switch":return[3,2];case"merge":return[3,4];case"enter":return[3,5];case"exit":return[3,6];case"nextIteration":return[3,7];case"tensorArray":return[3,8];case"tensorArrayWrite":return[3,9];case"tensorArrayRead":return[3,10];case"tensorArrayGather":return[3,11];case"tensorArrayScatter":return[3,12];case"tensorArrayConcat":return[3,13];case"tensorArraySplit":return[3,14];case"tensorArraySize":return[3,15];case"tensorArrayClose":return[3,16];}return[3,17];case 1:return[2,[getParamValue("pred",z,M,t).clone()]];case 2:return e=getParamValue("pred",z,M,t),a=getParamValue("data",z,M,t),[4,e.data()];case 3:return[2,n.sent()[0]?[void 0,a.clone()]:[a.clone(),void 0]];case 4:return[2,(F=z.inputNames.find(function(a){return void 0!==getTensor(a,M,t)}))?[getTensor(F,M,t).clone()]:void 0];case 5:return B=getParamValue("frameName",z,M,t),U=getParamValue("tensor",z,M,t),t.enterFrame(B),[2,[U.clone()]];case 6:return W=getParamValue("tensor",z,M,t),t.exitFrame(),[2,[W.clone()]];case 7:return G=getParamValue("tensor",z,M,t),t.nextIteration(),[2,[G.clone()]];case 8:return q=getParamValue("size",z,M,t),H=getParamValue("dtype",z,M,t),K=getParamValue("elementShape",z,M,t),X=getParamValue("dynamicSize",z,M,t),Y=getParamValue("clearAfterRead",z,M,t),Z=getParamValue("identicalElementShapes",z,M,t),Q=getParamValue("name",z,M,t),J=new TensorArray(Q,H,q,K,Z,X,Y),t.addTensorArray(J),[2,[scalar(J.id),scalar(1)]];case 9:return ee=getParamValue("tensorArrayId",z,M,t),te=getParamValue("index",z,M,t),ae=getParamValue("tensor",z,M,t),t.getTensorArray(ee).write(te,ae),[2,[scalar(1)]];case 10:return ne=getParamValue("tensorArrayId",z,M,t),re=getParamValue("index",z,M,t),[2,[t.getTensorArray(ne).read(re)]];case 11:return oe=getParamValue("tensorArrayId",z,M,t),se=getParamValue("indices",z,M,t),ie=getParamValue("dtype",z,M,t),[2,[t.getTensorArray(oe).gather(se,ie)]];case 12:return pe=getParamValue("tensorArrayId",z,M,t),le=getParamValue("indices",z,M,t),de=getParamValue("tensor",z,M,t),t.getTensorArray(pe).scatter(le,de),[2,[scalar(1)]];case 13:return ue=getParamValue("tensorArrayId",z,M,t),ce=t.getTensorArray(ue),me=getParamValue("dtype",z,M,t),[2,[ce.concat(me)]];case 14:return he=getParamValue("tensorArrayId",z,M,t),ge=getParamValue("tensor",z,M,t),fe=getParamValue("lengths",z,M,t),t.getTensorArray(he).split(fe,ge),[2,[scalar(1)]];case 15:return ye=getParamValue("tensorArrayId",z,M,t),be=t.getTensorArray(ye),[2,[scalar(be.size(),"int32")]];case 16:return xe=getParamValue("tensorArrayId",z,M,t),t.getTensorArray(xe).clearAndClose(),[2,[]];case 17:throw TypeError("Node type "+z.op+" is not implemented");}})})}function executeOp$5(l,e,t){return __awaiter$2(this,void 0,void 0,function(){var a,d,u,c,m;return __generator$2(this,function(n){switch(n.label){case 0:switch(l.op){case"nonMaxSuppression":return[3,1];case"whereAsync":return[3,3];case"setdiff1dAsync":return[3,5];}return[3,7];case 1:return a=getParamValue("boxes",l,e,t),d=getParamValue("scores",l,e,t),u=getParamValue("maxOutputSize",l,e,t),c=getParamValue("iouThreshold",l,e,t),m=getParamValue("scoreThreshold",l,e,t),[4,image_ops.nonMaxSuppressionAsync(a,d,u,c,m)];case 2:return[2,[n.sent()]];case 3:return[4,whereAsync(getParamValue("condition",l,e,t))];case 4:return[2,[n.sent()]];case 5:return[4,setdiff1dAsync(getParamValue("x",l,e,t),getParamValue("y",l,e,t))];case 6:return[2,n.sent()];case 7:throw TypeError("Node type "+l.op+" is not implemented");}})})}function executeOp$15(n,e,t){switch(n.category){case"arithmetic":return executeOp(n,e,t);case"basic_math":return executeOp$1(n,e,t);case"control":return executeOp$2(n,e,t);case"convolution":return executeOp$3(n,e,t);case"creation":return executeOp$4(n,e,t);case"dynamic":return executeOp$5(n,e,t);case"evaluation":return executeOp$6(n,e,t);case"image":return executeOp$8(n,e,t);case"graph":return executeOp$7(n,e,t);case"logical":return executeOp$9(n,e,t);case"matrices":return executeOp$10(n,e,t);case"normalization":return executeOp$11(n,e,t);case"reduction":return executeOp$12(n,e,t);case"slice_join":return executeOp$13(n,e,t);case"transformation":return executeOp$14(n,e,t);default:throw TypeError("Node type "+n.op+" is not implemented");}}function loadFrozenModel(o,e,t){return __awaiter$2(this,void 0,void 0,function(){var a;return __generator$2(this,function(r){switch(r.label){case 0:return[4,(a=new FrozenModel(o,e,t)).load()];case 1:return r.sent(),[2,a];}})})}// @tensorflow/tfjs Copyright 2018 Google
/**
   * @license
   * Copyright 2019 Victor Dibia.
   * Handtrack.js - A library for prototyping realtime hand tracking using neural networks.
   * Licensed under the MIT License (the "License"); 
   * Code snippets from the tensorflow coco-ssd example are reused here - https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd
   * =============================================================================
   */async function load(e){let t=Object.assign({},defaultParams,e);// console.log(modelParams) 
const a=new ObjectDetection(t);return await a.load(),a}function startVideo(e){return e.width=e.width||640,e.height=e.height||e.width*(3/4),new Promise(function(t){navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}}).then(a=>{window.localStream=a,e.srcObject=a,e.onloadedmetadata=()=>{e.play(),t(!0)}}).catch(function(){t(!1)})})}async function stopVideo(){return!!window.localStream&&void window.localStream.getTracks().forEach(e=>(e.stop(),!0))}function getValidResolution(e,t,a){const n=t*e-1;return n-n%a+1}function getInputTensorDimensions(e){return e instanceof Tensor?[e.shape[0],e.shape[1]]:[e.height,e.width]}function calculateMaxScores(e,t,a){const n=[],r=[];for(let o=0;o<t;o++){let t=Number.MIN_VALUE,s=-1;for(let n=0;n<a;n++)e[o*a+n]>t&&(t=e[o*a+n],s=n);n[o]=t,r[o]=s}// console.log([maxes, classes])
return[n,r]}var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(a,e){a.__proto__=e}||function(a,e){for(var t in e)e.hasOwnProperty(t)&&(a[t]=e[t])},__assign=Object.assign||function(a){for(var e=1,s=arguments.length,n;e<s;e++)for(var i in n=arguments[e])Object.prototype.hasOwnProperty.call(n,i)&&(a[i]=n[i]);return a},contexts={},WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0},util=Object.freeze({shuffle:shuffle,clamp:clamp,nearestLargerEven:nearestLargerEven,sum:sum,randUniform:randUniform,distSquared:distSquared,assert:assert,assertShapesMatch:assertShapesMatch,assertNonNull:assertNonNull,flatten:flatten,sizeFromShape:sizeFromShape,isScalarShape:isScalarShape,arraysEqual:arraysEqual,isInt:isInt,tanh:tanh,sizeToSquarishShape:sizeToSquarishShape,createShuffledIndices:createShuffledIndices,rightPad:rightPad,repeatedTry:repeatedTry,inferFromImplicitShape:inferFromImplicitShape,squeezeShape:squeezeShape,getTypedArrayFromDType:getTypedArrayFromDType,checkComputationForNaN:checkComputationForNaN,checkConversionForNaN:checkConversionForNaN,hasEncodingLoss:hasEncodingLoss,isTypedArray:isTypedArray,bytesPerElement:bytesPerElement,isFunction:isFunction,nearestDivisor:nearestDivisor,computeStrides:computeStrides,toTypedArray:toTypedArray,makeOnesTypedArray:makeOnesTypedArray,makeZerosTypedArray:makeZerosTypedArray,now:now}),Profiler=function(){function t(a,e){this.backendTimer=a,this.logger=e,null==e&&(this.logger=new Logger)}return t.prototype.profileKernel=function(s,e){var i=this,a=this.backendTimer.time(function(){t=e()}),t;return(Array.isArray(t)?t:[t]).forEach(function(e){var t=e.dataSync();checkComputationForNaN(t,e.dtype,s),a.then(function(n){var r="";null!=n.getExtraProfileInfo&&(r=n.getExtraProfileInfo()),i.logger.logKernelProfile(s,e,t,n.kernelMs,r)})}),t},t}(),Logger=function(){function t(){}return t.prototype.logKernelProfile=function(p,e,t,r,n){var o=rightPad(r+"ms",9),a=rightPad(p,25),i=e.rank,s=e.size,d=rightPad(e.shape.toString(),14);console.log("%c"+a+"\t%c"+o+"\t%c"+i+"D "+d+"\t%c"+s+"\t%c"+n,"font-weight:bold","color:red","color:blue","color: orange","color: green")},t}(),FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7,TensorBuffer=function(){function t(a,e,t){if(this.dtype=e,this.shape=a.slice(),this.size=sizeFromShape(a),null!=t){var r=t.length;assert(r===this.size,"Length of values '"+r+"' does not match the size inferred by the shape '"+this.size+"'.")}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=t||getTypedArrayFromDType(e,sizeFromShape(this.shape)),this.strides=computeStrides(a)}return t.prototype.set=function(a){for(var e=[],o=1;o<arguments.length;o++)e[o-1]=arguments[o];0===e.length&&(e=[0]),assert(e.length===this.rank,"The number of provided coordinates ("+e.length+") must match the rank ("+this.rank+")");var s=this.locToIndex(e);this.values[s]=a},t.prototype.get=function(){for(var a=[],o=0;o<arguments.length;o++)a[o]=arguments[o];0===a.length&&(a=[0]);for(var s=a[a.length-1],i=0;i<a.length-1;++i)s+=this.strides[i]*a[i];return this.values[s]},t.prototype.locToIndex=function(a){if(0===this.rank)return 0;if(1===this.rank)return a[0];for(var e=a[a.length-1],n=0;n<a.length-1;++n)e+=this.strides[n]*a[n];return e},t.prototype.indexToLoc=function(a){if(0===this.rank)return[];if(1===this.rank)return[a];for(var n=Array(this.shape.length),t=0;t<n.length-1;++t)n[t]=_Mathfloor(a/this.strides[t]),a-=n[t]*this.strides[t];return n[n.length-1]=a,n},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return Tensor.make(this.shape,{values:this.values},this.dtype)},t}(),trackerFn=null,opHandler=null,Tensor=function(){function a(a,e,t,r){this.isDisposedInternal=!1,this.shape=a.slice(),this.dtype=e||"float32",this.size=sizeFromShape(a),null!=t&&assert(this.size===t.length,"Based on the provided shape, ["+a+"], and dtype "+this.dtype+", the tensor should have "+this.size+" values but has "+t.length),this.strides=computeStrides(a),this.dataId=null==r?{}:r,this.id=trackerFn().nextTensorId(),this.rankType=5>this.rank?this.rank.toString():"higher",trackerFn().registerTensor(this),null!=t&&trackerFn().write(this.dataId,t)}return a.make=function(e,t,r){return new a(e,r,t.values,t.dataId)},a.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},a.prototype.asScalar=function(){return this.throwIfDisposed(),assert(1===this.size,"The array must have only 1 element."),this.reshape([])},a.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},a.prototype.as2D=function(a,e){return this.throwIfDisposed(),this.reshape([a,e])},a.prototype.as3D=function(a,e,t){return this.throwIfDisposed(),this.reshape([a,e,t])},a.prototype.as4D=function(a,e,t,r){return this.throwIfDisposed(),this.reshape([a,e,t,r])},a.prototype.asType=function(t){return this.throwIfDisposed(),opHandler.cast(this,t)},Object.defineProperty(a.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),a.prototype.get=function(){for(var a=[],o=0;o<arguments.length;o++)a[o]=arguments[o];assert(a.length===this.rank,"Number of coordinates in get() must match the rank of the tensor"),assert("complex64"!==this.dtype,"Tensor.get() is not supported for complex64 tensors yet."),this.throwIfDisposed(),0===a.length&&(a=[0]);for(var s=a[a.length-1],i=0;i<a.length-1;++i)s+=this.strides[i]*a[i];return this.dataSync()[s]},a.prototype.buffer=function(){return opHandler.buffer(this.shape,this.dtype,this.dataSync())},a.prototype.data=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(){return this.throwIfDisposed(),[2,trackerFn().read(this.dataId)]})})},a.prototype.dataSync=function(){return this.throwIfDisposed(),trackerFn().readSync(this.dataId)},a.prototype.dispose=function(){this.isDisposed||(trackerFn().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(a.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),a.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},a.prototype.toFloat=function(){return this.asType("float32")},a.prototype.toInt=function(){return this.asType("int32")},a.prototype.toBool=function(){return this.asType("bool")},a.prototype.print=function(t){return void 0===t&&(t=!1),opHandler.print(this,t)},a.prototype.reshape=function(t){return this.throwIfDisposed(),opHandler.reshape(this,t)},a.prototype.reshapeAs=function(t){return this.throwIfDisposed(),this.reshape(t.shape)},a.prototype.expandDims=function(t){return void 0===t&&(t=0),opHandler.expandDims(this,t)},a.prototype.cumsum=function(a,n,o){return void 0===a&&(a=0),void 0===n&&(n=!1),void 0===o&&(o=!1),opHandler.cumsum(this,a,n,o)},a.prototype.squeeze=function(t){return this.throwIfDisposed(),opHandler.squeeze(this,t)},a.prototype.clone=function(){return this.throwIfDisposed(),opHandler.clone(this)},a.prototype.toString=function(t){return void 0===t&&(t=!1),tensorToString(this.dataSync(),this.shape,this.dtype,t)},a.prototype.tile=function(t){return this.throwIfDisposed(),opHandler.tile(this,t)},a.prototype.gather=function(a,e){return void 0===e&&(e=0),this.throwIfDisposed(),opHandler.gather(this,a,e)},a.prototype.matMul=function(a,e,n){return void 0===e&&(e=!1),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.matMul(this,a,e,n)},a.prototype.dot=function(t){return this.throwIfDisposed(),opHandler.dot(this,t)},a.prototype.norm=function(a,n,o){return void 0===a&&(a="euclidean"),void 0===n&&(n=null),void 0===o&&(o=!1),this.throwIfDisposed(),opHandler.norm(this,a,n,o)},a.prototype.slice=function(a,e){return this.throwIfDisposed(),opHandler.slice(this,a,e)},a.prototype.reverse=function(t){return this.throwIfDisposed(),opHandler.reverse(this,t)},a.prototype.concat=function(a,e){return void 0===e&&(e=0),this.throwIfDisposed(),opHandler.concat([this,a],e)},a.prototype.split=function(a,e){return void 0===e&&(e=0),this.throwIfDisposed(),opHandler.split(this,a,e)},a.prototype.stack=function(a,e){return void 0===e&&(e=0),opHandler.stack([this,a],e)},a.prototype.unstack=function(a,e){return void 0===e&&(e=0),opHandler.unstack(this,e)},a.prototype.pad=function(a,e){return void 0===e&&(e=0),opHandler.pad(this,a,e)},a.prototype.batchNormalization=function(a,e,t,s,n){return void 0===t&&(t=.001),this.throwIfDisposed(),opHandler.batchNormalization(this,a,e,t,s,n)},a.prototype.all=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.all(this,a,n)},a.prototype.any=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.any(this,a,n)},a.prototype.logSumExp=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.logSumExp(this,a,n)},a.prototype.sum=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.sum(this,a,n)},a.prototype.prod=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.prod(this,a,n)},a.prototype.mean=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.mean(this,a,n)},a.prototype.min=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.min(this,a,n)},a.prototype.max=function(a,n){return void 0===a&&(a=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.max(this,a,n)},a.prototype.argMin=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),opHandler.argMin(this,t)},a.prototype.argMax=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),opHandler.argMax(this,t)},a.prototype.cast=function(t){return this.throwIfDisposed(),opHandler.cast(this,t)},a.prototype.add=function(t){return this.throwIfDisposed(),opHandler.add(this,t)},a.prototype.addStrict=function(t){return this.throwIfDisposed(),opHandler.addStrict(this,t)},a.prototype.atan2=function(t){return this.throwIfDisposed(),opHandler.atan2(this,t)},a.prototype.sub=function(t){return this.throwIfDisposed(),opHandler.sub(this,t)},a.prototype.subStrict=function(t){return this.throwIfDisposed(),opHandler.subStrict(this,t)},a.prototype.pow=function(t){return this.throwIfDisposed(),opHandler.pow(this,t)},a.prototype.powStrict=function(t){return this.throwIfDisposed(),opHandler.powStrict(this,t)},a.prototype.mul=function(t){return this.throwIfDisposed(),opHandler.mul(this,t)},a.prototype.mulStrict=function(t){return this.throwIfDisposed(),opHandler.mulStrict(this,t)},a.prototype.div=function(t){return this.throwIfDisposed(),opHandler.div(this,t)},a.prototype.floorDiv=function(t){return this.throwIfDisposed(),opHandler.floorDiv(this,t)},a.prototype.divStrict=function(t){return this.throwIfDisposed(),opHandler.divStrict(this,t)},a.prototype.minimum=function(t){return this.throwIfDisposed(),opHandler.minimum(this,t)},a.prototype.minimumStrict=function(t){return this.throwIfDisposed(),opHandler.minimumStrict(this,t)},a.prototype.maximum=function(t){return this.throwIfDisposed(),opHandler.maximum(this,t)},a.prototype.maximumStrict=function(t){return this.throwIfDisposed(),opHandler.maximumStrict(this,t)},a.prototype.mod=function(t){return this.throwIfDisposed(),opHandler.mod(this,t)},a.prototype.modStrict=function(t){return this.throwIfDisposed(),opHandler.modStrict(this,t)},a.prototype.squaredDifference=function(t){return this.throwIfDisposed(),opHandler.squaredDifference(this,t)},a.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),opHandler.squaredDifferenceStrict(this,t)},a.prototype.transpose=function(t){return this.throwIfDisposed(),opHandler.transpose(this,t)},a.prototype.notEqual=function(t){return this.throwIfDisposed(),opHandler.notEqual(this,t)},a.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),opHandler.notEqualStrict(this,t)},a.prototype.less=function(t){return this.throwIfDisposed(),opHandler.less(this,t)},a.prototype.lessStrict=function(t){return this.throwIfDisposed(),opHandler.lessStrict(this,t)},a.prototype.equal=function(t){return this.throwIfDisposed(),opHandler.equal(this,t)},a.prototype.equalStrict=function(t){return this.throwIfDisposed(),opHandler.equalStrict(this,t)},a.prototype.lessEqual=function(t){return this.throwIfDisposed(),opHandler.lessEqual(this,t)},a.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),opHandler.lessEqualStrict(this,t)},a.prototype.greater=function(t){return this.throwIfDisposed(),opHandler.greater(this,t)},a.prototype.greaterStrict=function(t){return this.throwIfDisposed(),opHandler.greaterStrict(this,t)},a.prototype.greaterEqual=function(t){return this.throwIfDisposed(),opHandler.greaterEqual(this,t)},a.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),opHandler.greaterEqualStrict(this,t)},a.prototype.logicalAnd=function(t){return this.throwIfDisposed(),opHandler.logicalAnd(this,t)},a.prototype.logicalOr=function(t){return this.throwIfDisposed(),opHandler.logicalOr(this,t)},a.prototype.logicalNot=function(){return this.throwIfDisposed(),opHandler.logicalNot(this)},a.prototype.logicalXor=function(t){return this.throwIfDisposed(),opHandler.logicalXor(this,t)},a.prototype.where=function(a,e){return this.throwIfDisposed(),opHandler.where(a,this,e)},a.prototype.neg=function(){return this.throwIfDisposed(),opHandler.neg(this)},a.prototype.ceil=function(){return this.throwIfDisposed(),opHandler.ceil(this)},a.prototype.floor=function(){return this.throwIfDisposed(),opHandler.floor(this)},a.prototype.sign=function(){return this.throwIfDisposed(),opHandler.sign(this)},a.prototype.exp=function(){return this.throwIfDisposed(),opHandler.exp(this)},a.prototype.expm1=function(){return this.throwIfDisposed(),opHandler.expm1(this)},a.prototype.log=function(){return this.throwIfDisposed(),opHandler.log(this)},a.prototype.log1p=function(){return this.throwIfDisposed(),opHandler.log1p(this)},a.prototype.sqrt=function(){return this.throwIfDisposed(),opHandler.sqrt(this)},a.prototype.rsqrt=function(){return this.throwIfDisposed(),opHandler.rsqrt(this)},a.prototype.square=function(){return this.throwIfDisposed(),opHandler.square(this)},a.prototype.reciprocal=function(){return this.throwIfDisposed(),opHandler.reciprocal(this)},a.prototype.abs=function(){return this.throwIfDisposed(),opHandler.abs(this)},a.prototype.clipByValue=function(a,e){return this.throwIfDisposed(),opHandler.clipByValue(this,a,e)},a.prototype.relu=function(){return this.throwIfDisposed(),opHandler.relu(this)},a.prototype.elu=function(){return this.throwIfDisposed(),opHandler.elu(this)},a.prototype.selu=function(){return this.throwIfDisposed(),opHandler.selu(this)},a.prototype.leakyRelu=function(t){return void 0===t&&(t=.2),this.throwIfDisposed(),opHandler.leakyRelu(this,t)},a.prototype.prelu=function(t){return this.throwIfDisposed(),opHandler.prelu(this,t)},a.prototype.sigmoid=function(){return this.throwIfDisposed(),opHandler.sigmoid(this)},a.prototype.logSigmoid=function(){return this.throwIfDisposed(),opHandler.logSigmoid(this)},a.prototype.softplus=function(){return this.throwIfDisposed(),opHandler.softplus(this)},a.prototype.zerosLike=function(){return this.throwIfDisposed(),opHandler.zerosLike(this)},a.prototype.onesLike=function(){return this.throwIfDisposed(),opHandler.onesLike(this)},a.prototype.sin=function(){return this.throwIfDisposed(),opHandler.sin(this)},a.prototype.cos=function(){return this.throwIfDisposed(),opHandler.cos(this)},a.prototype.tan=function(){return this.throwIfDisposed(),opHandler.tan(this)},a.prototype.asin=function(){return this.throwIfDisposed(),opHandler.asin(this)},a.prototype.acos=function(){return this.throwIfDisposed(),opHandler.acos(this)},a.prototype.atan=function(){return this.throwIfDisposed(),opHandler.atan(this)},a.prototype.sinh=function(){return this.throwIfDisposed(),opHandler.sinh(this)},a.prototype.cosh=function(){return this.throwIfDisposed(),opHandler.cosh(this)},a.prototype.tanh=function(){return this.throwIfDisposed(),opHandler.tanh(this)},a.prototype.asinh=function(){return this.throwIfDisposed(),opHandler.asinh(this)},a.prototype.acosh=function(){return this.throwIfDisposed(),opHandler.acosh(this)},a.prototype.atanh=function(){return this.throwIfDisposed(),opHandler.atanh(this)},a.prototype.erf=function(){return this.throwIfDisposed(),opHandler.erf(this)},a.prototype.round=function(){return this.throwIfDisposed(),opHandler.round(this)},a.prototype.step=function(t){return void 0===t&&(t=0),this.throwIfDisposed(),opHandler.step(this,t)},a.prototype.softmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),opHandler.softmax(this,t)},a.prototype.logSoftmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),opHandler.logSoftmax(this,t)},a.prototype.resizeBilinear=function(a,e){return void 0===e&&(e=!1),this.throwIfDisposed(),opHandler.image.resizeBilinear(this,a,e)},a.prototype.resizeNearestNeighbor=function(a,e){return void 0===e&&(e=!1),this.throwIfDisposed(),opHandler.image.resizeNearestNeighbor(this,a,e)},a.prototype.conv1d=function(s,e,t,r,i,p){return void 0===r&&(r="NWC"),void 0===i&&(i=1),this.throwIfDisposed(),opHandler.conv1d(this,s,e,t,r,i,p)},a.prototype.conv2d=function(s,e,t,r,i,p){return void 0===r&&(r="NHWC"),void 0===i&&(i=[1,1]),this.throwIfDisposed(),opHandler.conv2d(this,s,e,t,r,i,p)},a.prototype.conv2dTranspose=function(a,e,t,r,n){return this.throwIfDisposed(),opHandler.conv2dTranspose(this,a,e,t,r,n)},a.prototype.depthwiseConv2D=function(s,e,t,r,i,p){return void 0===r&&(r="NHWC"),void 0===i&&(i=[1,1]),this.throwIfDisposed(),opHandler.depthwiseConv2d(this,s,e,t,r,i,p)},a.prototype.separableConv2d=function(s,e,t,r,n,i){return void 0===n&&(n=[1,1]),void 0===i&&(i="NHWC"),this.throwIfDisposed(),opHandler.separableConv2d(this,s,e,t,r,n,i)},a.prototype.avgPool=function(a,e,t,r){return this.throwIfDisposed(),opHandler.avgPool(this,a,e,t,r)},a.prototype.maxPool=function(a,e,t,r){return this.throwIfDisposed(),opHandler.maxPool(this,a,e,t,r)},a.prototype.localResponseNormalization=function(a,o,s,i){return void 0===a&&(a=5),void 0===o&&(o=1),void 0===s&&(s=1),void 0===i&&(i=.5),opHandler.localResponseNormalization(this,a,o,s,i)},a.prototype.pool=function(a,e,t,r,n){return this.throwIfDisposed(),opHandler.pool(this,a,e,t,r,n)},a.prototype.variable=function(a,n,t){return void 0===a&&(a=!0),this.throwIfDisposed(),Variable.variable(this,a,n,t)},a.prototype.unsortedSegmentSum=function(a,e){return this.throwIfDisposed(),opHandler.unsortedSegmentSum(this,a,e)},a.prototype.batchToSpaceND=function(a,e){return this.throwIfDisposed(),opHandler.batchToSpaceND(this,a,e)},a.prototype.spaceToBatchND=function(a,e){return this.throwIfDisposed(),opHandler.spaceToBatchND(this,a,e)},a.prototype.topk=function(a,n){return void 0===a&&(a=1),void 0===n&&(n=!0),this.throwIfDisposed(),opHandler.topk(this,a,n)},a.prototype.stridedSlice=function(a,e,t,r,s){return void 0===r&&(r=0),void 0===s&&(s=0),this.throwIfDisposed(),opHandler.stridedSlice(this,a,e,t,r,s)},a.prototype.depthToSpace=function(a,e){return this.throwIfDisposed(),opHandler.depthToSpace(this,a,e)},a.prototype.fft=function(){return this.throwIfDisposed(),opHandler.spectral.fft(this)},a.prototype.ifft=function(){return this.throwIfDisposed(),opHandler.spectral.ifft(this)},a}();Object.defineProperty(Tensor,Symbol.hasInstance,{value:function(t){return!!t&&null!=t.shape&&null!=t.dtype}});var Variable=function(a){function s(e,t,s){void 0===t&&(t=!0);var n=a.call(this,e.shape,e.dtype,null,e.dataId)||this;n.trainable=t,n.name=s,null==n.name&&(n.name=trackerFn().nextVariableId().toString());try{trackerFn().registerVariable(n)}catch(t){throw trackerFn().disposeTensor(n),t}return n}return __extends(s,a),s.variable=function(t,a,i,n){return void 0===a&&(a=!0),null!=n&&n!==t.dtype&&(t=t.asType(n)),new s(t,a,i)},s.prototype.assign=function(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value ("+t.dtype+") and previous value ("+this.dtype+") must match");if(!arraysEqual(t.shape,this.shape))throw new Error("shape of the new value ("+t.shape+") and previous value ("+this.shape+") must match");trackerFn().disposeTensor(this),this.dataId=t.dataId,trackerFn().registerTensor(this)},s}(Tensor);Object.defineProperty(Variable,Symbol.hasInstance,{value:function(t){return t instanceof Tensor&&null!=t.assign&&t.assign instanceof Function}});var variable=Variable.variable,Engine=function(){function t(a,e,t){this.backend=a,this.safeMode=e,this.debugMode=t,this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numDataBuffers=0,this.profiling=!1,this.gradientScopeCount=0,this.customGradientDepth=0,this.keepTensors=new Set,this.tensorInfo=new WeakMap,this.activeScope={track:[],name:"default scope"},this.scopeStack=[this.activeScope],this.profiler=new Profiler(a),this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.moveData=function(t){this.write(t,this.readSync(t))},t.prototype.tidy=function(s,e,i){var p=this;void 0===i&&(i=!1);var n=null,l;if(null==e){if("function"!=typeof s)throw new Error("Please provide a function to tidy()");e=s}else{if("string"!=typeof s&&!(s instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=s}return this.scopedRun(function(){return p.startScope(n,i)},function(){return p.endScope(l,i)},function(){return(l=e())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),l})},t.prototype.scopedRun=function(a,o,e){a();try{var t=e();return o(),t}catch(t){throw o(),t}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.runKernel=function(p,d,t){var e=this,r=[],a=function(t){return r.push(t),t},o=this.activeScope.name,s=this.numBytes,i=this.numTensors,l;if(this.scopedRun(function(){return e.customGradientDepth++},function(){return e.customGradientDepth--},function(){l=e.debugMode()?e.profiler.profileKernel(o,function(){return p(e.backend,a)}):p(e.backend,a)}),this.shouldRecord()){var u={id:this.nextTapeNodeId++,name:o,inputs:d,outputs:Array.isArray(l)?l:[l]};null!=t&&(u.gradient=function(a){return t(a,r)}),this.activeTape.push(u)}return this.profiling&&this.activeProfile.kernels.push({name:o,bytesAdded:this.numBytes-s,totalBytesSnapshot:this.numBytes,tensorsAdded:this.numTensors-i,totalTensorsSnapshot:this.numTensors,inputShapes:Object.keys(d).map(function(t){return d[t].shape}),outputShape:Array.isArray(l)?l.map(function(t){return t.shape}):l.shape}),l},t.prototype.registerTensor=function(a){var e=this.tensorInfo.has(a.dataId)?this.tensorInfo.get(a.dataId).refCount:0;this.numTensors++,0===e&&(this.numDataBuffers++,"complex64"!==a.dtype&&(this.numBytes+=sizeFromShape(a.shape)*bytesPerElement(a.dtype)),this.tensorInfo.set(a.dataId,{backend:this.backend,dtype:a.dtype,shape:a.shape,refCount:0}),this.backend.register(a.dataId,a.shape,a.dtype)),this.tensorInfo.get(a.dataId).refCount++,a instanceof Variable||this.track(a)},t.prototype.registerVariable=function(t){if(null!=this.registeredVariables[t.name])throw new Error("Variable with name "+t.name+" was already registered");this.registeredVariables[t.name]=t},t.prototype.disposeTensor=function(t){this.tensorInfo.has(t.dataId)&&(this.keepTensors.has(t.id)&&this.keepTensors.delete(t.id),this.numTensors--,1>=this.tensorInfo.get(t.dataId).refCount?(this.tensorInfo.get(t.dataId).backend.disposeData(t.dataId),this.numDataBuffers--,"complex64"!==t.dtype&&(this.numBytes-=sizeFromShape(t.shape)*bytesPerElement(t.dtype)),this.tensorInfo.delete(t.dataId)):this.tensorInfo.get(t.dataId).refCount--)},t.prototype.disposeVariables=function(){for(var a in this.registeredVariables){var e=this.registeredVariables[a];this.disposeTensor(e),delete this.registeredVariables[a]}},t.prototype.memory=function(){var t=this.backend.memory();return t.numTensors=this.numTensors,t.numDataBuffers=this.numDataBuffers,t.numBytes=this.numBytes,t},t.prototype.profile=function(a){return __awaiter(this,void 0,void 0,function(){var e,n;return __generator(this,function(){return this.profiling=!0,e=this.numBytes,n=this.numTensors,this.activeProfile.kernels=[],this.activeProfile.result=a(),this.profiling=!1,this.activeProfile.peakBytes=_Mathmax.apply(Math,this.activeProfile.kernels.map(function(t){return t.totalBytesSnapshot})),this.activeProfile.newBytes=this.numBytes-e,this.activeProfile.newTensors=this.numTensors-n,[2,this.activeProfile]})})},t.prototype.shouldRecord=function(){return null!=this.activeTape&&0===this.customGradientDepth},t.prototype.addTapeNode=function(a,e,s){var r={};a.forEach(function(a,e){r[e]=a});var t={id:this.nextTapeNodeId++,name:this.activeScope.name,inputs:r,outputs:[e],gradient:function(a){var n={};return s(a).forEach(function(t,e){n[e]=function(){return t}}),n}};this.activeTape.push(t)},t.prototype.keep=function(t){if(1===this.scopeStack.length&&this.safeMode)throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {...}) to avoid memory leaks.");return this.keepTensors.add(t.id),t},t.prototype.startScope=function(a,e){void 0===e&&(e=!1),e&&0===this.gradientScopeCount&&(this.activeTape=[]),e&&this.gradientScopeCount++;var n={track:[],name:"unnamed scope"};a&&(n.name=a),this.scopeStack.push(n),this.activeScope=n},t.prototype.endScope=function(p,e){var l=this;void 0===e&&(e=!1),e&&(this.gradientScopeCount--,0===this.gradientScopeCount&&(this.activeTape=null));var r=new Set(this.keepTensors),n=getTensorsInContainer(p);n.forEach(function(t){return r.add(t.id)});for(var o=0,d;o<this.activeScope.track.length;o++)d=this.activeScope.track[o],r.has(d.id)||(null==this.activeTape?d.dispose():n.push(d));var u=this.scopeStack.pop();this.activeScope=0===this.scopeStack.length?{track:[],name:"default scope"}:this.scopeStack[this.scopeStack.length-1],n.forEach(function(t){!l.keepTensors.has(t.id)&&isTensorInList(t,u.track)&&l.track(t)})},t.prototype.gradients=function(p,e,t,r){var l=this;return void 0===r&&(r=!1),assert(0<e.length,"gradients() received an empty list of xs."),this.tidy("gradients",function(){var n=p();assert(n instanceof Tensor,"The result y returned by f() must be a tensor.");var a=getFilteredNodesXToY(l.activeTape,e,n);if(!r&&0===a.length&&0<e.length)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");var o={};return o[n.id]=null==t?ones(n.shape):t,backpropagateGradients(o,a),{value:n,grads:e.map(function(t){return o[t.id]})}},!0)},t.prototype.customGrad=function(r){var e=this;return assert(isFunction(r),"The f passed in customGrad(f) must be a function."),function(){for(var s=[],t=0,o,i;t<arguments.length;t++)s[t]=arguments[t];return(assert(s.every(function(t){return t instanceof Tensor}),"The args passed in customGrad(f)(x1, x2,...) must all be tensors"),e.scopedRun(function(){return e.customGradientDepth++},function(){return e.customGradientDepth--},function(){i=e.tidy(r.name,function(){var e=r.apply(void 0,s),t=e.value,n=e.gradFunc;return assert(t instanceof Tensor,"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),assert(isFunction(n),"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o=n,t},!0)}),e.shouldRecord())&&e.addTapeNode(s,i,function(a){var e=o(a),t=Array.isArray(e)?e:[e];return assert(t.length===s.length,"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),assert(t.every(function(t){return t instanceof Tensor}),"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."),t}),i}},t.prototype.write=function(a,e){var t=this.tensorInfo.get(a);this.backend!==t.backend&&(t.backend.disposeData(a),t.backend=this.backend,this.backend.register(a,t.shape,t.dtype)),this.backend.write(a,e)},t.prototype.readSync=function(t){return this.tensorInfo.get(t).backend.readSync(t)},t.prototype.read=function(t){return this.tensorInfo.get(t).backend.read(t)},t.prototype.fromPixels=function(a,e){return this.backend.fromPixels(a,e)},t.prototype.time=function(a){return __awaiter(this,void 0,void 0,function(){var e,o;return __generator(this,function(t){switch(t.label){case 0:return e=now(),[4,this.backend.time(a)];case 1:return(o=t.sent()).wallMs=now()-e,[2,o];}})})},t.prototype.track=function(t){if(1===this.scopeStack.length&&this.safeMode)throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {op();...}); to avoid memory leaks.");return this.activeScope.track.push(t),t},t.nextTensorId=0,t.nextVariableId=0,t}(),Type;!function(t){t[t.NUMBER=0]="NUMBER",t[t.BOOLEAN=1]="BOOLEAN",t[t.STRING=2]="STRING"}(Type||(Type={}));var URL_PROPERTIES=[{name:"DEBUG",type:Type.BOOLEAN},{name:"IS_BROWSER",type:Type.BOOLEAN},{name:"WEBGL_LAZILY_UNPACK",type:Type.BOOLEAN},{name:"WEBGL_CPU_FORWARD",type:Type.BOOLEAN},{name:"WEBGL_PACK_BATCHNORMALIZATION",type:Type.BOOLEAN},{name:"WEBGL_CONV_IM2COL",type:Type.BOOLEAN},{name:"WEBGL_MAX_TEXTURE_SIZE",type:Type.NUMBER},{name:"WEBGL_PAGING_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",type:Type.NUMBER},{name:"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",type:Type.BOOLEAN},{name:"WEBGL_VERSION",type:Type.NUMBER},{name:"WEBGL_RENDER_FLOAT32_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_DOWNLOAD_FLOAT_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_FENCE_API_ENABLED",type:Type.BOOLEAN},{name:"WEBGL_SIZE_UPLOAD_UNIFORM",type:Type.NUMBER},{name:"BACKEND",type:Type.STRING},{name:"EPSILON",type:Type.NUMBER},{name:"PROD",type:Type.BOOLEAN},{name:"TENSORLIKE_CHECK_SHAPE_CONSISTENCY",type:Type.BOOLEAN}],TENSORFLOWJS_FLAGS_PREFIX="tfjsflags",EPSILON_FLOAT16=.001,TEST_EPSILON_FLOAT16=.1,EPSILON_FLOAT32=1e-7,TEST_EPSILON_FLOAT32=.001,Environment=function(){function t(t){this.features={},this.registry={},null!=t&&(this.features=t),this.get("DEBUG")&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}return t.setBackend=function(a,e){if(void 0===e&&(e=!1),!(a in ENV.registry))throw new Error("Backend name '"+a+"' not found in registry");ENV.engine.backend=ENV.findBackend(a),ENV.backendName=a},t.getBackend=function(){return ENV.initEngine(),ENV.backendName},t.disposeVariables=function(){ENV.engine.disposeVariables()},t.memory=function(){return ENV.engine.memory()},t.profile=function(t){return ENV.engine.profile(t)},t.tidy=function(a,e,t){return void 0===t&&(t=!1),ENV.engine.tidy(a,e,t)},t.dispose=function(t){getTensorsInContainer(t).forEach(function(t){return t.dispose()})},t.keep=function(t){return ENV.engine.keep(t)},t.time=function(t){return ENV.engine.time(t)},t.prototype.get=function(t){return t in this.features?this.features[t]:(this.features[t]=this.evaluateFeature(t),this.features[t])},t.prototype.getFeatures=function(){return this.features},t.prototype.set=function(a,e){this.features[a]=e},t.prototype.getBestBackendName=function(){var a=this;if(0===Object.keys(this.registry).length)throw new Error("No backend found in registry.");return Object.keys(this.registry).map(function(e){return{name:e,entry:a.registry[e]}}).sort(function(a,e){return e.entry.priority-a.entry.priority})[0].name},t.prototype.evaluateFeature=function(a){if("DEBUG"===a)return!1;if("IS_BROWSER"===a)return"undefined"!=typeof window;if("IS_NODE"===a)return"undefined"!=typeof process&&void 0!==process.versions.node;if("IS_CHROME"===a)return isChrome();if("WEBGL_CPU_FORWARD"===a)return!0;if("WEBGL_PACK_BATCHNORMALIZATION"===a)return!1;if("WEBGL_LAZILY_UNPACK"===a)return!1;if("WEBGL_CONV_IM2COL"===a)return!1;if("WEBGL_PAGING_ENABLED"===a)return this.get("IS_BROWSER")&&!this.get("PROD");if("WEBGL_MAX_TEXTURE_SIZE"===a)return getWebGLMaxTextureSize(this.get("WEBGL_VERSION"));if("IS_TEST"===a)return!1;if("BACKEND"===a)return this.getBestBackendName();if("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"===a){var e=this.get("WEBGL_VERSION");return 0===e?0:getWebGLDisjointQueryTimerVersion(e)}if("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"===a)return 0<this.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")&&!isMobile();if("HAS_WEBGL"===a)return 0<this.get("WEBGL_VERSION");if("WEBGL_VERSION"===a)return isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0;if("WEBGL_RENDER_FLOAT32_ENABLED"===a)return isRenderToFloatTextureEnabled(this.get("WEBGL_VERSION"));if("WEBGL_DOWNLOAD_FLOAT_ENABLED"===a)return isDownloadFloatTextureEnabled(this.get("WEBGL_VERSION"));if("WEBGL_FENCE_API_ENABLED"===a)return isWebGLFenceEnabled(this.get("WEBGL_VERSION"));if("WEBGL_SIZE_UPLOAD_UNIFORM"===a)return this.get("WEBGL_RENDER_FLOAT32_ENABLED")?4:0;if("TEST_EPSILON"===a)return 32===this.backend.floatPrecision()?TEST_EPSILON_FLOAT32:TEST_EPSILON_FLOAT16;if("EPSILON"===a)return 32===this.backend.floatPrecision()?EPSILON_FLOAT32:EPSILON_FLOAT16;if("PROD"===a)return!1;if("TENSORLIKE_CHECK_SHAPE_CONSISTENCY"===a)return!this.get("PROD");throw new Error("Unknown feature "+a+".")},t.prototype.setFeatures=function(t){this.features=Object.assign({},t)},t.prototype.reset=function(){this.features=getFeaturesFromURL(),null!=this.globalEngine&&(this.globalEngine=null)},Object.defineProperty(t.prototype,"backend",{get:function(){return this.engine.backend},enumerable:!0,configurable:!0}),t.prototype.findBackend=function(t){return t in this.registry?this.registry[t].backend:null},t.prototype.registerBackend=function(s,e,t,i){var n=this;if(void 0===t&&(t=1),s in this.registry)return console.warn(s+" backend was already registered. Reusing existing backend"),null!=i&&i(function(){return n.engine}),!1;try{var o=e();return o.setDataMover({moveData:function(t){return n.engine.moveData(t)}}),this.registry[s]={backend:o,priority:t},!0}catch(e){return console.warn("Registration of backend "+s+" failed"),console.warn(e.stack||e.message),!1}},t.prototype.removeBackend=function(t){if(!(t in this.registry))throw new Error(t+" backend not found in registry");this.registry[t].backend.dispose(),delete this.registry[t]},Object.defineProperty(t.prototype,"engine",{get:function(){return this.initEngine(),this.globalEngine},enumerable:!0,configurable:!0}),t.prototype.initEngine=function(){var a=this;if(null==this.globalEngine){this.backendName=this.get("BACKEND");var e=this.findBackend(this.backendName);this.globalEngine=new Engine(e,!1,function(){return a.get("DEBUG")})}},t}(),ENV=getOrMakeEnvironment(),environment=Object.freeze({Environment:Environment,ENV:ENV}),tidy=Environment.tidy,keep=Environment.keep,dispose=Environment.dispose,PARALLELIZE_THRESHOLD=30,softmax=op({softmax_:softmax_}),logSoftmax=op({logSoftmax_:logSoftmax_}),complex=op({complex_:complex_}),real=op({real_:real_}),imag=op({imag_:imag_}),onesLike=op({onesLike_:onesLike_}),zerosLike=op({zerosLike_:zerosLike_}),MAX_TEXTURE_SIZE,DType,Rank,UpcastInt32AndMap,UpcastBoolAndMap,UpcastFloat32AndMap,UpcastComplex64AndMap;!function(t){t.float32="float32",t.int32="int32",t.bool="bool"}(DType||(DType={})),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Rank||(Rank={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(UpcastInt32AndMap||(UpcastInt32AndMap={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(UpcastBoolAndMap||(UpcastBoolAndMap={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(UpcastFloat32AndMap||(UpcastFloat32AndMap={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));var upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap},DataStorage=function(){function t(t){this.dataMover=t,this.data=new WeakMap}return t.prototype.get=function(t){return this.data.has(t)||this.dataMover.moveData(t),this.data.get(t)},t.prototype.set=function(a,e){this.data.set(a,e)},t.prototype.has=function(t){return this.data.has(t)},t.prototype.delete=function(t){return this.data.delete(t)},t}(),ArgMinMaxProgram=function(){return function(p,e,t){this.variableNames=["A"];var r=p.windowSize,n=p.batchSize,o=p.inSize,a=_Mathceil(o/r);t||this.variableNames.push("bestIndicesA"),this.outputShape=[n,a];var i="max"===e?">":"<",s=t?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+s+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+i+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}}(),AvgPool2DBackpropProgram=function(){return function(p){this.variableNames=["dy"],this.outputShape=p.inShape;var e=p.filterHeight,t=p.filterWidth,r=p.strideHeight,n=p.strideWidth,o=p.dilationHeight,a=p.dilationWidth,i=p.effectiveFilterHeight,s=p.effectiveFilterWidth,d=i-1-p.padInfo.top,l=s-1-p.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+d+", "+l+");\n      const float avgMultiplier = float("+1/(e*t)+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+i+";\n            wR += "+o+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+p.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+s+";\n            wC+= "+a+") {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+p.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),BatchNormProgram=function(){return function(p,e,t,r,n,o){this.outputShape=[],this.supportsBroadcasting=!0,this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(p,e),assertAndGetBroadcastShape(p,t);var a="0.0";null!=r&&(assertAndGetBroadcastShape(p,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");var l="1.0";null!=n&&(assertAndGetBroadcastShape(p,n),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=p,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+a+";\n        float scale = "+l+";\n        float inv = scale * inversesqrt(variance + float("+o+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "}}(),BatchNormPackedProgram=function(){return function(p,e,t,r,n,o){this.supportsBroadcasting=!0,this.usesPackedTextures=!0,this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(p,e),assertAndGetBroadcastShape(p,t);var a=broadcastSample("mean",e.length),i=broadcastSample("variance",t.length),s="vec4 offset = vec4(0.0)";null!=r&&(assertAndGetBroadcastShape(p,r),this.variableNames.push("offset"),s=broadcastSample("offset",r.length));var d="vec4 scale = vec4(1.0)";null!=n&&(assertAndGetBroadcastShape(p,n),this.variableNames.push("scale"),d=broadcastSample("scale",n.length)),this.outputShape=p,this.userCode="\n      void main() {\n        ivec4 rc = getOutputCoords();\n\n        "+s+";\n        "+d+";\n\n        vec4 x = getX(rc.x, rc.y, rc.z, rc.w);\n        "+a+";\n        "+i+";\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+o+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "}}(),COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},BinaryOpComplexProgram=function(){return function(a,e,t){this.variableNames=["AReal","AImag","BReal","BImag"],this.supportsBroadcasting=!0,this.outputShape=assertAndGetBroadcastShape(e,t),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+a+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}}(),CHECK_NAN_SNIPPET="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n",ADD="return a + b;",SUB="return a - b;",MUL="return a * b;",DIV="if (a == b) return 1.0;\n  return a / b;",INT_DIV="\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n",POW="\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",SQUARED_DIFFERENCE="return (a - b) * (a - b);",EQUAL="return float(a == b);",NOT_EQUAL="return float(a != b);",LESS="return float(a < b);",LESS_EQUAL="return float(a <= b);",GREATER="return float(a > b);",GREATER_EQUAL="return float(a >= b);",LOGICAL_AND="return float(a >= 1.0 && b >= 1.0);",LOGICAL_OR="return float(a >= 1.0 || b >= 1.0);",MAX=CHECK_NAN_SNIPPET+"\n  return max(a, b);\n",MIN=CHECK_NAN_SNIPPET+"\n  return min(a, b);\n",MOD="if (b == 0.0) return NAN;\n  return mod(a, b);",ATAN2=CHECK_NAN_SNIPPET+"\n  return atan(a, b);\n",ELU_DER="return (b >= 1.0) ? a : a * (b + 1.0);",BinaryOpProgram=function(){function t(a,e,t){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.outputShape=assertAndGetBroadcastShape(e,t),this.userCode="\n      uniform float NAN;\n      float binaryOperation(float a, float b) {\n        "+a+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(){var a=this;return function(e,t){null==a.startLoc&&(a.startLoc=e.getUniformLocationNoThrow(t,"NAN"),null==a.startLoc)||e.gl.uniform1f(a.startLoc,NaN)}},t}(),ClipProgram=function(){return function(a,e,t){this.variableNames=["A"],this.outputShape=a,this.userCode="\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, float("+e+"), float("+t+")));\n      }\n    "}}(),ComplexAbsProgram=function(){return function(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float real = getRealAtOutCoords();\n        float imag = getImagAtOutCoords();\n        vec2 v = vec2(real, imag);\n\n        setOutput(sqrt(dot(v, v)));\n      }\n    "}}(),ConcatProgram=function(){return function(a,e){this.variableNames=["A","B"],this.outputShape=[],this.outputShape=computeOutShape([a,e],1),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < "+a[1]+") {\n          value = getA(yR, yC);\n        } else {\n          yC -= "+a[1]+";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    "}}(),Conv2DDerFilterProgram=function(){return function(a){this.variableNames=["x","dy"],this.outputShape=a.filterShape;var e=a.strideHeight,t=a.strideWidth,r=a.padInfo.top,n=a.padInfo.left;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+a.batchSize+"; b++) {\n          for (int yR = 0; yR < "+a.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+a.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+a.outWidth+"; yC++) {\n              int xC = wC + yC * "+t+" - "+n+";\n\n              if (xC < 0 || xC >= "+a.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Conv2DDerInputProgram=function(){return function(s){this.variableNames=["dy","W"],this.outputShape=s.inShape;var e=s.filterHeight,t=s.filterWidth,r=s.strideHeight,n=s.strideWidth,o=e-1-s.padInfo.top,a=t-1-s.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+o+", "+a+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+s.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+t+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+s.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+t+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+s.outChannels+"; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),DepthwiseConv2DDerFilterProgram=function(){return function(s){this.variableNames=["x","dy"],this.outputShape=s.filterShape;var e=s.strideHeight,t=s.strideWidth,r=s.padInfo.top,n=s.padInfo.left,o=s.outChannels/s.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+o+" + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < "+s.batchSize+"; b++) {\n          for (int yR = 0; yR < "+s.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+s.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+s.outWidth+"; yC++) {\n              int xC = wC + yC * "+t+" - "+n+";\n\n              if (xC < 0 || xC >= "+s.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),DepthwiseConv2DDerInputProgram=function(){return function(p){this.variableNames=["dy","W"],this.outputShape=p.inShape;var e=p.filterHeight,t=p.filterWidth,r=p.strideHeight,n=p.strideWidth,o=e-1-p.padInfo.top,a=t-1-p.padInfo.left,i=p.outChannels/p.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+o+", "+a+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+p.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+t+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+p.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+t+" - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+i+"; dm++) {\n              int d2 = d1 * "+i+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Conv2DProgram=function(){return function(p){this.variableNames=["x","W"],this.outputShape=p.outShape;var e=p.padInfo.top,t=p.padInfo.left,r=p.strideHeight,n=p.strideWidth,o=p.dilationHeight,a=p.dilationWidth,i=p.filterHeight,s=p.filterWidth,d=4*_Mathfloor(p.inChannels/4),l=p.inChannels%4;this.userCode="\n      const ivec2 strides = ivec2("+r+", "+n+");\n      const ivec2 pads = ivec2("+e+", "+t+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+i+"; wR++) {\n          int xR = xRCorner + wR * "+o+";\n\n          if (xR < 0 || xR >= "+p.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+s+"; wC++) {\n            int xC = xCCorner + wC * "+a+";\n\n            if (xC < 0 || xC >= "+p.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+d+"; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if ("+(1==l)+") {\n              dotProd +=\n                getX(batch, xR, xC, "+d+") *\n                getW(wR, wC, "+d+", d2);\n            } else if ("+(2==l)+") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, "+d+"),\n                getX(batch, xR, xC, "+d+" + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, "+d+", d2),\n                getW(wR, wC, "+d+" + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if ("+(3==l)+") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, "+d+"),\n                getX(batch, xR, xC, "+d+" + 1),\n                getX(batch, xR, xC, "+d+" + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, "+d+", d2),\n                getW(wR, wC, "+d+" + 1, d2),\n                getW(wR, wC, "+d+" + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),DepthwiseConv2DProgram=function(){return function(d){this.variableNames=["x","W"],this.outputShape=d.outShape;var e=d.inHeight,t=d.inWidth,r=d.padInfo.top,n=d.padInfo.left,o=d.strideHeight,a=d.strideWidth,i=d.dilationHeight,s=d.dilationWidth,u=d.filterHeight,l=d.filterWidth,c=d.outChannels/d.inChannels;this.userCode="\n      const ivec2 strides = ivec2("+o+", "+a+");\n      const ivec2 pads = ivec2("+r+", "+n+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+c+";\n        int q = d2 - d1 * "+c+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+u+"; wR++) {\n          int xR = xRCorner + wR * "+i+";\n\n          if (xR < 0 || xR >= "+e+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+l+"; wC++) {\n            int xC = xCCorner + wC * "+s+";\n\n            if (xC < 0 || xC >= "+t+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),CropAndResizeProgram=function(){return function(b,e,t,r,n){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var o=b[0],a=b[1],i=b[2],s=b[3],u=e[0],l=t[0],c=t[1];this.outputShape=[u,l,c,s];var p="bilinear"===r?1:0,d=[a-1+".0",i-1+".0"],h=d[0],f=d[1],m=1<l?[""+(a-1)/(l-1),"(y2-y1) * height_ratio","y1*"+h+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+h],g=m[0],N=m[1],y=m[2],x=1<c?[""+(i-1)/(c-1),"(x2-x1) * width_ratio","x1*"+f+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+f],I=x[0],v=x[1],C=x[2];this.userCode="\n      const float height_ratio = float("+g+");\n      const float width_ratio = float("+I+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+o+") {\n          return;\n        }\n\n        float height_scale = "+N+";\n        float width_scale = "+v+";\n\n        float in_y = "+y+";\n        if( in_y < 0.0 || in_y > "+h+" ) {\n          setOutput(float("+n+"));\n          return;\n        }\n        float in_x = "+C+";\n        if( in_x < 0.0 || in_x > "+f+" ) {\n          setOutput(float("+n+"));\n          return;\n        }\n\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\n        if("+p+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\n\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          float newValue = top + (bottom - top) * fracRC.x;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestRC = ivec2(floor(\n            sourceFracIndexRC + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\n          setOutput(newValue);\n        }\n      }\n    "}}(),SAMPLE_1D_SNIPPET="\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_2D_SNIPPET="\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_3D_SNIPPET="\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_4D_SNIPPET="\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom4D(int texNumR, int texNumC, int texelsInBatch2,\n    int texelsInBatch, int texelsInLogicalRow, int b2, int b,\n    int row, int col) {\n  int index = b2 * texelsInBatch2 + b * texelsInBatch +\n    (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_5D_SNIPPET="\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 +\n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_6D_SNIPPET="\nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int stride4,\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\n    stride3 + depth3 * stride4 + depth4;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",FLOAT_TEXTURE_SAMPLE_SNIPPET="\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n",FLOAT_TEXTURE_SET_R_SNIPPET="\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n",FLOAT_TEXTURE_SET_RGBA_SNIPPET="\n  void setOutput(vec4 val) {\n    gl_FragColor = val;\n  }\n",SHADER_PREFIX="\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  struct ivec6\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n    int v;\n  };\n\n  bool isNaN(float val) {\n    return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  "+SAMPLE_1D_SNIPPET+"\n  "+SAMPLE_2D_SNIPPET+"\n  "+SAMPLE_3D_SNIPPET+"\n  "+SAMPLE_4D_SNIPPET+"\n  "+SAMPLE_5D_SNIPPET+"\n  "+SAMPLE_6D_SNIPPET+"\n",SHADER_PACKED_PREFIX="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n",CumSumProgram=function(){return function(s,e,t){this.variableNames=["x"],this.outputShape=s;var r=s.length,n=s[s.length-1],o=t?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(t?"return "+n+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+getCoordsDataType(r)+" coords = getOutputCoords();\n        int end = "+getFinalCoord(r,"coords")+";\n        float val = 0.0;\n        for (int i = "+n+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+o+" end) {\n            continue;\n          }\n          if (idx == end && "+e+") {\n            continue;\n          }\n          "+getFinalCoord(r,"coords")+" = idx;\n          val += getX("+getCoords(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}}(),DepthToSpaceProgram=function(){function t(a,e,t){this.variableNames=["x"],this.outputShape=[],this.outputShape=a,this.blockSize=e,this.dataFormat=t,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+e+";\n      int offset_h = imod(h, "+e+");\n      int in_w = w / "+e+";\n      int offset_w = imod(w, "+e+");\n      int offset_d = (offset_h * "+e+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),EncodeFloatProgram=function(){return function(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isNaN(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        gl_FragColor = encode_float(x);\n      }\n    "}}(),COMPLEX_FFT={REAL:"return real * expR - imag * expI;",IMAG:"return real * expI + imag * expR;"},FFTProgram=function(){return function(s,e,t){this.variableNames=["real","imag"];var r=e[1];this.outputShape=e;var n=t?"2.0 * "+_MathPI:"-2.0 * "+_MathPI,o=t?r+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+n+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+s+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+r+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+r+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+o+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "}}(),FromPixelsProgram=function(){return function(a){this.variableNames=["A"];var e=a[0],t=a[1];this.outputShape=a,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+t+".0, "+e+".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}}(),GatherProgram=function(){return function(s,e,t){this.variableNames=["A","indices"];var r=s.slice();r[t]=e,this.outputShape=r,this.rank=r.length;var n=getCoordsDataType(this.rank),o=getSourceCoords(s,t);this.userCode="\n      void main() {\n        "+n+" resRC = getOutputCoords();\n        setOutput(getA("+o+"));\n      }\n    "}}(),GatherNDProgram=function(){return function(s,e,t){this.sliceDim=s,this.strides=e,this.variableNames=["x","indices"],this.outputShape=t;var r=getCoordsDataType(e.length),n=getCoordsDataType(t.length),o=1<this.sliceDim?"strides[j]":"strides";this.userCode="\n        "+r+" strides = "+r+"("+this.strides+");\n         void main() {\n          "+n+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+o+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "}}(),TextureUsage,PhysicalTextureType;!function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(TextureUsage||(TextureUsage={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(PhysicalTextureType||(PhysicalTextureType={}));var webGLDebugErrorCheckingEnabled=!1,lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g,webgl_util=Object.freeze({callAndCheck:callAndCheck,enableDebugWebGLErrorChecking:enableDebugWebGLErrorChecking,checkWebGLError:checkWebGLError,getWebGLErrorMessage:getWebGLErrorMessage,getExtensionOrThrow:getExtensionOrThrow,createVertexShader:createVertexShader,createFragmentShader:createFragmentShader,createProgram:createProgram,linkProgram:linkProgram,validateProgram:validateProgram,createStaticVertexBuffer:createStaticVertexBuffer,createStaticIndexBuffer:createStaticIndexBuffer,getNumChannels:getNumChannels,createTexture:createTexture,validateTextureSize:validateTextureSize,createFramebuffer:createFramebuffer,bindVertexBufferToProgramAttribute:bindVertexBufferToProgramAttribute,bindTextureUnit:bindTextureUnit,unbindTextureUnit:unbindTextureUnit,getProgramUniformLocationOrThrow:getProgramUniformLocationOrThrow,getProgramUniformLocation:getProgramUniformLocation,bindTextureToProgramUniformSampler:bindTextureToProgramUniformSampler,bindCanvasToFramebuffer:bindCanvasToFramebuffer,bindColorTextureToFramebuffer:bindColorTextureToFramebuffer,unbindColorTextureFromFramebuffer:unbindColorTextureFromFramebuffer,validateFramebuffer:validateFramebuffer,getFramebufferErrorMessage:getFramebufferErrorMessage,getTextureShapeFromLogicalShape:getTextureShapeFromLogicalShape,isReshapeFree:isReshapeFree}),gpgpu_util=Object.freeze({createVertexShader:createVertexShader$1,createVertexBuffer:createVertexBuffer,createIndexBuffer:createIndexBuffer,getTextureConfig:getTextureConfig,createFloat32MatrixTexture:createFloat32MatrixTexture,createFloat16MatrixTexture:createFloat16MatrixTexture,createUnsignedBytesMatrixTexture:createUnsignedBytesMatrixTexture,createPackedMatrixTexture:createPackedMatrixTexture,createFloat16PackedMatrixTexture:createFloat16PackedMatrixTexture,bindVertexProgramAttributeStreams:bindVertexProgramAttributeStreams,uploadPixelDataToTexture:uploadPixelDataToTexture,uploadMatrixToTexture:uploadMatrixToTexture,uploadMatrixToPackedTexture:uploadMatrixToPackedTexture,maybeCreateBufferFromOutputTexture:maybeCreateBufferFromOutputTexture,downloadFloat32MatrixFromBuffer:downloadFloat32MatrixFromBuffer,downloadFloat32MatrixFromOutputTexture:downloadFloat32MatrixFromOutputTexture,downloadByteEncodedFloatMatrixFromOutputTexture:downloadByteEncodedFloatMatrixFromOutputTexture,downloadMatrixFromPackedOutputTexture:downloadMatrixFromPackedOutputTexture}),GPGPUContext=function(){function t(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.autoDebugValidate=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[],this.gl=null==t?getWebGLContext(ENV.get("WEBGL_VERSION")):t,1===ENV.get("WEBGL_VERSION")?(this.textureFloatExtension=getExtensionOrThrow(this.gl,"OES_texture_float"),this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float"),ENV.get("WEBGL_RENDER_FLOAT32_ENABLED")||(this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,"OES_texture_half_float"),this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float"))):this.colorBufferFloatExtension=getExtensionOrThrow(this.gl,"EXT_color_buffer_float"),this.vertexBuffer=createVertexBuffer(this.gl),this.indexBuffer=createIndexBuffer(this.gl),this.framebuffer=createFramebuffer(this.gl),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}return t.prototype.dispose=function(){var a=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var e=this.gl;callAndCheck(e,function(){return e.finish()}),callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),callAndCheck(e,function(){return e.deleteFramebuffer(a.framebuffer)}),callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,null)}),callAndCheck(e,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)}),callAndCheck(e,function(){return e.deleteBuffer(a.indexBuffer)}),this.disposed=!0}},t.prototype.enableAutomaticDebugValidation=function(t){this.autoDebugValidate=t,enableDebugWebGLErrorChecking(t)},t.prototype.createFloat32MatrixTexture=function(a,e){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,a,e,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(a,e){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,a,e,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(a,e){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,a,e,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(a,e){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,a,e)},t.prototype.createFloat16PackedMatrixTexture=function(a,e){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,a,e,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(a,e){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,a,e,this.textureConfig)},t.prototype.deleteMatrixTexture=function(a){var e=this;this.throwIfDisposed(),this.outputTexture===a&&(unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,function(){return e.gl.deleteTexture(a)})},t.prototype.uploadMatrixToTexture=function(a,e,t,r){this.throwIfDisposed();var n=getNumChannels();return uploadMatrixToTexture(this.gl,a,e,t,r,n,this.textureConfig)},t.prototype.uploadMatrixToPackedTexture=function(a,e,t,r,n){return this.throwIfDisposed(),uploadMatrixToPackedTexture(this.gl,a,e,t,r,n,this.textureConfig)},t.prototype.downloadFloat32MatrixFromOutputTexture=function(a,e,t){var r=this;return this.downloadMatrixDriver(a,function(){return downloadFloat32MatrixFromOutputTexture(r.gl,e,t,r.textureConfig)})},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(a,e,t){var r=this;return this.downloadMatrixDriver(a,function(){return downloadByteEncodedFloatMatrixFromOutputTexture(r.gl,e,t,r.textureConfig)})},t.prototype.downloadFloat32MatrixFromBuffer=function(a,e,t){return downloadFloat32MatrixFromBuffer(this.gl,a,e,t,this.textureConfig)},t.prototype.maybeCreateBufferFromTexture=function(a,e,t){this.bindTextureToFrameBuffer(a);var r=maybeCreateBufferFromOutputTexture(this.gl,a,e,t,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},t.prototype.createAndWaitForFence=function(){var t=this.createFence(this.gl);return this.pollFence(t)},t.prototype.createFence=function(s){var e=this,n,i;if(ENV.get("WEBGL_FENCE_API_ENABLED")){var p=s,o=p.fenceSync(p.SYNC_GPU_COMMANDS_COMPLETE,0);s.flush(),i=function(){var t=p.clientWaitSync(o,0,0);return t===p.ALREADY_SIGNALED||t===p.CONDITION_SATISFIED},n=o}else 0<ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?(n=this.beginQuery(),this.endQuery(),i=function(){return e.isQueryAvailable(n,ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):i=function(){return!0};return{query:n,isFencePassed:i}},t.prototype.downloadMatrixFromPackedTexture=function(s,e,t,r,n,o){var a=this;return this.downloadMatrixDriver(s,function(){return downloadMatrixFromPackedOutputTexture(a.gl,e,t,r,n,o,a.textureConfig)})},t.prototype.createProgram=function(a){this.throwIfDisposed();var e=this.gl,t=createFragmentShader(e,a),r=createVertexShader$1(e),n=createProgram(e);return callAndCheck(e,function(){return e.attachShader(n,r)}),callAndCheck(e,function(){return e.attachShader(n,t)}),linkProgram(e,n),this.autoDebugValidate&&validateProgram(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(e,this.program,this.vertexBuffer)),n},t.prototype.deleteProgram=function(a){var e=this;this.throwIfDisposed(),a===this.program&&(this.program=null),null!=a&&callAndCheck(this.gl,function(){return e.gl.deleteProgram(a)})},t.prototype.setProgram=function(a){var e=this;this.throwIfDisposed(),this.program=a,null!=this.program&&this.autoDebugValidate&&validateProgram(this.gl,this.program),callAndCheck(this.gl,function(){return e.gl.useProgram(a)})},t.prototype.getUniformLocation=function(a,e,t){return void 0===t&&(t=!0),this.throwIfDisposed(),t?getProgramUniformLocationOrThrow(this.gl,a,e):getProgramUniformLocation(this.gl,a,e)},t.prototype.getAttributeLocation=function(a,e){var t=this;return this.throwIfDisposed(),callAndCheck(this.gl,function(){return t.gl.getAttribLocation(a,e)})},t.prototype.getUniformLocationNoThrow=function(a,e){return this.throwIfDisposed(),this.gl.getUniformLocation(a,e)},t.prototype.setInputMatrixTexture=function(a,e,t){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,this.program,a,e,t)},t.prototype.setOutputMatrixTexture=function(a,e,t){this.setOutputMatrixTextureDriver(a,t,e)},t.prototype.setOutputPackedMatrixTexture=function(s,e,t){this.throwIfDisposed();var r=getPackedMatrixTextureShapeWidthHeight(e,t),n=r[0],o=r[1];this.setOutputMatrixTextureDriver(s,n,o)},t.prototype.setOutputMatrixWriteRegion=function(a,e,t,r){this.setOutputMatrixWriteRegionDriver(t,a,r,e)},t.prototype.setOutputPackedMatrixWriteRegion=function(){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&validateProgram(this.gl,this.program),validateFramebuffer(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var t=this.gl;this.autoDebugValidate&&this.debugValidate(),callAndCheck(t,function(){return t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)})},t.prototype.blockUntilAllProgramsCompleted=function(){var t=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return t.gl.finish()})},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,2===ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var a=this.gl,e=this.getQueryTimerExtensionWebGL2(),t=a.createQuery();return a.beginQuery(e.TIME_ELAPSED_EXT,t),t}var r=this.getQueryTimerExtensionWebGL1(),n=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,n),n},t.prototype.endQuery=function(){if(2!==ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var a=this.getQueryTimerExtensionWebGL1();a.endQueryEXT(a.TIME_ELAPSED_EXT)}else{var e=this.gl,t=this.getQueryTimerExtensionWebGL2();e.endQuery(t.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(a){return __awaiter(this,void 0,void 0,function(){var e=this;return __generator(this,function(t){switch(t.label){case 0:return[4,repeatedTry(function(){return e.disposed||e.isQueryAvailable(a,ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return t.sent(),[2,this.getQueryTime(a,ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];}})})},t.prototype.getQueryTime=function(a,e){if(0===e)return null;if(2===e){var t=this.gl;return t.getQueryParameter(a,t.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(a,r.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(a,e){if(0===e)return!0;if(2===e){var t=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=t.getQueryParameter(a,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}return s=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(a,r.QUERY_RESULT_AVAILABLE_EXT),null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint},t.prototype.pollFence=function(a){var e=this;return new Promise(function(t){e.addItemToPoll(function(){return a.isFencePassed()},function(){return t()})})},t.prototype.pollItems=function(){for(var a=binSearchLastTrue(this.itemsToPoll.map(function(t){return t.isDoneFn})),e=0;e<=a;++e)(0,this.itemsToPoll[e].resolveFn)();this.itemsToPoll=this.itemsToPoll.slice(a+1)},t.prototype.addItemToPoll=function(a,e){var t=this;this.itemsToPoll.push({isDoneFn:a,resolveFn:e}),1<this.itemsToPoll.length||repeatedTry(function(){return t.pollItems(),0===t.itemsToPoll.length})},t.prototype.bindTextureToFrameBuffer=function(t){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,t,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null==this.outputTexture?unbindColorTextureFromFramebuffer(this.gl,this.framebuffer):(bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(this.gl))},t.prototype.downloadMatrixDriver=function(a,e){this.bindTextureToFrameBuffer(a);var t=e();return this.unbindTextureToFrameBuffer(),t},t.prototype.setOutputMatrixTextureDriver=function(a,e,t){this.throwIfDisposed();var r=this.gl;bindColorTextureToFramebuffer(r,a,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(r),this.outputTexture=a,callAndCheck(r,function(){return r.viewport(0,0,e,t)}),callAndCheck(r,function(){return r.scissor(0,0,e,t)})},t.prototype.setOutputMatrixWriteRegionDriver=function(a,e,t,r){var n=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return n.gl.scissor(a,e,t,r)})},t.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},t}(),Im2ColProgram=function(){return function(m,e,t){this.variableNames=["A"],this.outputShape=m;var r=t.filterWidth,n=t.inChannels,o=t.strideWidth,a=t.strideHeight,i=t.padInfo,s=t.outWidth,u=t.dilationWidth,l=t.dilationHeight,c=i.left,p=i.top,d=n*r;this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            int blockIndex = rc.y + col;\n            int pos = rc.x + row;\n\n            if(blockIndex >= "+m[1]+" || pos >= "+m[0]+") continue;\n\n            int offsetY = int(blockIndex / ("+s+")) * "+a+" - "+p+";\n            int d0 = offsetY + "+l+" * (pos / "+d+");\n\n            if(d0 >= "+e[0]+" || d0 < 0) continue;\n\n            int offsetX = int(mod(float(blockIndex), "+s+".) * "+o+". - "+c+".);\n            int d1 = offsetX + "+u+" * (int(mod(float(pos), "+d+".) / "+n+".));\n\n            if(d1 >= "+e[1]+" || d1 < 0) continue;\n\n            result[row * 2 + col] = getA(d0, d1, int(mod(float(pos), "+n+".)));\n          }\n        }\n\n        gl_FragColor = result;\n      }\n    "}}(),LRNProgram=function(){return function(p,e,t,r,n){this.variableNames=["x"],this.outputShape=[];var o=e,i=p[3]-1,s;this.outputShape=p;var l="float("+t+") + float("+r+") * sum";s=.5===n?"inversesqrt("+l+")":1===n?"1.0/("+l+")":"exp(log("+l+") * float(-"+n+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+o+"; j <= "+o+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+i+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+s+";\n        setOutput(val);\n      }\n    "}}(),LRNGradProgram=function(){return function(a,e,t,r,n){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=a,this.depth=a[3],this.depthRadius=e,this.bias=t,this.alpha=r,this.beta=n,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+e+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+e+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+t+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+n+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+n+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}}(),MaxPool2DBackpropProgram=function(){return function(p){this.variableNames=["dy","maxPos"],this.outputShape=p.inShape;var e=p.strideHeight,t=p.strideWidth,r=p.dilationHeight,n=p.effectiveFilterHeight,o=p.effectiveFilterWidth,a=n-1-p.padInfo.top,i=o-1-p.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+n+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+e+".0;\n\n          if (dyR < 0.0 || dyR >= "+p.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+o+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+t+".0;\n\n            if (dyC < 0.0 || dyC >= "+p.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+(n*o-1)+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+o+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),MatMulProgram=function(){return function(d,e,m,h){void 0===m&&(m=!1),void 0===h&&(h=!1),this.variableNames=["matrixA","matrixB"];var t=d[0],o=m?d[2]:d[1],a=h?e[1]:e[2],i=m?d[1]:d[2];this.outputShape=[t,o,a];var s=function(a,e){return m?"batch, "+e+" + "+a+", aRow":"batch, aRow, "+e+" + "+a},u=function(a,e){return h?"batch, bCol, "+e+" + "+a:"batch, "+e+" + "+a+", bCol"},l=4*_Mathfloor(i/4),c=i%4;this.userCode=" float dotARowBCol(int batch, int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < "+l+"; i += 4) {\n        vec4 a = vec4(\n          getMatrixA("+s(0,"i")+"),\n          getMatrixA("+s(1,"i")+"),\n          getMatrixA("+s(2,"i")+"),\n          getMatrixA("+s(3,"i")+")\n        );\n        vec4 b = vec4(\n          getMatrixB("+u(0,"i")+"),\n          getMatrixB("+u(1,"i")+"),\n          getMatrixB("+u(2,"i")+"),\n          getMatrixB("+u(3,"i")+")\n        );\n\n        result += dot(a, b);\n      }\n\n      if ("+(1==c)+") {\n        result += getMatrixA("+s(0,l)+") *\n          getMatrixB("+u(0,l)+");\n      } else if ("+(2==c)+") {\n        vec2 a = vec2(\n          getMatrixA("+s(0,l)+"),\n          getMatrixA("+s(1,l)+")\n        );\n        vec2 b = vec2(\n          getMatrixB("+u(0,l)+"),\n          getMatrixB("+u(1,l)+")\n        );\n        result += dot(a, b);\n      } else if ("+(3==c)+") {\n        vec3 a = vec3(\n          getMatrixA("+s(0,l)+"),\n          getMatrixA("+s(1,l)+"),\n          getMatrixA("+s(2,l)+")\n        );\n        vec3 b = vec3(\n          getMatrixB("+u(0,l)+"),\n          getMatrixB("+u(1,l)+"),\n          getMatrixB("+u(2,l)+")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec3 resBRC = getOutputCoords();\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\n    }\n    "}}(),MatMulPackedProgram=function(){return function(p,e,t,r,d){void 0===r&&(r=!1),void 0===d&&(d=!1),this.variableNames=["matrixA","matrixB"],this.usesPackedTextures=!0,this.outputShape=t;var m=r?p[0]:p[1],a=_Mathceil(m/2),i=r?"i * 2, rc.x":"rc.x, i * 2",s=d?"rc.y, i * 2":"i * 2, rc.y",u=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],l=d?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];this.userCode="\n      const float sharedDimension = "+a+".0;\n\n      vec4 dot2x2ARowBCol(ivec2 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+a+"; i++) {\n          vec4 a = getMatrixA("+i+");\n          vec4 b = getMatrixB("+s+");\n\n          result += ("+u[0]+" * "+l[0]+") + ("+u[1]+" * "+l[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n        setOutput(dot2x2ARowBCol(rc));\n      }\n    "}}(),MultinomialProgram=function(){function t(a,e,t){this.variableNames=["probs"],this.outputShape=[a,t],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(e-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(e-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(a){var e=this;return function(t,r){null==e.seedLoc&&(e.seedLoc=t.getUniformLocation(r,"seed")),t.gl.uniform1f(e.seedLoc,a)}},t}(),OneHotProgram=function(){return function(a,e,t,r){this.variableNames=["indices"],this.outputShape=[a,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+t+"),\n                      float(index == coords.y)));\n      }\n    "}}(),PackProgram=function(){return function(s){this.variableNames=["A"],this.outputShape=s;var e=s.length,t=getChannels("rc",e),r=getCoordsDataType(e),n=getOutOfBoundsCondition(e,s,t),o=getSetup(e,s[s.length-1],s[s.length-2],t),a=getOutput(s,t);this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n\n        if("+n+") {\n          gl_FragColor = vec4(0);\n        } else {\n          "+o+"\n\n          setOutput(vec4("+a+"));\n        }\n      }\n    "}}(),PadProgram=function(){return function(p,e,t){this.variableNames=["x"],this.outputShape=e.map(function(e,t){return e[0]+p[t]+e[1]});var r=p.length,n=getCoordsDataType(r),o=e.map(function(t){return t[0]}).join(","),a=e.map(function(e,t){return e[0]+p[t]}).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1===r?"\n        int start = "+o+";\n        int end = "+a+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+t+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ":"\n      "+n+" start = "+n+"("+o+");\n      "+n+" end = "+n+"("+a+");\n\n      void main() {\n        "+n+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+t+"));\n        } else {\n          "+n+" coords = outC - start;\n          setOutput(getX("+i+"));\n        }\n      }\n    "}}(),Pool2DProgram=function(){return function(y,e,t){if(this.variableNames=["x"],"avg"===e&&t)throw new Error("Cannot compute positions for average pool.");var r=y.filterWidth,n=y.strideHeight,o=y.strideWidth,a=y.dilationHeight,i=y.dilationWidth,s=y.effectiveFilterHeight,u=y.effectiveFilterWidth,l=y.padInfo.top,c=y.padInfo.left;this.outputShape=y.outShape;var p="avg"===e,d="0.0";if(p||(d="-1.0 / 0.0"),t)this.userCode="\n        const ivec2 strides = ivec2("+n+", "+o+");\n        const ivec2 pads = ivec2("+l+", "+c+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+s+";\n              wR += "+a+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+y.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+u+";\n                wC += "+i+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+y.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+u+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var b=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(b="avgValue / count");var x=4*_Mathfloor(r/4),m=r%4,g="\n      if ("+p+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+n+", "+o+");\n      const ivec2 pads = ivec2("+l+", "+c+");\n      const float initializationValue = "+d+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+y.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+d+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+s+";\n            wR += "+a+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+y.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+x+"; wC += 4) {\n            int xC = xCCorner + wC * "+i+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+i+", d),\n              getValue(batch, xR, xC + 2 * "+i+", d),\n              getValue(batch, xR, xC + 3 * "+i+", d)\n            );\n\n            "+g+"\n          }\n\n          int xC = xCCorner + "+x+";\n          if ("+(1==m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(2==m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+i+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(3==m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+i+", d),\n              getValue(batch, xR, xC + 2 * "+i+", d),\n              initializationValue\n            );\n\n            "+g+"\n          }\n        }\n        setOutput("+b+");\n      }\n    "}}}(),ReduceProgram=function(){return function(m,e){this.variableNames=["x"];var t=m.windowSize,r=m.batchSize,n=m.inSize,o=_Mathceil(n/t);this.outputShape=[r,o];var a="0.0",g="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 0.0",g="min"):"max"==e&&(a="-1.0 / 0.0",g="max");var f=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?f="sumValue":"prod"===e?f="prodValue":"all"===e?f="allValue":"any"==e&&(f="anyValue");var y=4*_Mathfloor(t/4),l=t%4,c="\n      if ("+("sum"===e)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===e)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+g+"(values, minMaxValue);\n      }\n    ",b="vec4";"all"===e?(a="1.0",c="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",b="bvec4"):"any"==e&&(a="0.0",c="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",b="bvec4");var x="";0<n%t&&(x="\n        if (inIdx < 0 || inIdx >= "+n+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+a+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+x+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+t+";\n\n        vec4 minMaxValue = vec4("+a+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+y+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+b+" values = "+b+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+c+"\n        }\n\n        int inIdx = inOffset + "+y+";\n        if ("+(1==l)+") {\n          "+b+" values = "+b+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+c+"\n        } else if ("+(2==l)+") {\n          "+b+" values = "+b+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+c+"\n        } else if ("+(3==l)+") {\n          "+b+" values = "+b+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+c+"\n        }\n        setOutput("+f+");\n      }\n    "}}(),ReshapePackedProgram=function(){return function(a,e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=a;for(var t="",s=0,i;4>s;s++)i="thisRC = rc;",1==s%2&&(i+="thisRC.z += 1;"),1<s&&(i+="thisRC.y += 1;"),t+="\n        "+i+"\n        "+(0<s?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+s+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(0<s?"}":"")+"\n      ";this.userCode="\n      "+getReshapedInputCoords(e)+"\n      "+getFlatIndex(a)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+a[1]+";\n        int cols = "+a[2]+";\n\n        "+t+"\n\n        setOutput(result);\n      }\n    "}}(),ResizeBilinearBackpropProgram=function(){return function(y,e,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,n=r[1],o=r[2],a=y.shape,i=a[1],s=a[2],u=[t&&1<i?n-1:n,t&&1<s?o-1:o],l=[t&&1<i?i-1:i,t&&1<s?s-1:s],c=u[0]/l[0],p=u[1]/l[1],d=1/c,h=1/p,f=2*_Mathceil(d)+2,m=2*_Mathceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+c+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+d+");\n        const float invWidthScale = float("+h+");\n\n        const int winHeight = int("+f+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+i+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+s+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(n-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(o-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ResizeBilinearProgram=function(){return function(p,e,t,r){this.variableNames=["A"],this.outputShape=[];var n=p[0],o=p[1],a=p[2],i=p[3];this.outputShape=[n,e,t,i];var s=[r&&1<e?o-1:o,r&&1<t?a-1:a],d=[r&&1<e?e-1:e,r&&1<t?t-1:t];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+s[0]/d[0]+",\n          "+s[1]/d[1]+");\n      const vec2 inputShapeRC = vec2("+o+".0, "+a+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}}(),ResizeNearestNeigborBackpropProgram=function(){return function(y,e,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,n=r[1],o=r[2],a=y.shape,i=a[1],s=a[2],u=[t&&1<i?n-1:n,t&&1<s?o-1:o],l=[t&&1<i?i-1:i,t&&1<s?s-1:s],c=u[0]/l[0],p=u[1]/l[1],d=1/c,h=1/p,f=2*_Mathceil(d)+2,m=2*_Mathceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+c+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+d+");\n        const float invWidthScale = float("+h+");\n\n        const int winHeight = int("+f+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+i+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+s+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+u[0]+") *\n                (float(dyR) / float("+l[0]+"));\n\n            float sourceFracCol =\n                float("+u[1]+") *\n                  (float(dyC) / float("+l[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+n+") - 1),\n                "+t+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+o+") - 1),\n                "+t+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ResizeNearestNeighborProgram=function(){return function(p,e,t,r){this.variableNames=["A"],this.outputShape=[];var n=p[0],o=p[1],a=p[2],i=p[3];this.outputShape=[n,e,t,i];var s=[r&&1<e?o-1:o,r&&1<t?a-1:a],d=[r&&1<e?e-1:e,r&&1<t?t-1:t],l=r?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+s[0]/d[0]+",\n          "+s[1]/d[1]+");\n      const vec2 inputShapeRC = vec2("+o+".0, "+a+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+l+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}}(),ReverseProgram=function(){return function(a,e){this.variableNames=["x"];var t=a.length;if(4<t)throw new Error("WebGL backend: Reverse of rank-"+t+" tensor is not yet supported");if(this.outputShape=a,1!==t){var r=a.map(function(t,r){return function(t){return-1!==e.indexOf(t)&&1!==a[t]?a[t]+" - coords["+t+"] - 1":"coords["+t+"]"}(r)}).join(","),n=getCoordsDataType(t);this.userCode="\n      void main() {\n        "+n+" coords = getOutputCoords();\n        setOutput(getX("+r+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+a[0]+" - coord - 1));\n        }\n      "}}(),ScatterProgram=function(){return function(m,e,t,r,n,o,a){void 0===a&&(a=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;var g=getCoordsDataType(n.length),s=getCoordsDataType(o.length),u="";1===t?u="i":2==t&&(u="i, j");var f="getIndices("+u+")",c="";1===r?c="i":2==r&&(c="i, coords[1]");var y="getUpdates("+c+")",d=1<e?"strides[j]":"strides";this.userCode="\n        "+g+" strides = "+g+"("+n+");\n\n        void main() {\n          "+s+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+m+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+e+"; j++) {\n              int index = round("+f+");\n              flattenedIndex += index * "+d+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+y+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "}}(),SegmentOpProgram=function(){return function(t){this.variableNames=["x","segmentIds"];var e=t.windowSize,r=t.batchSize,n=t.inSize,o=t.numSegments,a=o*_Mathceil(n/e);this.outputShape=[r,a];var i=4*_Mathfloor(e/4),s=e%4,l="";0<n%e&&(l="\n        if (inIdx < 0 || inIdx >= "+n+") {\n          return initializationValue;\n        }\n      ");var d="";0<n%e&&(d="\n        if (inIdx < 0 || inIdx >= "+n+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+l+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+d+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+o+")) * float("+e+"));\n        int currentSeg = int(mod(float(outIdx), float("+o+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+i+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+"\n        sumValue += dot(values, filter);\n    "+"\n        }\n\n        int inIdx = inOffset + "+i+";\n        if ("+(1==s)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+"\n        sumValue += dot(values, filter);\n    "+"\n        } else if ("+(2==s)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+"\n        sumValue += dot(values, filter);\n    "+"\n        } else if ("+(3==s)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+"\n        sumValue += dot(values, filter);\n    "+"\n        }\n        setOutput(sumValue);\n      }\n    "}}(),SelectProgram=function(){return function(p,e,t){var r,d;if(this.variableNames=["c","a","b"],this.outputShape=e,4<t)throw Error("Where for rank "+t+" is not yet supported");if(1===t)d="resRC",r="resRC";else{for(var c=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[],s=0;s<e.length;s++)i.push(""+c[s]),s<p&&a.push(""+c[s]);r=a.join(),d=i.join()}var m=getCoordsDataType(t);this.userCode="\n      void main() {\n        "+m+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+d+"));\n        } else {\n          setOutput(getB("+d+"));\n        }\n      }\n    "}}(),SliceProgram=function(){function t(a){this.variableNames=["source"],this.outputShape=a,this.rank=a.length;var e=getCoordsDataType(this.rank),t=getCoords$1(this.rank);this.userCode="\n      uniform "+e+" start;\n\n      void main() {\n        "+e+" sourceLoc = start + getOutputCoords();\n        setOutput(getSource("+t+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(a){var e=this;if(a.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+a.length+")");return function(t,r){if(null!=e.startLoc||(e.startLoc=t.getUniformLocationNoThrow(r,"start"),null!=e.startLoc))if(1===e.rank)t.gl.uniform1i(e.startLoc,a[0]);else if(2===e.rank)t.gl.uniform2i(e.startLoc,a[0],a[1]);else if(3===e.rank)t.gl.uniform3i(e.startLoc,a[0],a[1],a[2]);else{if(4!==e.rank)throw Error("Slicing for rank "+e.rank+" is not yet supported");t.gl.uniform4i(e.startLoc,a[0],a[1],a[2],a[3])}}},t}(),StridedSliceProgram=function(){return function(p,e,t,r){this.variableNames=["x"];var n=t.filter(function(a,e){return-1===r.indexOf(e)});this.outputShape=n;var o=t.length,a=getCoordsDataType(t.length),i=getCoordsDataType(n.length),s="";if(1===o)s="coords * strides + begin";else{var d=0;s=t.map(function(a,e){return-1===r.indexOf(e)?(d++,1===n.length?"coords * strides["+e+"] + begin["+e+"]":"coords["+(d-1)+"] * strides["+e+"] + begin["+e+"]"):"begin["+e+"]"}).join(",")}this.userCode="\n      "+a+" begin = "+a+"("+p+");\n      "+a+" strides = "+a+"("+e+");\n\n      void main() {\n        "+i+" coords = getOutputCoords();\n        setOutput(getX("+s+"));\n      }\n    "}}(),TextureManager=function(){function t(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(s,e,t){var r=getPhysicalFromLogicalTextureType(e,t),o=getKeyFromTextureShape(s,r,t),a;if(o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]),0<this.freeTextures[o].length){this.numFreeTextures--,this.numUsedTextures++,this.log();var p=this.freeTextures[o].shift();return this.usedTextures[o].push(p),p}return this.numUsedTextures++,this.log(),r===PhysicalTextureType.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(s[0],s[1]):r===PhysicalTextureType.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(s[0],s[1]):r===PhysicalTextureType.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(s[0],s[1]):r===PhysicalTextureType.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(s[0],s[1]):r===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(s[0],s[1])),this.usedTextures[o].push(a),a},t.prototype.releaseTexture=function(s,e,t,r){if(null!=this.freeTextures){var n=getKeyFromTextureShape(e,getPhysicalFromLogicalTextureType(t,r),r);n in this.freeTextures||(this.freeTextures[n]=[]),this.freeTextures[n].push(s),this.numFreeTextures++,this.numUsedTextures--;var o=this.usedTextures[n],a=o.indexOf(s);if(0>a)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(a,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+t+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var a=this;if(null!=this.freeTextures){for(var e in this.freeTextures)this.freeTextures[e].forEach(function(e){a.gpgpu.deleteMatrixTexture(e)});for(var e in this.usedTextures)this.usedTextures[e].forEach(function(e){a.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}(),TileProgram=function(){return function(s,e){this.variableNames=["A"];for(var t=Array(s.length),r=0;r<t.length;r++)t[r]=s[r]*e[r];this.outputShape=t,this.rank=t.length;var i=getCoordsDataType(this.rank),o=getSourceCoords$2(s);this.userCode="\n      void main() {\n        "+i+" resRC = getOutputCoords();\n        setOutput(getA("+o+"));\n      }\n    "}}(),TransposeProgram=function(){return function(s,e){this.variableNames=["A"];for(var t=Array(s.length),r=0;r<t.length;r++)t[r]=s[e[r]];this.outputShape=t,this.rank=t.length;var i=getCoordsDataType(this.rank),o=getSwitchedCoords(e);this.userCode="\n    void main() {\n      "+i+" resRC = getOutputCoords();\n      setOutput(getA("+o+"));\n    }\n    "}}(),ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429,SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805,UnaryOpProgram=function(){function t(a,e){this.variableNames=["A"],this.outputShape=a,this.userCode="\n      uniform float NAN;\n      float unaryOperation(float x) {\n        "+e+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(){var a=this;return function(e,t){null==a.startLoc&&(a.startLoc=e.getUniformLocationNoThrow(t,"NAN"),null==a.startLoc)||e.gl.uniform1f(a.startLoc,NaN)}},t}(),CHECK_NAN_SNIPPET$1="if (isNaN(x)) return x;",ABS="return abs(x);",RELU=CHECK_NAN_SNIPPET$1+"\n  return (x < 0.0) ? 0.0 : x;\n",ELU="return (x >= 0.0) ? x : (exp(x) - 1.0);",SELU="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+SELU_SCALEALPHA+";\n  float scale = "+SELU_SCALE+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n",NEG="return -x;",CEIL="return ceil(x);",FLOOR="return floor(x);",SIGN="\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n",ROUND="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",EXP="return exp(x);",EXPM1="return exp(x) - 1.0;",LOG="if (x < 0.0) return NAN;\n  return log(x);",LOG1P="return log(1.0 + x);",SQRT="return sqrt(x);",RSQRT="return inversesqrt(x);",SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));",SOFTPLUS="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",SIN=CHECK_NAN_SNIPPET$1+"\n  return sin(x);\n",COS=CHECK_NAN_SNIPPET$1+"\n  return cos(x);\n",TAN="return tan(x);",ASIN="return asin(x);",ACOS="return acos(x);",ATAN=CHECK_NAN_SNIPPET$1+"\n  return atan(x);\n",SINH="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",COSH="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",TANH="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",ASINH="return log(x + sqrt(x * x + 1.0));",ACOSH=CHECK_NAN_SNIPPET$1+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",ATANH=CHECK_NAN_SNIPPET$1+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",ERF="\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = "+ERF_P+";\n  float a1 = "+ERF_A1+";\n  float a2 = "+ERF_A2+";\n  float a3 = "+ERF_A3+";\n  float a4 = "+ERF_A4+";\n  float a5 = "+ERF_A5+";\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n",SQUARE="return x * x;",RECIPROCAL="return 1.0 / x;",LOGICAL_NOT="return float(!(x >= 1.0));",TO_INT="return float(int(x));",UnpackProgram=function(){return function(s){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=s;var e=s.length,t=getChannels("rc",e),r=getCoordsDataType(e),n=getSourceCoords$1(e,t),o=t.slice(-2),a=1===e?"rc":"vec2("+o.join(",")+")";this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n        vec4 packedInput = getA("+n+");\n\n        setOutput(getChannel(packedInput, "+a+"));\n      }\n    "}}(),concat=op({concat_:concat_}),concat1d=op({concat1d_:concat1d_}),concat2d=op({concat2d_:concat2d_}),concat3d=op({concat3d_:concat3d_}),concat4d=op({concat4d_:concat4d_}),split$1=op({split_:split_}),alea=createCommonjsModule(function(t){!function(a,e,t){function s(a,e){return e.c=a.c,e.s0=a.s0,e.s1=a.s1,e.s2=a.s2,e}function n(n,e){var t=new function(a){var o=this,e=(s=4022871197,function(t){t=t.toString();for(var a=0,o;a<t.length;a++)o=.02519603282416938*(s+=t.charCodeAt(a)),o-=s=o>>>0,s=(o*=s)>>>0,s+=4294967296*(o-=s);return 23283064365386963e-26*(s>>>0)}),s;o.next=function(){var t=2091639*o.s0+23283064365386963e-26*o.c;return o.s0=o.s1,o.s1=o.s2,o.s2=t-(o.c=0|t)},o.c=1,o.s0=e(" "),o.s1=e(" "),o.s2=e(" "),o.s0-=e(a),0>o.s0&&(o.s0+=1),o.s1-=e(a),0>o.s1&&(o.s1+=1),o.s2-=e(a),0>o.s2&&(o.s2+=1),e=null}(n),r=e&&e.state,o=t.next;return o.int32=function(){return 0|4294967296*t.next()},o.double=function(){return o()+11102230246251565e-32*(0|2097152*o())},o.quick=o,r&&("object"==typeof r&&s(r,t),o.state=function(){return s(t,{})}),o}e&&e.exports?e.exports=n:t&&t.amd?t(function(){return n}):this.alea=n}(0,t,!1)}),xor128=createCommonjsModule(function(t){!function(a,e,t){function s(a,e){return e.x=a.x,e.y=a.y,e.z=a.z,e.w=a.w,e}function n(n,e){var t=new function(a){var o=this,e="";o.x=0,o.y=0,o.z=0,o.w=0,o.next=function(){var t=o.x^o.x<<11;return o.x=o.y,o.y=o.z,o.z=o.w,o.w^=o.w>>>19^t^t>>>8},a===(0|a)?o.x=a:e+=a;for(var t=0;t<e.length+64;t++)o.x^=0|e.charCodeAt(t),o.next()}(n),r=e&&e.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do var a=((t.next()>>>11)+(t.next()>>>0)/4294967296)/2097152;while(0===a);return a},o.int32=t.next,o.quick=o,r&&("object"==typeof r&&s(r,t),o.state=function(){return s(t,{})}),o}e&&e.exports?e.exports=n:t&&t.amd?t(function(){return n}):this.xor128=n}(0,t,!1)}),xorwow=createCommonjsModule(function(t){!function(a,e,t){function s(a,e){return e.x=a.x,e.y=a.y,e.z=a.z,e.w=a.w,e.v=a.v,e.d=a.d,e}function n(n,e){var t=new function(a){var o=this,e="";o.next=function(){var t=o.x^o.x>>>2;return o.x=o.y,o.y=o.z,o.z=o.w,o.w=o.v,0|(o.d=0|o.d+362437)+(o.v=o.v^o.v<<4^t^t<<1)},o.x=0,o.y=0,o.z=0,o.w=0,o.v=0,a===(0|a)?o.x=a:e+=a;for(var t=0;t<e.length+64;t++)o.x^=0|e.charCodeAt(t),t==e.length&&(o.d=o.x<<10^o.x>>>4),o.next()}(n),r=e&&e.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do var a=((t.next()>>>11)+(t.next()>>>0)/4294967296)/2097152;while(0===a);return a},o.int32=t.next,o.quick=o,r&&("object"==typeof r&&s(r,t),o.state=function(){return s(t,{})}),o}e&&e.exports?e.exports=n:t&&t.amd?t(function(){return n}):this.xorwow=n}(0,t,!1)}),xorshift7=createCommonjsModule(function(t){!function(a,e,t){function s(a,e){return e.x=a.x.slice(),e.i=a.i,e}function n(n,i){null==n&&(n=+new Date);var t=new function(a){var s=this;s.next=function(){var t=s.x,a=s.i,n,o;return n=t[a],o=(n^=n>>>7)^n<<24,o^=(n=t[7&a+1])^n>>>10,o^=(n=t[7&a+3])^n>>>3,o^=(n=t[7&a+4])^n<<7,n=t[7&a+7],o^=(n^=n<<13)^n<<9,t[a]=o,s.i=7&a+1,o},function(a,e){var o=[],n;if(e===(0|e))o[0]=e;else for(e=""+e,n=0;n<e.length;++n)o[7&n]=o[7&n]<<15^e.charCodeAt(n)+o[7&n+1]<<13;for(;8>o.length;)o.push(0);for(n=0;8>n&&0===o[n];++n);for(8==n?o[7]=-1:o[n],a.x=o,a.i=0,n=256;0<n;--n)a.next()}(s,a)}(n),r=i&&i.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do var a=((t.next()>>>11)+(t.next()>>>0)/4294967296)/2097152;while(0===a);return a},o.int32=t.next,o.quick=o,r&&(r.x&&s(r,t),o.state=function(){return s(t,{})}),o}e&&e.exports?e.exports=n:t&&t.amd?t(function(){return n}):this.xorshift7=n}(0,t,!1)}),xor4096=createCommonjsModule(function(t){!function(a,e,t){function s(a,e){return e.i=a.i,e.w=a.w,e.X=a.X.slice(),e}function n(n,i){null==n&&(n=+new Date);var t=new function(a){var s=this;s.next=function(){var t=s.w,i=s.X,o=s.i,p,l;return s.w=t=0|t+1640531527,l=i[127&o+34],p=i[o=127&o+1],l^=l<<13,p^=p<<17,l^=l>>>15,p^=p>>>12,l=i[o]=l^p,s.i=o,0|l+(t^t>>>16)},function(p,e){var l=[],s=128,d,c,m,h,g;for(e===(0|e)?(c=e,e=null):(e+="\0",c=0,s=_Mathmax(s,e.length)),m=0,h=-32;h<s;++h)e&&(c^=e.charCodeAt((h+32)%e.length)),0===h&&(g=c),c^=c<<10,c^=c>>>15,c^=c<<4,c^=c>>>13,0<=h&&(g=0|g+1640531527,m=0==(d=l[127&h]^=c+g)?m+1:0);for(128<=m&&(l[127&(e&&e.length||0)]=-1),m=127,h=512;0<h;--h)c=l[127&m+34],d=l[m=127&m+1],c^=c<<13,d^=d<<17,c^=c>>>15,d^=d>>>12,l[m]=c^d;p.w=g,p.X=l,p.i=m}(s,a)}(n),r=i&&i.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do var a=((t.next()>>>11)+(t.next()>>>0)/4294967296)/2097152;while(0===a);return a},o.int32=t.next,o.quick=o,r&&(r.X&&s(r,t),o.state=function(){return s(t,{})}),o}e&&e.exports?e.exports=n:t&&t.amd?t(function(){return n}):this.xor4096=n}(0,t,!1)}),tychei=createCommonjsModule(function(t){!function(a,e,t){function s(a,e){return e.a=a.a,e.b=a.b,e.c=a.c,e.d=a.d,e}function n(n,e){var t=new function(a){var s=this,e="";s.next=function(){var t=s.b,a=s.c,i=s.d,p=s.a;return t=t<<25^t>>>7^a,a=0|a-i,i=i<<24^i>>>8^p,p=0|p-t,s.b=t=t<<20^t>>>12^a,s.c=a=0|a-i,s.d=i<<16^a>>>16^p,s.a=0|p-t},s.a=0,s.b=0,s.c=-1640531527,s.d=1367130551,a===_Mathfloor(a)?(s.a=0|a/4294967296,s.b=0|a):e+=a;for(var t=0;t<e.length+20;t++)s.b^=0|e.charCodeAt(t),s.next()}(n),r=e&&e.state,o=function(){return(t.next()>>>0)/4294967296};return o.double=function(){do var a=((t.next()>>>11)+(t.next()>>>0)/4294967296)/2097152;while(0===a);return a},o.int32=t.next,o.quick=o,r&&("object"==typeof r&&s(r,t),o.state=function(){return s(t,{})}),o}e&&e.exports?e.exports=n:t&&t.amd?t(function(){return n}):this.tychei=n}(0,t,!1)}),seedrandom=createCommonjsModule(function(a){!function(s,i){function e(a,e,n){var m=[],h=t(function s(e,t){var r=[],o=typeof e,a;if(t&&"object"==o)for(a in e)try{r.push(s(e[a],t-1))}catch(t){}return r.length?r:"string"==o?e:e+"\0"}((e=1==e?{entropy:!0}:e||{}).entropy?[a,p(s)]:null==a?function(){try{var t;return c&&(t=c.randomBytes)?t=t(256):(t=new Uint8Array(256),(d.crypto||d.msCrypto).getRandomValues(t)),p(t)}catch(t){var a=d.navigator,n=a&&a.plugins;return[+new Date,d,n,d.screen,p(s)]}}():a,3),m),g=new function(a){var p=a.length,l=this,n=0,d=l.i=l.j=0,u=l.S=[],s;for(p||(a=[p++]);n<256;)u[n]=n++;for(n=0;n<256;n++)u[n]=u[d=255&d+a[n%p]+(s=u[n])],u[d]=s;(l.g=function(a){for(var n=0,p=l.i,d=l.j,u=l.S,s;a--;)s=u[p=255&p+1],n=n*256+u[255&(u[p]=u[d=255&d+s])+(u[d]=s)];return l.i=p,l.j=d,n})(256)}(m),f=function(){for(var a=g.g(6),n=o,s=0;a<u;)a=(a+s)*256,n*=256,s=g.g(1);for(;a>=l;)a/=2,n/=2,s>>>=1;return(a+s)/n};return f.int32=function(){return 0|g.g(4)},f.quick=function(){return g.g(4)/4294967296},f.double=f,t(p(g.S),s),(e.pass||n||function(a,e,t,n){return n&&(n.S&&r(n,g),a.state=function(){return r(g,{})}),t?(i.random=a,e):a})(f,h,"global"in e?e.global:this==i,e.state)}function r(a,e){return e.i=a.i,e.j=a.j,e.S=a.S.slice(),e}function t(a,e){for(var t=a+"",n=0,s;n<t.length;)e[255&n]=255&(s^=19*e[255&n])+t.charCodeAt(n++);return p(e)}function p(t){return _StringfromCharCode.apply(0,t)}var d=this,o=i.pow(256,6),u=i.pow(2,52),l=2*u,c;if(i.seedrandom=e,t(i.random(),s),a.exports){a.exports=e;try{c=require("crypto")}catch(t){}}}([],Math)});seedrandom.alea=alea,seedrandom.xor128=xor128,seedrandom.xorwow=xorwow,seedrandom.xorshift7=xorshift7,seedrandom.xor4096=xor4096,seedrandom.tychei=tychei;var seedrandom$1=seedrandom,seedrandom_1=seedrandom$1.alea,MPRandGauss=function(){function t(s,e,t,r,n){this.mean=s,this.stdDev=e,this.dtype=t,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var o=n||Math.random();this.random=seedrandom_1(o.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var p=this.nextVal;return this.nextVal=NaN,p}for(var e=!1,l,d;!e;){var u=void 0,c=void 0,m=void 0;do m=(u=2*this.random()-1)*u+(c=2*this.random()-1)*c;while(1<=m||0===m);var h=_Mathsqrt(-2*_Mathlog(m)/m);l=this.mean+this.stdDev*u*h,d=this.mean+this.stdDev*c*h,this.truncated&&!this.isValidTruncated(l)||(e=!0)}return this.truncated&&!this.isValidTruncated(d)||(this.nextVal=this.convertValue(d)),this.convertValue(l)},t.prototype.convertValue=function(t){return null==this.dtype||"float32"===this.dtype?t:_Mathround(t)},t.prototype.isValidTruncated=function(t){return t<=this.upper&&t>=this.lower},t}(),batchToSpaceND=op({batchToSpaceND_:batchToSpaceND_}),cast=op({cast_:cast_}),clone=op({clone_:clone_}),cumsum=op({cumsum_:cumsum_}),depthToSpace=op({depthToSpace_:depthToSpace_}),expandDims=op({expandDims_:expandDims_}),eye=op({eye_:eye_}),fromPixels=op({fromPixels_:fromPixels_}),multinomial=op({multinomial_:multinomial_}),oneHot=op({oneHot_:oneHot_}),pad=op({pad_:pad_}),pad1d=op({pad1d_:pad1d_}),pad2d=op({pad2d_:pad2d_}),pad3d=op({pad3d_:pad3d_}),pad4d=op({pad4d_:pad4d_}),rand=op({rand_:rand_}),randomNormal=op({randomNormal_:randomNormal_}),randomUniform=op({randomUniform_:randomUniform_}),reshape=op({reshape_:reshape_}),spaceToBatchND=op({spaceToBatchND_:spaceToBatchND_}),squeeze=op({squeeze_:squeeze_}),stack=op({stack_:stack_}),tile=op({tile_:tile_}),truncatedNormal=op({truncatedNormal_:truncatedNormal_}),unstack=op({unstack_:unstack_}),setdiff1dAsync=setdiff1dAsync_,CPU_HANDOFF_SIZE_THRESHOLD=10,BEFORE_PAGING_CONSTANT=300,MATMUL_SHARED_DIM_THRESHOLD=1e3,MathBackendWebGL=function(){function t(a,e){if(void 0===e&&(e=!0),this.gpgpu=a,this.delayedStorage=e,this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.lruDataGPU=[],this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.binaryCache={},this.disposed=!1,1>ENV.get("WEBGL_VERSION"))throw new Error("WebGL is not supported on this device");if(null==a){var n=getWebGLContext(ENV.get("WEBGL_VERSION"));this.gpgpu=new GPGPUContext(n),this.canvas=n.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpuCreatedLocally=!1,this.canvas=a.gl.canvas;ENV.get("WEBGL_PAGING_ENABLED")&&(this.NUM_BYTES_BEFORE_PAGING=window.screen.height*window.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT),this.textureManager=new TextureManager(this.gpgpu)}return t.prototype.register=function(a,e,t){if(this.texData.has(a))throw new Error("Data buffer is already registered");this.texData.set(a,{shape:e,dtype:t,values:null,texture:null,complexTensors:null,texShape:null,usage:TextureUsage.RENDER,isPacked:!1})},t.prototype.setDataMover=function(t){this.texData=new DataStorage(t)},t.prototype.fromPixels=function(s,p){if(null==s)throw new Error("pixels passed to tf.fromPixels() can not be null");var t=[s.height,s.width],r=[s.height,s.width,p];if(!(s instanceof HTMLVideoElement||s instanceof HTMLImageElement||s instanceof HTMLCanvasElement||s instanceof ImageData))throw new Error("pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+s.constructor.name);if(s instanceof HTMLVideoElement){if(null==this.fromPixels2DContext){if(!ENV.get("IS_BROWSER"))throw new Error("Can't read pixels from HTMLImageElement outside the browser.");if("complete"!==document.readyState)throw new Error("The DOM is not ready yet. Please call tf.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object");this.fromPixels2DContext=document.createElement("canvas").getContext("2d")}this.fromPixels2DContext.canvas.width=s.width,this.fromPixels2DContext.canvas.height=s.height,this.fromPixels2DContext.drawImage(s,0,0,s.width,s.height),s=this.fromPixels2DContext.canvas}var n=this.makeTensorHandle(t,"int32");this.texData.get(n.dataId).usage=TextureUsage.PIXELS,this.gpgpu.uploadPixelDataToTexture(this.getTexture(n.dataId),s);var o=new FromPixelsProgram(r),a=this.compileAndRun(o,[n]);return this.disposeData(n.dataId),a},t.prototype.makeTensorHandle=function(a,e){var t={};return this.register(t,a,e),{dataId:t,shape:a,dtype:e}},t.prototype.write=function(p,e){if(null==e)throw new Error("MathBackendWebGL.write(): values can not be null");var t=this.texData.get(p),r=t.texture,n=t.texShape,o=t.usage,a=t.dtype,i=t.isPacked;if("complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");null!=r&&(this.releaseTexture(p,r,n,o,i),t.texture=null,t.texShape=null),t.usage=TextureUsage.UPLOAD,t.values=e,this.delayedStorage||this.uploadToGPU(p)},t.prototype.readSync=function(p){var e=this.texData.get(p),t=e.values,r=e.dtype,n=e.complexTensors;if(null!=t)return this.convertAndCacheOnCPU(p);var o=null!=this.activeTimers,s,l;return l=(o&&(s=performance.now()),"complex64"===r)?mergeRealAndImagArrays(n.real.dataSync(),n.imag.dataSync()):this.getValuesFromTexture(p),o&&(this.downloadWaitMs+=performance.now()-s),this.convertAndCacheOnCPU(p,l)},t.prototype.read=function(p){return __awaiter(this,void 0,void 0,function(){var d,e,m,h,g,f,y,b,x;return __generator(this,function(t){switch(t.label){case 0:if(this.pendingRead.has(p))return d=this.pendingRead.get(p),[2,new Promise(function(t){return d.push(t)})];if(e=this.texData.get(p),m=e.texture,h=e.values,g=e.texShape,null!=h)return[2,this.convertAndCacheOnCPU(p)];if(this.pendingRead.set(p,[]),!ENV.get("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ENV.get("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return f=this.gpgpu.maybeCreateBufferFromTexture(m,g[0],g[1]),[4,this.gpgpu.createAndWaitForFence()];case 1:return t.sent(),y=f instanceof WebGLTexture?this.getValuesFromTexture(p):this.gpgpu.downloadFloat32MatrixFromBuffer(f,g[0],g[1]),b=this.convertAndCacheOnCPU(p,y),x=this.pendingRead.get(p),this.pendingRead.delete(p),x.forEach(function(t){return t(b)}),this.pendingDisposal.has(p)&&(this.pendingDisposal.delete(p),this.disposeData(p)),[2,b];}})})},t.prototype.getValuesFromTexture=function(m){var e=this.texData.get(m),t=e.shape,r=e.dtype,n=e.texture,o=e.texShape;if(ENV.get("WEBGL_DOWNLOAD_FLOAT_ENABLED")){if(this.texData.get(m).isPacked){var a=sizeFromShape(t.slice(0,t.length-2)),i=1<t.length?t[t.length-2]:1,s=t[t.length-1];return this.gpgpu.downloadMatrixFromPackedTexture(n,a,i,s,o[0],o[1])}return this.gpgpu.downloadFloat32MatrixFromOutputTexture(n,o[0],o[1])}var u=this.makeTensorHandle(t,"float32");u.size=sizeFromShape(t),this.texData.get(u.dataId).usage=TextureUsage.DOWNLOAD;var l=new EncodeFloatProgram(t);this.compileAndRun(l,[{shape:t,dtype:r,dataId:m}],u,null,!1);var c=this.texData.get(u.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]);return this.disposeData(u.dataId),p},t.prototype.time=function(p){return __awaiter(this,void 0,void 0,function(){var e,l,d,c,m,h,g;return __generator(this,function(t){switch(t.label){case 0:return e=this.activeTimers,l=[],d=!1,null==this.programTimersStack?(this.programTimersStack=l,d=!0):this.activeTimers.push(l),this.activeTimers=l,p(),c=flatten(this.activeTimers.map(function(t){return t.query})).filter(function(t){return null!=t}),m=flatten(this.activeTimers.map(function(t){return t.name})).filter(function(t){return null!=t}),this.activeTimers=e,d&&(this.programTimersStack=null),[4,Promise.all(c)];case 1:return h=t.sent(),g={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:sum(h),getExtraProfileInfo:function(){return h.map(function(a,e){return{name:m[e],ms:a}}).map(function(t){return t.name+": "+t.ms}).join(", ")},wallMs:null},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,g];}})})},t.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},t.prototype.startTimer=function(){return 0<ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?this.gpgpu.beginQuery():{startMs:performance.now(),endMs:null}},t.prototype.endTimer=function(t){return 0<ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?(this.gpgpu.endQuery(),t):(t.endMs=performance.now(),t)},t.prototype.getQueryTime=function(a){return __awaiter(this,void 0,void 0,function(){var e;return __generator(this,function(){return 0<ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?[2,this.gpgpu.waitForQueryAndGetTime(a)]:[2,(e=a).endMs-e.startMs]})})},t.prototype.disposeData=function(s){if(!this.pendingDisposal.has(s))if(this.pendingRead.has(s))this.pendingDisposal.add(s);else if(this.texData.has(s)){var e=this.texData.get(s),t=e.texture,r=e.texShape,n=e.usage,o=e.complexTensors,a=e.isPacked;null!=t&&this.releaseTexture(s,t,r,n,a),null!=o&&(o.real.dispose(),o.imag.dispose()),this.texData.delete(s)}},t.prototype.getTexture=function(t){return this.uploadToGPU(t),this.texData.get(t).texture},t.prototype.getCPUBackend=function(){return ENV.get("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=ENV.findBackend("cpu")),this.cpuBackend):null},t.prototype.shouldExecuteOnCPU=function(a,n){var o=this;return void 0===n&&(n=CPU_HANDOFF_SIZE_THRESHOLD),null!=this.getCPUBackend()&&a.every(function(t){return null==o.texData.get(t.dataId).texture&&t.size<n})},t.prototype.getGPGPUContext=function(){return this.gpgpu},t.prototype.getCanvas=function(){return this.canvas},t.prototype.complex=function(a,e){var t=this.makeOutputArray(a.shape,"complex64");return this.texData.get(t.dataId).complexTensors={real:ENV.engine.keep(a.clone()),imag:ENV.engine.keep(e.clone())},t},t.prototype.real=function(t){return this.texData.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.texData.get(t.dataId).complexTensors.imag.clone()},t.prototype.slice=function(a,e,t){if(this.shouldExecuteOnCPU([a]))return this.cpuBackend.slice(a,e,t);var r=new SliceProgram(t),n=r.getCustomSetupFunc(e);return this.compileAndRun(r,[a],null,n)},t.prototype.stridedSlice=function(m,e,t,r,n,o,a,i,s){if(this.shouldExecuteOnCPU([m]))return this.cpuBackend.stridedSlice(m,e,t,r,n,o,a,i,s);var u=getStridedSlicedInfo(m.shape,e,t,r,n,o,a,i,s),l=u[0],c=u[1],p=u[2],d=c.filter(function(a,e){return-1===p.indexOf(e)});if(d.some(function(t){return 0===t}))return tensor([],d);var h=new StridedSliceProgram(l,r,c,p);return this.compileAndRun(h,[m])},t.prototype.reverse=function(a,e){var t=new ReverseProgram(a.shape,e);return this.compileAndRun(t,[a])},t.prototype.concat2Tensors=function(s,e,t){var r=computeOutShape([s.shape,e.shape],t),n=s.as2D(-1,sizeFromShape(s.shape.slice(t))),o=e.as2D(-1,sizeFromShape(e.shape.slice(t))),a=new ConcatProgram(n.shape,o.shape);return this.compileAndRun(a,[n,o]).reshape(r)},t.prototype.concat=function(a,e){if(this.shouldExecuteOnCPU(a))return this.cpuBackend.concat(a,e);if(1===a.length)return a[0];for(var t=a[0],o=1;o<a.length;++o)t=this.concat2Tensors(t,a[o],e);return t},t.prototype.neg=function(a){var e=new UnaryOpProgram(a.shape,NEG);return this.compileAndRun(e,[a])},t.prototype.batchMatMul=function(m,g,y,r){var n=y?m.shape[2]:m.shape[1],o=r?g.shape[1]:g.shape[2],a=y?m.shape[1]:m.shape[2],i=m.shape[0];if((1===n||1===o)&&a>MATMUL_SHARED_DIM_THRESHOLD){y&&(m=m.transpose([0,2,1])),r&&(g=g.transpose([0,2,1]));var s=1===o?m:m.as3D(i,a,1),u=1===o?2:1,l=1===o?g.as3D(i,1,a):g;return this.multiply(s,l).sum(u,!0)}if(1===i){var c=m.as2D(m.shape[1],m.shape[2]),p=g.as2D(g.shape[1],g.shape[2]),d=new MatMulPackedProgram(c.shape,p.shape,[n,o],y,r),h=this.compileAndRun(d,[c,p],this.makePackedTensor(d.outputShape));return!1===ENV.get("WEBGL_LAZILY_UNPACK")&&(h=this.unpackTensor(h)),h.reshape([1,h.shape[0],h.shape[1]])}return this.compileAndRun(new MatMulProgram(m.shape,g.shape,y,r),[m,g])},t.prototype.multiply=function(d,e){if("complex64"===d.dtype){var t=this.texData.get(d.dataId),r=this.texData.get(e.dataId),n=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,d.shape,e.shape),o=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,d.shape,e.shape),a=[this.makeComplexComponentTensorHandle(d,t.complexTensors.real),this.makeComplexComponentTensorHandle(d,t.complexTensors.imag),this.makeComplexComponentTensorHandle(e,r.complexTensors.real),this.makeComplexComponentTensorHandle(e,r.complexTensors.imag)],i=this.compileAndRun(n,a),s=this.compileAndRun(o,a),u=this.complex(i,s);return i.dispose(),s.dispose(),u}if(this.shouldExecuteOnCPU([d,e]))return this.cpuBackend.multiply(d,e);var l=new BinaryOpProgram(MUL,d.shape,e.shape),c=this.makeOutputArray(l.outputShape,d.dtype);return this.compileAndRun(l,[d,e],c)},t.prototype.batchNormalization=function(d,e,t,r,n,o){var a=[d,e,t],i=null;null!=o&&(i=o.shape,a.push(o));var m=null;null!=n&&(m=n.shape,a.push(n));var h=null,g=BatchNormProgram;ENV.get("WEBGL_PACK_BATCHNORMALIZATION")&&(h=this.makePackedTensor(d.shape),g=BatchNormPackedProgram);var f=new g(d.shape,e.shape,t.shape,i,m,r);return this.compileAndRun(f,a,h)},t.prototype.localResponseNormalization4D=function(s,e,t,r,n){var o=new LRNProgram(s.shape,e,t,r,n);return this.compileAndRun(o,[s])},t.prototype.LRNGrad=function(p,e,t,r,n,o,a){var i=new LRNGradProgram(e.shape,r,n,o,a);return this.compileAndRun(i,[e,t,p])},t.prototype.tile=function(a,e){var t=new TileProgram(a.shape,e);return this.compileAndRun(t,[a])},t.prototype.pad=function(a,e,t){var r=new PadProgram(a.shape,e,t);return this.compileAndRun(r,[a])},t.prototype.transpose=function(a,e){var t=new TransposeProgram(a.shape,e);return this.compileAndRun(t,[a])},t.prototype.gather=function(a,e,t){var r=new GatherProgram(a.shape,e.size,t);return this.compileAndRun(r,[a,e])},t.prototype.batchToSpaceND=function(p,e,t){assert(4>=p.rank,"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");var r=e.reduce(function(a,e){return a*e}),n=getReshaped(p.shape,e,r),o=getPermuted(n.length,e.length),a=getReshapedPermuted(p.shape,e,r),i=getSliceBeginCoords(t,e.length),s=getSliceSize(a,t,e.length);return p.reshape(n).transpose(o).reshape(a).slice(i,s)},t.prototype.spaceToBatchND=function(p,e,t){assert(4>=p.rank,"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");var r=e.reduce(function(a,e){return a*e}),n=[[0,0]];n.push.apply(n,t);for(var o=1+e.length;o<p.shape.length;++o)n.push([0,0]);var d=p.pad(n),i=getReshaped(d.shape,e,r,!1),s=getPermuted(i.length,e.length,!1),u=getReshapedPermuted(d.shape,e,r,!1);return d.reshape(i).transpose(s).reshape(u)},t.prototype.reduce=function(p,e,t){var r=p.shape[0],n=p.shape[1],o=computeOptimalWindowSize(n),a=new ReduceProgram({windowSize:o,inSize:n,batchSize:r},e),i=a.outputShape,s=i[0],d=i[1],l=this.makeOutputArray([s,d],t);return this.compileAndRun(a,[p],l),1===l.shape[1]?l:this.reduce(l,e,t)},t.prototype.argReduce=function(d,e,t){void 0===t&&(t=null);var m=d.shape[0],h=d.shape[1];null!=t&&(m=t.shape[0],h=t.shape[1]);var g=computeOptimalWindowSize(h),a=new ArgMinMaxProgram({windowSize:g,inSize:h,batchSize:m},e,null==t),i=a.outputShape,s=i[0],u=i[1],l=this.makeOutputArray([s,u],"int32"),c=[d];return null!=t&&c.push(t),this.compileAndRun(a,c,l),1===l.shape[1]?l:this.argReduce(d,e,l)},t.prototype.sum=function(s,e){assertAxesAreInnerMostDims("sum",e,s.rank);var t=computeOutAndReduceShapes(s.shape,e),r=t[0],n=sizeFromShape(t[1]),o=s.as2D(-1,n),a=sumOutType(s.dtype);return this.reduce(o,"sum",a).reshape(r)},t.prototype.prod=function(s,e){var t=computeOutAndReduceShapes(s.shape,e),r=t[0],n=sizeFromShape(t[1]),o=s.as2D(-1,n),a=sumOutType(s.dtype);return this.reduce(o,"prod",a).reshape(r)},t.prototype.unsortedSegmentSum=function(p,e,t){var r=0,d=getAxesPermutation([r],p.rank),o=p;null!=d&&(o=p.transpose(d),r=getInnerMostAxes(1,p.rank)[0]);var m=computeOutShape$1(o.shape,r,t),i=sizeFromShape([o.shape[r]]),s=o.as2D(-1,i),u=sumOutType(p.dtype),l=this.segOpCompute(s,"unsortedSegmentSum",e,u,t).reshape(m);return null!=d&&(l=l.transpose(getUndoAxesPermutation(d))),l},t.prototype.segOpCompute=function(m,e,t,h,n){var o=m.shape[0],a=m.shape[1],i=segOpComputeOptimalWindowSize(a,n),s=new SegmentOpProgram({windowSize:i,inSize:a,batchSize:o,numSegments:n},e),u=s.outputShape,l=u[0],c=u[1],p=this.makeOutputArray([l,c],h);return this.compileAndRun(s,[m,t],p),p.shape[1]===n?p:(t=range(0,n).tile([a/i]),this.segOpCompute(p,e,t,h,n))},t.prototype.argMin=function(s,e){var t=[e];assertAxesAreInnerMostDims("argMin",t,s.rank);var r=computeOutAndReduceShapes(s.shape,t),n=r[0],o=sizeFromShape(r[1]),a=s.as2D(-1,o);return this.argReduce(a,"min").reshape(n)},t.prototype.argMax=function(s,e){var t=[e];assertAxesAreInnerMostDims("argMax",t,s.rank);var r=computeOutAndReduceShapes(s.shape,t),n=r[0],o=sizeFromShape(r[1]),a=s.as2D(-1,o);return this.argReduce(a,"max").reshape(n)},t.prototype.cumsum=function(a,e,t,r){if(e!==a.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(a.rank-1)+" but got axis="+e);var n=new CumSumProgram(a.shape,t,r);return this.compileAndRun(n,[a])},t.prototype.equal=function(a,e){var t=new BinaryOpProgram(EQUAL,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.notEqual=function(a,e){var t=new BinaryOpProgram(NOT_EQUAL,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.less=function(a,e){if(this.shouldExecuteOnCPU([a,e]))return this.cpuBackend.less(a,e);var t=new BinaryOpProgram(LESS,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.lessEqual=function(a,e){var t=new BinaryOpProgram(LESS_EQUAL,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.greater=function(a,e){if(this.shouldExecuteOnCPU([a,e]))return this.cpuBackend.greater(a,e);var t=new BinaryOpProgram(GREATER,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.greaterEqual=function(a,e){var t=new BinaryOpProgram(GREATER_EQUAL,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.logicalNot=function(a){var e=new UnaryOpProgram(a.shape,LOGICAL_NOT);return this.compileAndRun(e,[a])},t.prototype.logicalAnd=function(a,e){var t=new BinaryOpProgram(LOGICAL_AND,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.logicalOr=function(a,e){var t=new BinaryOpProgram(LOGICAL_OR,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"bool");return this.compileAndRun(t,[a,e],r)},t.prototype.select=function(a,e,t){var r=new SelectProgram(a.rank,e.shape,e.rank),n=this.makeOutputArray(r.outputShape,upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[a,e,t],n)},t.prototype.where=function(a){warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var e=a.dataSync();return whereImpl(a.shape,e)},t.prototype.topk=function(a,e,t){return topkImpl(a.dataSync(),a.shape,a.dtype,e,t)},t.prototype.min=function(s,e){assertAxesAreInnerMostDims("min",e,s.rank);var t=computeOutAndReduceShapes(s.shape,e),r=t[0],n=sizeFromShape(t[1]),o=s.as2D(-1,n);return this.reduce(o,"min",o.dtype).reshape(r)},t.prototype.minimum=function(a,e){if(this.shouldExecuteOnCPU([a,e]))return this.cpuBackend.minimum(a,e);var t=new BinaryOpProgram(MIN,a.shape,e.shape);return this.compileAndRun(t,[a,e])},t.prototype.mod=function(a,e){var t=new BinaryOpProgram(MOD,a.shape,e.shape),r=t.getCustomSetupFunc();return this.compileAndRun(t,[a,e],null,r)},t.prototype.max=function(s,e){assertAxesAreInnerMostDims("max",e,s.rank);var t=computeOutAndReduceShapes(s.shape,e),r=t[0],n=sizeFromShape(t[1]),o=s.as2D(-1,n);return this.reduce(o,"max",o.dtype).reshape(r)},t.prototype.maximum=function(a,e){if(this.shouldExecuteOnCPU([a,e]))return this.cpuBackend.maximum(a,e);var t=new BinaryOpProgram(MAX,a.shape,e.shape);return this.compileAndRun(t,[a,e])},t.prototype.all=function(s,e){assertAxesAreInnerMostDims("all",e,s.rank);var t=computeOutAndReduceShapes(s.shape,e),r=t[0],n=sizeFromShape(t[1]),o=s.as2D(-1,n);return this.reduce(o,"all",o.dtype).reshape(r)},t.prototype.any=function(s,e){assertAxesAreInnerMostDims("any",e,s.rank);var t=computeOutAndReduceShapes(s.shape,e),r=t[0],n=sizeFromShape(t[1]),o=s.as2D(-1,n);return this.reduce(o,"any",o.dtype).reshape(r)},t.prototype.squaredDifference=function(a,e){var t=new BinaryOpProgram(SQUARED_DIFFERENCE,a.shape,e.shape);return this.compileAndRun(t,[a,e])},t.prototype.realDivide=function(a,e){var t=new BinaryOpProgram(DIV,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"float32");return this.compileAndRun(t,[a,e],r)},t.prototype.floorDiv=function(a,e){var t=new BinaryOpProgram(INT_DIV,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,"int32");return this.compileAndRun(t,[a,e],r)},t.prototype.add=function(a,e){if("complex64"===a.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(a,e,ADD);var t=new BinaryOpProgram(ADD,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,upcastType(a.dtype,e.dtype));return this.compileAndRun(t,[a,e],r)},t.prototype.complexSeparableBinaryOp=function(p,e,t){var r=this,n=this.texData.get(p.dataId),o=this.texData.get(e.dataId),a=[[n.complexTensors.real,o.complexTensors.real],[n.complexTensors.imag,o.complexTensors.imag]].map(function(n){var o=n[0],a=n[1],i=new BinaryOpProgram(t,p.shape,e.shape),s=r.makeOutputArray(i.outputShape,upcastType(o.dtype,a.dtype)),d=r.makeComplexComponentTensorHandle(p,o),l=r.makeComplexComponentTensorHandle(e,a);return r.compileAndRun(i,[d,l],s)}),i=a[0],s=a[1],d=this.complex(i,s);return i.dispose(),s.dispose(),d},t.prototype.makeComplexComponentTensorHandle=function(a,e){return{dataId:e.dataId,dtype:e.dtype,shape:a.shape}},t.prototype.addN=function(a){for(var e=a[0],n=1;n<a.length;n++)e=this.add(e,a[n]);return e},t.prototype.subtract=function(a,e){if("complex64"===a.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(a,e,SUB);if(this.shouldExecuteOnCPU([a,e]))return this.cpuBackend.subtract(a,e);var t=new BinaryOpProgram(SUB,a.shape,e.shape),r=this.makeOutputArray(t.outputShape,upcastType(a.dtype,e.dtype));return this.compileAndRun(t,[a,e],r)},t.prototype.pow=function(a,e){var t=new BinaryOpProgram(POW,a.shape,e.shape),r=t.getCustomSetupFunc(),n=this.makeOutputArray(t.outputShape,upcastType(a.dtype,e.dtype));return this.compileAndRun(t,[a,e],n,r)},t.prototype.ceil=function(a){var e=new UnaryOpProgram(a.shape,CEIL);return this.compileAndRun(e,[a])},t.prototype.floor=function(a){var e=new UnaryOpProgram(a.shape,FLOOR);return this.compileAndRun(e,[a])},t.prototype.sign=function(a){var e=new UnaryOpProgram(a.shape,SIGN);return this.compileAndRun(e,[a])},t.prototype.round=function(a){var e=new UnaryOpProgram(a.shape,ROUND);return this.compileAndRun(e,[a])},t.prototype.exp=function(a){var e=new UnaryOpProgram(a.shape,EXP);return this.compileAndRun(e,[a])},t.prototype.expm1=function(a){var e=new UnaryOpProgram(a.shape,EXPM1);return this.compileAndRun(e,[a])},t.prototype.log=function(a){var e=new UnaryOpProgram(a.shape,LOG),t=e.getCustomSetupFunc();return this.compileAndRun(e,[a],null,t)},t.prototype.log1p=function(a){var e=new UnaryOpProgram(a.shape,LOG1P);return this.compileAndRun(e,[a])},t.prototype.sqrt=function(a){var e=new UnaryOpProgram(a.shape,SQRT);return this.compileAndRun(e,[a])},t.prototype.rsqrt=function(a){var e=new UnaryOpProgram(a.shape,RSQRT);return this.compileAndRun(e,[a])},t.prototype.square=function(a){var e=new UnaryOpProgram(a.shape,SQUARE);return this.compileAndRun(e,[a])},t.prototype.reciprocal=function(a){var e=new UnaryOpProgram(a.shape,RECIPROCAL);return this.compileAndRun(e,[a])},t.prototype.relu=function(a){var e=new UnaryOpProgram(a.shape,RELU);return this.compileAndRun(e,[a])},t.prototype.elu=function(a){var e=new UnaryOpProgram(a.shape,ELU);return this.compileAndRun(e,[a])},t.prototype.eluDer=function(a,e){var t=new BinaryOpProgram(ELU_DER,a.shape,e.shape);return this.compileAndRun(t,[a,e])},t.prototype.selu=function(a){var e=new UnaryOpProgram(a.shape,SELU);return this.compileAndRun(e,[a])},t.prototype.int=function(a){var e=new UnaryOpProgram(a.shape,TO_INT),t=this.makeOutputArray(e.outputShape,"int32");return this.compileAndRun(e,[a],t)},t.prototype.clip=function(a,e,t){var r=new ClipProgram(a.shape,e,t);return this.compileAndRun(r,[a])},t.prototype.abs=function(a){var e=new UnaryOpProgram(a.shape,ABS);return this.compileAndRun(e,[a])},t.prototype.complexAbs=function(a){var e=this.texData.get(a.dataId),t=new ComplexAbsProgram(a.shape),r=[this.makeComplexComponentTensorHandle(a,e.complexTensors.real),this.makeComplexComponentTensorHandle(a,e.complexTensors.imag)];return this.compileAndRun(t,r)},t.prototype.sigmoid=function(a){var e=new UnaryOpProgram(a.shape,SIGMOID);return this.compileAndRun(e,[a])},t.prototype.softplus=function(a){var e=new UnaryOpProgram(a.shape,SOFTPLUS);return this.compileAndRun(e,[a])},t.prototype.sin=function(a){var e=new UnaryOpProgram(a.shape,SIN);return this.compileAndRun(e,[a])},t.prototype.cos=function(a){var e=new UnaryOpProgram(a.shape,COS);return this.compileAndRun(e,[a])},t.prototype.tan=function(a){var e=new UnaryOpProgram(a.shape,TAN);return this.compileAndRun(e,[a])},t.prototype.asin=function(a){var e=new UnaryOpProgram(a.shape,ASIN);return this.compileAndRun(e,[a])},t.prototype.acos=function(a){var e=new UnaryOpProgram(a.shape,ACOS);return this.compileAndRun(e,[a])},t.prototype.atan=function(a){var e=new UnaryOpProgram(a.shape,ATAN);return this.compileAndRun(e,[a])},t.prototype.atan2=function(a,e){var t=new BinaryOpProgram(ATAN2,a.shape,e.shape);return this.compileAndRun(t,[a,e])},t.prototype.sinh=function(a){var e=new UnaryOpProgram(a.shape,SINH);return this.compileAndRun(e,[a])},t.prototype.cosh=function(a){var e=new UnaryOpProgram(a.shape,COSH);return this.compileAndRun(e,[a])},t.prototype.tanh=function(a){var e=new UnaryOpProgram(a.shape,TANH);return this.compileAndRun(e,[a])},t.prototype.asinh=function(a){var e=new UnaryOpProgram(a.shape,ASINH);return this.compileAndRun(e,[a])},t.prototype.acosh=function(a){var e=new UnaryOpProgram(a.shape,ACOSH),t=e.getCustomSetupFunc();return this.compileAndRun(e,[a],null,t)},t.prototype.atanh=function(a){var e=new UnaryOpProgram(a.shape,ATANH),t=e.getCustomSetupFunc();return this.compileAndRun(e,[a],null,t)},t.prototype.erf=function(a){var e=new UnaryOpProgram(a.shape,ERF);return this.compileAndRun(e,[a])},t.prototype.step=function(a,e){var t=new UnaryOpProgram(a.shape,STEP(e));return this.compileAndRun(t,[a])},t.prototype.conv2dWithIm2Row=function(y,e,t){var r=t.filterWidth,n=t.filterHeight,o=t.inChannels,a=t.outWidth,i=t.outHeight,s=r*n*o,u=i*a,l=[s,u],c=y.squeeze([0]),p=e.reshape([s,-1]),d=new Im2ColProgram(l,c.shape,t),h=this.compileAndRun(d,[c],this.makePackedTensor(l)),f=new MatMulPackedProgram(h.shape,p.shape,[u,t.outChannels],!0,!1),m=this.compileAndRun(f,[h,p],this.makePackedTensor(f.outputShape));return!1===ENV.get("WEBGL_LAZILY_UNPACK")&&(m=this.unpackTensor(m)),m.reshape([1,i,a,t.outChannels])},t.prototype.conv2d=function(a,e,t){if(ENV.get("WEBGL_CONV_IM2COL")&&1===a.shape[0])return this.conv2dWithIm2Row(a,e,t);var r=new Conv2DProgram(t);return this.compileAndRun(r,[a,e])},t.prototype.conv2dDerInput=function(a,e,t){var r=new Conv2DDerInputProgram(t);return this.compileAndRun(r,[a,e])},t.prototype.conv2dDerFilter=function(a,e,t){var r=new Conv2DDerFilterProgram(t);return this.compileAndRun(r,[a,e])},t.prototype.depthwiseConv2D=function(a,e,t){var r=new DepthwiseConv2DProgram(t);return this.compileAndRun(r,[a,e])},t.prototype.depthwiseConv2DDerInput=function(a,e,t){var r=new DepthwiseConv2DDerInputProgram(t);return this.compileAndRun(r,[a,e])},t.prototype.depthwiseConv2DDerFilter=function(a,e,t){var r=new DepthwiseConv2DDerFilterProgram(t);return this.compileAndRun(r,[a,e])},t.prototype.maxPool=function(a,e){var t=new Pool2DProgram(e,"max",!1),r=this.makeOutputArray(t.outputShape,a.dtype);return this.compileAndRun(t,[a],r)},t.prototype.avgPool=function(a,e){var t=new Pool2DProgram(e,"avg",!1),r=this.makeOutputArray(t.outputShape,"float32");return this.compileAndRun(t,[a],r)},t.prototype.maxPoolBackprop=function(p,e,t,r){var n=new Pool2DProgram(r,"max",!0),o=this.compileAndRun(n,[e]),a=new MaxPool2DBackpropProgram(r),i=this.makeOutputArray(a.outputShape,e.dtype),s=this.compileAndRun(a,[p,o],i);return o.dispose(),s},t.prototype.avgPoolBackprop=function(a,e,t){var r=new AvgPool2DBackpropProgram(t),n=this.makeOutputArray(r.outputShape,e.dtype);return this.compileAndRun(r,[a],n)},t.prototype.cast=function(a,e){return castTensor(a,e,this)},t.prototype.reshape=function(a,e){return this.texData.get(a.dataId).isPacked&&!isReshapeFree(a.shape,e)?this.packedReshape(a,e):reshapeTensor(a,e)},t.prototype.resizeBilinear=function(a,e,t,r){var n=new ResizeBilinearProgram(a.shape,e,t,r);return this.compileAndRun(n,[a])},t.prototype.resizeBilinearBackprop=function(a,e,t){var r=new ResizeBilinearBackpropProgram(a,e,t);return this.compileAndRun(r,[a])},t.prototype.resizeNearestNeighbor=function(a,e,t,r){var n=new ResizeNearestNeighborProgram(a.shape,e,t,r);return this.compileAndRun(n,[a])},t.prototype.resizeNearestNeighborBackprop=function(a,e,t){var r=new ResizeNearestNeigborBackpropProgram(a,e,t);return this.compileAndRun(r,[a])},t.prototype.multinomial=function(p,e,t,r){var n=e?p:softmax(p),o=n.shape[0],a=n.shape[1],i=new MultinomialProgram(o,a,t),s=this.makeOutputArray(i.outputShape,"int32"),d=i.getCustomSetupFunc(r);return this.compileAndRun(i,[n],s,d)},t.prototype.oneHot=function(a,e,t,r){var n=new OneHotProgram(a.size,e,t,r);return this.compileAndRun(n,[a])},t.prototype.nonMaxSuppression=function(a,e,t,r,n){return warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),nonMaxSuppressionImpl(a.dataSync(),e.dataSync(),t,r,n)},t.prototype.cropAndResize=function(s,e,t,r,n,o){var a=new CropAndResizeProgram(s.shape,e.shape,r,n,o);return this.compileAndRun(a,[s,e,t])},t.prototype.depthToSpace=function(p,e,t){assert(1<e,"blockSize should be > 1 for depthToSpace, but was: "+e);var r=p.shape[0],n=("NHWC"===t?p.shape[1]:p.shape[2])*e,o=("NHWC"===t?p.shape[2]:p.shape[3])*e,a=("NHWC"===t?p.shape[3]:p.shape[1])/(e*e),i=new DepthToSpaceProgram("NHWC"===t?[r,n,o,a]:[r,a,n,o],e,t);return this.compileAndRun(i,[p])},t.prototype.split=function(a,e,t){return split(a,e,t)},t.prototype.scatterND=function(l,e,t){var r=calculateShapes(e,l,t),n=r.sliceRank,o=r.numUpdates,a=r.sliceSize,i=r.strides,s=r.outputSize,u=l.reshape([o,n]),c=e.reshape([o,a]);if(0===s)return reshapeTensor(tensor([]),t);var p=scalar(0),d=new ScatterProgram(o,n,u.rank,c.rank,i,[s/a,a]);return this.compileAndRun(d,[c,u,p]).reshape(t)},t.prototype.sparseToDense=function(p,e,t,r){var n=calculateShapes(e,p,t),o=n.sliceRank,a=n.numUpdates,i=n.strides,s=n.outputSize,d=new ScatterProgram(a,o,p.rank,e.rank,i,[s,1],!1);return this.compileAndRun(d,[e,p,r]).reshape(t)},t.prototype.fft=function(t){return this.fftImpl(t,!1)},t.prototype.ifft=function(t){return this.fftImpl(t,!0)},t.prototype.fftImpl=function(p,e){var t=this.texData.get(p.dataId),r=new FFTProgram(COMPLEX_FFT.REAL,p.shape,e),n=new FFTProgram(COMPLEX_FFT.IMAG,p.shape,e),o=[this.makeComplexComponentTensorHandle(p,t.complexTensors.real),this.makeComplexComponentTensorHandle(p,t.complexTensors.imag)],a=this.compileAndRun(r,o),i=this.compileAndRun(n,o),s=this.complex(a,i).as2D(p.shape[0],p.shape[1]);return a.dispose(),i.dispose(),s},t.prototype.gatherND=function(d,e){var t=e.shape,r=t[t.length-1],n=prepareAndValidate(d,e),o=n[0],a=n[1],i=n[2],s=n[3],u=e.reshape([a,r]),l=d.reshape([d.size/i,i]),c=new GatherNDProgram(r,s,[a,i]);return this.compileAndRun(c,[l,u]).reshape(o)},t.prototype.makeOutputArray=function(a,e){return Tensor.make(a,{},e)},t.prototype.makePackedTensor=function(a){var e=Tensor.make(a,{});return this.texData.get(e.dataId).isPacked=!0,e},t.prototype.unpackTensor=function(a){var e=new UnpackProgram(a.shape);return this.compileAndRun(e,[a])},t.prototype.getBatchDim=function(a,e){return void 0===e&&(e=2),sizeFromShape(a.slice(0,a.length-e))},t.prototype.getRowsCols=function(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[1<t.length?t[t.length-2]:1,t[t.length-1]]},t.prototype.packedReshape=function(a,e){var t=a.reshape([this.getBatchDim(a.shape)].concat(this.getRowsCols(a.shape))),r=[this.getBatchDim(e)].concat(this.getRowsCols(e)),n=new ReshapePackedProgram(r,t.shape);return this.compileAndRun(n,[t],this.makePackedTensor(r)).reshape(e)},t.prototype.compileAndRun=function(y,e,t,b,n){var x=this;if(void 0===n&&(n=!0),null==t&&(t=this.makeOutputArray(y.outputShape,e[0].dtype)),0===t.size)return this.texData.get(t.dataId).values=getTypedArrayFromDType(t.dtype,0),t;var a=e.map(function(e){if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var a=x.texData.get(e.dataId);if(null==a.texture&&(a.isPacked||!y.usesPackedTextures)&&sizeFromShape(e.shape)<=ENV.get("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:x.readSync(e.dataId)};if(a.isPacked!==!!y.usesPackedTextures){var s,i;a.isPacked?(s=new UnpackProgram(e.shape),i=x.compileAndRun(s,[e])):(s=new PackProgram(e.shape),i=x.compileAndRun(s,[e],x.makePackedTensor(e.shape))),a=x.texData.get(i.dataId),e=i}return x.uploadToGPU(e.dataId),{shape:e.shape,texData:a,isUniform:!1}});this.uploadToGPU(t.dataId);var i={shape:t.shape,texData:this.texData.get(t.dataId),isUniform:!1},u=makeShaderKey(y,a,i),l=this.getAndSaveBinary(u,function(){return compileProgram(x.gpgpu,y,a,i)}),c=null!=this.activeTimers,p;if(c&&(p=this.startTimer()),runProgram(l,a,i,b),ENV.get("WEBGL_PAGING_ENABLED")&&n&&this.numBytesInGPU>this.NUM_BYTES_BEFORE_PAGING)for(var N=this.numBytesInGPU-this.NUM_BYTES_BEFORE_PAGING;0<N&&0<this.lruDataGPU.length;){var I=this.lruDataGPU.shift(),h=this.texData.get(I),f=h.shape,m=h.dtype;N-=this.computeBytes(f,m),this.read(I)}return c&&(p=this.endTimer(p),this.activeTimers.push({name:y.constructor.name,query:this.getQueryTime(p)})),t},t.prototype.getAndSaveBinary=function(a,e){return a in this.binaryCache||(this.binaryCache[a]=e()),this.binaryCache[a]},t.prototype.getTextureManager=function(){return this.textureManager},t.prototype.dispose=function(){if(!this.disposed){for(var t in this.binaryCache)this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram);this.textureManager.dispose(),this.canvas.remove(),null!=this.fromPixels2DContext&&this.fromPixels2DContext.canvas.remove(),this.gpgpuCreatedLocally&&this.gpgpu.dispose(),this.disposed=!0}},t.prototype.floatPrecision=function(){var t=this;return tidy(function(){return 0<t.abs(scalar(1e-8)).get()?32:16})},t.prototype.uploadToGPU=function(m){var e=this.texData.get(m),t=e.shape,r=e.values,n=e.texture,o=e.dtype,a=e.usage,i=e.isPacked;if(null==n){var s=null!=this.activeTimers,l;s&&(l=performance.now());var g=getTextureShapeFromLogicalShape(t,i);e.texShape=g;var c=this.acquireTexture(m,g,a,i);if(e.texture=c,null!=r){if(i){var p=sizeFromShape(t.slice(0,t.length-2)),d=1<t.length?t[t.length-2]:1,h=t[t.length-1];this.gpgpu.uploadMatrixToPackedTexture(c,p,d,h,typedArrayToFloat32(r,o))}else this.gpgpu.uploadMatrixToTexture(c,g[0],g[1],typedArrayToFloat32(r,o));e.values=null,s&&(this.uploadWaitMs+=performance.now()-l)}}else ENV.get("WEBGL_PAGING_ENABLED")&&0<=this.lruDataGPU.indexOf(m)&&(this.lruDataGPU.splice(this.lruDataGPU.indexOf(m),1),this.lruDataGPU.push(m))},t.prototype.convertAndCacheOnCPU=function(p,e){var t=this.delayedStorage,r=this.texData.get(p),n=r.texture,o=r.texShape,a=r.dtype,i=r.usage,s=r.isPacked;return t&&null!=n&&(this.releaseTexture(p,n,o,i,s),r.texture=null,r.texShape=null),r.usage=TextureUsage.UPLOAD,null!=e&&(r.values=float32ToTypedArray(e,a)),r.values},t.prototype.releaseTexture=function(p,e,t,r,n){var o=this.texData.get(p),a=o.shape,i=o.dtype;if(ENV.get("WEBGL_PAGING_ENABLED")){var s=this.lruDataGPU.indexOf(p);0<=s&&this.lruDataGPU.splice(s,1)}this.numBytesInGPU-=this.computeBytes(a,i),this.textureManager.releaseTexture(e,t,r,n)},t.prototype.acquireTexture=function(s,e,t,r){var n=this.texData.get(s),o=n.shape,a=n.dtype;return ENV.get("WEBGL_PAGING_ENABLED")&&this.lruDataGPU.push(s),this.numBytesInGPU+=this.computeBytes(o,a),this.textureManager.acquireTexture(e,t,r)},t.prototype.computeBytes=function(a,e){return sizeFromShape(a)*bytesPerElement(e)},t}();ENV.get("IS_BROWSER")&&ENV.registerBackend("webgl",function(){return new MathBackendWebGL},2,setTensorTracker);var abs=op({abs_:abs_}),acos=op({acos_:acos_}),acosh=op({acosh_:acosh_}),asin=op({asin_:asin_}),asinh=op({asinh_:asinh_}),atan=op({atan_:atan_}),atanh=op({atanh_:atanh_}),ceil=op({ceil_:ceil_}),clipByValue=op({clipByValue_:clipByValue_}),cos=op({cos_:cos_}),cosh=op({cosh_:cosh_}),erf=op({erf_:erf_}),exp=op({exp_:exp_}),expm1=op({expm1_:expm1_}),floor=op({floor_:floor_}),log$1=op({log_:log_}),log1p=op({log1p_:log1p_}),logSigmoid=op({logSigmoid_:logSigmoid_}),neg=op({neg_:neg_}),reciprocal=op({reciprocal_:reciprocal_}),round=op({round_:round_}),rsqrt=op({rsqrt_:rsqrt_}),sigmoid=op({sigmoid_:sigmoid_}),sign=op({sign_:sign_}),sin=op({sin_:sin_}),sinh=op({sinh_:sinh_}),softplus=op({softplus_:softplus_}),sqrt=op({sqrt_:sqrt_}),square=op({square_:square_}),step=op({step_:step_}),tan=op({tan_:tan_}),tanh$1=op({tanh_:tanh_}),batchNormalization2d=op({batchNormalization2d_:batchNormalization2d_}),batchNormalization3d=op({batchNormalization3d_:batchNormalization3d_}),batchNormalization4d=op({batchNormalization4d_:batchNormalization4d_}),batchNormalization=op({batchNormalization_:batchNormalization_}),matMul=op({matMul_:matMul_}),dot=op({dot_:dot_}),outerProduct=op({outerProduct_:outerProduct_}),conv1d=op({conv1d_:conv1d_}),conv2d=op({conv2d_:conv2d_}),conv2dDerFilter=op({conv2dDerFilter_:conv2dDerFilter_}),depthwiseConv2d=op({depthwiseConv2d_:depthwiseConv2d_}),separableConv2d=op({separableConv2d_:separableConv2d_}),conv2dTranspose=op({conv2dTranspose_:conv2dTranspose_}),reverse=op({reverse_:reverse_}),reverse1d=op({reverse1d_:reverse1d_}),reverse2d=op({reverse2d_:reverse2d_}),reverse3d=op({reverse3d_:reverse3d_}),reverse4d=op({reverse4d_:reverse4d_}),maxPool=op({maxPool_:maxPool_}),avgPool=op({avgPool_:avgPool_}),pool=op({pool_:pool_}),slice=op({slice_:slice_}),slice1d=op({slice1d_:slice1d_}),slice2d=op({slice2d_:slice2d_}),slice3d=op({slice3d_:slice3d_}),slice4d=op({slice4d_:slice4d_}),all=op({all_:all_}),any=op({any_:any_}),argMax=op({argMax_:argMax_}),argMin=op({argMin_:argMin_}),logSumExp=op({logSumExp_:logSumExp_}),max=op({max_:max_}),mean=op({mean_:mean_}),min=op({min_:min_}),moments=op({moments_:moments_}),sum$1=op({sum_:sum_}),prod=op({prod_:prod_}),equal=op({equal_:equal_}),equalStrict=op({equalStrict_:equalStrict_}),greater=op({greater_:greater_}),greaterEqual=op({greaterEqual_:greaterEqual_}),greaterEqualStrict=op({greaterEqualStrict_:greaterEqualStrict_}),greaterStrict=op({greaterStrict_:greaterStrict_}),less=op({less_:less_}),lessEqual=op({lessEqual_:lessEqual_}),lessEqualStrict=op({lessEqualStrict_:lessEqualStrict_}),lessStrict=op({lessStrict_:lessStrict_}),notEqual=op({notEqual_:notEqual_}),notEqualStrict=op({notEqualStrict_:notEqualStrict_}),add=op({add_:add_}),addN=op({addN_:addN_}),addStrict=op({addStrict_:addStrict_}),atan2=op({atan2_:atan2_}),div=op({div_:div_}),divStrict=op({divStrict_:divStrict_}),floorDiv=op({floorDiv_:floorDiv_}),maximum=op({maximum_:maximum_}),maximumStrict=op({maximumStrict_:maximumStrict_}),minimum=op({minimum_:minimum_}),minimumStrict=op({minimumStrict_:minimumStrict_}),mod=op({mod_:mod_}),modStrict=op({modStrict_:modStrict_}),mul=op({mul_:mul_}),mulStrict=op({mulStrict_:mulStrict_}),pow=op({pow_:pow_}),powStrict=op({powStrict_:powStrict_}),squaredDifference=op({squaredDifference_:squaredDifference_}),squaredDifferenceStrict=op({squaredDifferenceStrict_:squaredDifferenceStrict_}),sub=op({sub_:sub_}),subStrict=op({subStrict_:subStrict_}),logicalAnd=op({logicalAnd_:logicalAnd_}),logicalNot=op({logicalNot_:logicalNot_}),logicalOr=op({logicalOr_:logicalOr_}),logicalXor=op({logicalXor_:logicalXor_}),where=op({where_:where_}),whereAsync=whereAsync_,elu=op({elu_:elu_}),leakyRelu=op({leakyRelu_:leakyRelu_}),prelu=op({prelu_:prelu_}),relu=op({relu_:relu_}),selu=op({selu_:selu_}),transpose=op({transpose_:transpose_}),localResponseNormalization=op({localResponseNormalization_:localResponseNormalization_}),norm=op({norm_:norm_}),gather=op({gather_:gather_}),unsortedSegmentSum=op({unsortedSegmentSum_:unsortedSegmentSum_}),basicLSTMCell=op({basicLSTMCell_:basicLSTMCell_}),multiRNNCell=op({multiRNNCell_:multiRNNCell_}),movingAverage=op({movingAverage_:movingAverage_}),stridedSlice=op({stridedSlice_:stridedSlice_}),topk=op({topk_:topk_}),scatterND=op({scatterND_:scatterND_}),fft=op({fft_:fft_}),ifft=op({ifft_:ifft_}),rfft=op({rfft_:rfft_}),spectral_ops=Object.freeze({fft:fft,ifft:ifft,rfft:rfft}),sparseToDense=op({sparseToDense_:sparseToDense_}),gatherND=op({gatherND_:gatherND_}),Reduction;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Reduction||(Reduction={}));var absoluteDifference=op({absoluteDifference_:absoluteDifference_}),computeWeightedLoss=op({computeWeightedLoss_:computeWeightedLoss_}),cosineDistance=op({cosineDistance_:cosineDistance_}),hingeLoss=op({hingeLoss_:hingeLoss_}),huberLoss=op({huberLoss_:huberLoss_}),logLoss=op({logLoss_:logLoss_}),meanSquaredError=op({meanSquaredError_:meanSquaredError_}),sigmoidCrossEntropy=op({sigmoidCrossEntropy_:sigmoidCrossEntropy_}),softmaxCrossEntropy=op({softmaxCrossEntropy_:softmaxCrossEntropy_}),loss_ops=Object.freeze({get Reduction(){return Reduction},absoluteDifference:absoluteDifference,computeWeightedLoss:computeWeightedLoss,cosineDistance:cosineDistance,hingeLoss:hingeLoss,huberLoss:huberLoss,logLoss:logLoss,meanSquaredError:meanSquaredError,sigmoidCrossEntropy:sigmoidCrossEntropy,softmaxCrossEntropy:softmaxCrossEntropy}),gramSchmidt=op({gramSchmidt_:gramSchmidt_}),qr=op({qr_:qr_}),linalg_ops=Object.freeze({gramSchmidt:gramSchmidt,qr:qr}),resizeBilinear=op({resizeBilinear_:resizeBilinear_}),resizeNearestNeighbor=op({resizeNearestNeighbor_:resizeNearestNeighbor_}),nonMaxSuppression=op({nonMaxSuppression_:nonMaxSuppression_}),nonMaxSuppressionAsync=nonMaxSuppressionAsync_,cropAndResize=cropAndResize_,image_ops=Object.freeze({resizeBilinear:resizeBilinear,resizeNearestNeighbor:resizeNearestNeighbor,nonMaxSuppression:nonMaxSuppression,nonMaxSuppressionAsync:nonMaxSuppressionAsync,cropAndResize:cropAndResize}),ops=Object.freeze({image:image_ops,linalg:linalg_ops,losses:loss_ops,spectral:spectral_ops,op:op,batchNormalization2d:batchNormalization2d,batchNormalization3d:batchNormalization3d,batchNormalization4d:batchNormalization4d,batchNormalization:batchNormalization,complex:complex,real:real,imag:imag,concat:concat,concat1d:concat1d,concat2d:concat2d,concat3d:concat3d,concat4d:concat4d,split:split$1,conv1d:conv1d,conv2d:conv2d,conv2dDerFilter:conv2dDerFilter,depthwiseConv2d:depthwiseConv2d,separableConv2d:separableConv2d,conv2dTranspose:conv2dTranspose,matMul:matMul,dot:dot,outerProduct:outerProduct,reverse:reverse,reverse1d:reverse1d,reverse2d:reverse2d,reverse3d:reverse3d,reverse4d:reverse4d,maxPool:maxPool,avgPool:avgPool,pool:pool,slice:slice,slice1d:slice1d,slice2d:slice2d,slice3d:slice3d,slice4d:slice4d,abs:abs,acos:acos,acosh:acosh,asin:asin,asinh:asinh,atan:atan,atanh:atanh,ceil:ceil,clipByValue:clipByValue,cos:cos,cosh:cosh,erf:erf,exp:exp,expm1:expm1,floor:floor,log:log$1,log1p:log1p,logSigmoid:logSigmoid,neg:neg,reciprocal:reciprocal,round:round,rsqrt:rsqrt,sigmoid:sigmoid,sign:sign,sin:sin,sinh:sinh,softplus:softplus,sqrt:sqrt,square:square,step:step,tan:tan,tanh:tanh$1,all:all,any:any,argMax:argMax,argMin:argMin,logSumExp:logSumExp,max:max,mean:mean,min:min,moments:moments,sum:sum$1,prod:prod,equal:equal,equalStrict:equalStrict,greater:greater,greaterEqual:greaterEqual,greaterEqualStrict:greaterEqualStrict,greaterStrict:greaterStrict,less:less,lessEqual:lessEqual,lessEqualStrict:lessEqualStrict,lessStrict:lessStrict,notEqual:notEqual,notEqualStrict:notEqualStrict,add:add,addN:addN,addStrict:addStrict,atan2:atan2,div:div,divStrict:divStrict,floorDiv:floorDiv,maximum:maximum,maximumStrict:maximumStrict,minimum:minimum,minimumStrict:minimumStrict,mod:mod,modStrict:modStrict,mul:mul,mulStrict:mulStrict,pow:pow,powStrict:powStrict,squaredDifference:squaredDifference,squaredDifferenceStrict:squaredDifferenceStrict,sub:sub,subStrict:subStrict,elu:elu,leakyRelu:leakyRelu,prelu:prelu,relu:relu,selu:selu,logicalAnd:logicalAnd,logicalNot:logicalNot,logicalOr:logicalOr,logicalXor:logicalXor,where:where,whereAsync:whereAsync,buffer:buffer,toPixels:toPixels,print:print,batchToSpaceND:batchToSpaceND,cast:cast,clone:clone,cumsum:cumsum,depthToSpace:depthToSpace,expandDims:expandDims,eye:eye,fromPixels:fromPixels,multinomial:multinomial,oneHot:oneHot,pad:pad,pad1d:pad1d,pad2d:pad2d,pad3d:pad3d,pad4d:pad4d,rand:rand,randomNormal:randomNormal,randomUniform:randomUniform,reshape:reshape,spaceToBatchND:spaceToBatchND,squeeze:squeeze,stack:stack,tile:tile,truncatedNormal:truncatedNormal,unstack:unstack,setdiff1dAsync:setdiff1dAsync,fill:fill,linspace:linspace,ones:ones$1,range:range,scalar:scalar,tensor:tensor,tensor1d:tensor1d,tensor2d:tensor2d,tensor3d:tensor3d,tensor4d:tensor4d,tensor5d:tensor5d,tensor6d:tensor6d,zeros:zeros,onesLike:onesLike,zerosLike:zerosLike,transpose:transpose,softmax:softmax,logSoftmax:logSoftmax,localResponseNormalization:localResponseNormalization,norm:norm,gather:gather,unsortedSegmentSum:unsortedSegmentSum,basicLSTMCell:basicLSTMCell,multiRNNCell:multiRNNCell,movingAverage:movingAverage,stridedSlice:stridedSlice,topk:topk,scatterND:scatterND,fft:fft,ifft:ifft,rfft:rfft,sparseToDense:sparseToDense,gatherND:gatherND}),MathBackendCPU=function(){function t(){this.blockSize=48,this.firstUse=!0,ENV.get("IS_BROWSER")&&(this.fromPixels2DContext=document.createElement("canvas").getContext("2d"))}return t.prototype.setDataMover=function(t){this.data=new DataStorage(t)},t.prototype.register=function(a,e,t){if(this.firstUse&&(this.firstUse=!1,ENV.get("IS_NODE")&&warn("\n============================\nHi there \uD83D\uDC4B. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n")),this.data.has(a))throw new Error("Data buffer is already registered");this.data.set(a,{dtype:t})},t.prototype.write=function(a,e){if(null==e)throw new Error("MathBackendCPU.write(): values can not be null");this.data.get(a).values=e},t.prototype.fromPixels=function(s,e){if(null==s)throw new Error("pixels passed to tf.fromPixels() can not be null");var t,p;if(ENV.get("IS_NODE")&&null==s.getContext)throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");if(null!=s.getContext)t=s.getContext("2d").getImageData(0,0,s.width,s.height).data;else if(s instanceof ImageData)t=s.data;else{if(!(s instanceof HTMLImageElement||s instanceof HTMLVideoElement))throw new Error("pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+s.constructor.name);if(null==this.fromPixels2DContext)throw new Error("Can't read pixels from HTMLImageElement outside the browser.");this.fromPixels2DContext.canvas.width=s.width,this.fromPixels2DContext.canvas.height=s.height,this.fromPixels2DContext.drawImage(s,0,0,s.width,s.height),t=this.fromPixels2DContext.getImageData(0,0,s.width,s.height).data}if(4===e)p=new Int32Array(t);else{var l=s.width*s.height;p=new Int32Array(l*e);for(var o=0;o<l;o++)for(var d=0;d<e;++d)p[o*e+d]=t[4*o+d]}return tensor3d(p,[s.height,s.width,e],"int32")},t.prototype.read=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(){return[2,this.readSync(t)]})})},t.prototype.readSync=function(a){var e=this.data.get(a),t=e.dtype,r=e.complexTensors;return"complex64"===t?mergeRealAndImagArrays(r.real.dataSync(),r.imag.dataSync()):this.data.get(a).values},t.prototype.disposeData=function(a){if(this.data.has(a)){var e=this.data.get(a).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(a)}},t.prototype.time=function(a){return __awaiter(this,void 0,void 0,function(){var e;return __generator(this,function(){return e=now(),a(),[2,{kernelMs:now()-e}]})})},t.prototype.memory=function(){return{unreliable:!0}},t.prototype.complex=function(a,e){var t=Tensor.make(a.shape,{},"complex64");return this.data.get(t.dataId).complexTensors={real:ENV.engine.keep(a.clone()),imag:ENV.engine.keep(e.clone())},t},t.prototype.real=function(t){return this.data.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.data.get(t.dataId).complexTensors.imag.clone()},t.prototype.assertNotComplex=function(a,n){Array.isArray(a)||(a=[a]),a.forEach(function(t){null!=t&&assert("complex64"!==t.dtype,n+" does not support complex64 tensors.")})},t.prototype.slice=function(s,p,e){this.assertNotComplex(s,"slice");for(var t=buffer(e,s.dtype),n=0;n<t.size;++n){var r=t.indexToLoc(n),a=r.map(function(t,e){return t+p[e]});t.set.apply(t,[s.get.apply(s,a)].concat(r))}return t.toTensor()},t.prototype.stridedSlice=function(b,e,t,r,n,o,a,i,s){this.assertNotComplex(b,"stridedSlice");var u=getStridedSlicedInfo(b.shape,e,t,r,n,o,a,i,s),l=u[0],c=u[1],p=u[2],d=c.filter(function(a,e){return-1===p.indexOf(e)});if(d.some(function(t){return 0===t}))return tensor([],d);for(var h=buffer(c,b.dtype),f=0;f<h.size;f++){for(var x=h.indexToLoc(f),g=Array(x.length),N=0;N<g.length;N++)g[N]=x[N]*r[N]+l[N];h.set.apply(h,[b.get.apply(b,g)].concat(x))}return h.toTensor().reshape(d)},t.prototype.reverse=function(s,e){this.assertNotComplex(s,"reverse");for(var t=buffer(s.shape,s.dtype),r=s.buffer(),n=function(n){var o=t.indexToLoc(n),a=o.slice();e.forEach(function(e){return a[e]=s.shape[e]-1-a[e]}),t.set.apply(t,[r.get.apply(r,a)].concat(o))},o=0;o<t.size;o++)n(o);return t.toTensor()},t.prototype.concat=function(p,l){this.assertNotComplex(p,"concat");var e=p.map(function(t){var e=sizeFromShape(t.shape.slice(l));return t.as2D(-1,e)}),d=computeOutShape(e.map(function(t){return t.shape}),1),n=buffer(d,p[0].dtype).values;if(1===e[0].shape[0]){var t=0;e.forEach(function(a){n.set(a.dataSync(),t),t+=a.size})}else{var o=0;e.forEach(function(i){for(var e=i.dataSync(),t=0,p=0;p<i.shape[0];++p)for(var l=p*d[1]+o,s=0;s<i.shape[1];++s)n[l+s]=e[t++];o+=i.shape[1]})}var r=computeOutShape(p.map(function(t){return t.shape}),l);return tensor(n,r,p[0].dtype)},t.prototype.neg=function(t){return this.assertNotComplex(t,"neg"),this.multiply(scalar(-1),t)},t.prototype.add=function(a,e){return"complex64"===a.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(a.cast("complex64"),e.cast("complex64"),function(a,e,t,r){return{real:a+t,imag:e+r}}):this.broadcastedBinaryOp(a,e,upcastType(a.dtype,e.dtype),function(a,e){return a+e})},t.prototype.addN=function(s){this.assertNotComplex(s,"addN");for(var e=s.map(function(t){return t.dataSync()}),t=buffer(s[0].shape,s[0].dtype),r=t.values,n=0;n<s.length;n++)for(var p=e[n],a=0;a<r.length;a++)r[a]+=p[a];return t.toTensor()},t.prototype.subtract=function(a,e){return"complex64"===a.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(a.cast("complex64"),e.cast("complex64"),function(a,e,t,r){return{real:a-t,imag:e-r}}):this.broadcastedBinaryOp(a,e,upcastType(a.dtype,e.dtype),function(a,e){return a-e})},t.prototype.pow=function(a,e){return this.assertNotComplex([a,e],"pow"),this.broadcastedBinaryOp(a,e,a.dtype,function(a,e){return _Mathpow(a,e)})},t.prototype.batchMatMul=function(D,e,t,r){this.assertNotComplex([D,e],"matMul");for(var n=t?D.shape[1]:D.shape[2],o=t?D.shape[2]:D.shape[1],a=r?e.shape[1]:e.shape[2],i=D.shape[0],s=D.dataSync(),u=e.dataSync(),l=t?[D.strides[0],1,D.strides[1]]:[D.strides[0],D.strides[1],1],c=l[0],p=l[1],d=l[2],h=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],f=h[0],m=h[1],g=h[2],v=o*a,y=new Float32Array(i*v),x=this.blockSize,T=0;T<i;T++)for(var P=0;P<o;P+=x)for(var O=0;O<a;O+=x)for(var L=0;L<n;L+=x)for(var z=_Mathmin(P+x,o),C=_Mathmin(O+x,a),_=_Mathmin(L+x,n),A=P;A<z;A++)for(var M=O;M<C;M++){for(var F=0,B=L;B<_;B++)F+=s[T*c+A*p+B*d]*u[B*f+M*m+T*g];y[T*v+(A*a+M)]+=F}return tensor3d(y,[i,o,a])},t.prototype.multiply=function(a,e){return"complex64"===a.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(a.cast("complex64"),e.cast("complex64"),function(a,e,t,r){return{real:a*t-e*r,imag:a*r+e*t}}):this.broadcastedBinaryOp(a,e,upcastType(a.dtype,e.dtype),function(a,e){return a*e})},t.prototype.realDivide=function(a,e){return this.assertNotComplex([a,e],"realDivide"),this.broadcastedBinaryOp(a,e,"float32",function(a,e){return a/e})},t.prototype.floorDiv=function(a,e){return this.assertNotComplex([a,e],"floorDiv"),this.broadcastedBinaryOp(a,e,"int32",function(a,e){return _Mathfloor(a/e)})},t.prototype.sum=function(m,e){this.assertNotComplex(m,"sum"),assertAxesAreInnerMostDims("sum",e,m.rank);for(var t=computeOutAndReduceShapes(m.shape,e),r=t[0],n=t[1],o=zeros(r,upcastType(m.dtype,"int32")),a=sizeFromShape(n),i=o.dataSync(),s=m.dataSync(),u=0;u<i.length;++u){for(var h=u*a,c=0,g=0;g<a;++g)c+=s[h+g];i[u]=c}return o},t.prototype.prod=function(m,e){this.assertNotComplex(m,"sum");for(var t=computeOutAndReduceShapes(m.shape,e),r=t[0],n=t[1],o=zeros(r,upcastType(m.dtype,"int32")),a=sizeFromShape(n),i=o.dataSync(),s=m.dataSync(),u=0;u<i.length;++u){for(var h=u*a,c=1,g=0;g<a;++g)c*=s[h+g];i[u]=c}return o},t.prototype.unsortedSegmentSum=function(p,e,l){this.assertNotComplex(p,"unsortedSegmentSum");for(var r=[],n=p.rank-e.rank,o=0;o<n;++o)e=e.expandDims(o+1);for(o=0;o<l;++o){var d=scalar(o,"int32"),i=equal(d,e).asType("float32").mul(p).sum(0);r.push(i)}return stack(r)},t.prototype.argMin=function(g,e){this.assertNotComplex(g,"argMin");var t=[e];assertAxesAreInnerMostDims("argMin",t,g.rank);for(var r=computeOutAndReduceShapes(g.shape,t),n=r[0],o=r[1],a=zeros(n,"int32"),i=sizeFromShape(o),s=a.dataSync(),u=g.dataSync(),l=0;l<s.length;++l){for(var y=l*i,p=u[y],b=0,x=0,N;x<i;++x)N=u[y+x],N<p&&(p=N,b=x);s[l]=b}return a},t.prototype.argMax=function(g,e){this.assertNotComplex(g,"argMax");var t=[e];assertAxesAreInnerMostDims("argMax",t,g.rank);for(var r=computeOutAndReduceShapes(g.shape,t),n=r[0],o=r[1],a=zeros(n,"int32"),i=sizeFromShape(o),s=a.dataSync(),u=g.dataSync(),l=0;l<s.length;++l){for(var y=l*i,p=u[y],b=0,x=0,N;x<i;++x)N=u[y+x],N>p&&(p=N,b=x);s[l]=b}return a},t.prototype.cumsum=function(m,e,t,r){if(this.assertNotComplex(m,"cumsum"),e!==m.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(m.rank-1)+" but got axis="+e);for(var n=upcastType(m.dtype,"int32"),o=zeros(m.shape,n),a=o.dataSync(),i=m.dataSync(),s=m.shape[m.rank-1],u=r?function(a,e){return a+s-e-1}:function(a,e){return a+e},l=0;l<i.length;l+=s)for(var g=0,f;g<s;g++)if(f=u(l,g),0==g)a[f]=t?0:i[f];else{var y=u(l,g-1);a[f]=t?i[y]+a[y]:i[f]+a[y]}return o},t.prototype.equal=function(a,e){return this.assertNotComplex([a,e],"equal"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a===e?1:0})},t.prototype.notEqual=function(a,e){return this.assertNotComplex([a,e],"notEqual"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a===e?0:1})},t.prototype.less=function(a,e){return this.assertNotComplex([a,e],"less"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a<e?1:0})},t.prototype.lessEqual=function(a,e){return this.assertNotComplex([a,e],"lessEqual"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a<=e?1:0})},t.prototype.greater=function(a,e){return this.assertNotComplex([a,e],"greater"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a>e?1:0})},t.prototype.greaterEqual=function(a,e){return this.assertNotComplex([a,e],"greaterEqual"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a>=e?1:0})},t.prototype.logicalNot=function(a){this.assertNotComplex(a,"logicalNot");for(var e=a.dataSync(),t=new Int32Array(e.length),r=0;r<e.length;++r)t[r]=e[r]?0:1;return Tensor.make(a.shape,{values:t},"bool")},t.prototype.logicalAnd=function(a,e){return this.assertNotComplex([a,e],"logicalAnd"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a&&e})},t.prototype.logicalOr=function(a,e){return this.assertNotComplex([a,e],"logicalOr"),this.broadcastedBinaryOp(a,e,"bool",function(a,e){return a||e})},t.prototype.select=function(d,e,t){this.assertNotComplex([d,e,t],"select");for(var r=d.dataSync(),n=e.dataSync(),o=t.dataSync(),a=zeros(e.shape,upcastType(e.dtype,t.dtype)),i=a.dataSync(),s=0,m=0===d.rank||1<d.rank||1===e.rank?1:e.shape[1],l=0;l<r.length;l++)for(var h=0;h<m;h++)i[s++]=1===r[l]?n[l]:o[l];return a},t.prototype.where=function(a){this.assertNotComplex([a],"where");var e=a.dataSync();return whereImpl(a.shape,e)},t.prototype.topk=function(a,e,t){return this.assertNotComplex(a,"topk"),topkImpl(a.dataSync(),a.shape,a.dtype,e,t)},t.prototype.min=function(m,e){this.assertNotComplex(m,"min"),assertAxesAreInnerMostDims("min",e,m.rank);for(var t=computeOutAndReduceShapes(m.shape,e),r=t[0],n=t[1],o=zeros(r,m.dtype),a=sizeFromShape(n),i=o.dataSync(),s=m.dataSync(),u=0;u<i.length;++u){for(var g=u*a,c=s[g],f=0,y;f<a;++f)y=s[g+f],y<c&&(c=y);i[u]=c}return o},t.prototype.minimum=function(a,e){return this.assertNotComplex([a,e],"minimum"),this.broadcastedBinaryOp(a,e,a.dtype,function(a,e){return _Mathmin(a,e)})},t.prototype.mod=function(a,e){return this.assertNotComplex([a,e],"mod"),this.broadcastedBinaryOp(a,e,a.dtype,function(a,e){var t=a%e;return 0>a&&0>e||0<=a&&0<=e?t:(t+e)%e})},t.prototype.max=function(m,e){this.assertNotComplex(m,"max"),assertAxesAreInnerMostDims("max",e,m.rank);for(var t=computeOutAndReduceShapes(m.shape,e),r=t[0],n=t[1],o=zeros(r,m.dtype),a=sizeFromShape(n),i=o.dataSync(),s=m.dataSync(),u=0;u<i.length;++u){for(var g=u*a,c=s[g],f=0,y;f<a;++f)y=s[g+f],y>c&&(c=y);i[u]=c}return o},t.prototype.maximum=function(a,e){return this.assertNotComplex([a,e],"maximum"),this.broadcastedBinaryOp(a,e,a.dtype,function(a,e){return _Mathmax(a,e)})},t.prototype.all=function(m,e){this.assertNotComplex(m,"all"),assertAxesAreInnerMostDims("all",e,m.rank);for(var t=computeOutAndReduceShapes(m.shape,e),r=t[0],n=t[1],o=zeros(r,m.dtype),a=sizeFromShape(n),i=o.dataSync(),s=m.dataSync(),u=0;u<i.length;++u){for(var g=u*a,c=s[g],f=0,y;f<a;++f)y=s[g+f],c=c&&y;i[u]=c}return o},t.prototype.any=function(m,e){this.assertNotComplex(m,"any"),assertAxesAreInnerMostDims("any",e,m.rank);for(var t=computeOutAndReduceShapes(m.shape,e),r=t[0],n=t[1],o=zeros(r,m.dtype),a=sizeFromShape(n),i=o.dataSync(),s=m.dataSync(),u=0;u<i.length;++u){for(var g=u*a,c=s[g],f=0,y;f<a;++f)y=s[g+f],c=c||y;i[u]=c}return o},t.prototype.squaredDifference=function(a,e){return this.assertNotComplex([a,e],"squaredDifference"),this.broadcastedBinaryOp(a,e,a.dtype,function(a,e){var t=a-e;return t*t})},t.prototype.ceil=function(a){this.assertNotComplex(a,"ceil");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0;r<e.length;++r)t[r]=_Mathceil(e[r]);return Tensor.make(a.shape,{values:t})},t.prototype.floor=function(a){this.assertNotComplex(a,"floor");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0;r<e.length;++r)t[r]=_Mathfloor(e[r]);return Tensor.make(a.shape,{values:t})},t.prototype.sign=function(a){this.assertNotComplex(a,"x");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0;r<e.length;++r)t[r]=0>e[r]?-1:0<e[r]?1:0;return Tensor.make(a.shape,{values:t})},t.prototype.round=function(a){this.assertNotComplex(a,"round");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0,s;r<e.length;++r)s=_Mathfloor(e[r]),t[r]=.5>e[r]-s?_Mathfloor(e[r]):.5<e[r]-s?_Mathceil(e[r]):0==s%2?s:s+1;return Tensor.make(a.shape,{values:t})},t.prototype.exp=function(a){this.assertNotComplex(a,"exp");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0;r<e.length;++r)t[r]=_Mathexp(e[r]);return Tensor.make(a.shape,{values:t})},t.prototype.expm1=function(a){this.assertNotComplex(a,"expm1");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0;r<e.length;++r)t[r]=Math.expm1(e[r]);return Tensor.make(a.shape,{values:t})},t.prototype.log=function(a){this.assertNotComplex(a,"log");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0,s;r<e.length;++r)s=e[r],t[r]=_Mathlog(s);return Tensor.make(a.shape,{values:t})},t.prototype.log1p=function(a){var e=Math.log1p;this.assertNotComplex(a,"log1p");for(var s=a.dataSync(),t=new Float32Array(s.length),r=0,i;r<s.length;++r)i=s[r],t[r]=e(i);return Tensor.make(a.shape,{values:t})},t.prototype.sqrt=function(a){this.assertNotComplex(a,"sqrt");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0,s;r<e.length;++r)s=e[r],t[r]=_Mathsqrt(s);return Tensor.make(a.shape,{values:t})},t.prototype.rsqrt=function(a){this.assertNotComplex(a,"rsqrt");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0,s;r<e.length;++r)s=e[r],t[r]=1/_Mathsqrt(s);return Tensor.make(a.shape,{values:t})},t.prototype.square=function(a){this.assertNotComplex(a,"square");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0,s;r<e.length;++r)s=e[r],t[r]=s*s;return Tensor.make(a.shape,{values:t})},t.prototype.reciprocal=function(a){this.assertNotComplex(a,"reciprocal");for(var e=a.dataSync(),t=new Float32Array(e.length),r=0;r<e.length;++r)t[r]=1/e[r];return Tensor.make(a.shape,{values:t})},t.prototype.relu=function(a){this.assertNotComplex(a,"relu");for(var e=zeros(a.shape,a.dtype),t=e.dataSync(),r=a.dataSync(),n=0;n<r.length;++n)t[n]=_Mathmax(0,r[n]);return e},t.prototype.elu=function(a){this.assertNotComplex(a,"elu");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0,s;r<t.length;++r)s=t[r],e[r]=0<=s?s:_Mathexp(s)-1;return Tensor.make(a.shape,{values:e})},t.prototype.eluDer=function(s,e){this.assertNotComplex([s,e],"eluDer");for(var t=new Float32Array(e.size),r=e.dataSync(),n=s.dataSync(),o=0,p;o<r.length;++o)p=r[o],t[o]=1<=p?n[o]:n[o]*(p+1);return Tensor.make(e.shape,{values:t})},t.prototype.selu=function(t){this.assertNotComplex(t,"selu");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0,o;r<n.length;++r)o=n[r],e[r]=0<=o?SELU_SCALE*o:SELU_SCALEALPHA*(_Mathexp(o)-1);return Tensor.make(t.shape,{values:e})},t.prototype.clip=function(s,e,t){this.assertNotComplex(s,"clip");for(var r=new Float32Array(s.size),n=s.dataSync(),o=0,p;o<n.length;++o)p=n[o],r[o]=p>t?t:p<e?e:p;return Tensor.make(s.shape,{values:r})},t.prototype.abs=function(a){for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=_Mathabs(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.complexAbs=function(s){for(var e=new Float32Array(s.size),t=s.dataSync(),r=0;r<s.size;++r){var i=t[2*r],o=t[2*r+1];e[r]=_Mathsqrt(i*i+o*o)}return Tensor.make(s.shape,{values:e})},t.prototype.int=function(a){this.assertNotComplex(a,"int");for(var e=new Int32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=t[r];return Tensor.make(a.shape,{values:e},"int32")},t.prototype.sigmoid=function(a){this.assertNotComplex(a,"sigmoid");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=1/(1+_Mathexp(-t[r]));return Tensor.make(a.shape,{values:e})},t.prototype.softplus=function(p){this.assertNotComplex(p,"softplus");for(var e=_Mathlog(1.1920928955078125e-7)+2,t=new Float32Array(p.size),r=p.dataSync(),n=0;n<r.length;++n){var l=r[n]>-e,a=r[n]<e,i=_Mathexp(r[n]),s=void 0;s=a?i:l?r[n]:_Mathlog(1+i),t[n]=s}return Tensor.make(p.shape,{values:t})},t.prototype.sin=function(a){this.assertNotComplex(a,"sin");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=_Mathsin(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.cos=function(a){this.assertNotComplex(a,"cos");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=_Mathcos(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.tan=function(a){this.assertNotComplex(a,"tan");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.tan(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.asin=function(a){this.assertNotComplex(a,"asin");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.asin(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.acos=function(a){this.assertNotComplex(a,"acos");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.acos(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.atan=function(a){this.assertNotComplex(a,"atan");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.atan(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.atan2=function(a,e){return this.assertNotComplex([a,e],"atan2"),this.broadcastedBinaryOp(a,e,a.dtype,function(a,e){return Math.atan2(a,e)})},t.prototype.sinh=function(a){this.assertNotComplex(a,"sinh");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.sinh(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.cosh=function(a){this.assertNotComplex(a,"cosh");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.cosh(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.tanh=function(a){this.assertNotComplex(a,"tanh");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=tanh(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.asinh=function(a){this.assertNotComplex(a,"asinh");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.asinh(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.acosh=function(a){this.assertNotComplex(a,"acosh");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.acosh(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.atanh=function(a){this.assertNotComplex(a,"atanh");for(var e=new Float32Array(a.size),t=a.dataSync(),r=0;r<t.length;++r)e[r]=Math.atanh(t[r]);return Tensor.make(a.shape,{values:e})},t.prototype.erf=function(a){this.assertNotComplex(a,"erf");for(var e=new Float32Array(a.size),t=a.dataSync(),n=0;n<t.length;++n){var r=t[n],o=1/(1+ERF_P*r);e[n]=1-((((ERF_A5*o+ERF_A4)*o+ERF_A3)*o+ERF_A2)*o+ERF_A1)*o*_Mathexp(-r*r)}return Tensor.make(a.shape,{values:e})},t.prototype.step=function(s,e){void 0===e&&(e=0),this.assertNotComplex(s,"step");for(var i=new Float32Array(s.size),r=s.dataSync(),n=0,p;n<r.length;++n)p=r[n],i[n]=isNaN(p)?NaN:0<p?1:e;return Tensor.make(s.shape,{values:i})},t.prototype.conv2d=function(P,e,t){this.assertNotComplex([P,e],"conv2d");for(var r=t.filterHeight,n=t.filterWidth,o=t.dilationHeight,a=t.dilationWidth,i=t.padInfo.left,s=t.padInfo.top,u=buffer(t.outShape,P.dtype),l=P.dataSync(),c=e.dataSync(),p=u.values,d=0;d<t.batchSize;++d)for(var O=d*P.strides[0],f=d*u.strides[0],m=0;m<t.outHeight;++m)for(var L=f+m*u.strides[1],v=m*t.strideHeight-i,y=0,z;y<r;y++)if(z=v+y*o,!(0>z||z>=t.inHeight))for(var F=y*e.strides[0],E=O+z*P.strides[1],w=0;w<t.outWidth;++w)for(var B=L+w*t.outChannels,b=w*t.strideWidth-s,C=0,V;C<n;C++)if(V=b+C*a,!(0>V||V>=t.inWidth))for(var U=F+C*e.strides[1],N=E+V*t.inChannels,R=U,W=0;W<t.inChannels;++W){for(var G=l[N+W],D=0;D<t.outChannels;++D)p[B+D]+=G*c[R+D];R+=t.outChannels}return u.toTensor()},t.prototype.conv2dDerInput=function(j,e,t){this.assertNotComplex([j,e],"conv2dDerInput");for(var r=buffer(t.inShape,"float32"),n=r.values,o=r.strides,a=o[0],i=o[1],s=o[2],u=j.dataSync(),l=j.strides,c=l[0],p=l[1],d=l[2],h=e.dataSync(),f=e.strides,m=f[0],g=f[1],v=f[2],y=t.batchSize,x=t.filterHeight,T=t.filterWidth,E=t.inChannels,w=t.inHeight,S=t.inWidth,b=t.outChannels,C=t.outHeight,_=t.outWidth,A=t.strideHeight,N=t.strideWidth,R=x-1-t.padInfo.top,I=T-1-t.padInfo.left,k=0;k<y;++k)for(var Y=0;Y<E;++Y)for(var Z=0;Z<w;++Z)for(var Q=Z-R,P=_Mathmax(0,_Mathceil(Q/A)),F=_Mathmin(C,(x+Q)/A),L=0;L<S;++L){for(var J=L-I,U=_Mathmax(0,_Mathceil(J/N)),z=_Mathmin(_,(T+J)/N),V=0,ee=P;ee<F;++ee)for(var te=ee*A-Q,W=U;W<z;++W)for(var ae=c*k+p*ee+d*W,$=m*(x-1-te)+g*(T-1-(W*N-J))+v*Y,X=0;X<b;++X)V+=u[ae+X]*h[$+X];n[a*k+i*Z+s*L+Y]=V}return r.toTensor()},t.prototype.conv2dDerFilter=function(b,e,t){this.assertNotComplex([b,e],"conv2dDerFilter");for(var r=t.strideHeight,n=t.strideWidth,o=t.filterHeight,a=t.filterWidth,i=buffer(t.filterShape,"float32"),s=t.padInfo.left,u=t.padInfo.top,l=0;l<o;++l)for(var N=_Mathmax(0,_Mathceil((u-l)/r)),p=_Mathmin(t.outHeight,(t.inHeight+u-l)/r),d=0;d<a;++d)for(var I=_Mathmax(0,_Mathceil((s-d)/n)),f=_Mathmin(t.outWidth,(t.inWidth+s-d)/n),m=0;m<t.inChannels;++m)for(var C=0;C<t.outChannels;++C){for(var k=0,R=0;R<t.batchSize;++R)for(var D=N;D<p;++D)for(var P=l+D*r-u,E=I,A;E<f;++E)A=d+E*n-s,k+=b.get(R,P,A,m)*e.get(R,D,E,C);i.set(k,l,d,m,C)}return i.toTensor()},t.prototype.depthwiseConv2D=function(L,e,t){this.assertNotComplex([L,e],"depthwiseConv2D");for(var r=t.filterHeight,n=t.filterWidth,o=t.dilationHeight,a=t.dilationWidth,i=t.padInfo.left,s=t.padInfo.top,u=t.outChannels/t.inChannels,l=buffer(t.outShape,L.dtype),c=L.dataSync(),p=e.dataSync(),d=l.values,h=0;h<t.batchSize;++h)for(var z=h*L.strides[0],m=h*l.strides[0],g=0;g<t.outHeight;++g)for(var F=m+g*l.strides[1],y=g*t.strideHeight-i,x=0,B;x<r;++x)if(B=y+x*o,!(0>B||B>=t.inHeight))for(var V=x*e.strides[0],w=z+B*L.strides[1],S=0;S<t.outWidth;++S)for(var U=F+S*l.strides[2],C=S*t.strideWidth-s,_=0,W;_<n;++_)if(W=C+_*a,!(0>W||W>=t.inWidth))for(var G=V+_*e.strides[1],R=w+W*t.inChannels,I=U,q=G,H=0;H<t.inChannels;++H){for(var j=c[R+H],O=0;O<u;++O)d[I+O]+=j*p[q+O];I+=u,q+=u}return l.toTensor()},t.prototype.depthwiseConv2DDerInput=function(Y,e,t){this.assertNotComplex([Y,e],"depthwiseConv2DDerInput");for(var r=buffer(t.inShape,"float32"),n=r.values,o=r.strides,a=o[0],i=o[1],s=o[2],u=Y.dataSync(),l=Y.strides,c=l[0],p=l[1],d=l[2],h=e.dataSync(),f=e.strides,m=f[0],g=f[1],v=f[2],y=t.batchSize,x=t.filterHeight,T=t.filterWidth,E=t.inChannels,w=t.inHeight,S=t.inWidth,b=t.outChannels,C=t.outHeight,_=t.outWidth,A=t.strideHeight,N=t.strideWidth,R=x-1-t.padInfo.top,I=T-1-t.padInfo.left,k=b/E,D=0;D<y;++D)for(var Z=0;Z<E;++Z)for(var Q=0;Q<w;++Q)for(var J=Q-R,F=_Mathmax(0,_Mathceil(J/A)),L=_Mathmin(C,(x+J)/A),B=0;B<S;++B){for(var ee=B-I,z=_Mathmax(0,_Mathceil(ee/N)),V=_Mathmin(_,(T+ee)/N),H=0,te=F;te<L;++te)for(var ae=te*A-J,q=z;q<V;++q)for(var ne=c*D+p*te+d*q,X=m*(x-1-ae)+g*(T-1-(q*N-ee))+v*Z,K=0;K<k;++K)H+=u[ne+(Z*k+K)]*h[X+K];n[a*D+i*Q+s*B+Z]=H}return r.toTensor()},t.prototype.depthwiseConv2DDerFilter=function(N,e,t){this.assertNotComplex([N,e],"depthwiseConv2DDerFilter");for(var r=t.strideHeight,n=t.strideWidth,o=t.filterHeight,a=t.filterWidth,i=buffer(t.filterShape,"float32"),s=t.padInfo.left,u=t.padInfo.top,l=t.outChannels/t.inChannels,c=0;c<o;++c)for(var I=_Mathmax(0,_Mathceil((u-c)/r)),d=_Mathmin(t.outHeight,(t.inHeight+u-c)/r),h=0;h<a;++h)for(var k=_Mathmax(0,_Mathceil((s-h)/n)),m=_Mathmin(t.outWidth,(t.inWidth+s-h)/n),g=0;g<t.outChannels;++g){for(var R=Math.trunc(g/l),y=g%l,x=0,D=0;D<t.batchSize;++D)for(var P=I;P<d;++P)for(var A=c+P*r-u,S=k,_;S<m;++S)_=h+S*n-s,x+=N.get(D,A,_,R)*e.get(D,P,S,g);i.set(x,c,h,R,y)}return i.toTensor()},t.prototype.tile=function(p,e){this.assertNotComplex(p,"tile");for(var t=Array(p.rank),r=0;r<t.length;r++)t[r]=p.shape[r]*e[r];var d=buffer(t,p.dtype),o=p.buffer();for(r=0;r<d.values.length;++r){for(var a=d.indexToLoc(r),i=Array(p.rank),s=0;s<i.length;s++)i[s]=a[s]%p.shape[s];var c=o.locToIndex(i);d.values[r]=o.values[c]}return d.toTensor()},t.prototype.pad=function(p,e,t){this.assertNotComplex(p,"pad");var r=e.map(function(e,t){return e[0]+p.shape[t]+e[1]}),n=e.map(function(t){return t[0]}),o=p.buffer(),a=buffer(r,p.dtype);0!==t&&a.values.fill(t);for(var i=0;i<p.size;i++){var d=o.indexToLoc(i),u=d.map(function(a,e){return a+n[e]});a.set.apply(a,[p.get.apply(p,d)].concat(u))}return a.toTensor()},t.prototype.transpose=function(p,e){this.assertNotComplex(p,"transpose");for(var t=Array(p.rank),r=0;r<t.length;r++)t[r]=p.shape[e[r]];var d=p.dataSync(),o=buffer(t,p.dtype),a=p.buffer();for(r=0;r<p.size;++r){for(var i=a.indexToLoc(r),s=Array(i.length),u=0;u<s.length;u++)s[u]=i[e[u]];var m=o.locToIndex(s);o.values[m]=d[r]}return o.toTensor()},t.prototype.gather=function(p,e,t){this.assertNotComplex([p,e],"gather");var r=p.shape.slice(),n=e.dataSync();r[t]=n.length;for(var o=buffer(r,p.dtype),a=p.buffer(),i=0;i<o.size;++i){var d=o.indexToLoc(i),u=d.slice();u[t]=n[d[t]];var l=a.locToIndex(u);o.values[i]=a.values[l]}return o.toTensor()},t.prototype.batchToSpaceND=function(p,e,t){this.assertNotComplex([p],"batchToSpaceND");var r=e.reduce(function(a,e){return a*e}),n=getReshaped(p.shape,e,r),o=getPermuted(n.length,e.length),a=getReshapedPermuted(p.shape,e,r),i=getSliceBeginCoords(t,e.length),s=getSliceSize(a,t,e.length);return p.reshape(n).transpose(o).reshape(a).slice(i,s)},t.prototype.spaceToBatchND=function(p,e,t){this.assertNotComplex([p],"spaceToBatchND");var r=e.reduce(function(a,e){return a*e}),n=[[0,0]];n.push.apply(n,t);for(var o=1+e.length;o<p.shape.length;++o)n.push([0,0]);var d=p.pad(n),i=getReshaped(d.shape,e,r,!1),s=getPermuted(i.length,e.length,!1),u=getReshapedPermuted(d.shape,e,r,!1);return d.reshape(i).transpose(s).reshape(u)},t.prototype.pool=function(z,e,t){this.assertNotComplex(z,"pool");for(var r=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,i=e.effectiveFilterHeight,s=e.effectiveFilterWidth,u=e.padInfo.top,l=e.padInfo.left,c="max"===t?_NumberNEGATIVE_INFINITY:Number.POSITIVE_INFINITY,p=z.dataSync(),d=buffer(e.outShape,z.dtype),h=d.values,f=e.outShape[1]*e.outShape[2]*e.outShape[3],m=e.outShape[2]*e.outShape[3],g=e.outShape[3],v=0;v<e.batchSize;++v)for(var B=v*f,x=v*z.strides[0],T=0;T<e.inChannels;++T)for(var V=0;V<e.outHeight;++V)for(var U=V*r-u,S=_Mathmax(0,U),b=_Mathmin(e.inHeight,i+U),C=B+V*m,_=0;_<e.outWidth;++_){for(var W=_*n-l,N=_Mathmax(0,W),R=_Mathmin(e.inWidth,s+W),I=c,G=0,q=0,H=S;H<b;H+=o){for(var j=x+H*z.strides[1],P=N,$;P<R;P+=a)$=p[j+P*z.strides[2]+T],"max"===t&&$>I?I=$:"avg"==t&&(G+=$,q++);if(isNaN(I))break}h[C+_*g+T]="avg"===t?G/q:I}return d.toTensor()},t.prototype.maxPool=function(a,e){return this.pool(a,e,"max")},t.prototype.maxPoolPositions=function(N,e){for(var t=buffer(e.outShape,"int32"),r=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,i=e.effectiveFilterHeight,s=e.effectiveFilterWidth,u=e.padInfo.top,l=e.padInfo.left,c=0;c<e.batchSize;++c)for(var I=0;I<e.inChannels;++I)for(var k=0;k<e.outHeight;++k){for(var R=k*r-u,f=R;0>f;)f+=o;for(var D=_Mathmin(e.inHeight,i+R),g=0;g<e.outWidth;++g){for(var P=g*n-l,y=P;0>y;)y+=a;for(var O=_Mathmin(e.inWidth,s+P),T=_NumberNEGATIVE_INFINITY,L=-1,z=f;z<D;z+=o)for(var M=z-R,b=y;b<O;b+=a){var F=b-P,_=N.get(c,z,b,I);_>T&&(T=_,L=M*s+F)}t.set(L,c,k,g,I)}}return t.toTensor()},t.prototype.maxPoolBackprop=function(N,e,t,r){this.assertNotComplex([e,t],"maxPoolBackprop");for(var n=this.maxPoolPositions(e,r),o=r.strideHeight,a=r.strideWidth,i=r.dilationHeight,s=r.dilationWidth,u=r.effectiveFilterHeight,l=r.effectiveFilterWidth,c=l-1-r.padInfo.left,p=u-1-r.padInfo.top,d=buffer(e.shape,"float32"),h=0;h<r.batchSize;++h)for(var I=0;I<r.inChannels;++I)for(var k=0;k<r.inHeight;++k)for(var R=0;R<r.inWidth;++R){for(var D=k-p,y=R-c,x=0,P=0,A;P<u;P+=i)if(A=(D+P)/o,!(0>A||A>=r.outHeight||_Mathfloor(A)!==A))for(var _=0,O;_<l;_+=s)if(O=(y+_)/a,!(0>O||O>=r.outWidth||_Mathfloor(O)!==O)){var L=u*l-1-n.get(h,A,O,I)===P*l+_?1:0;0!=L&&(x+=N.get(h,A,O,I)*L)}d.set(x,h,k,R,I)}return d.toTensor()},t.prototype.avgPoolBackprop=function(f,e,t){this.assertNotComplex([f,e],"avgPoolBackprop");for(var r=t.strideHeight,n=t.strideWidth,o=t.filterHeight,a=t.filterWidth,i=t.dilationHeight,s=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=l-1-t.padInfo.left,p=u-1-t.padInfo.top,d=buffer(e.shape,"float32"),h=0;h<t.batchSize;++h)for(var N=0;N<t.inChannels;++N)for(var I=0;I<t.inHeight;++I)for(var k=0;k<t.inWidth;++k){for(var R=I-p,x=k-c,T=0,D=0,P;D<u;D+=i)if(P=(R+D)/r,!(0>P||P>=t.outHeight||_Mathfloor(P)!==P))for(var A=0,_;A<l;A+=s)_=(x+A)/n,0>_||_>=t.outWidth||_Mathfloor(_)!==_||(T+=f.get(h,P,_,N));d.set(T*(1/(o*a)),h,I,k,N)}return d.toTensor()},t.prototype.cast=function(a,e){return castTensor(a,e,this)},t.prototype.reshape=function(a,e){return reshapeTensor(a,e)},t.prototype.avgPool=function(a,e){return this.assertNotComplex(a,"avgPool"),this.pool(a,e,"avg").toFloat()},t.prototype.resizeBilinear=function(T,e,t,r){this.assertNotComplex(T,"resizeBilinear");for(var n=T.shape,o=n[0],a=n[1],i=n[2],s=n[3],u=T.dataSync(),l=new Float32Array(sizeFromShape([o,e,t,s])),c=[r&&1<e?a-1:a,r&&1<t?i-1:i],p=[r&&1<e?e-1:e,r&&1<t?t-1:t],d=0,z=c[0]/p[0],f=c[1]/p[1],m=0;m<o;m++)for(var B=0;B<e;B++)for(var V=z*B,y=_Mathfloor(V),x=_Mathmin(a-1,_Mathceil(V)),E=m*T.strides[0]+y*T.strides[1],w=m*T.strides[0]+x*T.strides[1],S=0;S<t;S++)for(var U=f*S,C=_Mathfloor(U),_=U-C,A=_Mathmin(i-1,_Mathceil(U)),N=E+C*T.strides[2],R=w+C*T.strides[2],I=E+ +A*T.strides[2],k=w+A*T.strides[2],D=0;D<s;D++){var W=u[N+D],O=u[R+D],P=W+(u[I+D]-W)*_,F=P+(O+(u[k+D]-O)*_-P)*(V-y);l[d++]=F}return tensor(l,[o,e,t,s])},t.prototype.resizeBilinearBackprop=function(z,e,t){this.assertNotComplex([z,e],"resizeBilinearBackprop");for(var r=e.shape,n=r[0],o=r[1],a=r[2],i=r[3],s=z.shape,u=s[1],l=s[2],c=new Float32Array(n*o*a*i),p=[t&&1<u?o-1:o,t&&1<l?a-1:a],d=[t&&1<u?u-1:u,t&&1<l?l-1:l],h=p[0]/d[0],f=p[1]/d[1],m=z.dataSync(),g=0,B=0;B<n;B++)for(var V=B*e.strides[0],x=0;x<u;x++)for(var U=x*h,E=_Mathfloor(U),w=_Mathmin(_Mathceil(U),o-1),S=V+E*e.strides[1],b=V+w*e.strides[1],C=U-E,_=1-C,A=0;A<l;A++)for(var W=A*f,R=_Mathfloor(W),I=_Mathmin(_Mathceil(W),a-1),k=W-R,D=1-k,M=S+R*e.strides[2],O=S+I*e.strides[2],P=b+R*e.strides[2],F=b+I*e.strides[2],L=0,q;L<i;L++)q=m[g++],c[M+L]+=q*(_*D),c[O+L]+=q*(_*k),c[P+L]+=q*(C*D),c[F+L]+=q*(C*k);return tensor4d(c,[n,a,o,i],e.dtype)},t.prototype.resizeNearestNeighbor=function(N,e,t,r){this.assertNotComplex(N,"resizeNearestNeighbor");for(var n=N.shape,o=n[0],a=n[1],i=n[2],s=n[3],u=N.dataSync(),l=new Float32Array(o*e*t*s),c=[r&&1<e?a-1:a,r&&1<t?i-1:i],p=[r&&1<e?e-1:e,r&&1<t?t-1:t],d=c[0]/p[0],h=c[1]/p[1],f=0,I=0;I<o;I++)for(var k=I*N.strides[0],v=0;v<e;v++)for(var R=d*v,x=k+_Mathmin(a-1,r?_Mathround(R):_Mathfloor(R))*N.strides[1],T=0;T<t;T++)for(var D=h*T,w=x+_Mathmin(i-1,r?_Mathround(D):_Mathfloor(D))*N.strides[2],S=0,P;S<s;S++)P=u[w+S],l[f++]=P;return tensor(l,[o,e,t,s],N.dtype)},t.prototype.resizeNearestNeighborBackprop=function(V,e,t){this.assertNotComplex([V,e],"resizeNearestNeighborBackprop");for(var r=e.shape,n=r[0],o=r[1],a=r[2],i=r[3],s=V.shape,u=s[1],l=s[2],c=new Float32Array(n*o*a*i),p=V.dataSync(),d=[t&&1<u?o-1:o,t&&1<l?a-1:a],h=[t&&1<u?u-1:u,t&&1<l?l-1:l],f=d[0]/h[0],m=d[1]/h[1],g=1/f,v=1/m,y=2*_Mathceil(g)+2,x=2*_Mathceil(v)+2,T=0;T<n;T++)for(var W=T*e.strides[0],w=0;w<o;w++)for(var G=W+w*e.strides[1],b=_Mathfloor(w*g),C=_Mathfloor(b-y/2),_=0;_<a;_++)for(var q=G+_*e.strides[2],N=_Mathfloor(_*v),R=_Mathfloor(N-x/2),I=0;I<i;I++){for(var H=0,j=0,$;j<y;j++)if($=j+C,!(0>$||$>=u)){var K=W+$*V.strides[1],P=$*f;if(w===_Mathmin(o-1,t?_Mathround(P):_Mathfloor(P)))for(var F=0,X;F<x;F++)if(X=F+R,!(0>X||X>=l)){var Y=K+X*V.strides[2],U=X*m;_===_Mathmin(a-1,t?_Mathround(U):_Mathfloor(U))&&(H+=p[Y+I])}}c[q+I]=H}return tensor4d(c,e.shape,e.dtype)},t.prototype.batchNormalization=function(b,e,t,r,n,o){this.assertNotComplex([b,e,t,n,o],"batchNormalization");for(var a=b.dataSync(),i=e.dataSync(),s=t.dataSync(),u=n?n.dataSync():new Float32Array([1]),l=o?o.dataSync():new Float32Array([0]),c=new Float32Array(a.length),p=l.length,d=u.length,h=s.length,f=i.length,m=0,N=0,I=0,S=0,C=0;C<a.length;++C)c[C]=l[m++]+(a[C]-i[N++])*u[I++]/_Mathsqrt(s[S++]+r),m>=p&&(m=0),N>=f&&(N=0),I>=d&&(I=0),S>=h&&(S=0);return tensor4d(c,b.shape)},t.prototype.localResponseNormalization4D=function(m,g,e,t,n){function r(t){for(var e=t%c,r=t-e+_Mathmax(0,e-g),s=t-e+_Mathmin(e+g,a),o=0,p;r<=s;r++)p=i[r],o+=p*p;return o}this.assertNotComplex(m,"localResponseNormalization4D");for(var c=m.shape[3],a=c-1,i=m.dataSync(),o=sizeFromShape(m.shape),s=new Float32Array(o),l=0;l<o;l++){var u=r(l),d=i[l]*_Mathpow(e+t*u,-n);s[l]=d}return tensor4d(s,m.shape)},t.prototype.LRNGrad=function(b,e,t,r,n,o,a){this.assertNotComplex(b,"LRNGrad");for(var i=b.shape[3],s=b.dataSync(),u=e.dataSync(),l=t.dataSync(),c=new Float32Array(sizeFromShape(b.shape)),p=sizeFromShape(b.shape),d=0;d<p;d++){for(var N=d%i,f=d-N+_Mathmax(0,N-r),m=d-N+_Mathmin(i,N+r+1),g=0,I=f;I<m;I++)g+=_Mathpow(u[I],2);for(g=o*g+n,I=f;I<m;I++){var S=-2*o*a*u[I]*l[d]/g;d===I&&(S+=_Mathpow(g,-a)),S*=s[d],c[I]+=S}}return tensor4d(c,b.shape)},t.prototype.multinomial=function(b,e,t,r){this.assertNotComplex(b,"multinomial");for(var n=e?b:softmax(b),o=n.shape[0],a=n.shape[1],i=zeros([o,t],"int32"),s=i.dataSync(),u=n.dataSync(),l=0;l<o;++l){var x=l*a,p=new Float32Array(a-1);p[0]=u[x];for(var d=1;d<p.length;++d)p[d]=p[d-1]+u[x+d];for(var N=seedrandom_1(r.toString()),f=l*t,m=0,I;m<t;++m){I=N(),s[f+m]=p.length;for(var S=0;S<p.length;S++)if(I<p[S]){s[f+m]=S;break}}}return i},t.prototype.oneHot=function(s,e,t,r){this.assertNotComplex(s,"oneHot");var n=new Float32Array(s.size*e);n.fill(r);for(var o=0;o<s.size;++o)0<=s.get(o)&&s.get(o)<e&&(n[o*e+s.get(o)]=t);return tensor2d(n,[s.size,e],"int32")},t.prototype.nonMaxSuppression=function(a,e,t,r,n){return this.assertNotComplex(a,"nonMaxSuppression"),nonMaxSuppressionImpl(a.dataSync(),e.dataSync(),t,r,n)},t.prototype.fft=function(t){if(1!==t.shape[0])throw new Error("tf.fft() on CPU only supports vectors.");return this.fftImpl(t,!1)},t.prototype.ifft=function(t){if(1!==t.shape[0])throw new Error("tf.ifft() on CPU only supports vectors.");return this.fftImpl(t,!0)},t.prototype.fftImpl=function(s,e){var t=s.as1D(),r=t.size;if(this.isExponentOf2(r)){var n=this.fftRadix2(t,r,e).as2D(s.shape[0],s.shape[1]);return e&&(n=complex(real(n).div(scalar(r)),imag(n).div(scalar(r)))),n}var p=s.dataSync(),a=splitRealAndImagArrays(this.fourierTransformByMatmul(p,r,e));return complex(a.real,a.imag).as2D(s.shape[0],s.shape[1])},t.prototype.isExponentOf2=function(t){return 0==(t&t-1)},t.prototype.fftRadix2=function(m,e,t){if(1===e)return m;var r=m.dataSync(),n=e/2,o=complexWithEvenIndex(r),a=complex(o.real,o.imag).as1D(),g=complexWithOddIndex(r),s=complex(g.real,g.imag).as1D();a=this.fftRadix2(a,n,t),s=this.fftRadix2(s,n,t);var y=exponents(e,t),l=complex(y.real,y.imag).mul(s),c=a.add(l),p=a.sub(l),d=real(c).concat(real(p)),h=imag(c).concat(imag(p));return complex(d,h).as1D()},t.prototype.fourierTransformByMatmul=function(p,e,t){for(var r=new Float32Array(2*e),n=0;n<e;n++){for(var d=0,c=0,m=0;m<e;m++){var h=exponent(n*m,e,t),u=getComplexWithIndex(p,m);d+=u.real*h.real-u.imag*h.imag,c+=u.real*h.imag+u.imag*h.real}t&&(d/=e,c/=e),assignToTypedArray(r,d,c,n)}return r},t.prototype.depthToSpace=function(b,e,t){assert("NHWC"===t,"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+t),assert(1<e,"blockSize should be > 1 for depthToSpace, but was: "+e);for(var r=b.shape[0],n=b.shape[1],o=b.shape[2],a=b.shape[3],i=n*e,s=o*e,u=a/(e*e),l=b.dataSync(),c=new Float32Array(r*i*s*u),p=0,N=0;N<r;++N)for(var I=0;I<i;++I)for(var S=_Mathfloor(I/e),m=I%e,g=0;g<s;++g)for(var C=_Mathfloor(g/e),y=(m*e+g%e)*u,x=0,k;x<u;++x)k=x+y+a*(C+o*(S+n*N)),c[p++]=l[k];return tensor4d(c,[r,i,s,u])},t.prototype.broadcastedBinaryOp=function(y,e,t,b){var n=assertAndGetBroadcastShape(y.shape,e.shape),x=buffer(n,t),a=y.dataSync(),i=e.dataSync(),s=getBroadcastDims(y.shape,n),u=getBroadcastDims(e.shape,n),l=x.values;if(0===s.length+u.length)for(var r=0;r<l.length;++r)l[r]=b(a[r%a.length],i[r%i.length]);else{var c=y.buffer(),d=e.buffer(),o=function(t){var n=x.indexToLoc(t),r=n.slice(-y.rank);s.forEach(function(t){return r[t]=0});var o=c.locToIndex(r),p=n.slice(-e.rank);u.forEach(function(t){return p[t]=0});var m=d.locToIndex(p);l[t]=b(a[o],i[m])};for(r=0;r<l.length;++r)o(r)}return x.toTensor()},t.prototype.broadcastedBinaryComplexOp=function(b,e,t){var r=assertAndGetBroadcastShape(b.shape,e.shape),x=buffer(r,"float32"),n=buffer(r,"float32"),o=b.dataSync(),i=e.dataSync(),s=getBroadcastDims(b.shape,r),u=getBroadcastDims(e.shape,r),l=x.values,c=n.values;if(0===s.length+u.length)for(var a=0;a<l.length;a++){var p=a%o.length,h=a%i.length,f=t(o[2*p],o[2*p+1],i[2*h],i[2*h+1]);l[a]=f.real,c[a]=f.imag}else{var N=this.data.get(b.dataId).complexTensors.real.buffer(),g=this.data.get(e.dataId).complexTensors.real.buffer(),m=function(r){var n=x.indexToLoc(r),a=n.slice(-b.rank);s.forEach(function(t){return a[t]=0});var p=N.locToIndex(a),d=n.slice(-e.rank);u.forEach(function(t){return d[t]=0});var h=g.locToIndex(d),m=t(o[2*p],o[2*p+1],i[2*h],i[2*h+1]);l[r]=m.real,c[r]=m.imag};for(a=0;a<l.length;a++)m(a)}return this.complex(x.toTensor(),n.toTensor())},t.prototype.split=function(a,e,t){return split(a,e,t)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.cropAndResize=function(Y,e,t,r,n,o){for(var a=Y.shape,i=a[0],s=a[1],u=a[2],l=a[3],c=e.shape[0],p=r[0],d=r[1],h=buffer([c,p,d,l]),f=e.dataSync(),m=t.dataSync(),g=Y.dataSync(),v=Y.strides,y=h.strides,x=0;x<c;x++){var Z=4*x,E=f[Z],w=f[Z+1],S=f[Z+2],b=f[Z+3],C=m[x];if(!(C>=i))for(var _=1<p?(S-E)*(s-1)/(p-1):0,A=1<d?(b-w)*(u-1)/(d-1):0,N=0,Q;N<p;N++)if(Q=1<p?E*(s-1)+N*_:.5*(E+S)*(s-1),0>Q||Q>s-1)for(var J=0;J<d;J++)for(var ee=0,te;ee<l;ee++)te=ee+J*y[2]+N*y[1]+x*y[0],h.values[te]=o;else if("bilinear"===n){var ae=_Mathfloor(Q),O=_Mathceil(Q),P=Q-ae;for(J=0;J<d;J++)if(0>(W=1<d?w*(u-1)+J*A:.5*(w+b)*(u-1))||W>u-1)for(ee=0;ee<l;ee++)te=ee+J*y[2]+N*y[1]+x*y[0],h.values[te]=o;else{var F=_Mathfloor(W),L=_Mathceil(W),B=W-F;for(ee=0;ee<l;ee++){var U=g[te=ee+F*v[2]+ae*v[1]+C*v[0]],z=g[te=ee+L*v[2]+ae*v[1]+C*v[0]],V=g[te=ee+F*v[2]+O*v[1]+C*v[0]],H=U+(z-U)*B,G=V+(g[te=ee+L*v[2]+O*v[1]+C*v[0]]-V)*B;te=ee+J*y[2]+N*y[1]+x*y[0],h.values[te]=H+(G-H)*P}}}else for(J=0;J<d;++J){var W;if(0>(W=1<d?w*(u-1)+J*A:.5*(w+b)*(u-1))||W>u-1)for(ee=0;ee<l;ee++)te=ee+J*y[2]+N*y[1]+x*y[0],h.values[te]=o;else{var ne=_Mathround(W),$=_Mathround(Q);for(ee=0;ee<l;ee++){var X=ee+ne*v[2]+$*v[1]+C*v[0],K=ee+J*y[2]+N*y[1]+x*y[0];h.values[K]=g[X]}}}}return h.toTensor()},t.prototype.sparseToDense=function(p,e,t,r){var n=calculateShapes(e,p,t),o=n.sliceRank,a=n.numUpdates,i=n.sliceSize,s=n.strides,d=n.outputSize;return this.scatter(p,e,t,d,i,a,o,s,r,!1)},t.prototype.gatherND=function(y,e){var t=e.shape,r=t[t.length-1],n=prepareAndValidate(y,e),o=n[0],a=n[1],i=n[2],s=n[3];if(0===a)return tensor([],o,y.dtype);for(var u=new TensorBuffer([a,i],y.dtype),l=e.dataSync(),c=y.dataSync(),p=0;p<a;p++){for(var b=[],h=0,x=0,N;x<r;x++)N=l[p*r+x],h+=N*s[x],b.push(N);if(0>h||h>=y.size/i)throw new Error("Invalid indices:  does not index into "+y.shape);for(var I=0;I<i;I++)u.values[p*i+I]=c[h*i+I]}return u.toTensor().reshape(o)},t.prototype.scatterND=function(p,e,t){var r=calculateShapes(e,p,t),n=r.sliceRank,o=r.numUpdates,a=r.sliceSize,i=r.strides,s=r.outputSize,d=scalar(0);return this.scatter(p,e,t,s,a,o,n,i,d,!0)},t.prototype.scatter=function(c,e,t,r,n,o,a,i,s,u){var l=c.dataSync(),p=e.dataSync();if(0===r)return tensor([],t,e.dtype);var d=new TensorBuffer([r/n,n],e.dtype);d.values.fill(s.dataSync()[0]);for(var h=0;h<o;h++){for(var b=[],m=0,N=0,I;N<a;N++)I=l[h*a+N],b.push(I),m+=I*i[N];if(0>m||m>=r/n)throw new Error("Invalid indices:  does not index into "+t);for(var S=0;S<n;S++)u?d.values[m*n+S]+=p[h*n+S]:d.values[m*n+S]=0===e.rank?p[0]:p[h*n+S]}return d.toTensor().reshape(t)},t}();ENV.registerBackend("cpu",function(){return new MathBackendCPU},1,setTensorTracker);var delayCallback="undefined"==typeof requestAnimationFrame?setImmediate:requestAnimationFrame,DTYPE_VALUE_SIZE_MAP={float32:4,int32:4,uint16:2,uint8:1,bool:1},useNodeBuffer="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa),IORouterRegistry=function(){function a(){this.saveRouters=[],this.loadRouters=[]}return a.getInstance=function(){return null==a.instance&&(a.instance=new a),a.instance},a.registerSaveRouter=function(e){a.getInstance().saveRouters.push(e)},a.registerLoadRouter=function(e){a.getInstance().loadRouters.push(e)},a.getSaveHandlers=function(e){return a.getHandlers(e,"save")},a.getLoadHandlers=function(e){return a.getHandlers(e,"load")},a.getHandlers=function(a,e){var o=[];return("load"===e?this.getInstance().loadRouters:this.getInstance().saveRouters).forEach(function(e){var t=e(a);null!==t&&o.push(t)}),o},a}(),URL_SCHEME_SUFFIX="://",ModelStoreManagerRegistry=function(){function a(){this.managers={}}return a.getInstance=function(){return null==a.instance&&(a.instance=new a),a.instance},a.registerManager=function(e,o){assert(null!=e,"scheme must not be undefined or null."),e.endsWith(URL_SCHEME_SUFFIX)&&(e=e.slice(0,e.indexOf(URL_SCHEME_SUFFIX))),assert(0<e.length,"scheme must not be an empty string.");var r=a.getInstance();assert(null==r.managers[e],"A model store manager is already registered for scheme '"+e+"'."),r.managers[e]=o},a.getManager=function(a){var e=this.getInstance().managers[a];if(null==e)throw new Error("Cannot find model manager for scheme '"+a+"'");return e},a.getSchemes=function(){return Object.keys(this.getInstance().managers)},a}(),DATABASE_NAME="tensorflowjs",DATABASE_VERSION=1,MODEL_STORE_NAME="models_store",INFO_STORE_NAME="model_info_store",BrowserIndexedDB=function(){function t(t){if(this.indexedDB=getIndexedDBFactory(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}return t.prototype.save=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,t)]})})},t.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(){return[2,this.databaseAction(this.modelPath)]})})},t.prototype.databaseAction=function(a,m){var h=this;return new Promise(function(t,e){var n=h.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);n.onupgradeneeded=function(){return setUpDatabase(n)},n.onsuccess=function(){var r=n.result;if(null==m){var a=r.transaction(MODEL_STORE_NAME,"readonly"),o=a.objectStore(MODEL_STORE_NAME).get(h.modelPath);o.onsuccess=function(){return null==o.result?(r.close(),e(new Error("Cannot find model with path '"+h.modelPath+"' in IndexedDB."))):void t(o.result.modelArtifacts)},o.onerror=function(){return r.close(),e(o.error)},a.oncomplete=function(){return r.close()}}else{var s=getModelArtifactsInfoForJSON(m),i=r.transaction(INFO_STORE_NAME,"readwrite"),l=i.objectStore(INFO_STORE_NAME),c=l.put({modelPath:h.modelPath,modelArtifactsInfo:s}),d;c.onsuccess=function(){var a=(d=r.transaction(MODEL_STORE_NAME,"readwrite")).objectStore(MODEL_STORE_NAME).put({modelPath:h.modelPath,modelArtifacts:m,modelArtifactsInfo:s});a.onsuccess=function(){return t({modelArtifactsInfo:s})},a.onerror=function(){var n=(l=i.objectStore(INFO_STORE_NAME)).delete(h.modelPath);n.onsuccess=function(){return r.close(),e(a.error)},n.onerror=function(){return r.close(),e(a.error)}}},c.onerror=function(){return r.close(),e(c.error)},i.oncomplete=function(){null==d?r.close():d.oncomplete=function(){return r.close()}}}},n.onerror=function(){return e(n.error)}})},t.URL_SCHEME="indexeddb://",t}(),indexedDBRouter=function(t){return ENV.get("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(t.slice(BrowserIndexedDB.URL_SCHEME.length)):null};IORouterRegistry.registerSaveRouter(indexedDBRouter),IORouterRegistry.registerLoadRouter(indexedDBRouter);var BrowserIndexedDBManager=function(){function t(){this.indexedDB=getIndexedDBFactory()}return t.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var a=this;return __generator(this,function(){return[2,new Promise(function(s,t){var r=a.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);r.onupgradeneeded=function(){return setUpDatabase(r)},r.onsuccess=function(){var n=r.result,e=n.transaction(INFO_STORE_NAME,"readonly"),i=e.objectStore(INFO_STORE_NAME).getAll();i.onsuccess=function(){for(var t={},e=0,a=i.result,n;e<a.length;e++)n=a[e],t[n.modelPath]=n.modelArtifactsInfo;s(t)},i.onerror=function(){return n.close(),t(i.error)},e.oncomplete=function(){return n.close()}},r.onerror=function(){return t(r.error)}})]})})},t.prototype.removeModel=function(p){return __awaiter(this,void 0,void 0,function(){var e=this;return __generator(this,function(){return p=maybeStripScheme(p),[2,new Promise(function(t,r){var n=e.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);n.onupgradeneeded=function(){return setUpDatabase(n)},n.onsuccess=function(){var e=n.result,a=e.transaction(INFO_STORE_NAME,"readwrite"),l=a.objectStore(INFO_STORE_NAME),s=l.get(p),i;s.onsuccess=function(){if(null==s.result)return e.close(),r(new Error("Cannot find model with path '"+p+"' in IndexedDB."));var t=l.delete(p),a=function(){var t=(i=e.transaction(MODEL_STORE_NAME,"readwrite")).objectStore(MODEL_STORE_NAME).delete(p);t.onsuccess=function(){return t(s.result.modelArtifactsInfo)},t.onerror=function(){return r(s.error)}};t.onsuccess=a,t.onerror=function(){return a(),e.close(),r(s.error)}},s.onerror=function(){return e.close(),r(s.error)},a.oncomplete=function(){null==i?e.close():i.oncomplete=function(){return e.close()}}},n.onerror=function(){return r(n.error)}})]})})},t}();if(ENV.get("IS_BROWSER"))try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(t){}var PATH_SEPARATOR="/",PATH_PREFIX="tensorflowjs_models",INFO_SUFFIX="info",MODEL_TOPOLOGY_SUFFIX="model_topology",WEIGHT_SPECS_SUFFIX="weight_specs",WEIGHT_DATA_SUFFIX="weight_data",BrowserLocalStorage=function(){function t(t){if(!ENV.get("IS_BROWSER")||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=getModelKeys(this.modelPath)}return t.prototype.save=function(a){return __awaiter(this,void 0,void 0,function(){var e,s,i,p;return __generator(this,function(){if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");e=JSON.stringify(a.modelTopology),s=JSON.stringify(a.weightSpecs),i=getModelArtifactsInfoForJSON(a);try{return this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(a.weightData)),[2,{modelArtifactsInfo:i}]}catch(t){for(p in this.keys)this.LS.removeItem(this.keys[p]);throw new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+i.modelTopologyBytes+", weightSpecsBytes="+i.weightSpecsBytes+", weightDataBytes="+i.weightDataBytes+".")}return[2]})})},t.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var a,s,i,p,l;return __generator(this,function(){if(null==(a=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==a.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(s={},null==(i=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(s.modelTopology=i,null==(p=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(s.weightSpecs=p,null==(l=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return s.weightData=base64StringToArrayBuffer(l),[2,s]})})},t.URL_SCHEME="localstorage://",t}(),localStorageRouter=function(t){return ENV.get("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(t.slice(BrowserLocalStorage.URL_SCHEME.length)):null};IORouterRegistry.registerSaveRouter(localStorageRouter),IORouterRegistry.registerLoadRouter(localStorageRouter);var BrowserLocalStorageManager=function(){function t(){assert(ENV.get("IS_BROWSER"),"Current environment is not a web browser"),assert(void 0!==window.localStorage,"Current browser does not appear to support localStorage"),this.LS=window.localStorage}return t.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var s,i,p,l,d,u;return __generator(this,function(){for(s={},i="tensorflowjs_models/",p="/info",l=0;l<this.LS.length;++l)(d=this.LS.key(l)).startsWith(i)&&d.endsWith(p)&&(u=getModelPathFromKey(d),s[u]=JSON.parse(this.LS.getItem(d)));return[2,s]})})},t.prototype.removeModel=function(a){return __awaiter(this,void 0,void 0,function(){var e,n;return __generator(this,function(){if(a=maybeStripScheme$1(a),e=getModelKeys(a),null==this.LS.getItem(e.info))throw new Error("Cannot find model at path '"+a+"'");return n=JSON.parse(this.LS.getItem(e.info)),this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),[2,n]})})},t}();if(ENV.get("IS_BROWSER"))try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(t){}var DEFAULT_FILE_NAME_PREFIX="model",DEFAULT_JSON_EXTENSION_NAME=".json",DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin",BrowserDownloads=function(){function a(e){if(!ENV.get("IS_BROWSER"))throw new Error("triggerDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(a.URL_SCHEME)&&(e=e.slice(a.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}return a.prototype.save=function(s){return __awaiter(this,void 0,void 0,function(){var e,p,l,d,u,c;return __generator(this,function(){if(e=window.URL.createObjectURL(new Blob([s.weightData],{type:"application/octet-stream"})),s.modelTopology instanceof ArrayBuffer)throw new Error("DownloadTrigger.save() does not support saving model topology in binary formats yet.");return p=[{paths:["./"+this.weightDataFileName],weights:s.weightSpecs}],l={modelTopology:s.modelTopology,weightsManifest:p},d=window.URL.createObjectURL(new Blob([JSON.stringify(l)],{type:"application/json"})),(u=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,u.href=d,u.click(),null!=s.weightData&&((c=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,c.href=e,c.click()),[2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(s)}]})})},a.URL_SCHEME="downloads://",a}(),BrowserFiles=function(){function t(t){if(null==t||1>t.length)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}return t.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var a=this,r,m;return __generator(this,function(){return r=this.files[0],m=this.files.slice(1),[2,new Promise(function(h,t){var e=new FileReader;e.onload=function(e){var n=JSON.parse(e.target.result),i=n.modelTopology;if(null!=i){0===m.length&&h({modelTopology:i});var o=n.weightsManifest;if(null!=o){var s;try{s=a.checkManifestAndWeightFiles(o,m)}catch(a){return void t(a)}var u=[],c=[],p=[];o.forEach(function(t){t.paths.forEach(function(t){c.push(t),p.push(null)}),u.push.apply(u,t.weights)}),o.forEach(function(a){a.paths.forEach(function(a){var e=new FileReader;e.onload=function(e){var t=e.target.result,n=c.indexOf(a);p[n]=t,-1===p.indexOf(null)&&h({modelTopology:i,weightSpecs:u,weightData:concatenateArrayBuffers(p)})},e.onerror=function(){t("Failed to weights data from file of path '"+a+"'.")},e.readAsArrayBuffer(s[a])})})}else t(new Error("weightManifest field is missing from file "+r.name))}else t(new Error("modelTopology field is missing from file "+r.name))},e.onerror=function(){t("Failed to read model topology and weights manifest JSON from file '"+r.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},e.readAsText(r)})]})})},t.prototype.checkManifestAndWeightFiles=function(s,p){for(var t=[],r=p.map(function(t){return basename(t.name)}),n={},e=0,o=s;e<o.length;e++)o[e].paths.forEach(function(o){var e=basename(o);if(-1!==t.indexOf(e))throw new Error("Duplicate file basename found in weights manifest: '"+e+"'");if(t.push(e),-1===r.indexOf(e))throw new Error("Weight file with basename '"+e+"' is not provided.");n[o]=p[r.indexOf(e)]});if(t.length!==p.length)throw new Error("Mismatch in the number of files in weights manifest ("+t.length+") and the number of weight files provided ("+p.length+").");return n},t}(),browserDownloadsRouter=function(t){return ENV.get("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(BrowserDownloads.URL_SCHEME)?browserDownloads(t.slice(BrowserDownloads.URL_SCHEME.length)):null};IORouterRegistry.registerSaveRouter(browserDownloadsRouter);var BrowserHTTPRequest=function(){function t(a,e,t){if(this.weightPathPrefix=t,this.DEFAULT_METHOD="POST","undefined"==typeof fetch)throw new Error("browserHTTPRequest is not supported outside the web browser without a fetch polyfill.");if(assert(null!=a&&0<a.length,"URL path for browserHTTPRequest must not be null, undefined or empty."),Array.isArray(a)&&assert(2===a.length,"URL paths for browserHTTPRequest must have a length of 2, (actual length is "+a.length+")."),this.path=a,null!=e&&null!=e.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e||{}}return t.prototype.save=function(s){return __awaiter(this,void 0,void 0,function(){var e,i,p,l;return __generator(this,function(t){switch(t.label){case 0:if(s.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,i=[{paths:["./model.weights.bin"],weights:s.weightSpecs}],p={modelTopology:s.modelTopology,weightsManifest:i},e.body.append("model.json",new Blob([JSON.stringify(p)],{type:"application/json"}),"model.json"),null!=s.weightData&&e.body.append("model.weights.bin",new Blob([s.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,fetch(this.path,e)];case 1:if((l=t.sent()).ok)return[2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(s),responses:[l]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+l.status+".");}})})},t.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(){return[2,Array.isArray(this.path)?this.loadBinaryModel():this.loadJSONModel()]})})},t.prototype.loadBinaryTopology=function(){return __awaiter(this,void 0,void 0,function(){var a,n;return __generator(this,function(e){switch(e.label){case 0:return e.trys.push([0,3,,4]),[4,fetch(this.path[0],this.requestInit)];case 1:if(!(a=e.sent()).ok)throw new Error("BrowserHTTPRequest.load() failed due to HTTP response: "+a.statusText);return[4,a.arrayBuffer()];case 2:return[2,e.sent()];case 3:throw n=e.sent(),new Error(this.path[0]+" not found. "+n);case 4:return[2];}})})},t.prototype.loadBinaryModel=function(){return __awaiter(this,void 0,void 0,function(){var p,l,d,c,m,h,g,f;return __generator(this,function(e){switch(e.label){case 0:return p=this.loadBinaryTopology(),[4,fetch(this.path[1],this.requestInit)];case 1:if(!(l=e.sent()).ok)throw new Error("BrowserHTTPRequest.load() failed due to HTTP response: "+l.statusText);return[4,Promise.all([p,l])];case 2:return d=e.sent(),c=d[0],[4,d[1].json()];case 3:return null==(m=e.sent())?[3,5]:[4,this.loadWeights(m)];case 4:f=e.sent(),h=f[0],g=f[1],e.label=5;case 5:return[2,{modelTopology:c,weightSpecs:h,weightData:g}];}})})},t.prototype.loadJSONModel=function(){return __awaiter(this,void 0,void 0,function(){var p,l,d,c,m,h,g,f;return __generator(this,function(e){switch(e.label){case 0:return[4,fetch(this.path,this.requestInit)];case 1:if(!(p=e.sent()).ok)throw new Error("BrowserHTTPRequest.load() failed due to HTTP response: "+p.statusText);return[4,p.json()];case 2:if(l=e.sent(),d=l.modelTopology,c=l.weightsManifest,null==d&&null==c)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==c?[3,4]:(g=l.weightsManifest,[4,this.loadWeights(g)]);case 3:f=e.sent(),m=f[0],h=f[1],e.label=4;case 4:return[2,{modelTopology:d,weightSpecs:m,weightData:h}];}})})},t.prototype.loadWeights=function(m){return __awaiter(this,void 0,void 0,function(){var e,h,g,f,y,b,x,N,I,v,S,C;return __generator(this,function(t){switch(t.label){case 0:for(e=Array.isArray(this.path)?this.path[1]:this.path,h=parseUrl(e),g=h[0],f=h[1],y=this.weightPathPrefix||g,b=[],x=0,N=m;x<N.length;x++)I=N[x],b.push.apply(b,I.weights);return v=[],m.forEach(function(t){t.paths.forEach(function(t){v.push(y+t+f)})}),S=[b],C=concatenateArrayBuffers,[4,loadWeightsAsArrayBuffer(v,this.requestInit)];case 1:return[2,S.concat([C.apply(void 0,[t.sent()])])];}})})},t.URL_SCHEME_REGEX=/^https?:\/\//,t}(),httpRequestRouter=function(t){return"undefined"==typeof fetch?null:(Array.isArray(t)?t.every(function(t){return isHTTPScheme(t)}):isHTTPScheme(t))?browserHTTPRequest(t):null};IORouterRegistry.registerSaveRouter(httpRequestRouter),IORouterRegistry.registerLoadRouter(httpRequestRouter);var PassthroughLoader=function(){function t(a,e,t){this.modelTopology=a,this.weightSpecs=e,this.weightData=t}return t.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(){return t={},null!=this.modelTopology&&(t=__assign({modelTopology:this.modelTopology},t)),null!=this.weightSpecs&&0<this.weightSpecs.length&&(t=__assign({weightSpecs:this.weightSpecs},t)),null!=this.weightData&&0<this.weightData.byteLength&&(t=__assign({weightData:this.weightData},t)),[2,t]})})},t}(),PassthroughSaver=function(){function t(t){this.saveHandler=t}return t.prototype.save=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(){return[2,this.saveHandler(t)]})})},t}(),registerSaveRouter=IORouterRegistry.registerSaveRouter,registerLoadRouter=IORouterRegistry.registerLoadRouter,getSaveHandlers=IORouterRegistry.getSaveHandlers,getLoadHandlers=IORouterRegistry.getLoadHandlers,io=Object.freeze({browserFiles:browserFiles,browserHTTPRequest:browserHTTPRequest,concatenateArrayBuffers:concatenateArrayBuffers,decodeWeights:decodeWeights,encodeWeights:encodeWeights,fromMemory:fromMemory,getLoadHandlers:getLoadHandlers,getModelArtifactsInfoForJSON:getModelArtifactsInfoForJSON,getSaveHandlers:getSaveHandlers,loadWeights:loadWeights,registerLoadRouter:registerLoadRouter,registerSaveRouter:registerSaveRouter,withSaveHandler:withSaveHandler,copyModel:copyModel,listModels:listModels,moveModel:moveModel,removeModel:removeModel}),confusionMatrix=op({confusionMatrix_:confusionMatrix_}),math=Object.freeze({confusionMatrix:confusionMatrix}),Serializable=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(a,e){return new a(e)},t}(),SerializationMap=function(){function a(){this.classNameMap={}}return a.getMap=function(){return null==a.instance&&(a.instance=new a),a.instance},a.register=function(e){a.getMap().classNameMap[e.className]=[e,e.fromConfig]},a}(),serialization=Object.freeze({Serializable:Serializable,SerializationMap:SerializationMap,registerClass:registerClass}),WEBGL_ENVS={HAS_WEBGL:!0},NODE_ENVS={IS_NODE:!0},CHROME_ENVS={IS_CHROME:!0},BROWSER_ENVS={IS_BROWSER:!0},CPU_ENVS={HAS_WEBGL:!1},BROWSER_CPU_ENVS={BACKEND:"test-cpu"},ALL_ENVS={},test_util=Object.freeze({WEBGL_ENVS:WEBGL_ENVS,NODE_ENVS:NODE_ENVS,CHROME_ENVS:CHROME_ENVS,BROWSER_ENVS:BROWSER_ENVS,CPU_ENVS:CPU_ENVS,BROWSER_CPU_ENVS:BROWSER_CPU_ENVS,ALL_ENVS:ALL_ENVS,expectArraysClose:expectArraysClose,expectPromiseToFail:expectPromiseToFail,expectArraysEqual:expectArraysEqual,expectNumbersClose:expectNumbersClose,expectValuesInRange:expectValuesInRange,expectArrayBuffersEqual:expectArrayBuffersEqual}),webgl=Object.freeze({gpgpu_util:gpgpu_util,webgl_util:webgl_util,MathBackendWebGL:MathBackendWebGL,GPGPUContext:GPGPUContext}),Optimizer=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends(e,a),e.prototype.minimize=function(s,e,i){void 0===e&&(e=!1);var r=this.computeGradients(s,i),n=r.value,o=r.grads;return this.applyGradients(o),Object.keys(o).forEach(function(t){return o[t].dispose()}),e?n:(n.dispose(),null)},e.prototype.computeGradients=function(a,e){return variableGrads(a,e)},e}(Serializable),AdadeltaOptimizer=function(a){function e(e,t,r){void 0===r&&(r=null);var s=a.call(this)||this;return s.learningRate=e,s.rho=t,s.epsilon=r,s.accumulatedGrads={},s.accumulatedUpdates={},s.c=keep(scalar(-e)),s.rhoScalar=keep(scalar(t)),s.oneMinusRho=keep(scalar(1-t)),null===r&&(r=ENV.get("EPSILON")),s.epsilonScalar=keep(scalar(r)),s}return __extends(e,a),e.prototype.applyGradients=function(p){var d=this,e=function(c){var r=ENV.engine.registeredVariables[c];null==t.accumulatedGrads[c]&&tidy(function(){d.accumulatedGrads[c]=zerosLike(r).variable(!1)}),null==t.accumulatedUpdates[c]&&tidy(function(){d.accumulatedUpdates[c]=zerosLike(r).variable(!1)});var o=p[c],a=t.accumulatedGrads[c],i=t.accumulatedUpdates[c];tidy(function(){var t=d.rhoScalar.mul(a).add(d.oneMinusRho.mul(o.square())),e=i.add(d.epsilonScalar).sqrt().div(a.add(d.epsilonScalar).sqrt()).mul(o),n=d.rhoScalar.mul(i).add(d.oneMinusRho.mul(e.square()));d.accumulatedGrads[c].assign(t),d.accumulatedUpdates[c].assign(n);var s=d.c.mul(e).add(r);r.assign(s)})},t=this;for(var a in p)e(a)},e.prototype.dispose=function(){var a=this;this.c.dispose(),this.epsilonScalar.dispose(),this.rhoScalar.dispose(),this.oneMinusRho.dispose(),null!=this.accumulatedUpdates&&(Object.keys(this.accumulatedUpdates).forEach(function(e){return a.accumulatedUpdates[e].dispose()}),Object.keys(this.accumulatedGrads).forEach(function(e){return a.accumulatedGrads[e].dispose()}))},e.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},e.fromConfig=function(a,e){return new a(e.learningRate,e.rho,e.epsilon)},e.className="AdadeltaOptimizer",e}(Optimizer);registerClass(AdadeltaOptimizer);var AdagradOptimizer=function(a){function e(e,t){void 0===t&&(t=.1);var o=a.call(this)||this;return o.learningRate=e,o.initialAccumulatorValue=t,o.accumulatedGrads={},o.c=keep(scalar(-e)),o.epsilon=keep(scalar(ENV.get("EPSILON"))),o}return __extends(e,a),e.prototype.applyGradients=function(s){var p=this,e=function(l){var r=ENV.engine.registeredVariables[l];null==t.accumulatedGrads[l]&&tidy(function(){p.accumulatedGrads[l]=fill(r.shape,p.initialAccumulatorValue).variable(!1)});var o=s[l],a=t.accumulatedGrads[l];tidy(function(){var t=a.add(o.square());p.accumulatedGrads[l].assign(t);var e=p.c.mul(o.div(t.add(p.epsilon).sqrt())).add(r);r.assign(e)})},t=this;for(var a in s)e(a)},e.prototype.dispose=function(){var a=this;this.epsilon.dispose(),this.c.dispose(),null!=this.accumulatedGrads&&Object.keys(this.accumulatedGrads).forEach(function(e){return a.accumulatedGrads[e].dispose()})},e.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},e.fromConfig=function(a,e){return new a(e.learningRate,e.initialAccumulatorValue)},e.className="AdagradOptimizer",e}(Optimizer);registerClass(AdagradOptimizer);var AdamOptimizer=function(s){function e(e,t,r,n){void 0===n&&(n=null);var i=s.call(this)||this;return i.learningRate=e,i.beta1=t,i.beta2=r,i.epsilon=n,i.accumulatedFirstMoment={},i.accumulatedSecondMoment={},i.c=keep(scalar(-e)),i.beta1Scalar=keep(scalar(t)),i.beta2Scalar=keep(scalar(r)),tidy(function(){i.accBeta1=scalar(t).variable(),i.accBeta2=scalar(r).variable()}),i.oneMinusBeta1=keep(scalar(1-t)),i.oneMinusBeta2=keep(scalar(1-r)),i.one=keep(scalar(1)),null===n&&(n=ENV.get("EPSILON")),i.epsScalar=keep(scalar(n)),i}return __extends(e,s),e.prototype.applyGradients=function(m){var e=this;tidy(function(){var t=e.one.sub(e.accBeta1),r=e.one.sub(e.accBeta2);for(var n in m){var o=ENV.engine.registeredVariables[n];if(null==e.accumulatedFirstMoment[n]){var a=!1;e.accumulatedFirstMoment[n]=zerosLike(o).variable(a)}null==e.accumulatedSecondMoment[n]&&(a=!1,e.accumulatedSecondMoment[n]=zerosLike(o).variable(a));var g=m[n],s=e.accumulatedFirstMoment[n],u=e.accumulatedSecondMoment[n],l=e.beta1Scalar.mul(s).add(e.oneMinusBeta1.mul(g)),c=e.beta2Scalar.mul(u).add(e.oneMinusBeta2.mul(g.square())),p=l.div(t),d=c.div(r);e.accumulatedFirstMoment[n].assign(l),e.accumulatedSecondMoment[n].assign(c);var h=e.c.mul(p.div(e.epsScalar.add(d.sqrt()))).add(o);o.assign(h)}e.accBeta1.assign(e.accBeta1.mul(e.beta1Scalar)),e.accBeta2.assign(e.accBeta2.mul(e.beta2Scalar))})},e.prototype.dispose=function(){var a=this;this.c.dispose(),this.epsScalar.dispose(),this.beta1Scalar.dispose(),this.beta2Scalar.dispose(),this.accBeta1.dispose(),this.accBeta2.dispose(),this.oneMinusBeta1.dispose(),this.oneMinusBeta2.dispose(),this.one.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return a.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedSecondMoment&&Object.keys(this.accumulatedSecondMoment).forEach(function(e){return a.accumulatedSecondMoment[e].dispose()})},e.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},e.fromConfig=function(a,e){return new a(e.learningRate,e.beta1,e.beta2,e.epsilon)},e.className="AdamOptimizer",e}(Optimizer);registerClass(AdamOptimizer);var AdamaxOptimizer=function(s){function e(e,t,r,n,p){void 0===n&&(n=null),void 0===p&&(p=0);var l=s.call(this)||this;return l.learningRate=e,l.beta1=t,l.beta2=r,l.epsilon=n,l.decay=p,l.accumulatedFirstMoment={},l.accumulatedWeightedInfNorm={},l.c=keep(scalar(-e)),l.beta1Scalar=keep(scalar(t)),l.beta2Scalar=keep(scalar(r)),l.decayScalar=keep(scalar(p)),tidy(function(){l.iteration=scalar(0).variable(),l.accBeta1=scalar(t).variable()}),l.oneMinusBeta1=keep(scalar(1-t)),l.one=keep(scalar(1)),null===n&&(n=ENV.get("EPSILON")),l.epsScalar=keep(scalar(n)),l}return __extends(e,s),e.prototype.applyGradients=function(m){var e=this;tidy(function(){var t=e.one.sub(e.accBeta1),r=e.c.div(e.one.add(e.decayScalar.mul(e.iteration)));for(var n in m){var o=ENV.engine.registeredVariables[n];if(null==e.accumulatedFirstMoment[n]){var a=!1;e.accumulatedFirstMoment[n]=zerosLike(o).variable(a)}null==e.accumulatedWeightedInfNorm[n]&&(a=!1,e.accumulatedWeightedInfNorm[n]=zerosLike(o).variable(a));var g=m[n],s=e.accumulatedFirstMoment[n],u=e.accumulatedWeightedInfNorm[n],l=e.beta1Scalar.mul(s).add(e.oneMinusBeta1.mul(g)),c=e.beta2Scalar.mul(u),p=g.abs(),d=c.maximum(p);e.accumulatedFirstMoment[n].assign(l),e.accumulatedWeightedInfNorm[n].assign(d);var h=r.div(t).mul(l.div(e.epsScalar.add(d))).add(o);o.assign(h)}e.iteration.assign(e.iteration.add(e.one)),e.accBeta1.assign(e.accBeta1.mul(e.beta1Scalar))})},e.prototype.dispose=function(){var a=this;this.c.dispose(),this.epsScalar.dispose(),this.accBeta1.dispose(),this.beta1Scalar.dispose(),this.beta2Scalar.dispose(),this.oneMinusBeta1.dispose(),this.decayScalar.dispose(),this.iteration.dispose(),this.one.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return a.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedWeightedInfNorm&&Object.keys(this.accumulatedWeightedInfNorm).forEach(function(e){return a.accumulatedWeightedInfNorm[e].dispose()})},e.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},e.fromConfig=function(a,e){return new a(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)},e.className="AdamaxOptimizer",e}(Optimizer);registerClass(AdamaxOptimizer);var SGDOptimizer=function(a){function e(e){var t=a.call(this)||this;return t.learningRate=e,t.setLearningRate(e),t}return __extends(e,a),e.prototype.applyGradients=function(a){var r=this;Object.keys(a).forEach(function(e){var t=a[e],n=ENV.engine.registeredVariables[e];tidy(function(){var a=r.c.mul(t).add(n);n.assign(a)})})},e.prototype.setLearningRate=function(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=keep(scalar(-t))},e.prototype.dispose=function(){this.c.dispose()},e.prototype.getConfig=function(){return{learningRate:this.learningRate}},e.fromConfig=function(a,e){return new a(e.learningRate)},e.className="SGDOptimizer",e}(Optimizer);registerClass(SGDOptimizer);var MomentumOptimizer=function(a){function e(e,t,r){void 0===r&&(r=!1);var s=a.call(this,e)||this;return s.learningRate=e,s.momentum=t,s.useNesterov=r,s.m=scalar(s.momentum),s.accumulations={},s}return __extends(e,a),e.prototype.applyGradients=function(s){var p=this,e=function(l){var r=ENV.engine.registeredVariables[l];null==t.accumulations[l]&&tidy(function(){p.accumulations[l]=zerosLike(r).variable(!1)});var o=t.accumulations[l],a=s[l];tidy(function(){var t=p.m.mul(o).add(a),n;n=p.useNesterov?p.c.mul(a.add(t.mul(p.m))).add(r):p.c.mul(t).add(r),p.accumulations[l].assign(t),r.assign(n)})},t=this;for(var a in s)e(a)},e.prototype.dispose=function(){if(a.prototype.dispose.call(this),this.m.dispose(),null!=this.accumulations)for(var e in this.accumulations)this.accumulations[e].dispose()},e.prototype.setMomentum=function(t){this.momentum=t},e.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},e.fromConfig=function(a,e){return new a(e.learningRate,e.momentum,e.useNesterov)},e.className="MomentumOptimizer",e}(SGDOptimizer);registerClass(MomentumOptimizer);var RMSPropOptimizer=function(s){function e(e,t,p,l,d){void 0===t&&(t=.9),void 0===p&&(p=0),void 0===l&&(l=null),void 0===d&&(d=!1);var u=s.call(this)||this;return u.learningRate=e,u.decay=t,u.momentum=p,u.epsilon=l,u.accumulatedMeanSquares={},u.accumulatedMeanGrads={},u.accumulatedMoments={},u.c=keep(scalar(e)),u.decayScalar=keep(scalar(t)),u.momentumScalar=keep(scalar(p)),u.oneMinusDecay=keep(scalar(1-t)),u.centered=d,null===l&&(l=ENV.get("EPSILON")),u.epsilonScalar=keep(scalar(l)),u}return __extends(e,s),e.prototype.applyGradients=function(p){var d=this,e=function(m){var r=ENV.engine.registeredVariables[m];null==t.accumulatedMeanSquares[m]&&tidy(function(){d.accumulatedMeanSquares[m]=zerosLike(r).variable(!1)}),null==t.accumulatedMeanGrads[m]&&t.centered&&tidy(function(){d.accumulatedMeanGrads[m]=zerosLike(r).variable(!1)}),null==t.accumulatedMoments[m]&&tidy(function(){d.accumulatedMoments[m]=zerosLike(r).variable(!1)});var o=t.accumulatedMeanSquares[m],a=t.accumulatedMeanGrads[m],i=t.accumulatedMoments[m],s=p[m];tidy(function(){var t=d.decayScalar.mul(o).add(d.oneMinusDecay.mul(s.square()));if(d.centered){var e=d.decayScalar.mul(a).add(d.oneMinusDecay.mul(s)),n=d.momentumScalar.mul(i).add(d.c.mul(s).div(t.sub(e.square().add(d.epsilonScalar)).sqrt()));d.accumulatedMeanSquares[m].assign(t),d.accumulatedMeanGrads[m].assign(e),d.accumulatedMoments[m].assign(n);var u=r.sub(n);r.assign(u)}else{var h=d.decayScalar.mul(o).add(d.oneMinusDecay.mul(s.square()));n=d.momentumScalar.mul(i).add(d.c.mul(s).div(h.add(d.epsilonScalar).sqrt())),d.accumulatedMeanSquares[m].assign(h),d.accumulatedMoments[m].assign(n),u=r.sub(n),r.assign(u)}})},t=this;for(var a in p)e(a)},e.prototype.dispose=function(){var a=this;this.c.dispose(),this.epsilonScalar.dispose(),this.decayScalar.dispose(),this.momentumScalar.dispose(),this.oneMinusDecay.dispose(),null!=this.accumulatedMeanSquares&&Object.keys(this.accumulatedMeanSquares).forEach(function(e){return a.accumulatedMeanSquares[e].dispose()}),null!=this.accumulatedMeanGrads&&this.centered&&Object.keys(this.accumulatedMeanGrads).forEach(function(e){return a.accumulatedMeanGrads[e].dispose()}),null!=this.accumulatedMoments&&Object.keys(this.accumulatedMoments).forEach(function(e){return a.accumulatedMoments[e].dispose()})},e.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},e.fromConfig=function(a,e){return new a(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)},e.className="RMSPropOptimizer",e}(Optimizer);registerClass(RMSPropOptimizer);var OptimizerConstructors=function(){function t(){}return t.sgd=function(t){return new SGDOptimizer(t)},t.momentum=function(a,e,t){return void 0===t&&(t=!1),new MomentumOptimizer(a,e,t)},t.rmsprop=function(a,e,s,i,p){return void 0===e&&(e=.9),void 0===s&&(s=0),void 0===i&&(i=null),void 0===p&&(p=!1),new RMSPropOptimizer(a,e,s,i,p)},t.adam=function(a,o,s,i){return void 0===a&&(a=.001),void 0===o&&(o=.9),void 0===s&&(s=.999),void 0===i&&(i=null),new AdamOptimizer(a,o,s,i)},t.adadelta=function(a,n,o){return void 0===a&&(a=.001),void 0===n&&(n=.95),void 0===o&&(o=null),new AdadeltaOptimizer(a,n,o)},t.adamax=function(a,s,i,p,l){return void 0===a&&(a=.002),void 0===s&&(s=.9),void 0===i&&(i=.999),void 0===p&&(p=null),void 0===l&&(l=0),new AdamaxOptimizer(a,s,i,p,l)},t.adagrad=function(a,e){return void 0===e&&(e=.1),new AdagradOptimizer(a,e)},t}(),train={sgd:OptimizerConstructors.sgd,momentum:OptimizerConstructors.momentum,adadelta:OptimizerConstructors.adadelta,adagrad:OptimizerConstructors.adagrad,rmsprop:OptimizerConstructors.rmsprop,adamax:OptimizerConstructors.adamax,adam:OptimizerConstructors.adam},setBackend=Environment.setBackend,getBackend=Environment.getBackend;setOpHandler(ops);/**
   * @license
   * Copyright 2018 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */var extendStatics$1=function(a,e){return(extendStatics$1=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(a,e){a.__proto__=e}||function(a,e){for(var t in e)e.hasOwnProperty(t)&&(a[t]=e[t])})(a,e)},__assign$1=function(){return(__assign$1=Object.assign||function(a){for(var e=1,o=arguments.length,r;e<o;e++)for(var s in r=arguments[e])Object.prototype.hasOwnProperty.call(r,s)&&(a[s]=r[s]);return a}).apply(this,arguments)},_epsilon=ENV.get("EPSILON"),_nextUniqueTensorId=0,_uidPrefixes={},scalarCache={float32:{},int32:{}},DEFAULT_DTYPE="float32",AttributeError=function(a){function e(t){var n=a.call(this,t)||this;return Object.setPrototypeOf(n,e.prototype),n}return __extends$1(e,a),e}(Error),RuntimeError=function(a){function e(t){var n=a.call(this,t)||this;return Object.setPrototypeOf(n,e.prototype),n}return __extends$1(e,a),e}(Error),ValueError=function(a){function e(t){var n=a.call(this,t)||this;return Object.setPrototypeOf(n,e.prototype),n}return __extends$1(e,a),e}(Error),NotImplementedError=function(a){function e(t){var n=a.call(this,t)||this;return Object.setPrototypeOf(n,e.prototype),n}return __extends$1(e,a),e}(Error),AssertionError=function(a){function e(t){var n=a.call(this,t)||this;return Object.setPrototypeOf(n,e.prototype),n}return __extends$1(e,a),e}(Error),IndexError=function(a){function e(t){var n=a.call(this,t)||this;return Object.setPrototypeOf(n,e.prototype),n}return __extends$1(e,a),e}(Error),_GLOBAL_CUSTOM_OBJECTS={},Constraint=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.getConfig=function(){return{}},e}(serialization.Serializable),MaxNorm=function(a){function e(e){var t=a.call(this)||this;return t.defaultMaxValue=2,t.defaultAxis=0,t.maxValue=null==e.maxValue?t.defaultMaxValue:e.maxValue,t.axis=null==e.axis?t.defaultAxis:e.axis,t}return __extends$1(e,a),e.prototype.apply=function(a){var e=this;return tidy(function(){var t=calcL2Norms(a,e.axis),n=clipByValue(t,0,e.maxValue);return mul(a,div(n,add(getScalar(epsilon()),t)))})},e.prototype.getConfig=function(){return{maxValue:this.maxValue,axis:this.axis}},e.className="MaxNorm",e}(Constraint);serialization.registerClass(MaxNorm);var UnitNorm=function(a){function e(e){var t=a.call(this)||this;return t.defaultAxis=0,t.axis=null==e.axis?t.defaultAxis:e.axis,t}return __extends$1(e,a),e.prototype.apply=function(a){var e=this;return tidy(function(){return div(a,add(getScalar(epsilon()),calcL2Norms(a,e.axis)))})},e.prototype.getConfig=function(){return{axis:this.axis}},e.className="UnitNorm",e}(Constraint);serialization.registerClass(UnitNorm);var NonNeg=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return relu(t)},e.className="NonNeg",e}(Constraint);serialization.registerClass(NonNeg);var MinMaxNorm=function(a){function e(e){var t=a.call(this)||this;return t.defaultMinValue=0,t.defaultMaxValue=1,t.defaultRate=1,t.defaultAxis=0,t.minValue=null==e.minValue?t.defaultMinValue:e.minValue,t.maxValue=null==e.maxValue?t.defaultMaxValue:e.maxValue,t.rate=null==e.rate?t.defaultRate:e.rate,t.axis=null==e.axis?t.defaultAxis:e.axis,t}return __extends$1(e,a),e.prototype.apply=function(a){var e=this;return tidy(function(){var t=calcL2Norms(a,e.axis),n=add(mul(getScalar(e.rate),clipByValue(t,e.minValue,e.maxValue)),mul(getScalar(1-e.rate),t));return mul(a,div(n,add(getScalar(epsilon()),t)))})},e.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}},e.className="MinMaxNorm",e}(Constraint);serialization.registerClass(MinMaxNorm);var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"},exports_constraints=Object.freeze({maxNorm:maxNorm,unitNorm:unitNorm,nonNeg:nonNeg,minMaxNorm:minMaxNorm}),nameMap=new Map,VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],VALID_PADDING_MODE_VALUES=["valid","same","causal"],VALID_POOL_MODE_VALUES=["max","avg"],_nameScopeStack=[],_nameScopeDivider="/",tensorNameRegex=new RegExp(/^[A-Za-z][-A-Za-z0-9\._\/]*$/),VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],VALID_DISTRIBUTION_VALUES=["normal","uniform"],Initializer=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.fromConfigUsesCustomObjects=function(){return!1},e.prototype.getConfig=function(){return{}},e}(serialization.Serializable),Zeros=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(a,e){return zeros(a,e)},e.className="Zeros",e}(Initializer);serialization.registerClass(Zeros);var Ones=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(a,e){return ones$1(a,e)},e.className="Ones",e}(Initializer);serialization.registerClass(Ones);var Constant=function(a){function e(e){var t=a.call(this)||this;if("object"!=typeof e)throw new ValueError("Expected argument of type ConstantConfig but got "+e);if(void 0===e.value)throw new ValueError("config must have value set but got "+e);return t.value=e.value,t}return __extends$1(e,a),e.prototype.apply=function(a,e){var t=this;return tidy(function(){return mul(scalar(t.value),ones$1(a,e))})},e.prototype.getConfig=function(){return{value:this.value}},e.className="Constant",e}(Initializer);serialization.registerClass(Constant);var RandomUniform=function(a){function e(e){var t=a.call(this)||this;return t.DEFAULT_MINVAL=-.05,t.DEFAULT_MAXVAL=.05,t.minval=e.minval||t.DEFAULT_MINVAL,t.maxval=e.maxval||t.DEFAULT_MAXVAL,t.seed=e.seed,t}return __extends$1(e,a),e.prototype.apply=function(a,e){return randomUniform(a,this.minval,this.maxval,e)},e.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}},e.className="RandomUniform",e}(Initializer);serialization.registerClass(RandomUniform);var RandomNormal=function(a){function e(e){var t=a.call(this)||this;return t.DEFAULT_MEAN=0,t.DEFAULT_STDDEV=.05,t.mean=e.mean||t.DEFAULT_MEAN,t.stddev=e.stddev||t.DEFAULT_STDDEV,t.seed=e.seed,t}return __extends$1(e,a),e.prototype.apply=function(a,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new NotImplementedError("randomNormal does not support dType "+e+".");return randomNormal$1(a,this.mean,this.stddev,e,this.seed)},e.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},e.className="RandomNormal",e}(Initializer);serialization.registerClass(RandomNormal);var TruncatedNormal=function(a){function e(e){var t=a.call(this)||this;return t.DEFAULT_MEAN=0,t.DEFAULT_STDDEV=.05,t.mean=e.mean||t.DEFAULT_MEAN,t.stddev=e.stddev||t.DEFAULT_STDDEV,t.seed=e.seed,t}return __extends$1(e,a),e.prototype.apply=function(a,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new NotImplementedError("truncatedNormal does not support dType "+e+".");return truncatedNormal(a,this.mean,this.stddev,e,this.seed)},e.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},e.className="TruncatedNormal",e}(Initializer);serialization.registerClass(TruncatedNormal);var Identity=function(a){function e(e){var t=a.call(this)||this;return t.gain=null==e.gain?getScalar(1):scalar(e.gain),t}return __extends$1(e,a),e.prototype.apply=function(t){var e=this;return tidy(function(){if(2!==t.length||t[0]!==t[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return mul(e.gain,eye(t[0]))})},e.prototype.getConfig=function(){return{gain:this.gain.get()}},e.className="Identity",e}(Initializer);serialization.registerClass(Identity);var VarianceScaling=function(a){function e(e){var t=a.call(this)||this;if(0>e.scale)throw new ValueError("scale must be a positive float. Got: "+e.scale);return t.scale=null==e.scale?1:e.scale,t.mode=e.mode,checkFanMode(t.mode),t.distribution=e.distribution,checkDistribution(t.distribution),t.seed=e.seed,t}return __extends$1(e,a),e.prototype.apply=function(p,e){var l=computeFans(p),n=l[0],r=l[1],i=this.scale;if(i/="fanIn"===this.mode?_Mathmax(1,n):"fanOut"===this.mode?_Mathmax(1,r):_Mathmax(1,(n+r)/2),"normal"===this.distribution){var d=_Mathsqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new NotImplementedError(this.getClassName()+" does not support dType "+e+".");return truncatedNormal(p,0,d,e,this.seed)}var o=_Mathsqrt(3*i);return randomUniform(p,-o,o,e)},e.prototype.getConfig=function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}},e.className="VarianceScaling",e}(Initializer);serialization.registerClass(VarianceScaling);var GlorotUniform=function(a){function e(e){return a.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})||this}return __extends$1(e,a),e.prototype.getClassName=function(){return VarianceScaling.className},e.className="GlorotUniform",e}(VarianceScaling);serialization.registerClass(GlorotUniform);var GlorotNormal=function(a){function e(e){return a.call(this,{scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})||this}return __extends$1(e,a),e.prototype.getClassName=function(){return VarianceScaling.className},e.className="GlorotNormal",e}(VarianceScaling);serialization.registerClass(GlorotNormal);var HeNormal=function(a){function e(e){return a.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})||this}return __extends$1(e,a),e.prototype.getClassName=function(){return VarianceScaling.className},e.className="HeNormal",e}(VarianceScaling);serialization.registerClass(HeNormal);var LeCunNormal=function(a){function e(e){return a.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})||this}return __extends$1(e,a),e.prototype.getClassName=function(){return VarianceScaling.className},e.className="LeCunNormal",e}(VarianceScaling);serialization.registerClass(LeCunNormal);var Orthogonal=function(a){function e(e){var t=a.call(this)||this;if(t.DEFAULT_GAIN=1,t.gain=null==e.gain?t.DEFAULT_GAIN:e.gain,t.seed=e.seed,null!=t.seed)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");return t}return __extends$1(e,a),e.prototype.apply=function(a){var e=this;return tidy(function(){if(2!==a.length)throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");2e3<a[0]*a[1]&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+a[0]*a[1]+") elements: Slowness may result.");var n=randomNormal$1(a[0]>a[1]?[a[1],a[0]]:a,0,1,"float32"),t=linalg_ops.gramSchmidt(n);return a[0]>a[1]&&(t=t.transpose()),mul(getScalar(e.gain),t)})},e.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}},e.className="Orthogonal",e}(Initializer);serialization.registerClass(Orthogonal);var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",identity:"Identity",leCunNormal:"LeCunNormal",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"},exports_initializers=Object.freeze({zeros:zeros$1,ones:ones$1$1,constant:constant,randomUniform:randomUniform$1,randomNormal:randomNormal$2,truncatedNormal:truncatedNormal$1,identity:identity,varianceScaling:varianceScaling,glorotUniform:glorotUniform,glorotNormal:glorotNormal,heNormal:heNormal,leCunNormal:leCunNormal,orthogonal:orthogonal}),DEFAULT_VARIABLE_NAME_PREFIX="Variable",LayerVariable=function(){function t(a,e,o,s,p){void 0===e&&(e="float32"),void 0===o&&(o=DEFAULT_VARIABLE_NAME_PREFIX),void 0===s&&(s=!0),void 0===p&&(p=null),this.dtype=null==e?"float32":e,this.shape=a.shape,this.id=getNextUniqueTensorId(),o=null==o?DEFAULT_VARIABLE_NAME_PREFIX:o,this.originalName=getScopedTensorName(o),this.name=getUniqueTensorName(this.originalName),this.trainable=s,this.constraint=p,this.val=variable(a,this.trainable,this.name,this.dtype)}return t.prototype.read=function(){return this.assertNotDisposed(),this.val},t.prototype.write=function(t){return this.assertNotDisposed(),checkShapesMatch(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this},t.prototype.dispose=function(){this.assertNotDisposed(),this.val.dispose()},t.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw new Error("LayersVariable "+this.name+" is already disposed.")},t}(),InputSpec=function(){return function(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null==t.shape?t.ndim:t.shape.length,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}(),SymbolicTensor=function(){return function(s,e,t,n,r,i,a){this.dtype=s,this.shape=e,this.sourceLayer=t,this.inputs=n,this.callArgs=r,this.outputTensorIndex=a,this.id=getNextUniqueTensorId(),null!=i&&(this.originalName=getScopedTensorName(i),this.name=getUniqueTensorName(this.originalName)),this.rank=e.length}}(),_nextNodeID=0,Node=function(){function t(a,e){this.callArgs=e,this.id=_nextNodeID++,this.outboundLayer=a.outboundLayer,this.inboundLayers=a.inboundLayers,this.nodeIndices=a.nodeIndices,this.tensorIndices=a.tensorIndices,this.inputTensors=a.inputTensors,this.outputTensors=a.outputTensors,this.inputMasks=a.inputMasks,this.outputMasks=a.outputMasks,this.inputShapes=a.inputShapes,this.outputShapes=a.outputShapes;for(var t=0,o=a.inboundLayers,r;t<o.length;t++)r=o[t],null!=r&&r.outboundNodes.push(this);a.outboundLayer.inboundNodes.push(this)}return t.prototype.getConfig=function(){for(var a=[],e=0,o=this.inboundLayers,n;e<o.length;e++)n=o[e],null==n?a.push(null):a.push(n.name);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:a,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}},t}(),_nextLayerID=0,Layer=function(p){function e(e){var t=p.call(this)||this;t._callHook=null,t._addedWeightNames=[],t._stateful=!1,t.id=_nextLayerID++,t.activityRegularizer=null,t.inputSpec=null,t.supportsMasking=!1,t._trainableWeights=[],t._nonTrainableWeights=[],t._losses=[],t._updates=[],t._built=!1,t.inboundNodes=[],t.outboundNodes=[];var n=e.name;if(!n){var l=t.getClassName();n=toSnakeCase(l)+"_"+getUid(l)}if(t.name=n,t.trainable=null==e.trainable||e.trainable,t.updatable=null==e.updatable||e.updatable,null!=e.inputShape||null!=e.batchInputShape){var i;if(null!=e.batchInputShape)i=e.batchInputShape;else if(null!=e.inputShape){var d=null;null!=e.batchSize&&(d=e.batchSize),i=[d].concat(e.inputShape)}t.batchInputShape=i;var u=e.dtype;null==u&&(u=e.inputDType),null==u&&(u="float32"),t.dtype=u}return t.initialWeights=null==e.weights?null:e.weights,t._refCount=null,t}return __extends$1(e,p),e.nodeKey=function(a,e){return a.name+"_ib-"+e.toString()},e.prototype.getNodeAtIndex=function(a,e){if(0===this.inboundNodes.length)throw new RuntimeError("The layer has never been called and thus has no defined "+e+".");if(this.inboundNodes.length<=a)throw new ValueError("Asked to get "+e+" at node "+a+", but the layer has only "+this.inboundNodes.length+" inbound nodes.");return this.inboundNodes[a]},e.prototype.getInputAt=function(t){return singletonOrArray(this.getNodeAtIndex(t,"input").inputTensors)},e.prototype.getOutputAt=function(t){return singletonOrArray(this.getNodeAtIndex(t,"output").outputTensors)},Object.defineProperty(e.prototype,"input",{get:function(){if(1<this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" has multiple inbound nodes, hence the notion of \"layer input\" is ill-defined. Use `getInputAt(nodeIndex)` instead.");if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" is not connected, no input to return.");return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" has no inbound nodes.");if(1<this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" has multiple inbound nodes, hence the notion of \"layer output\" is ill-defined. Use `getOutputAt(nodeIndex)` instead.");return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0}),e.prototype.calculateLosses=function(){return this.losses.map(function(t){return t()})},Object.defineProperty(e.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"built",{get:function(){return this._built},set:function(t){this._built=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"trainableWeights",{get:function(){return this.trainable?this._trainableWeights:[]},set:function(t){this._trainableWeights=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this._nonTrainableWeights:this._trainableWeights.concat(this._nonTrainableWeights)},set:function(t){this._nonTrainableWeights=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"stateful",{get:function(){return this._stateful},enumerable:!0,configurable:!0}),e.prototype.resetStates=function(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")},e.prototype.assertInputCompatibility=function(m){if(m=toList(m),null!=this.inputSpec&&0!==this.inputSpec.length){var g=toList(this.inputSpec);if(m.length!==g.length)throw new ValueError("Layer "+this.name+" expects "+g.length+" inputs, but it received "+m.length+" input tensors. Input received: "+m);for(var t=0;t<m.length;t++){var f=m[t],r=g[t];if(null!=r){var i=f.rank;if(null!=r.ndim&&i!==r.ndim)throw new ValueError("Input "+t+" is incompatible with layer "+this.name+": expected ndim="+r.ndim+", found ndim="+i);if(null!=r.maxNDim&&i>r.maxNDim)throw new ValueError("Input "+t+" is incompatible with layer "+this.name+": expected max_ndim="+r.maxNDim+", found ndim="+i);if(null!=r.minNDim&&i<r.minNDim)throw new ValueError("Input "+t+" is incompatible with layer "+this.name+": expected min_ndim="+r.minNDim+", found ndim="+i+".");if(null!=r.dtype&&f.dtype!==r.dtype)throw new ValueError("Input "+t+" is incompatible with layer "+this.name+" : expected dtype="+r.dtype+", found dtype="+f.dtype+".");if(r.axes){var a=f.shape;for(var o in r.axes){var s=+o,l=r.axes[o],u=0<=s?a[s]:a[a.length+s];if(null!=l&&-1===[l,null].indexOf(u))throw new ValueError("Input "+t+" is incompatible with layer "+this.name+": expected axis "+s+" of input shape to have value "+l+" but got shape "+a+".")}}if(null!=r.shape)for(var c=0;c<r.shape.length;++c){var y=r.shape[c],h=f.shape[c];if(null!=y&&null!=h&&y!==h)throw new ValueError("Input "+t+" is incompatible with layer "+this.name+": expected shape="+r.shape+", found shape=${xShape}.")}}}}},e.prototype.call=function(t){return t},e.prototype.invokeCallHook=function(a,e){null!=this._callHook&&this._callHook(a,e)},e.prototype.setCallHook=function(t){this._callHook=t},e.prototype.clearCallHook=function(){this._callHook=null},e.prototype.apply=function(y,e){var b=this;e=e||{},this.assertNotDisposed();for(var n=toList(y),r=!0,p=0,d=n;p<d.length;p++)if(!(d[p]instanceof SymbolicTensor)){r=!1;break}for(var x=!0,o=0,c=n;o<c.length;o++)if(c[o]instanceof SymbolicTensor){x=!1;break}if(r==x)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,function(){if(!b.built){b.assertInputCompatibility(y);for(var t=[],r=0,s=toList(y),o;r<s.length;r++)o=s[r],t.push(o.shape);b.build(singletonOrArray(t)),b.built=!0,b.initialWeights&&b.setWeights(b.initialWeights),null===b._refCount&&x&&(b._refCount=1)}if(b.assertInputCompatibility(y),x){for(var i=[],u=0,N=toList(f=b.call(y,e)),p;u<N.length;u++)p=N[u],-1!==n.indexOf(p)&&(p=p.clone()),i.push(p);if(f=singletonOrArray(i),null!=b.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return f}var I=collectInputShape(y),d=b.computeOutputShape(I),f=void 0,v=guessOutputDType(y);if(b.warnOnIncompatibleInputShape(Array.isArray(y)?I[0]:I),f=null!=d&&0<d.length&&Array.isArray(d[0])?d.map(function(t,a){return new SymbolicTensor(v,t,b,toList(y),e,b.name,a)}):new SymbolicTensor(v,d,b,toList(y),e,b.name),b.addInboundNode(y,f,null,null,I,d,e),b._refCount++,null!=b.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return f})},e.prototype.warnOnIncompatibleInputShape=function(a){if(null!=this.batchInputShape)if(a.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(a)+") does not match that of the batchInputShape ("+JSON.stringify(this.batchInputShape)+") of the layer "+this.name);else{var e=!1;this.batchInputShape.forEach(function(t,n){null!=t&&null!=a[n]&&a[n]!==t&&(e=!0)}),e&&console.warn("The shape of the input tensor ("+JSON.stringify(a)+") does not match the expectation of layer "+this.name+": "+JSON.stringify(this.batchInputShape))}},Object.defineProperty(e.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new AttributeError("The layer "+this.name+" has never been called and thus has no defined output shape.");for(var o=[],e=0,s=this.inboundNodes;e<s.length;e++){var n=s[e],r=JSON.stringify(n.outputShapes);-1===o.indexOf(r)&&o.push(r)}if(1===o.length){var i=this.inboundNodes[0].outputShapes;return Array.isArray(i)&&Array.isArray(i[0])&&1===i.length?i[0]:i}throw new AttributeError("The layer "+this.name+" has multiple inbound nodes with different output shapes. Hence the notion of \"outut shape\" is ill-defined for the layer.")},enumerable:!0,configurable:!0}),e.prototype.countParams=function(){if(!this.built)throw new RuntimeError("You tried to call countParams() on "+this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return countParamsInWeights(this.weights)},e.prototype.build=function(){this.built=!0},e.prototype.getWeights=function(t){return void 0===t&&(t=!1),batchGetValue(t?this.trainableWeights:this.weights)},e.prototype.setWeights=function(p){var e=this;tidy(function(){var t=e.weights;if(t.length!==p.length)throw new ValueError("You called setWeights(weights) on layer \""+e.name+"\" with a weight list of length "+p.length+", but the layer was expecting "+t.length+" weights. Provided weights: "+p+"...");if(0!==t.length){for(var n=[],r=batchGetValue(t),i=0;i<r.length;++i){var d=r[i],o=t[i],s=p[i];if(!util.arraysEqual(d.shape,s.shape))throw new ValueError("Layer weight shape "+d.shape+" not compatible with provided weight shape "+s.shape);n.push([o,s])}batchSetValue(n)}})},e.prototype.addWeight=function(p,e,t,l,r,i,d){if(-1!==this._addedWeightNames.indexOf(p))throw new ValueError("Duplicate weight name "+p+" for layer "+this.name);this._addedWeightNames.push(p),null==t&&(t="float32");var o=new LayerVariable(l.apply(e,t),t,p,i,d);return null!=r&&this.addLoss(function(){return r.apply(o.read())}),null==i&&(i=!0),i?this._trainableWeights.push(o):this._nonTrainableWeights.push(o),o},e.prototype.addLoss=function(a){var n;null==a||Array.isArray(a)&&0===a.length||(a=toList(a),void 0!==this._losses&&null!==this._losses&&(n=this.losses).push.apply(n,a))},e.prototype.computeOutputShape=function(t){return t},e.prototype.computeMask=function(a,e){var t=this;if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError("Layer "+this.name+" does not support masking,but was passed an inputMask.");e.forEach(function(a){if(null!=a)throw new TypeError("Layer "+t.name+" does not support masking,but was passed an inputMask.")})}return null}return e},e.prototype.addInboundNode=function(m,e,g,y,b,x,N){void 0===N&&(N=null);var I=toList(m);e=toList(e),g=toList(g),y=toList(y),b=normalizeShapeList(b),x=normalizeShapeList(x);for(var s=[],l=[],u=[],c=0,v=I,h;c<v.length;c++)h=v[c],s.push(h.sourceLayer),l.push(h.nodeIndex),u.push(h.tensorIndex);new Node({outboundLayer:this,inboundLayers:s,nodeIndices:l,tensorIndices:u,inputTensors:I,outputTensors:e,inputMasks:g,outputMasks:y,inputShapes:b,outputShapes:x},N);for(var S=0;S<e.length;S++)e[S].sourceLayer=this,e[S].nodeIndex=this.inboundNodes.length-1,e[S].tensorIndex=S},e.prototype.getConfig=function(){var t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t},e.prototype.disposeWeights=function(){return this.weights.forEach(function(t){return t.dispose()}),this.weights.length},e.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Layer '"+this.name+"' is already disposed.")},e.prototype.dispose=function(){if(!this.built)throw new Error("Cannot dispose Layer "+this.name+" because it has not been built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}},e}(serialization.Serializable),InputLayer=function(o){function e(e){var t=o.call(this,{dtype:e.dtype,name:null==e.name?getUid("input").toString():e.name})||this;if(null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),t.trainable=!1,t.built=!0,t.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var n=e.batchInputShape;if(null==n){if(null==e.inputShape)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new ValueError("Cannot specify batchSize if batchInputShape isspecified when creating an InputLayer.");var s=e.dtype||"float32";t.batchInputShape=n,t.dtype=s,t.inputSpec=[{shape:n}];var i=new SymbolicTensor(t.dtype,t.batchInputShape,t,[],{},t.name);return i.nodeIndex=0,i.tensorIndex=0,new Node({outboundLayer:t,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]}),t}return __extends$1(e,o),e.prototype.apply=function(){throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)},e.prototype.dispose=function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}},e.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}},e.className="InputLayer",e}(Layer),ModelLoggingVerbosity;serialization.registerClass(InputLayer),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));var BaseCallback=function(){function t(){this.validationData=null}return t.prototype.setParams=function(t){this.params=t},t.prototype.onEpochBegin=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2]})})},t.prototype.onEpochEnd=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2]})})},t.prototype.onBatchBegin=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2]})})},t.prototype.onBatchEnd=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2]})})},t.prototype.onTrainBegin=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2]})})},t.prototype.onTrainEnd=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2]})})},t.prototype.setModel=function(){},t}(),CallbackList=function(){function t(a,n){void 0===n&&(n=10),null==a&&(a=[]),this.callbacks=a,this.queueLength=n}return t.prototype.append=function(t){this.callbacks.push(t)},t.prototype.setParams=function(a){for(var e=0,r=this.callbacks;e<r.length;e++)r[e].setParams(a)},t.prototype.setModel=function(a){for(var e=0,r=this.callbacks;e<r.length;e++)r[e].setModel(a)},t.prototype.onEpochBegin=function(a,e){return __awaiter$1(this,void 0,void 0,function(){var t,o;return __generator$1(this,function(n){switch(n.label){case 0:null==e&&(e={}),t=0,o=this.callbacks,n.label=1;case 1:return t<o.length?[4,o[t].onEpochBegin(a,e)]:[3,4];case 2:n.sent(),n.label=3;case 3:return t++,[3,1];case 4:return[2];}})})},t.prototype.onEpochEnd=function(a,e){return __awaiter$1(this,void 0,void 0,function(){var t,o;return __generator$1(this,function(n){switch(n.label){case 0:null==e&&(e={}),t=0,o=this.callbacks,n.label=1;case 1:return t<o.length?[4,o[t].onEpochEnd(a,e)]:[3,4];case 2:n.sent(),n.label=3;case 3:return t++,[3,1];case 4:return[2];}})})},t.prototype.onBatchBegin=function(a,e){return __awaiter$1(this,void 0,void 0,function(){var t,o;return __generator$1(this,function(n){switch(n.label){case 0:null==e&&(e={}),t=0,o=this.callbacks,n.label=1;case 1:return t<o.length?[4,o[t].onBatchBegin(a,e)]:[3,4];case 2:n.sent(),n.label=3;case 3:return t++,[3,1];case 4:return[2];}})})},t.prototype.onBatchEnd=function(a,e){return __awaiter$1(this,void 0,void 0,function(){var t,o;return __generator$1(this,function(n){switch(n.label){case 0:return null==e&&(e={}),[4,resolveScalarsInLogs(e)];case 1:n.sent(),t=0,o=this.callbacks,n.label=2;case 2:return t<o.length?[4,o[t].onBatchEnd(a,e)]:[3,5];case 3:n.sent(),n.label=4;case 4:return t++,[3,2];case 5:return[2];}})})},t.prototype.onTrainBegin=function(a){return __awaiter$1(this,void 0,void 0,function(){var e,o;return __generator$1(this,function(t){switch(t.label){case 0:null==a&&(a={}),e=0,o=this.callbacks,t.label=1;case 1:return e<o.length?[4,o[e].onTrainBegin(a)]:[3,4];case 2:t.sent(),t.label=3;case 3:return e++,[3,1];case 4:return[2];}})})},t.prototype.onTrainEnd=function(a){return __awaiter$1(this,void 0,void 0,function(){var e,o;return __generator$1(this,function(t){switch(t.label){case 0:null==a&&(a={}),e=0,o=this.callbacks,t.label=1;case 1:return e<o.length?[4,o[e].onTrainEnd(a)]:[3,4];case 2:t.sent(),t.label=3;case 3:return e++,[3,1];case 4:return[2];}})})},t}(),ModelTrainingYielder=function(){function a(t){this.yieldEvery=t,this.batchCount=0,this.batchDurationsMillis=[],this.autoYieldEveryBatches=null,this.batchStartMillis=util.now()}return a.prototype.resolveOneTensorInLogs=function(s){return __awaiter$1(this,void 0,void 0,function(){var e,o,p,l,d;return __generator$1(this,function(t){switch(t.label){case 0:for(o in e=[],s)e.push(o);p=0,t.label=1;case 1:return p<e.length?(l=e[p],"number"==typeof(d=s[l])?[3,3]:[4,d.data()]):[3,4];case 2:return t.sent(),[3,4];case 3:return p++,[3,1];case 4:return[2];}})})},a.prototype.maybeYieldOnBatch=function(e){return __awaiter$1(this,void 0,void 0,function(){var t,o;return __generator$1(this,function(n){switch(n.label){case 0:return"auto"===this.yieldEvery?(this.batchCount++,null==this.autoYieldEveryBatches?[4,this.resolveOneTensorInLogs(e)]:[3,3]):[3,7];case 1:return n.sent(),t=util.now(),[4,nextFrame()];case 2:return n.sent(),this.batchCount>a.SKIP_FIRST_BATCHES&&(this.batchDurationsMillis.push(t-this.batchStartMillis),this.batchDurationsMillis.length>=a.DECISION_BATCH_COUNT&&(o=this.batchDurationsMillis.reduce(function(a,e){return a+e})/this.batchDurationsMillis.length,this.autoYieldEveryBatches=_Mathround(a.THRESHOLD_MILLIS/o),1>this.autoYieldEveryBatches&&(this.autoYieldEveryBatches=1))),this.batchStartMillis=util.now(),this.lastYieldBatchCount=this.batchCount,[3,6];case 3:return this.batchCount-this.lastYieldBatchCount>=this.autoYieldEveryBatches?[4,nextFrame()]:[3,6];case 4:return n.sent(),[4,this.resolveOneTensorInLogs(e)];case 5:n.sent(),this.lastYieldBatchCount=this.batchCount,n.label=6;case 6:return[3,9];case 7:return"batch"===this.yieldEvery?[4,nextFrame()]:[3,9];case 8:n.sent(),n.label=9;case 9:return[2];}})})},a.prototype.maybeYieldOnEpoch=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(t){switch(t.label){case 0:return"epoch"===this.yieldEvery?[4,nextFrame()]:[3,2];case 1:t.sent(),t.label=2;case 2:return[2];}})})},a.SKIP_FIRST_BATCHES=1,a.DECISION_BATCH_COUNT=2,a.THRESHOLD_MILLIS=16,a}(),BaseLogger=function(a){function e(e){var t=a.call(this)||this;return t.yieldEvery=e||"auto",t}return __extends$1(e,a),e.prototype.onTrainBegin=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return this.autoYielder=new ModelTrainingYielder(this.yieldEvery),[2]})})},e.prototype.onEpochBegin=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return this.seen=0,this.totals={},[2]})})},e.prototype.onBatchEnd=function(a,s){return __awaiter$1(this,void 0,void 0,function(){var t=this,a,p,l,d;return __generator$1(this,function(e){switch(e.label){case 0:return[4,this.autoYielder.maybeYieldOnBatch(s)];case 1:for(d in e.sent(),null==s&&(s={}),a=null==s.size?0:s.size,this.seen+=a,p=function(e){var n=s[e];if("number"==typeof n)l.totals.hasOwnProperty(e)||(l.totals[e]=0),l.totals[e]+=n*a;else{var r;e in l.totals?r=l.totals[e]:l.totals[e]=getScalar(0),l.totals[e]=tidy(function(){return add(t.totals[e],mul(n,getScalar(a)))}),null!=r&&r.dispose()}},l=this,s)p(d);return[2];}})})},e.prototype.onEpochEnd=function(a,p){return __awaiter$1(this,void 0,void 0,function(){var t=this,o,s,l,d,u;return __generator$1(this,function(e){switch(e.label){case 0:return[4,this.autoYielder.maybeYieldOnEpoch()];case 1:if(e.sent(),null!=p)for(o=function(a){return null==s.totals[a]?"continue":void("number"==typeof s.totals[a]?p[a]=s.totals[a]/s.seen:tidy(function(){p[a]=mul(div(getScalar(1),getScalar(t.seen)),t.totals[a]),t.totals[a].dispose(),keep(p[a])}))},s=this,l=0,d=this.params.metrics;l<d.length;l++)u=d[l],o(u);return[2];}})})},e}(BaseCallback),History=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.onTrainBegin=function(){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return this.epoch=[],this.history={},[2]})})},e.prototype.onEpochEnd=function(a,e){return __awaiter$1(this,void 0,void 0,function(){var t;return __generator$1(this,function(){for(t in null==e&&(e={}),this.epoch.push(a),e)null==this.history[t]&&(this.history[t]=[]),this.history[t].push(e[t]);return[2]})})},e.prototype.syncData=function(){return __awaiter$1(this,void 0,void 0,function(){var p,d,c,u,m,h,g,f,y;return __generator$1(this,function(e){switch(e.label){case 0:for(u in p=[],d=[],c=[],this.history)for(m=this.history[u],h=0;h<m.length;++h)"number"!=typeof m[h]&&(g=m[h],p.push(g.data()),d.push(u),c.push(h));return[4,Promise.all(p)];case 1:for(f=e.sent(),y=0;y<f.length;++y)this.history[d[y]][c[y]].dispose(),this.history[d[y]][c[y]]=f[y][0];return[2];}})})},e}(BaseCallback),CustomCallback=function(a){function e(e){var t=a.call(this)||this;return t.trainBegin=e.onTrainBegin,t.trainEnd=e.onTrainEnd,t.epochBegin=e.onEpochBegin,t.epochEnd=e.onEpochEnd,t.batchBegin=e.onBatchBegin,t.batchEnd=e.onBatchEnd,t}return __extends$1(e,a),e.prototype.onEpochBegin=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(t){switch(t.label){case 0:return null==this.epochBegin?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.epochBegin(a,e)];case 2:t.sent(),t.label=3;case 3:return[2];}})})},e.prototype.onEpochEnd=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(t){switch(t.label){case 0:return null==this.epochEnd?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.epochEnd(a,e)];case 2:t.sent(),t.label=3;case 3:return[2];}})})},e.prototype.onBatchBegin=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(t){switch(t.label){case 0:return null==this.batchBegin?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.batchBegin(a,e)];case 2:t.sent(),t.label=3;case 3:return[2];}})})},e.prototype.onBatchEnd=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(t){switch(t.label){case 0:return null==this.batchEnd?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.batchEnd(a,e)];case 2:t.sent(),t.label=3;case 3:return[2];}})})},e.prototype.onTrainBegin=function(a){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(e){switch(e.label){case 0:return null==this.trainBegin?[3,3]:[4,resolveScalarsInLogs(a)];case 1:return e.sent(),[4,this.trainBegin(a)];case 2:e.sent(),e.label=3;case 3:return[2];}})})},e.prototype.onTrainEnd=function(a){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(e){switch(e.label){case 0:return null==this.trainEnd?[3,3]:[4,resolveScalarsInLogs(a)];case 1:return e.sent(),[4,this.trainEnd(a)];case 2:e.sent(),e.label=3;case 3:return[2];}})})},e}(BaseCallback),CallbackConstructorRegistry=function(){function a(){}return a.registerCallbackConstructor=function(e,t){util.assert(0<=e&&_NumberisInteger(e),"Verbosity level is expected to be an integer >= 0, but got "+e),a.checkForDuplicate(t),null==a.constructors[e]&&(a.constructors[e]=[]),a.constructors[e].push(t)},a.checkForDuplicate=function(r){for(var e in a.constructors)a.constructors[+e].forEach(function(t){if(t===r)throw new ValueError("Duplicate callback constructor.")})},a.clear=function(){a.constructors={}},a.createCallbacks=function(e){var t=[];for(var n in a.constructors){var r=+n;e>=r&&t.push.apply(t,a.constructors[r])}return t.map(function(t){return new t})},a.constructors={},a}(),mse$1=meanSquaredError$1,MSE$1=meanSquaredError$1,mae$1=meanAbsoluteError,MAE$1=meanAbsoluteError,mape$1=meanAbsolutePercentageError,MAPE$1=meanAbsolutePercentageError,categoricalCrossentropy$1=categoricalCrossentropy,cosine$1=cosineProximity,sparseCategoricalCrossentropy$1=sparseCategoricalCrossentropy,version$1="0.8.5",Container=function(ae){function x(e){var t=ae.call(this,{})||this;if(t.containerNodes=new Set,t.name=e.name,null==t.name){var n=t.getClassName().toLowerCase();t.name=getUid(n)}if(t.supportsMasking=!1,t.trainable=!0,t.updatable=!0,t.inputs=Array.isArray(e.inputs)?e.inputs.slice():[e.inputs],t.outputs=Array.isArray(e.outputs)?e.outputs.slice():[e.outputs],unique(t.inputs).length!==t.inputs.length)throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+t.inputs.map(function(t){return t.name}));unique(t.outputs).length!==t.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+t.outputs.map(function(t){return t.name})),t.inputLayers=[],t.inputLayersNodeIndices=[],t.inputLayersTensorIndices=[],t.outputLayers=[],t.outputLayersNodeIndices=[],t.outputLayersTensorIndices=[],t.layers=[];for(var r=0,i=t.outputs;r<i.length;r++){var o=(C=i[r]).sourceLayer,oe=C.nodeIndex,se=C.tensorIndex;t.outputLayers.push(o),t.outputLayersNodeIndices.push(oe),t.outputLayersTensorIndices.push(se)}for(var pe=0,le=t.inputs;pe<le.length;pe++)o=(C=le[pe]).sourceLayer,oe=C.nodeIndex,se=C.tensorIndex,assert$1(0===oe,"input layer has >1 nodes"),assert$1(0===se,"input layer has >1 tensors"),t.inputLayers.push(o),t.inputLayersNodeIndices.push(oe),t.inputLayersTensorIndices.push(se);t.inputNames=[],t.outputNames=[],t.feedInputShapes=[],t.feedInputNames=[],t.feedOutputNames=[];for(var p=0;p<t.inputLayers.length;p++){if(!((o=t.inputLayers[p])instanceof InputLayer))throw new TypeError("Input layers to a Model must be InputLayer objects. Received inputs: "+e.inputs+". Input "+p+" (0-based) originates from layer type "+o.getClassName()+".");t.inputNames.push(o.name),t.feedInputShapes.push(o.batchInputShape),t.feedInputNames.push(o.name)}for(var de=0,ue=t.outputLayers;de<ue.length;de++)o=ue[de],t.outputNames.push(o.name);t.internalInputShapes=t.inputs.map(function(t){return t.shape}),t.internalOutputShapes=t.outputs.map(function(t){return t.shape});for(var f={},g={},m={},y={},v={},b=[],w=function(r,e,n,i,m,g){null!=i&&null!=m&&null!=g||(i=r.sourceLayer,m=r.nodeIndex,g=r.tensorIndex);var y=i.inboundNodes[m];if(-1!==n.indexOf(y))throw new RuntimeError("The tensor "+r.name+" at layer \""+i.name+"\" is part of a cycle.");if(-1===e.indexOf(y)){t.containerNodes.add(x.nodeKey(i,m)),(i.id in v)||(v[i.id]=Object.keys(v).length),-1===n.indexOf(y)&&n.push(y);for(var l=y.inboundLayers.length,u=0;u<l;u++){var N=y.inputTensors[u],p=y.inboundLayers[u],h=y.nodeIndices[u],d=y.tensorIndices[u];w(N,e,n,p,h,d)}for(e.push(y);0<=n.indexOf(y);)n.splice(n.indexOf(y),1);b.push(y)}},z=[],S=[],I=0,ce=t.outputs,C;I<ce.length;I++)C=ce[I],w(C,z,S);for(var me=0,he=b.slice().reverse();me<he.length;me++){g[(Z=he[me]).id]=Z,Z.id in f||(f[Z.id]=0);var E=f[Z.id],ge=null==m[Z.outboundLayer.id]?0:m[Z.outboundLayer.id];for(E=_Mathmax(E,ge),m[Z.outboundLayer.id]=E,y[Z.outboundLayer.id]=Z.outboundLayer,f[Z.id]=E,p=0;p<Z.inboundLayers.length;p++){var L=Z.inboundLayers[p],fe=(oe=Z.nodeIndices[p],L.inboundNodes[oe]),T=null==f[fe.id]?0:f[fe.id];f[fe.id]=_Mathmax(E+1,T),g[fe.id]=fe}}var D={};for(var O in f)(E=f[O])in D||(D[E]=[]),D[E].push(g[O]);var R={};for(var M in m)(E=m[M])in R||(R[E]=[]),R[E].push(y[M]);var P=Object.keys(R).map(function(t){return parseInt(t,10)}).sort(reverseNumberCompare);t.layers=[];for(var ye=0,be=P,B;ye<be.length;ye++){B=R[E=be[ye]],B.sort(function(a,e){var t=v[a.id],n=v[e.id];return t<n?-1:t>n?1:0});for(var xe=0,Ne=B;xe<Ne.length;xe++)o=Ne[xe],t.layers.push(o)}t.layersByDepth=R,P=Object.keys(D).map(function(t){return parseInt(t,10)}).sort(reverseNumberCompare);for(var W=t.inputs.slice(),$=[],q=0,Ie=P;q<Ie.length;q++)for(var J=0,ve=D[E=Ie[q]];J<ve.length;J++){var Z;if(null!=(o=(Z=ve[J]).outboundLayer)){for(var Se=0,Ce=Z.inputTensors;Se<Ce.length;Se++)if(C=Ce[Se],-1===W.indexOf(C))throw new RuntimeError("Graph disconnected: cannot obtain value for tensor "+C+" at layer \""+o.name+"\". The following previous layers were accessed without issue: "+$);for(var X=0,ke=Z.outputTensors;X<ke.length;X++)C=ke[X],W.push(C);$.push(o.name)}}t.nodesByDepth=D;for(var ee=t.layers.map(function(t){return t.name}),te=function(a){var e=ee.filter(function(e){return e===a}).length;if(1!==e)throw new RuntimeError("The name \""+a+"\" is used "+e+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(ee))},ne=0,Te=ee;ne<Te.length;ne++)te(Te[ne]);return t.outboundNodes=[],t.inboundNodes=[],new Node({outboundLayer:t,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:t.inputs,outputTensors:t.outputs,inputMasks:t.inputs.map(function(){return null}),outputMasks:t.outputs.map(function(){return null}),inputShapes:t.inputs.map(function(t){return t.shape}),outputShapes:t.outputs.map(function(t){return t.shape})}),t.built=!0,t._refCount=1,t}return __extends$1(x,ae),x.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Container '"+this.name+"' is already disposed.")},x.prototype.dispose=function(){this.assertNotDisposed();var a={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount)for(var e=0,o=this.layers,n;e<o.length;e++)n=o[e],a.numDisposedVariables+=n.dispose().numDisposedVariables;return a.refCountAfterDispose=this._refCount,a},Object.defineProperty(x.prototype,"trainableWeights",{get:function(){if(0<this._trainableWeights.length)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];for(var a=[],o=0,s=this.layers,n;o<s.length;o++)n=s[o],a=a.concat(n.trainableWeights);return a},enumerable:!0,configurable:!0}),Object.defineProperty(x.prototype,"nonTrainableWeights",{get:function(){for(var s=[],e=0,p=this.layers,n;e<p.length;e++)n=p[e],s.push.apply(s,n.nonTrainableWeights);if(!this.trainable){for(var l=[],i=0,d=this.layers;i<d.length;i++)n=d[i],l.push.apply(l,n.trainableWeights);return l.concat(s)}return s},enumerable:!0,configurable:!0}),Object.defineProperty(x.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),x.prototype.loadWeights=function(a,e,o,s){void 0===e&&(e=!1),void 0===o&&(o=!1),void 0===s&&(s=!0),o?loadWeightsFromNamedTensorMap(a,this.layers,s):loadWeightsFromJson(a,this.layers,e)},x.prototype.updatedConfig=function(){var t=this.getConfig();return{className:this.getClassName(),config:t,kerasVersion:"tfjs-layers "+version$1,backend:"TensorFlow.js"}},x.prototype.toJSON=function(a,e){void 0===e&&(e=!0);var r=convertTsToPythonic(this.updatedConfig());return e?JSON.stringify(r):r},x.prototype.call=function(a,o){var t=this;return tidy(function(){var e;return a=toList(a),e="mask"in o?toList(o.mask):pyListRepeat(null,a.length),t.runInternalGraph(a,e)[0]})},x.prototype.computeMask=function(a,o){var t=this;return tidy(function(){var e;return a=toList(a),e=null==o?pyListRepeat(null,a.length):toList(o),t.runInternalGraph(a,e)[1]})},x.prototype.computeOutputShape=function(x){var e=normalizeShapeList(x);if(e.length!==this.inputLayers.length)throw new ValueError("Invalid inputShape argument "+x+": model has "+this.inputLayers.length+" tensor inputs.");for(var t={},n=0;n<e.length;n++){var C=this.inputLayers[n],k=e[n];t[S=C.name+"_0_0"]=k}var a=Object.keys(this.nodesByDepth).map(function(t){return parseInt(t,10)}).sort(reverseNumberCompare);if(1<a.length)for(var o=0,T=a;o<T.length;o++)for(var l=T[o],u=0,E=this.nodesByDepth[l],p;u<E.length;u++)if(p=E[u],C=p.outboundLayer,-1===this.inputLayers.map(function(t){return t.id}).indexOf(C.id)){for(var R=[],d=0;d<p.inboundLayers.length;d++){var D=p.inboundLayers[d],g=p.nodeIndices[d],m=p.tensorIndices[d],P=t[S=D.name+"_"+g+"_"+m];R.push(P)}var v=normalizeShapeList(C.computeOutputShape(singletonOrArray(R))),b=C.inboundNodes.indexOf(p);for(d=0;d<v.length;d++)t[S=C.name+"_"+b+"_"+d]=v[d]}var A=[],_=[];for(n=0;n<this.outputLayers.length;n++){C=this.outputLayers[n],b=this.outputLayersNodeIndices[n],m=this.outputLayersTensorIndices[n];var S=C.name+"_"+b+"_"+m;_.push(S)}for(n=0;n<_.length;n++){var O=_[n];assert$1(O in t),A.push(t[O])}return singletonOrArray(A)},x.prototype.runInternalGraph=function(R,e){null==e&&(e=pyListRepeat(null,R.length));for(var P={},n=0;n<this.inputs.length;++n){var O=this.inputs[n],M=R[n],F=e[n];P[O.id]=[M,F]}for(var B=0,V=Object.keys(this.nodesByDepth).map(function(t){return parseInt(t,10)}).sort(reverseNumberCompare);B<V.length;B++)for(var l=V[B],u=0,U=this.nodesByDepth[l];u<U.length;u++){for(var p=U[u],h=p.outboundLayer,d=p.inputTensors,f=p.outputTensors,g=[],m=0,W=d;m<W.length;m++)(O=W[m]).id in P&&g.push(P[O.id]);if(g.length===d.length){var v={},G=void 0,q=void 0,H=void 0,j=void 0;if(null!=p.callArgs&&(v=p.callArgs),1===g.length){var $=g[0],N=$[0],C=$[1];null==v.mask&&(v.mask=C),H=toList(h.call(N,v)),j=toList(h.computeMask(N,C)),G=[N],q=[C]}else G=g.map(function(t){return t[0]}),q=g.map(function(t){return t[1]}),null==v.mask&&(v.mask=q),H=toList(h.call(G,v)),j=toList(h.computeMask(G,q));if(h.activityRegularizer)throw new NotImplementedError("Model invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(n=0;n<f.length;++n)O=f[n],M=H[n],F=j[n],P[O.id]=[M,F]}}for(var A=[],_=[],E=[],k=0,K=this.outputs;k<K.length;k++){assert$1((O=K[k]).id in P,"Could not compute output "+O.name+" : "+O.id);var x=P[O.id],T=x[0];F=x[1],E.push(T.shape),A.push(T),_.push(F)}return[A,_,E]},x.prototype.buildNodeConversionMap=function(){for(var e={},t=0,r=this.layers,a,p;t<r.length;t++){p=r[t],a=p instanceof x?1:0;for(var d=0,u;d<p.inboundNodes.length;d++)u=x.nodeKey(p,d),this.containerNodes.has(u)&&(e[u]=a,a+=1)}return e},x.prototype.getLayer=function(a,e){if(null!=e){if(this.layers.length<=e)throw new ValueError("Was asked to retrieve layer at index "+e+", but model only has "+this.layers.length+" layer(s).");return this.layers[e]}if(null==a)throw new ValueError("Provide either a layer name or layer index");for(var t=0,o=this.layers,r;t<o.length;t++)if(r=o[t],r.name===a)return r;throw new ValueError("No such layer: "+a)},x.prototype.calculateLosses=function(){var t=this;return tidy(function(){for(var e=[],n=0,p=t.layers;n<p.length;n++)for(var i=p[n],a=0,l;a<i.inboundNodes.length;++a)l=x.nodeKey(i,a),t.containerNodes.has(l)&&e.push.apply(e,i.calculateLosses());return e})},x.prototype.getConfig=function(){for(var t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[],r=0,N=this.layers;r<N.length;r++){for(var a=(v=N[r]).getClassName(),o=v.getConfig(),s=[],l=0;l<v.inboundNodes.length;l++){var I=v.inboundNodes[l],c=x.nodeKey(v,l),S={};if(this.containerNodes.has(c)){if(I.callArgs)try{JSON.stringify(I.callArgs),S=I.callArgs}catch(t){console.warn("Layer "+v.name+" was passed non-serializable keyword arguments: "+I.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),S={}}if(0<I.inboundLayers.length){for(var C=[],d=0;d<I.inboundLayers.length;d++){var k=I.inboundLayers[d],g=I.nodeIndices[d],T=I.tensorIndices[d];null==(D=e[x.nodeKey(k,g)])&&(D=0),C.push([k.name,D,T,S])}s.push(C)}}}n.push({name:v.name,className:a,config:o,inboundNodes:s})}t.layers=n;var E=[];for(d=0;d<this.inputLayers.length;d++){var v=this.inputLayers[d];g=this.inputLayersNodeIndices[d],c=x.nodeKey(v,g),this.containerNodes.has(c)&&(null!==(D=e[c])&&void 0!==D||(D=0),T=this.inputLayersTensorIndices[d],E.push([v.name,D,T]))}t.inputLayers=E;var R=[];for(d=0;d<this.outputLayers.length;d++)if(v=this.outputLayers[d],g=this.outputLayersNodeIndices[d],c=x.nodeKey(v,g),this.containerNodes.has(c)){var D;null!==(D=e[c])&&void 0!==D||(D=0),T=this.outputLayersTensorIndices[d],R.push([v.name,D,T])}return t.outputLayers=R,t},x.fromConfig=function(x,k){function T(n,e){n.name in a?a[n.name].push(e):a[n.name]=[e]}function e(n,e){for(var t=[],a=0,m=e,s;a<m.length;a++){var g=m[a],l=g[0],u=g[1],c=g[2];if(3===g.length)s={};else{if(4!==g.length)throw new ValueError("Improperly formatted model config for layer "+JSON.stringify(n)+": "+JSON.stringify(g));s=g[3]}if(!(l in i))return void T(n,e);var p=i[l];if(p.inboundNodes.length<=u)return void T(n,e);var h=p.inboundNodes[u];t.push(h.outputTensors[c])}0<t.length&&n.apply(singletonOrArray(t),s)}function t(t){var e=t.name,n=deserialize(t,null==k.customObjects?{}:k.customObjects);i[e]=n;for(var a=0,r=t.inboundNodes,s;a<r.length;a++){if(s=r[a],!(s instanceof Array))throw new ValueError("Corrupted configuration, expected array for nodeData: "+s);T(n,s)}}for(var i={},a={},n=k.name,r=k.layers,o=0,s=r;o<s.length;o++)t(h=s[o]);for(;!isObjectEmpty(a);)for(var l=0,c=r,h;l<c.length;l++)if(h=c[l],(A=i[h.name]).name in a){var E=a[A.name];delete a[A.name];for(var f=0,R=E;f<R.length;f++)e(A,R[f])}for(var m=[],y=[],v=0,D=k.inputLayers;v<D.length;v++){var w=(h=D[v])[0],P=h[1],O=h[2];assert$1(w in i);var L=(A=i[w]).inboundNodes[P].outputTensors;m.push(L[O])}for(var M=0,F=k.outputLayers;M<F.length;M++){w=(h=F[M])[0],P=h[1],O=h[2],assert$1(w in i);var A;L=(A=i[w]).inboundNodes[P].outputTensors,y.push(L[O])}return new x({inputs:m,outputs:y,name:n})},Object.defineProperty(x.prototype,"stateful",{get:function(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var a=0,n=this.layers;a<n.length;a++)if(n[a].stateful)return!0;return!1},enumerable:!0,configurable:!0}),x.prototype.resetStates=function(){var t=this;tidy(function(){t.layers.forEach(function(t){t.stateful&&t.resetStates()})})},x}(Layer),FeedDict=function(){function o(e){if(this.id2Value={},e instanceof o)for(var t in e.id2Value)this.id2Value[t]=e.id2Value[t];else{if(null==e)return;for(var n=0,s=e,i;n<s.length;n++)i=s[n],this.add(i.key,i.value)}}return o.prototype.add=function(a,e){if(null!=this.id2Value[a.id])throw new ValueError("Duplicate key: name="+a.name+", id="+a.id);return this.id2Value[a.id]=assertFeedCompatibility(a,e),this},o.prototype.addFeed=function(t){this.add(t.key,t.value)},o.prototype.hasKey=function(t){return null!=this.id2Value[t.id]},o.prototype.getValue=function(t){if(null==this.id2Value[t.id])throw new ValueError("Nonexistent key: "+JSON.stringify(t));return this.id2Value[t.id]},o}(),DEFAULT_VALIDATION_BATCH_SIZE=32,Model=function(a){function e(e){var t=a.call(this,e)||this;return t.isTraining=!1,t}return __extends$1(e,a),e.prototype.summary=function(a,e,t){if(void 0===t&&(t=console.log),!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,a,e,t)},e.prototype.compile=function(d){var m=this;if(null==d.loss&&(d.loss=[]),this.loss=d.loss,"string"==typeof d.optimizer)this.optimizer=getOptimizer(d.optimizer);else{if(!(d.optimizer instanceof Optimizer))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer=d.optimizer}var e=[];if(!(Array.isArray(d.loss)||"string"==typeof d.loss||"function"==typeof d.loss)){for(var t in d.loss=d.loss,d.loss)if(-1===this.outputNames.indexOf(t))throw new ValueError("Unknown entry in loss dictionary: \""+t+"\". Only expect the following keys: "+this.outputNames);for(var a in this.outputNames)null==d.loss[a]&&console.warn("Output \""+a+"\" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to "+a+" during training"),e.push(get(d.loss[a]))}else if(Array.isArray(d.loss)){if(d.loss.length!==this.outputs.length)throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has "+this.outputs.length+" output(s), but you passed loss="+d.loss+".");var o=d.loss;e=o.map(function(t){return get(t)})}else{var r=get(d.loss);this.outputs.map(function(){e.push(r)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(var i=0;i<this.outputs.length;++i){var h=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(h),this.feedLossFns.push(this.lossFunctions[i])}var u=[];this.metrics=d.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",function(){for(var t=0;t<m.outputs.length;++t)if(-1===u.indexOf(t)){var a=m.lossFunctions[t];1<m.outputs.length&&(m.metricsTensors.push([a,t]),m.metricsNames.push(m.outputNames[t]+"_loss"))}});var c=collectMetrics(d.metrics,this.outputNames);nameScope("metric",function(){for(var t=function(t){return-1===u.indexOf(t)?void!function(e){for(var n=function(e){if(-1!==["accuracy","acc","crossentropy","ce"].indexOf(e)){var a=m.internalOutputShapes[t];1===a[a.length-1]||m.lossFunctions[t]===binaryCrossentropy?-1===["accuracy","acc"].indexOf(e)?-1!==["crossentropy","ce"].indexOf(e)&&(l=binaryCrossentropy$1):l=binaryAccuracy:m.lossFunctions[t]===sparseCategoricalCrossentropy?-1===["accuracy","acc"].indexOf(e)?-1!==["crossentropy","ce"].indexOf(e)&&(l=sparseCategoricalCrossentropy$1):l=sparseCategoricalAccuracy:-1===["accuracy","acc"].indexOf(e)?-1!==["crossentropy","ce"].indexOf(e)&&(l=categoricalCrossentropy$1):l=categoricalAccuracy;var n;-1===["accuracy","acc"].indexOf(e)?-1!==["crossentropy","ce"].indexOf(e)&&(n="ce"):n="acc",u=l,d=""+n}else{var r=get$1(e);u=r,d=""+e}var o;nameScope(d,function(){o=u}),function(t,e,a){1<m.outputNames.length&&(e=m.outputNames[t]+"_"+e),m.metricsNames.push(e),m.metricsTensors.push([a,t])}(t,d,o)},o=0,p=e,d,l,u;o<p.length;o++)n(p[o])}(c[t]):"continue"},e=0;e<m.outputs.length;++e)t(e)}),this.collectedTrainableWeights=this.trainableWeights},e.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")},e.prototype.evaluate=function(s,e,t){void 0===t&&(t={});var p=null==t.batchSize?32:t.batchSize;checkBatchSize(p);var r=this.standardizeUserData(s,e,!0,p);try{var i=r[0].concat(r[1]);this.makeTestFunction();var a=this.testFunction;return singletonOrArray(this.testLoop(a,i,p,t.verbose,t.steps))}finally{disposeNewTensors(r[0],s),disposeNewTensors(r[1],e)}},e.prototype.evaluateDataset=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return this.makeTestFunction(),[2,evaluateDataset(this,a,e)]})})},e.prototype.checkNumSamples=function(a,e,t,n){var o;if(!(void 0===n&&(n="steps"),null!=t)){if(null==a)throw new ValueError("Either the input data should have a defined shape, or "+n+" shoud be specified.");o=Array.isArray(a)?a[0].shape[0]:a.shape[0]}else if(o=null,null!=e)throw new ValueError("If "+n+" is set, batchSize must be null or undefined.Got batchSize = "+e);return o},e.prototype.execute=function(d,m){if(Array.isArray(m)&&0===m.length)throw new ValueError("`outputs` is an empty Array, which is not allowed.");var t=Array.isArray(m),n=t?m:[m],r=this.retrieveSymbolicTensors(n),i=new FeedDict;if(d instanceof Tensor&&(d=[d]),Array.isArray(d)){if(d.length!==this.inputs.length)throw new ValueError("The number of inputs provided ("+d.length+") does not match the number of inputs of this model ("+this.inputs.length+").");for(var a=0;a<this.inputs.length;++a)i.add(this.inputs[a],d[a])}else for(var h=0,g=this.inputs;h<g.length;h++){var l=g[h],u=d[l.name];if(null==u)throw new ValueError("No value is provided for the model's input "+l.name);i.add(l,u)}var c=execute(r,i);return t?c:c[0]},e.prototype.retrieveSymbolicTensors=function(p){for(var e=pyListRepeat(null,p.length),t=p.length,d=0,m=this.layers;d<m.length;d++){for(var i=m[d],a=Array.isArray(i.output)?i.output:[i.output],o=a.map(function(t){return t.name}),s=0,h;s<p.length&&(h=o.indexOf(p[s]),-1!==h&&(e[s]=a[h],t--),0!==t);++s);if(0===t)break}if(0<t){var g=[];throw e.forEach(function(e,t){null==e&&g.push(p[t])}),new ValueError("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(g))}return e},e.prototype.predictLoop=function(p,e,d){var c=this;return void 0===e&&(e=32),void 0===d&&(d=!1),tidy(function(){var t=c.checkNumSamples(p);if(d)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");for(var r=makeBatches(t,e),a=[],n=function(e){var t=tidy(function(){var t=r[e][0],a=r[e][1],n=sliceArrays(p,t,a),o=[];if(Array.isArray(n))for(var s=0;s<n.length;++s)o.push({key:c.inputs[s],value:n[s]});else o.push({key:c.inputs[0],value:n});var i=new FeedDict(o);return execute(c.outputs,i)});if(0===e)for(var n=0,o=t,s;n<o.length;n++)s=o[n],a.push(s);else for(var d=0;d<t.length;++d)a[d]=concatAlongFirstAxis(a[d],t[d])},o=0;o<r.length;++o)n(o);return singletonOrArray(a)})},e.prototype.predict=function(a,e){void 0===e&&(e={});var o=ensureTensorsRank2OrHigher(a);checkInputData(o,this.inputNames,this.feedInputShapes,!1);try{var n=null==e.batchSize?32:e.batchSize;return checkBatchSize(n),this.predictLoop(o,n)}finally{disposeNewTensors(o,a)}},e.prototype.predictOnBatch=function(t){return checkInputData(t,this.inputNames,this.feedInputShapes,!0),this.predictLoop(t,t.shape[0])},e.prototype.standardizeUserData=function(s,p,l,d){if(void 0===l&&(l=!0),null==this.optimizer)throw new RuntimeError("You must compile a model before training/testing. Use Model.compile(modelCompileConfig).");for(var r=[],i=0,u;i<this.feedOutputShapes.length;++i)u=this.feedOutputShapes[i],this.feedLossFns[i]===sparseCategoricalCrossentropy?r.push(u.slice(0,u.length-1).concat([1])):r.push(u);if(checkArrayLengths(s=standardizeInputData(s,this.feedInputNames,this.feedInputShapes,!1,"input"),p=standardizeInputData(p,this.feedOutputNames,r,!1,"target"),null),checkLossAndTargetCompatibility(p,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=d&&0<d&&0!=s[0].shape[0]%d)throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+d+". Found: "+s[0].shape[0]+" sample(s).");return[s,p,null]},e.prototype.testLoop=function(o,e,t,n,b){var i=this;return void 0===n&&(n=0),tidy(function(){var a=i.checkNumSamples(e,t,b,"steps"),r=[];if(0<n)throw new NotImplementedError("Verbose mode is not implemented yet.");if(null!=b)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");for(var s=makeBatches(a,t),l=tensor1d(range$1(0,a)),u=0;u<s.length;++u){var x=s[u][0],p=s[u][1],h=sliceAlongFirstAxis(l,x,p-x),d=sliceArraysByIndices(e,h),f=o(d);if(0==u)for(var g=0;g<f.length;++g)r.push(getScalar(0));for(g=0;g<f.length;++g){var N=f[g];r[g]=add(r[g],mul(getScalar(p-x),N))}}for(g=0;g<r.length;++g)r[g]=div(r[g],getScalar(a));return r})},e.prototype.getDedupedMetricsNames=function(){for(var a=this.metricsNames,e=[],t=0;t<a.length;++t){var o=a[t],r=o;1<count(a,o)&&(r+="_"+count(a.slice(0,t),o)),e.push(r)}return e},e.prototype.makeTrainFunction=function(){var d=this;return function(e){var o=e.slice(0,d.inputs.length),t=e.slice(d.inputs.length,d.inputs.length+d.outputs.length),n=[],r=d.collectedTrainableWeights.map(function(t){return t.read()});return[d.optimizer.minimize(function(){for(var e=[],r=0;r<d.inputs.length;++r)e.push({key:d.inputs[r],value:o[r]});var i=new FeedDict(e),s=execute(d.outputs,i,{training:!0}),l;for(r=0;r<d.lossFunctions.length;++r){var m=(0,d.lossFunctions[r])(t[r],s[r]);mean(m),l=0==r?m:add(l,m)}for(r=0;r<d.metricsTensors.length;++r){var u=d.metricsTensors[r][0],c=d.metricsTensors[r][1],p=mean(u(t[c],s[c]));keep(p),n.push(p)}return l=mean(l),d.calculateLosses().forEach(function(t){l=add(l,t)}),l},!0,r)].concat(n)}},e.prototype.makeTestFunction=function(){var m=this;this.testFunction=function(e){return tidy(function(){for(var t=[],r=e.slice(0,m.inputs.length),i=e.slice(m.inputs.length,m.inputs.length+m.outputs.length),a=[],o=0,g;o<m.inputs.length;++o)a.push({key:m.inputs[o],value:r[o]});var y=new FeedDict(a),l=execute(m.outputs,y);for(o=0;o<m.lossFunctions.length;++o){var u=m.lossFunctions[o],c=mean(u(i[o],l[o]));g=0==o?c:add(g,c),t.push(g)}for(o=0;o<m.metricsTensors.length;++o){var p=m.metricsTensors[o][0],h=m.metricsTensors[o][1],d=mean(p(i[h],l[h]));t.push(d)}return t})}},e.prototype.fit=function(a,e,t){return void 0===t&&(t={}),__awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2,fitTensors(this,a,e,t)]})})},e.prototype.fitDataset=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){return[2,fitDataset(this,a,e)]})})},e.prototype.getNamedWeights=function(o){for(var e={},t=null!=o&&o.trainableOnly,n=t?this.trainableWeights:this.weights,r=this.getWeights(t),s=0;s<n.length;++s)t&&!n[s].trainable||(e[n[s].originalName]=r[s]);return e},Object.defineProperty(e.prototype,"stopTraining",{set:function(t){this.stopTraining_=t},enumerable:!0,configurable:!0}),e.prototype.save=function(p,l){return __awaiter$1(this,void 0,void 0,function(){var e,t,d,u,c;return __generator$1(this,function(a){switch(a.label){case 0:if("string"==typeof p){if(0===(e=io.getSaveHandlers(p)).length)throw new ValueError("Cannot find any save handlers for URL '"+p+"'");if(1<e.length)throw new ValueError("Found more than one ("+e.length+") save handlers for URL '"+p+"'");p=e[0]}if(null==p.save)throw new ValueError("Model.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,io.encodeWeights(this.getNamedWeights(l))];case 1:return t=a.sent(),d=!1,u=null,c=this.toJSON(u,d),[2,p.save({modelTopology:c,weightData:t.data,weightSpecs:t.specs})];}})})},e.className="Model",e}(Container);serialization.registerClass(Model);var Sequential=function(o){function p(e){var s=o.call(this,{inputs:[],outputs:[]})||this;if(e=e||{},s.trainable=!0,s._updatable=!0,s.built=!1,s.name=null==e.name?getUid("sequential_"):e.name,null!=e.layers)for(var n=0,p=e.layers,i;n<p.length;n++)i=p[n],s.add(i);return s}return __extends$1(p,o),p.prototype.checkShape=function(t){if(t.inboundNodes[0].outputTensors[0].shape.some(function(t){return 0>t}))throw new ValueError("Negative dimension size caused by adding layer "+t.name+" with input shape ["+t.inboundNodes[0].inputTensors[0].shape+"]")},p.prototype.add=function(t){var e=t instanceof p||t instanceof Model,r;if(e){if(1!==(r=t).outputs.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==r.inputs.length)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var o=Input({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(e)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==t.inboundNodes.length)throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. Model received layer "+t.name+" which has "+t.inboundNodes.length+" pre-existing inbound connections.");if(1!==t.inboundNodes[0].outputTensors.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(function(t){return t.shape}),outputShapes:this.outputs[0].shape})}else{var s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1},p.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}},p.prototype.call=function(a,e){return null==this.model&&this.build(),this.model.call(a,e)},p.prototype.build=function(t){if(getExactlyOneShape(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Model({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.model.updatable=this.updatable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0},p.prototype.countParams=function(){return this.built||this.build(),o.prototype.countParams.call(this)},p.prototype.summary=function(e,t,a){void 0===a&&(a=console.log),this.built||this.build(),o.prototype.summary.call(this,e,t,a)},p.prototype.setWeights=function(t){null==this.model&&this.build(),this.model.setWeights(t)},Object.defineProperty(p.prototype,"updatable",{get:function(){return this._updatable},set:function(t){this.built&&(this.model.updatable=t),this._updatable=t},enumerable:!0,configurable:!0}),p.prototype.evaluate=function(a,e,t){if(void 0===t&&(t={}),!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(a,e,t)},p.prototype.evaluateDataset=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.evaluateDataset(a,e)]})})},p.prototype.predict=function(a,e){return void 0===e&&(e={}),null==this.model&&this.build(),this.model.predict(a,e)},p.prototype.predictOnBatch=function(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)},p.prototype.compile=function(t){this.build(),this.model.compile(t),this.optimizer=this.model.optimizer,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames},p.prototype.fit=function(a,e,t){return void 0===t&&(t={}),__awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fit(a,e,t)]})})},p.prototype.fitDataset=function(a,e){return __awaiter$1(this,void 0,void 0,function(){return __generator$1(this,function(){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fitDataset(a,e)]})})},p.fromConfig=function(t,e){var n={},d;if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new ValueError("Legacy serialization format not supported yet.");d=e}else util.assert(null!=e.layers,"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),d=e.layers,delete e.layers,n=e;var u=new t(n);if(!(u instanceof p))throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: "+u);for(var a=0,c=d,s;a<c.length;a++)s=deserialize(c[a]),u.add(s);return u},Object.defineProperty(p.prototype,"stopTraining",{set:function(t){this.model.stopTraining=t},enumerable:!0,configurable:!0}),p.prototype.getConfig=function(){for(var a=[],e=0,o=this.layers,n;e<o.length;e++)n=o[e],a.push({className:n.getClassName(),config:n.getConfig()});return a},p.className="Sequential",p}(Model);serialization.registerClass(Sequential);var Activation=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.getConfig=function(){return{}},e}(serialization.Serializable),Elu=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(a,e){return void 0===e&&(e=1),elu$1(a,e)},e.className="elu",e}(Activation);serialization.registerClass(Elu);var Selu=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return selu(t)},e.className="selu",e}(Activation);serialization.registerClass(Selu);var Relu=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return relu(t)},e.className="relu",e}(Activation);serialization.registerClass(Relu);var Relu6=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return tidy(function(){return minimum(getScalar(6),relu(t))})},e.className="relu6",e}(Activation);serialization.registerClass(Relu6);var Linear=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return t},e.className="linear",e}(Activation);serialization.registerClass(Linear);var Sigmoid=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return sigmoid(t)},e.className="sigmoid",e}(Activation);serialization.registerClass(Sigmoid);var HardSigmoid=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return hardSigmoid(t)},e.className="hardSigmoid",e}(Activation);serialization.registerClass(HardSigmoid);var Softplus=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return softplus(t)},e.className="softplus",e}(Activation);serialization.registerClass(Softplus);var Softsign=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return softsign(t)},e.className="softsign",e}(Activation);serialization.registerClass(Softsign);var Tanh=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(t){return tanh$1(t)},e.className="tanh",e}(Activation);serialization.registerClass(Tanh);var Softmax=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(a,e){return void 0===e&&(e=-1),softmax(a,e)},e.className="softmax",e}(Activation);serialization.registerClass(Softmax);var ReLU=function(a){function e(e){var t=a.call(this,null==e?{}:e)||this;return t.supportsMasking=!0,null!=e&&(t.maxValue=e.maxValue),t}return __extends$1(e,a),e.prototype.call=function(t){t=getExactlyOneTensor(t);var a=relu(t);return null!=this.maxValue&&(a=clipByValue(a,0,this.maxValue)),a},e.prototype.computeOutputShape=function(t){return t},e.prototype.getConfig=function(){var e={maxValue:this.maxValue},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="ReLU",e}(Layer);serialization.registerClass(ReLU);var LeakyReLU=function(a){function e(e){var r=a.call(this,null==e?{}:e)||this;return r.DEFAULT_ALPHA=.3,null==e&&(e={}),r.alpha=null==e.alpha?r.DEFAULT_ALPHA:e.alpha,r}return __extends$1(e,a),e.prototype.call=function(t){var e=getExactlyOneTensor(t);return leakyRelu(e,this.alpha)},e.prototype.computeOutputShape=function(t){return t},e.prototype.getConfig=function(){var e={alpha:this.alpha},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="LeakyReLU",e}(Layer);serialization.registerClass(LeakyReLU);var ELU$1=function(a){function e(e){var r=a.call(this,null==e?{}:e)||this;if(r.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==r.DEFAULT_ALPHA)throw new NotImplementedError("Non-default alpha value ("+e.alpha+") is not supported by the ELU layer yet.");return r.alpha=null==e.alpha?r.DEFAULT_ALPHA:e.alpha,r}return __extends$1(e,a),e.prototype.call=function(t){var e=getExactlyOneTensor(t);return elu(e)},e.prototype.computeOutputShape=function(t){return t},e.prototype.getConfig=function(){var e={alpha:this.alpha},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="ELU",e}(Layer);serialization.registerClass(ELU$1);var ThresholdedReLU=function(a){function e(e){var r=a.call(this,null==e?{}:e)||this;return r.DEFAULT_THETA=1,null==e&&(e={}),r.theta=null==e.theta?r.DEFAULT_THETA:e.theta,r.thetaTensor=getScalar(r.theta),r}return __extends$1(e,a),e.prototype.call=function(t){var e=getExactlyOneTensor(t);return e.mul(cast$1(e.greater(this.thetaTensor),"float32"))},e.prototype.computeOutputShape=function(t){return t},e.prototype.getConfig=function(){var e={theta:this.theta},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="ThresholdedReLU",e}(Layer);serialization.registerClass(ThresholdedReLU);var Softmax$1=function(a){function e(e){var r=a.call(this,null==e?{}:e)||this;return r.DEFAULT_AXIS=1,null==e&&(e={}),r.softmax=new Softmax().apply,r.axis=null==e.axis?r.DEFAULT_AXIS:e.axis,r}return __extends$1(e,a),e.prototype.call=function(t){var e=getExactlyOneTensor(t);return this.softmax(e,this.axis)},e.prototype.computeOutputShape=function(t){return t},e.prototype.getConfig=function(){var e={axis:this.axis},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Softmax",e}(Layer);serialization.registerClass(Softmax$1);var Regularizer=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e}(serialization.Serializable),L1L2=function(a){function e(e){var t=a.call(this)||this,n=null==e||null==e.l1?.01:e.l1,r=null==e||null==e.l2?.01:e.l2;return t.hasL1=0!==n,t.hasL2=0!==r,t.l1=getScalar(n),t.l2=getScalar(r),t}return __extends$1(e,a),e.prototype.apply=function(a){var e=this;return tidy(function(){var t=zeros([1]);return e.hasL1&&(t=add(t,sum$1(mul(e.l1,abs(a))))),e.hasL2&&(t=add(t,sum$1(mul(e.l2,square$1(a))))),t.asScalar()})},e.prototype.getConfig=function(){return{l1:this.l1.dataSync()[0],l2:this.l2.dataSync()[0]}},e.fromConfig=function(a,e){return new a({l1:e.l1,l2:e.l2})},e.className="L1L2",e}(Regularizer);serialization.registerClass(L1L2);var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"},BaseConv=function(a){function e(t,n){var r=a.call(this,n)||this;if(r.bias=null,r.DEFAULT_KERNEL_INITIALIZER="glorotNormal",r.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyConfig(n),r.rank=t,1!==r.rank&&2!==r.rank)throw new NotImplementedError("Convolution layer for rank other than 1 or 2 ("+r.rank+") is not implemented yet.");if(r.kernelSize=normalizeArray(n.kernelSize,t,"kernelSize"),r.strides=normalizeArray(null==n.strides?1:n.strides,t,"strides"),r.padding=null==n.padding?"valid":n.padding,checkPaddingMode(r.padding),r.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,checkDataFormat(r.dataFormat),r.activation=getActivation(n.activation),r.useBias=null==n.useBias||n.useBias,r.biasInitializer=getInitializer(n.biasInitializer||r.DEFAULT_BIAS_INITIALIZER),r.biasConstraint=getConstraint(n.biasConstraint),r.biasRegularizer=getRegularizer(n.biasRegularizer),r.activityRegularizer=getRegularizer(n.activityRegularizer),r.dilationRate=normalizeArray(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===r.rank&&Array.isArray(r.dilationRate)&&1!==r.dilationRate.length)throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(r.dilationRate));if(2===r.rank)if("number"==typeof r.dilationRate)r.dilationRate=[r.dilationRate,r.dilationRate];else if(2!==r.dilationRate.length)throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(r.dilationRate));return r}return __extends$1(e,a),e.verifyConfig=function(t){if(assert$1("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!checkArrayTypeAndLength(t.kernelSize,"number",1,2))throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(t.kernelSize)+".")},e.prototype.getConfig=function(){var e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e}(Layer),Conv=function(a){function e(t,n){var r=a.call(this,t,n)||this;return r.kernel=null,e.verifyConfig(n),r.filters=n.filters,r.kernelInitializer=getInitializer(n.kernelInitializer||r.DEFAULT_KERNEL_INITIALIZER),r.kernelConstraint=getConstraint(n.kernelConstraint),r.kernelRegularizer=getRegularizer(n.kernelRegularizer),r}return __extends$1(e,a),e.prototype.build=function(a){a=getExactlyOneShape(a);var o="channelsFirst"===this.dataFormat?1:a.length-1;if(null==a[o])throw new ValueError("The channel dimension of the input should be defined. Found "+a[o]);var t=a[o],r=this.kernelSize.concat([t,this.filters]),s;this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:(s={},s[o]=t,s)}],this.built=!0},e.prototype.call=function(a){var o=this;return tidy(function(){var e;a=getExactlyOneTensor(a);var n=null==o.bias?null:o.bias.read();if(1===o.rank)e=conv1dWithBias(a,o.kernel.read(),n,o.strides[0],o.padding,o.dataFormat,o.dilationRate[0]);else if(2===o.rank)e=conv2dWithBias(a,o.kernel.read(),n,o.strides,o.padding,o.dataFormat,o.dilationRate);else if(3===o.rank)throw new NotImplementedError("3D convolution is not implemented yet.");return null!=o.activation&&(e=o.activation.apply(e)),e})},e.prototype.computeOutputShape=function(o){o=getExactlyOneShape(o);for(var s=[],t="channelsLast"===this.dataFormat?o.slice(1,o.length-1):o.slice(2),n=0,p;n<t.length;++n)p=convOutputLength(t[n],this.kernelSize[n],this.padding,this.strides[n],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[n]),s.push(p);var l=[o[0]];return"channelsLast"===this.dataFormat?(l=l.concat(s)).push(this.filters):(l.push(this.filters),l=l.concat(s)),l},e.prototype.getConfig=function(){var e={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.verifyConfig=function(t){if(!("filters"in t)||"number"!=typeof t.filters||1>t.filters)throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(t.filters))},e}(BaseConv),Conv2D=function(a){function e(t){var n=a.call(this,2,t)||this;return e.verifyConfig(t),n}return __extends$1(e,a),e.prototype.getConfig=function(){var e=a.prototype.getConfig.call(this);return delete e.rank,e},e.verifyConfig=function(t){if("number"!=typeof t.kernelSize&&!checkArrayTypeAndLength(t.kernelSize,"number",1,2))throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv2D",e}(Conv);serialization.registerClass(Conv2D);var Conv2DTranspose=function(a){function e(e){var t=a.call(this,e)||this;if(t.inputSpec=[new InputSpec({ndim:4})],"same"!==t.padding&&"valid"!==t.padding)throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+t.padding);return t}return __extends$1(e,a),e.prototype.build=function(a){if(4!==(a=getExactlyOneShape(a)).length)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(a));var o="channelsFirst"===this.dataFormat?1:a.length-1;if(null==a[o])throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");var t=a[o],r=this.kernelSize.concat([this.filters,t]),s;this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:(s={},s[o]=t,s)})],this.built=!0},e.prototype.call=function(m){var e=this;return tidy(function(){var n=getExactlyOneTensor(m);if(4!==n.shape.length)throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+n.shape.length);var g=n.shape,a=g[0],o,y;"channelsFirst"===e.dataFormat?(o=2,y=3):(o=1,y=2);var b=g[o],s=g[y],l=e.kernelSize[0],u=e.kernelSize[1],c=e.strides[0],p=e.strides[1],h=[a,deconvLength(b,c,l,e.padding),deconvLength(s,p,u,e.padding),e.filters];"channelsLast"!==e.dataFormat&&(n=transpose(n,[0,2,3,1]));var d=conv2dTranspose(n,e.kernel.read(),h,e.strides,e.padding);return"channelsLast"!==e.dataFormat&&(d=transpose(d,[0,3,1,2])),null!=e.bias&&(d=biasAdd(d,e.bias.read(),e.dataFormat)),null!=e.activation&&(d=e.activation.apply(d)),d})},e.prototype.computeOutputShape=function(p){var d=(p=getExactlyOneShape(p)).slice(),i,u,c;"channelsFirst"===this.dataFormat?(i=1,u=2,c=3):(i=3,u=1,c=2);var m=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],s=this.strides[1];return d[i]=this.filters,d[u]=deconvLength(d[u],o,m,this.padding),d[c]=deconvLength(d[c],s,a,this.padding),d},e.prototype.getConfig=function(){var e=a.prototype.getConfig.call(this);return delete e.dilationRate,e},e.className="Conv2DTranspose",e}(Conv2D);serialization.registerClass(Conv2DTranspose);var SeparableConv=function(a){function e(e,t){var n=a.call(this,e,t)||this;if(n.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",n.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",n.depthwiseKernel=null,n.pointwiseKernel=null,null==t.filters)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new ValueError("SeparableConv"+n.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(t.padding));return n.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,n.depthwiseInitializer=getInitializer(t.depthwiseInitializer||n.DEFAULT_DEPTHWISE_INITIALIZER),n.depthwiseRegularizer=getRegularizer(t.depthwiseRegularizer),n.depthwiseConstraint=getConstraint(t.depthwiseConstraint),n.pointwiseInitializer=getInitializer(t.depthwiseInitializer||n.DEFAULT_POINTWISE_INITIALIZER),n.pointwiseRegularizer=getRegularizer(t.pointwiseRegularizer),n.pointwiseConstraint=getConstraint(t.pointwiseConstraint),n}return __extends$1(e,a),e.prototype.build=function(s){if((s=getExactlyOneShape(s)).length<this.rank+2)throw new ValueError("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2)+", but received input shape: "+JSON.stringify(s));var p="channelsFirst"===this.dataFormat?1:s.length-1;if(null==s[p]||0>s[p])throw new ValueError("The channel dimension of the inputs should be defined, but found "+JSON.stringify(s[p]));for(var t=s[p],n=this.kernelSize.concat([t,this.depthMultiplier]),r=[],i=0;i<this.rank;++i)r.push(1);r.push(t*this.depthMultiplier,this.filters);var l;this.depthwiseKernel=this.addWeight("depthwise_kernel",n,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:(l={},l[p]=t,l)})],this.built=!0},e.prototype.call=function(a){var r=this;return tidy(function(){var e;if(a=getExactlyOneTensor(a),1===r.rank)throw new NotImplementedError("1D separable convolution is not implemented yet.");return 2===r.rank&&("channelsFirst"===r.dataFormat&&(a=transpose(a,[0,2,3,1])),e=separableConv2d(a,r.depthwiseKernel.read(),r.pointwiseKernel.read(),r.strides,r.padding,r.dilationRate,"NHWC")),r.useBias&&(e=biasAdd(e,r.bias.read(),r.dataFormat)),null!=r.activation&&(e=r.activation.apply(e)),"channelsFirst"===r.dataFormat&&(e=transpose(e,[0,3,1,2])),e})},e.prototype.getConfig=function(){var e=a.prototype.getConfig.call(this);return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),e.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),e.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),e.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),e.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),e.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),e},e.className="SeparableConv",e}(Conv),SeparableConv2D=function(a){function e(e){return a.call(this,2,e)||this}return __extends$1(e,a),e.className="SeparableConv2D",e}(SeparableConv);serialization.registerClass(SeparableConv2D);var Conv1D=function(a){function e(t){var n=a.call(this,1,t)||this;return e.verifyConfig(t),n.inputSpec=[{ndim:3}],n}return __extends$1(e,a),e.prototype.getConfig=function(){var e=a.prototype.getConfig.call(this);return delete e.rank,delete e.dataFormat,e},e.verifyConfig=function(t){if("number"!=typeof t.kernelSize&&!checkArrayTypeAndLength(t.kernelSize,"number",1,1))throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+JSON.stringify(t.kernelSize)+".")},e.className="Conv1D",e}(Conv);serialization.registerClass(Conv1D);var Cropping2D=function(a){function e(e){var t=a.call(this,e)||this;return t.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,t.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,t.inputSpec=[{ndim:4}],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]},e.prototype.call=function(t){var a=this;return tidy(function(){return t=getExactlyOneTensor(t),"channelsLast"===a.dataFormat?sliceAlongAxis(sliceAlongAxis(t,a.cropping[0][0],t.shape[1]-a.cropping[0][0]-a.cropping[0][1],2),a.cropping[1][0],t.shape[2]-a.cropping[1][1]-a.cropping[1][0],3):sliceAlongAxis(sliceAlongAxis(t,a.cropping[0][0],t.shape[2]-a.cropping[0][0]-a.cropping[0][1],3),a.cropping[1][0],t.shape[3]-a.cropping[1][1]-a.cropping[1][0],4)})},e.prototype.getConfig=function(){var e={cropping:this.cropping,dataFormat:this.dataFormat},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Cropping2D",e}(Layer);serialization.registerClass(Cropping2D);var UpSampling2D=function(a){function e(e){var t=a.call(this,e)||this;return t.DEFAULT_SIZE=[2,2],t.inputSpec=[{ndim:4}],t.size=null==e.size?t.DEFAULT_SIZE:e.size,t.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,t}return __extends$1(e,a),e.prototype.computeOutputShape=function(a){if("channelsFirst"===this.dataFormat){var e=null==a[2]?null:this.size[0]*a[2],r=null==a[3]?null:this.size[1]*a[3];return[a[0],a[1],e,r]}return e=null==a[1]?null:this.size[0]*a[1],r=null==a[2]?null:this.size[1]*a[2],[a[0],e,r,a[3]]},e.prototype.call=function(s){var e=this;return tidy(function(){var n=getExactlyOneTensor(s),p=n.shape;if("channelsFirst"===e.dataFormat){n=transpose(n,[0,2,3,1]);var r=e.size[0]*p[2],l=e.size[1]*p[3],d=n.resizeNearestNeighbor([r,l]);return transpose(d,[0,3,1,2])}return r=e.size[0]*p[1],l=e.size[1]*p[2],n.resizeNearestNeighbor([r,l])})},e.prototype.getConfig=function(){var e={size:this.size,dataFormat:this.dataFormat},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="UpSampling2D",e}(Layer);serialization.registerClass(UpSampling2D);var DepthwiseConv2D=function(a){function e(e){var t=a.call(this,2,e)||this;return t.depthwiseKernel=null,t.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,t.depthwiseInitializer=getInitializer(e.depthwiseInitializer||t.DEFAULT_KERNEL_INITIALIZER),t.depthwiseConstraint=getConstraint(e.depthwiseConstraint),t.depthwiseRegularizer=getRegularizer(e.depthwiseRegularizer),t}return __extends$1(e,a),e.prototype.build=function(a){if(4>(a=getExactlyOneShape(a)).length)throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+JSON.stringify(a)+".");var o="channelsFirst"===this.dataFormat?1:3;if(null==a[o]||0>a[o])throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+a[o]+").");var t=a[o],n=[this.kernelSize[0],this.kernelSize[1],t,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",n,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[t*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0},e.prototype.call=function(a){var r=this;return tidy(function(){var e=depthwiseConv2d$1(a=getExactlyOneTensor(a),r.depthwiseKernel.read(),r.strides,r.padding,r.dataFormat,null);return r.useBias&&(e=biasAdd(e,r.bias.read(),r.dataFormat)),null!=r.activation&&(e=r.activation.apply(e)),e})},e.prototype.computeOutputShape=function(o){o=getExactlyOneShape(o);var s="channelsFirst"===this.dataFormat?o[2]:o[1],t="channelsFirst"===this.dataFormat?o[3]:o[2],n="channelsFirst"===this.dataFormat?o[1]*this.depthMultiplier:o[3]*this.depthMultiplier,r=convOutputLength(s,this.kernelSize[0],this.padding,this.strides[0]),i=convOutputLength(t,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[o[0],n,r,i]:[o[0],r,i,n]},e.prototype.getConfig=function(){var e=a.prototype.getConfig.call(this);return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),e.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),e.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),e},e.className="DepthwiseConv2D",e}(BaseConv);serialization.registerClass(DepthwiseConv2D);var Dropout=function(a){function e(e){var t=a.call(this,e)||this;if(t.rate=_Mathmax(_Mathmin(e.rate,1),0),t.rateScalar=getScalar(t.rate),t.noiseShape=e.noiseShape,t.seed=e.seed,null!=t.seed)throw new NotImplementedError("Non-default seed is not implemented in Dropout layer yet: "+t.seed);return t.supportsMasking=!0,t}return __extends$1(e,a),e.prototype.getNoiseShape=function(a){if(null==this.noiseShape)return this.noiseShape;for(var e=a.shape,t=[],n=0;n<this.noiseShape.length;++n)t.push(null==this.noiseShape[n]?e[n]:this.noiseShape[n]);return t},e.prototype.call=function(o,e){var t=this;return tidy(function(){t.invokeCallHook(o,e);var n=getExactlyOneTensor(o);if(null!=t.noiseShape&&!util.arraysEqual(n.shape,t.noiseShape))throw new NotImplementedError("Non-default noise shape is not implemented in Dropout layer yet: "+JSON.stringify(t.noiseShape));if(0<t.rate&&1>t.rate){var r=null!=e.training&&e.training,s=t.getNoiseShape(n);return inTrainPhase(function(){return dropout(n,t.rateScalar,s,t.seed)},function(){return n},r)}return o})},e.prototype.getConfig=function(){var e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Dropout",e}(Layer);serialization.registerClass(Dropout);var Dense=function(a){function e(e){var t=a.call(this,e)||this;if(t.activation=null,t.useBias=!0,t.kernel=null,t.bias=null,t.DEFAULT_KERNEL_INITIALIZER="glorotNormal",t.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){var n=null;null!=e.batchSize&&(n=e.batchSize),t.batchInputShape=[n,e.inputDim]}return t.units=e.units,t.activation=getActivation(e.activation),null!=e.useBias&&(t.useBias=e.useBias),t.kernelInitializer=getInitializer(e.kernelInitializer||t.DEFAULT_KERNEL_INITIALIZER),t.biasInitializer=getInitializer(e.biasInitializer||t.DEFAULT_BIAS_INITIALIZER),t.kernelConstraint=getConstraint(e.kernelConstraint),t.biasConstraint=getConstraint(e.biasConstraint),t.kernelRegularizer=getRegularizer(e.kernelRegularizer),t.biasRegularizer=getRegularizer(e.biasRegularizer),t.activityRegularizer=getRegularizer(e.activityRegularizer),t.inputSpec=[{minNDim:2}],t}return __extends$1(e,a),e.prototype.build=function(a){var r=(a=getExactlyOneShape(a))[a.length-1],n;null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:(n={},n[-1]=r,n)}],this.built=!0},e.prototype.computeOutputShape=function(a){var n=(a=getExactlyOneShape(a)).slice();return n[n.length-1]=this.units,n},e.prototype.call=function(a,e){var t=this;return tidy(function(){t.invokeCallHook(a,e);var n=dot$1(getExactlyOneTensor(a),t.kernel.read());return null!=t.bias&&(n=biasAdd(n,t.bias.read())),null!=t.activation&&(n=t.activation.apply(n)),n})},e.prototype.getConfig=function(){var e={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Dense",e}(Layer);serialization.registerClass(Dense);var Flatten=function(a){function e(e){var t=a.call(this,e||{})||this;return t.inputSpec=[{minNDim:3}],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(a){for(var r=0,o=(a=getExactlyOneShape(a)).slice(1);r<o.length;r++)if(null==o[r])throw new ValueError("The shape of the input to \"Flatten\" is not fully defined (got "+a.slice(1)+"). Make sure to pass a complete \"input_shape\" or \"batch_input_shape\" argument to the first layer in your model.");return[a[0],arrayProd(a,1)]},e.prototype.call=function(a,e){var t=this;return tidy(function(){return t.invokeCallHook(a,e),batchFlatten(getExactlyOneTensor(a))})},e.className="Flatten",e}(Layer);serialization.registerClass(Flatten);var Activation$1=function(a){function e(e){var t=a.call(this,e)||this;return t.supportsMasking=!0,t.activation=getActivation(e.activation),t}return __extends$1(e,a),e.prototype.call=function(a,e){var t=this;return tidy(function(){t.invokeCallHook(a,e);var n=getExactlyOneTensor(a);return t.activation.apply(n)})},e.prototype.getConfig=function(){var e={activation:serializeActivation(this.activation)},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Activation",e}(Layer);serialization.registerClass(Activation$1);var RepeatVector=function(a){function e(e){var t=a.call(this,e)||this;return t.n=e.n,t.inputSpec=[{ndim:2}],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(t){return[t[0],this.n,t[1]]},e.prototype.call=function(t){var a=this;return tidy(function(){return repeat(t=getExactlyOneTensor(t),a.n)})},e.prototype.getConfig=function(){var e={n:this.n},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="RepeatVector",e}(Layer);serialization.registerClass(RepeatVector);var Reshape=function(a){function e(e){var t=a.call(this,e)||this;t.targetShape=e.targetShape;for(var n=0;n<t.targetShape.length;++n)t.isUnknown(t.targetShape[n])&&(t.targetShape[n]=null);return t}return __extends$1(e,a),e.prototype.isUnknown=function(t){return 0>t||null==t},e.prototype.fixUnknownDimension=function(p,e){for(var t="Total size of new array must be unchanged.",n=e.slice(),r=1,d=null,u=0,c;u<n.length;++u)if(c=n[u],this.isUnknown(c)){if(null!=d)throw new ValueError("Can only specifiy one unknown dimension.");d=u}else r*=c;var m=arrayProd(p);if(null!==d){if(0===r||0!=m%r)throw new ValueError(t);n[d]=m/r}else if(m!==r)throw new ValueError(t);return n},e.prototype.computeOutputShape=function(a){for(var e=!1,r=0;r<a.length;++r)if(this.isUnknown(a[r])){e=!0;break}return e?a.slice(0,1).concat(this.targetShape):a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape))},e.prototype.call=function(o,e){var t=this;return tidy(function(){t.invokeCallHook(o,e);var n=getExactlyOneTensor(o),r=n.shape,s=r.slice(0,1).concat(t.fixUnknownDimension(r.slice(1),t.targetShape));return n.reshape(s)})},e.prototype.getConfig=function(){var e={targetShape:this.targetShape},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Reshape",e}(Layer);serialization.registerClass(Reshape);var Permute=function(a){function e(e){var t=a.call(this,e)||this;if(null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+e.dims+" instead.");var n=range$1(1,e.dims.length+1);if(!util.arraysEqual(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");return t.dims=e.dims,t.dimsIncludingBatch=[0].concat(t.dims),t.inputSpec=[new InputSpec({ndim:t.dims.length+1})],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(a){var o=(a=getExactlyOneShape(a)).slice();return this.dims.forEach(function(e,t){o[t+1]=a[e]}),o},e.prototype.call=function(t){return transpose(getExactlyOneTensor(t),this.dimsIncludingBatch)},e.prototype.getConfig=function(){var e={dims:this.dims},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Permute",e}(Layer);serialization.registerClass(Permute);var Embedding=function(a){function e(e){var t=a.call(this,e)||this;if(t.embeddings=null,t.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){var n=null;null!=e.batchSize&&(n=e.batchSize),t.batchInputShape=null==e.inputLength?[n,null]:[n].concat(toList(e.inputLength))}return t.inputDim=e.inputDim,t.outputDim=e.outputDim,t.embeddingsInitializer=getInitializer(e.embeddingsInitializer||t.DEFAULT_EMBEDDINGS_INITIALIZER),t.embeddingsRegularizer=getRegularizer(e.embeddingsRegularizer),t.activityRegularizer=getRegularizer(e.activityRegularizer),t.embeddingsConstraint=getConstraint(e.embeddingsConstraint),t.maskZero=e.maskZero,t.inputLength=e.inputLength,t}return __extends$1(e,a),e.prototype.build=function(){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0},e.prototype.warnOnIncompatibleInputShape=function(){},e.prototype.computeMask=function(){throw new NotImplementedError("computeMask has not been implemented for Embedding yet")},e.prototype.computeOutputShape=function(o){if(o=getExactlyOneShape(o),null==this.inputLength)return o.concat([this.outputDim]);var s=toList(this.inputLength);if(s.length!==o.length-1)throw new ValueError("\"inputLength\" is "+this.inputLength+", but received input shape has shape "+o);for(var t=0,p=0;p<s.length;++p){var l=s[p],i=o[p+1];if(null!=l&&null!=i&&l!==i)throw new ValueError("\"inputLength\" is "+this.inputLength+", but received input shape has shape "+o);null==l&&(s[t]=i),t++}return[o[0]].concat(s,[this.outputDim])},e.prototype.call=function(a,e){var t=this;return tidy(function(){t.invokeCallHook(a,e);var n=getExactlyOneTensor(a);return"int32"!==n.dtype&&(n=cast$1(n,"int32")),gather$1(t.embeddings.read(),n.as1D()).reshape(getExactlyOneShape(t.computeOutputShape(n.shape)))})},e.prototype.getConfig=function(){var e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Embedding",e}(Layer);serialization.registerClass(Embedding);var Merge=function(a){function e(e){var t=a.call(this,e||{})||this;return t.supportsMasking=!0,t}return __extends$1(e,a),e.prototype.mergeFunction=function(){throw new NotImplementedError},e.prototype.computeElementwiseOpOutputShape=function(o,e){if(null==o||null==e)return null;if(o.length<e.length)return this.computeElementwiseOpOutputShape(e,o);if(0===e.length)return o;for(var t=o.slice(0,o.length-e.length),n=0;n<e.length;++n){var s=o[o.length-e.length+n],i=e[n];if(null==s||null==i||0>s||0>i)t.push(null);else if(1===s)t.push(i);else if(1===i)t.push(s);else{if(s!==i)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(o)+" "+JSON.stringify(e));t.push(s)}}return t},e.prototype.build=function(p){if(Array.isArray(p)&&!Array.isArray(p[0])&&(p=[getExactlyOneShape(p)]),2>(p=p).length)throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got "+p.length+" input(s).");for(var l=[],d=0,u=p;d<u.length;d++)null!=(m=u[d])&&null!==m[0]&&l.push(m[0]);if(1<(l=unique(l)).length)throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: "+JSON.stringify(p)+".");for(var r=null==p[0]?null:p[0].slice(1),c=1,m;c<p.length;++c)m=null==p[c]?null:p[c].slice(1),r=this.computeElementwiseOpOutputShape(r,m);var h=p.map(function(t){return t.length});this.reshapeRequired=-1!==p.indexOf(null)||1!==unique(h).length},e.prototype.call=function(x){var N=this;return tidy(function(){if(x=x,N.reshapeRequired){var e=[],t=x.map(function(t){return t.rank});if(-1===t.indexOf(null)){for(var n=max$1(t),r=0,i=x;r<i.length;r++){for(var o=(p=i[r]).rank,I=0;I<n-o;++I)p=expandDims$1(p,1);e.push(p)}return N.mergeFunction(e)}for(var S=!1,C=0,k=x;C<k.length;C++){var p;if(null==(o=(p=k[C]).rank)){var T=p.shape,d=T[0],E=T.slice(1).concat([d]),R=p.reshape([d].concat(arrayProd(T.slice(1))));R=(R=transpose(R,[1,0])).reshape(E),e.push(R),S=!0}else if(1<o){var D=range$1(1,o).concat([0]);e.push(transpose(p,D)),S=!0}else e.push(p)}var P=N.mergeFunction(e),A=P.rank;if(S)if(null==A){var b=P.shape;E=[d=b[b.length-1]].concat(b.slice(0,b.length-1)),P=transpose(P.reshape([-1,d]),[1,0]).reshape(E)}else 1<A&&(D=[A-1].concat(range$1(0,A-1)),P=transpose(P,D));return P}return N.mergeFunction(x)})},e.prototype.computeOutputShape=function(s){var p=null==(s=s)[0]?null:s[0].slice(1);for(var l=1,d;l<s.length;++l)d=null==s[l]?null:s[l].slice(1),p=this.computeElementwiseOpOutputShape(p,d);for(var u=[],c=0,m=s;c<m.length;c++)null!=(d=m[c])&&null!==d[0]&&u.push(d[0]);return p=1===(u=unique(u)).length?u.concat(p):[null].concat(p)},e.prototype.computeMask=function(){throw new NotImplementedError("computeMask has not been implemented for Merge yet")},e}(Layer),Add=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.mergeFunction=function(a){return tidy(function(){for(var e=a[0].clone(),r=1;r<a.length;++r)e=add(e,a[r]);return e})},e.className="Add",e}(Merge);serialization.registerClass(Add);var Multiply=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.mergeFunction=function(a){return tidy(function(){for(var e=a[0].clone(),r=1;r<a.length;++r)e=mul(e,a[r]);return e})},e.className="Multiply",e}(Merge);serialization.registerClass(Multiply);var Average=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.mergeFunction=function(a){return tidy(function(){for(var e=a[0].clone(),r=1;r<a.length;++r)e=add(e,a[r]);return mul(getScalar(1/a.length),e)})},e.className="Average",e}(Merge);serialization.registerClass(Average);var Maximum=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.mergeFunction=function(a){return tidy(function(){for(var e=a[0],r=1;r<a.length;++r)e=maximum(e,a[r]);return e})},e.className="Maximum",e}(Merge);serialization.registerClass(Maximum);var Minimum=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.mergeFunction=function(a){return tidy(function(){for(var e=a[0],r=1;r<a.length;++r)e=minimum(e,a[r]);return e})},e.className="Minimum",e}(Merge);serialization.registerClass(Minimum);var Concatenate=function(a){function e(e){var r=a.call(this,e)||this;return r.DEFAULT_AXIS=-1,null==e&&(e={}),r.axis=null==e.axis?r.DEFAULT_AXIS:e.axis,r.supportsMasking=!0,r.reshapeRequired=!1,r}return __extends$1(e,a),e.prototype.build=function(p){if(!Array.isArray(p)||!Array.isArray(p[0])||1===p.length)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var d=!0,m=0,h=p=p;m<h.length;m++)if(null!=(u=h[m])){d=!1;break}if(!d){for(var r=[],i=0,g;i<p.length;++i){g=p[i].slice(),g.splice(this.axis,1);for(var f=!1,y=0,b=r,u;y<b.length;y++)if(u=b[y],util.arraysEqual(u,g)){f=!0;break}f||r.push(g)}if(1<r.length)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(p))}},e.prototype.mergeFunction=function(a){var e=this;return tidy(function(){return concatenate(a,e.axis)})},e.prototype.computeOutputShape=function(s){if(!Array.isArray(s)||!Array.isArray(s[0]))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");for(var e=s,t=e[0].slice(),n=0>this.axis?t.length+this.axis:this.axis,r=0,p=e.slice(1),a;r<p.length;r++){if(a=p[r],null==t[n]||null==a[n]){t[n]=null;break}t[n]+=a[n]}return t},e.prototype.computeMask=function(){throw new NotImplementedError("computeMask has not been implemented for Concatenate yet")},e.prototype.getConfig=function(){var e={axis:this.axis},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Concatenate",e}(Merge);serialization.registerClass(Concatenate);var Dot=function(a){function e(e){var t=a.call(this,e)||this;return t.axes=e.axes,t.normalize=null!=e.normalize&&e.normalize,t.supportsMasking=!0,t.reshapeRequired=!1,t}return __extends$1(e,a),e.prototype.build=function(a){util.assert(Array.isArray(a)&&2===a.length&&Array.isArray(a[0])&&Array.isArray(a[1]),"A `Dot` layer should be called on a list of exactly 2 inputs.");var e=a[0],t=a[1];if(3<e.length||3<t.length)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var n=this.interpretAxes(e,t);if(e[n[0]]!==t[n[1]])throw new ValueError("Dimension incompatibility: "+e[n[0]]+" !== "+t[n[1]])},e.prototype.mergeFunction=function(a){if(2!==a.length)throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received "+a.length+" input(s).");var e=a[0],o=a[1],s;return s=Array.isArray(this.axes)?this.axes.map(function(e,t){return interpretAxis(e,a[t].shape.length)}):[interpretAxis(this.axes,e.shape.length),interpretAxis(this.axes,o.shape.length)],this.normalize&&(e=l2Normalize(e,s[0]),o=l2Normalize(o,s[1])),batchDot(e,o,s)},e.prototype.interpretAxes=function(a,e){return Array.isArray(this.axes)?this.axes:[interpretAxis(this.axes,a.length),interpretAxis(this.axes,e.length)]},e.prototype.computeOutputShape=function(a){util.assert(Array.isArray(a)&&2===a.length&&Array.isArray(a[0])&&Array.isArray(a[1]),"A `Dot` layer should be called on a list of exactly 2 inputs.");var e=a[0].slice(),t=a[1].slice();if(3<e.length||3<t.length)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var n=this.interpretAxes(e,t);e.splice(n[0],1),t.splice(n[1],1),t.splice(0,1);var r=e.concat(t);return 1===r.length&&r.push(1),r},e.prototype.computeMask=function(){throw new NotImplementedError("computeMask has not been implemented for Dot yet")},e.prototype.getConfig=function(){var e={axes:this.axes,normalize:this.normalize},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="Dot",e}(Merge);serialization.registerClass(Dot);var BatchNormalization=function(a){function e(e){var r=this;return null==e&&(e={}),(r=a.call(this,e)||this).supportsMasking=!0,r.axis=null==e.axis?-1:e.axis,r.momentum=null==e.momentum?.99:e.momentum,r.epsilon=null==e.epsilon?.001:e.epsilon,r.center=null==e.center||e.center,r.scale=null==e.scale||e.scale,r.betaInitializer=getInitializer(e.betaInitializer||"zeros"),r.gammaInitializer=getInitializer(e.gammaInitializer||"ones"),r.movingMeanInitializer=getInitializer(e.movingMeanInitializer||"zeros"),r.movingVarianceInitializer=getInitializer(e.movingVarianceInitializer||"ones"),r.betaConstraint=getConstraint(e.betaConstraint),r.gammaConstraint=getConstraint(e.gammaConstraint),r.betaRegularizer=getRegularizer(e.betaRegularizer),r.gammaRegularizer=getRegularizer(e.gammaRegularizer),r.stepCount=0,r}return __extends$1(e,a),e.prototype.build=function(a){a=getExactlyOneShape(a);var o=0<=this.axis?this.axis:this.axis+a.length,t=a[o];if(null==t)throw new ValueError("Axis "+o+" of input tensor should have a defined dimension but the layer received an input with shape "+JSON.stringify(a)+".");this.inputSpec=[new InputSpec({ndim:a.length,axes:(s={},s[o]=t,s)})];var n=[t],s;this.scale&&(this.gamma=this.addWeight("gamma",n,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",n,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",n,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",n,null,this.movingVarianceInitializer,null,!1),this.built=!0},e.prototype.call=function(b,e){var x=this;return tidy(function(){var t=null!=e.training&&e.training,n=getExactlyOneTensor(b),r=n.shape,a=r.length,o=range$1(0,a),s=0<=x.axis?x.axis:x.axis+a;o.splice(s,1);var i=pyListRepeat(1,a);i[s]=r[s];var l=o.slice();l.sort();var u=!util.arraysEqual(l,range$1(0,a).slice(0,a-1));if(!t)return function(){if(u){var o=x.movingMean.read().reshape(i),e=x.movingVariance.read().reshape(i),t=x.center?x.beta.read().reshape(i):null,r=x.scale?x.gamma.read().reshape(i):null;return batchNormalization$1(n,o,e,t,r,x.epsilon)}return batchNormalization$1(n,x.movingMean.read(),x.movingVariance.read(),null==x.beta?null:x.beta.read(),null==x.gamma?null:x.gamma.read(),x.epsilon)}();var p=normalizeBatchInTraining(n,x.gamma.read(),x.beta.read(),o,x.epsilon),c=p[0],d=p[1],h=p[2],g=arrayProd(o.map(function(t){return n.shape[t]})),m=h.mul(getScalar(g/(g-(1+x.epsilon))));return function(){x.stepCount++;var a=movingAverage(x.movingMean.read(),d,x.momentum,x.stepCount);x.movingMean.write(a);var e=movingAverage(x.movingVariance.read(),m,x.momentum,x.stepCount);x.movingVariance.write(e)}(),c})},e.prototype.getConfig=function(){var e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="BatchNormalization",e}(Layer);serialization.registerClass(BatchNormalization);var ZeroPadding2D=function(a){function e(e){var o=this;if(null==e&&(e={}),(o=a.call(this,e)||this).dataFormat=null==e.dataFormat?imageDataFormat():e.dataFormat,null==e.padding)o.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)o.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+e.padding.length+" array.");var s,p;if("number"==typeof e.padding[0])s=[e.padding[0],e.padding[0]],p=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+e.padding[0].length+" array.");if(s=e.padding[0],2!==e.padding[1].length)throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+e.padding[1].length+" array.");p=e.padding[1]}o.padding=[s,p]}return o.inputSpec=[new InputSpec({ndim:4})],o}return __extends$1(e,a),e.prototype.computeOutputShape=function(a){var r,o;return a=getExactlyOneShape(a),"channelsFirst"===this.dataFormat?(r=null!=a[2]&&0<=a[2]?a[2]+this.padding[0][0]+this.padding[0][1]:null,o=null!=a[3]&&0<=a[3]?a[3]+this.padding[1][0]+this.padding[1][1]:null,[a[0],a[1],r,o]):(r=null!=a[1]&&0<=a[1]?a[1]+this.padding[0][0]+this.padding[0][1]:null,o=null!=a[2]&&0<=a[2]?a[2]+this.padding[1][0]+this.padding[1][1]:null,[a[0],r,o,a[3]])},e.prototype.call=function(t){var e=this;return tidy(function(){return spatial2dPadding(getExactlyOneTensor(t),e.padding,e.dataFormat)})},e.prototype.getConfig=function(){var e={padding:this.padding,dataFormat:this.dataFormat},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="ZeroPadding2D",e}(Layer);serialization.registerClass(ZeroPadding2D);var Pooling1D=function(a){function e(e){var t=this;if(null==e.poolSize&&(e.poolSize=2),t=a.call(this,e)||this,"number"==typeof e.poolSize)t.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(e.poolSize));t.poolSize=e.poolSize}if(null==e.strides)t.strides=t.poolSize;else if("number"==typeof e.strides)t.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(e.strides));t.strides=e.strides}return t.padding=null==e.padding?"valid":e.padding,checkPaddingMode(t.padding),t.inputSpec=[new InputSpec({ndim:3})],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(a){var n=convOutputLength((a=getExactlyOneShape(a))[1],this.poolSize[0],this.padding,this.strides[0]);return[a[0],n,a[2]]},e.prototype.call=function(a,o){var t=this;return tidy(function(){t.invokeCallHook(a,o),a=expandDims$1(getExactlyOneTensor(a),2);var e=t.poolingFunction(getExactlyOneTensor(a),[t.poolSize[0],1],[t.strides[0],1],t.padding,"channelsLast");return squeeze(e,[2])})},e.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e}(Layer),MaxPooling1D=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.poolingFunction=function(a,e,t,n,r){return checkDataFormat(r),checkPaddingMode(n),pool2d(a,e,t,n,r,"max")},e.className="MaxPooling1D",e}(Pooling1D);serialization.registerClass(MaxPooling1D);var AveragePooling1D=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.poolingFunction=function(a,e,t,n,r){return checkDataFormat(r),checkPaddingMode(n),pool2d(a,e,t,n,r,"avg")},e.className="AveragePooling1D",e}(Pooling1D);serialization.registerClass(AveragePooling1D);var Pooling2D=function(a){function e(e){var t=this;if(null==e.poolSize&&(e.poolSize=[2,2]),(t=a.call(this,e)||this).poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)t.strides=t.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+e.strides.length+".");t.strides=e.strides}else t.strides=[e.strides,e.strides];return t.padding=null==e.padding?"valid":e.padding,t.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,checkDataFormat(t.dataFormat),checkPaddingMode(t.padding),t.inputSpec=[new InputSpec({ndim:4})],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(a){a=getExactlyOneShape(a);var r="channelsFirst"===this.dataFormat?a[2]:a[1],o="channelsFirst"===this.dataFormat?a[3]:a[2];return r=convOutputLength(r,this.poolSize[0],this.padding,this.strides[0]),o=convOutputLength(o,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[a[0],a[1],r,o]:[a[0],r,o,a[3]]},e.prototype.call=function(a,e){var t=this;return tidy(function(){return t.invokeCallHook(a,e),t.poolingFunction(getExactlyOneTensor(a),t.poolSize,t.strides,t.padding,t.dataFormat)})},e.prototype.getConfig=function(){var e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e}(Layer),MaxPooling2D=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.poolingFunction=function(a,e,t,n,r){return checkDataFormat(r),checkPaddingMode(n),pool2d(a,e,t,n,r,"max")},e.className="MaxPooling2D",e}(Pooling2D);serialization.registerClass(MaxPooling2D);var AveragePooling2D=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.poolingFunction=function(a,e,t,n,r){return checkDataFormat(r),checkPaddingMode(n),pool2d(a,e,t,n,r,"avg")},e.className="AveragePooling2D",e}(Pooling2D);serialization.registerClass(AveragePooling2D);var GlobalPooling1D=function(a){function e(e){var t=a.call(this,e)||this;return t.inputSpec=[new InputSpec({ndim:3})],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(t){return[t[0],t[2]]},e.prototype.call=function(){throw new NotImplementedError},e}(Layer),GlobalAveragePooling1D=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.call=function(a){return tidy(function(){var e=getExactlyOneTensor(a);return mean(e,1)})},e.className="GlobalAveragePooling1D",e}(GlobalPooling1D);serialization.registerClass(GlobalAveragePooling1D);var GlobalMaxPooling1D=function(a){function e(e){return a.call(this,e)||this}return __extends$1(e,a),e.prototype.call=function(a){return tidy(function(){var e=getExactlyOneTensor(a);return max(e,1)})},e.className="GlobalMaxPooling1D",e}(GlobalPooling1D);serialization.registerClass(GlobalMaxPooling1D);var GlobalPooling2D=function(a){function e(e){var t=a.call(this,e)||this;return t.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,checkDataFormat(t.dataFormat),t.inputSpec=[new InputSpec({ndim:4})],t}return __extends$1(e,a),e.prototype.computeOutputShape=function(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]},e.prototype.call=function(){throw new NotImplementedError},e.prototype.getConfig=function(){var e={dataFormat:this.dataFormat},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e}(Layer),GlobalAveragePooling2D=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.call=function(a){var e=this;return tidy(function(){var n=getExactlyOneTensor(a);return"channelsLast"===e.dataFormat?mean(n,[1,2]):mean(n,[2,3])})},e.className="GlobalAveragePooling2D",e}(GlobalPooling2D);serialization.registerClass(GlobalAveragePooling2D);var GlobalMaxPooling2D=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.call=function(a){var e=this;return tidy(function(){var n=getExactlyOneTensor(a);return"channelsLast"===e.dataFormat?max(n,[1,2]):max(n,[2,3])})},e.className="GlobalMaxPooling2D",e}(GlobalPooling2D);serialization.registerClass(GlobalMaxPooling2D);var RNN=function(m){function e(e){var t=m.call(this,e)||this,a;if(null==e.cell)throw new ValueError("cell property is missing for the constructor of RNN.");if(null==(a=Array.isArray(e.cell)?new StackedRNNCells({cells:e.cell}):e.cell).stateSize)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");return t.cell=a,t.returnSequences=null!=e.returnSequences&&e.returnSequences,t.returnState=null!=e.returnState&&e.returnState,t.goBackwards=null!=e.goBackwards&&e.goBackwards,t._stateful=null!=e.stateful&&e.stateful,t.unroll=null!=e.unroll&&e.unroll,t.supportsMasking=!0,t.inputSpec=[new InputSpec({ndim:3})],t.stateSpec=null,t.states=null,t.numConstants=null,t.keptStates=[],t}return __extends$1(e,m),e.prototype.getStates=function(){return null==this.states?range$1(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(function(){return null}):this.states},e.prototype.setStates=function(t){this.states=t},e.prototype.computeOutputShape=function(p){isArrayOfShapes(p)&&(p=p[0]),p=p;var l=this.cell.stateSize;Array.isArray(l)||(l=[l]);var d=l[0],r;if(r=this.returnSequences?[p[0],p[1],d]:[p[0],d],this.returnState){for(var u=[],i=0,c=l,o;i<c.length;i++)o=c[i],u.push([p[0],o]);return[r].concat(u)}return r},e.prototype.computeMask=function(){throw new NotImplementedError("computeMask has not been implemented for RNN yet")},e.prototype.build=function(a){if(null!=this.numConstants)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(a)&&(a=a[0]),a=a;var o=this.stateful?a[0]:null,t=a[a.length-1];this.inputSpec[0]=new InputSpec({shape:[o,null,t]});var n=[a[0]].concat(a.slice(2)),s;if(!(this.cell.build(n),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec))this.stateSpec=s.map(function(t){return new InputSpec({shape:[null,t]})});else if(!util.arraysEqual(this.stateSpec.map(function(t){return t.shape[t.shape.length-1]}),s))throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec="+this.stateSpec+"; However cell.stateSize is "+this.cell.stateSize);this.stateful&&this.resetStates()},e.prototype.resetStates=function(p,l){var d=this;void 0===l&&(l=!1),tidy(function(){if(!d.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");var t=d.inputSpec[0].shape[0];if(null==t)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==d.states)d.states=Array.isArray(d.cell.stateSize)?d.cell.stateSize.map(function(a){return zeros([t,a])}):[zeros([t,d.cell.stateSize])];else if(null==p)dispose(d.states),null!=d.keptStates&&(dispose(d.keptStates),d.keptStates=[]),Array.isArray(d.cell.stateSize)?d.states=d.cell.stateSize.map(function(a){return zeros([t,a])}):d.states[0]=zeros([t,d.cell.stateSize]);else{if(Array.isArray(p)||(p=[p]),p.length!==d.states.length)throw new ValueError("Layer "+d.name+" expects "+d.states.length+" state(s), but it received "+p.length+" state value(s). Input received: "+p);!0===l?d.keptStates.push(d.states.slice()):dispose(d.states);for(var e=0;e<d.states.length;++e){var n=p[e],a=Array.isArray(d.cell.stateSize)?d.cell.stateSize[e]:d.cell.stateSize,r=[t,a];if(!util.arraysEqual(n.shape,r))throw new ValueError("State "+e+" is incompatible with layer "+d.name+": expected shape="+r+", received shape="+n.shape);d.states[e]=n}}d.states.forEach(function(t){return keep(t)})})},e.prototype.apply=function(e,g){var y=null==g?null:g.initialState,b=null==g?null:g.constants;null==g&&(g={});var x=standardizeArgs(e,y,b,this.numConstants);e=x.inputs,y=x.initialState,b=x.constants;var a=[],N=[];if(null!=y){g.initialState=y,a=a.concat(y),this.stateSpec=[];for(var I=0,v=y,u;I<v.length;I++)u=v[I],this.stateSpec.push(new InputSpec({shape:u.shape}));N=N.concat(this.stateSpec)}if(null!=b&&(g.constants=b,a=a.concat(b),this.numConstants=b.length),a[0]instanceof SymbolicTensor){var S=[e].concat(a),p=this.inputSpec.concat(N),h=this.inputSpec;this.inputSpec=p;var d=m.prototype.apply.call(this,S,g);return this.inputSpec=h,d}return m.prototype.apply.call(this,e,g)},e.prototype.call=function(d,m){var g=this;return tidy(function(){var e=null==m?null:m.mask,t=null==m?null:m.training,n=null==m?null:m.initialState;if(d=getExactlyOneTensor(d),null==n&&(n=g.stateful?g.states:g.getInitialState(d)),null!=e)throw new NotImplementedError("Masking is not implemented for RNN yet");var r=Array.isArray(g.cell.stateSize)?g.cell.stateSize.length:1;if(n.length!==r)throw new ValueError("RNN Layer has "+r+" state(s) but was passed "+n.length+" initial state(s).");g.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");var o={training:t},s=rnn(function(a,e){var t=g.cell.call([a].concat(e),o);return[t[0],t.slice(1)]},d,n,g.goBackwards,null,null,g.unroll,g.returnSequences),i=s[0],l=s[1],u=s[2];g.stateful&&g.resetStates(u,t);var p=g.returnSequences?l:i;return g.returnState?[p].concat(u):p})},e.prototype.getInitialState=function(a){var e=this;return tidy(function(){var t=zeros(a.shape);return t=expandDims$1(t=sum$1(t,[1,2])),Array.isArray(e.cell.stateSize)?e.cell.stateSize.map(function(a){return 1<a?tile$1(t,[1,a]):t}):1<e.cell.stateSize?[tile$1(t,[1,e.cell.stateSize])]:[t]})},Object.defineProperty(e.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0}),e.prototype.getConfig=function(){var e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);var t=this.cell.getConfig();e.cell={className:this.cell.getClassName(),config:t};var a=m.prototype.getConfig.call(this);return Object.assign(e,a),e},e.className="RNN",e}(Layer);serialization.registerClass(RNN);var RNNCell=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e}(Layer),SimpleRNNCell=function(a){function e(e){var t=a.call(this,e)||this;return t.DEFAULT_ACTIVATION="tanh",t.DEFAULT_KERNEL_INITIALIZER="glorotNormal",t.DEFAULT_RECURRENT_INITIALIZER="orthogonal",t.DEFAULT_BIAS_INITIALIZER="zeros",t.units=e.units,t.activation=getActivation(null==e.activation?t.DEFAULT_ACTIVATION:e.activation),t.useBias=null==e.useBias||e.useBias,t.kernelInitializer=getInitializer(e.kernelInitializer||t.DEFAULT_KERNEL_INITIALIZER),t.recurrentInitializer=getInitializer(e.recurrentInitializer||t.DEFAULT_RECURRENT_INITIALIZER),t.biasInitializer=getInitializer(e.biasInitializer||t.DEFAULT_BIAS_INITIALIZER),t.kernelRegularizer=getRegularizer(e.kernelRegularizer),t.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),t.biasRegularizer=getRegularizer(e.biasRegularizer),t.kernelConstraint=getConstraint(e.kernelConstraint),t.recurrentConstraint=getConstraint(e.recurrentConstraint),t.biasConstraint=getConstraint(e.biasConstraint),t.dropout=min$1([1,max$1([0,null==e.dropout?0:e.dropout])]),t.recurrentDropout=min$1([1,max$1([0,null==e.recurrentDropout?0:e.recurrentDropout])]),t.stateSize=t.units,t.dropoutMask=null,t.recurrentDropoutMask=null,t}return __extends$1(e,a),e.prototype.build=function(t){t=getExactlyOneShape(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0},e.prototype.call=function(p,d){var t=this;return tidy(function(){if(2!==(p=p).length)throw new ValueError("SimpleRNNCell expects 2 input Tensors, got "+p.length+".");var e=p[1];p=p[0];var n=null!=d.training&&d.training,a;0<t.dropout&&1>t.dropout&&null==t.dropoutMask&&(t.dropoutMask=generateDropoutMask(function(){return onesLike(p)},t.dropout,n)),0<t.recurrentDropout&&1>t.recurrentDropout&&null==t.recurrentDropoutMask&&(t.recurrentDropoutMask=generateDropoutMask(function(){return onesLike(e)},t.recurrentDropout,n));var u=t.dropoutMask,o=t.recurrentDropoutMask;a=dot$1(null==u?p:mul(p,u),t.kernel.read()),null!=t.bias&&(a=biasAdd(a,t.bias.read())),null!=o&&(e=mul(e,o));var s=add(a,dot$1(e,t.recurrentKernel.read()));return null!=t.activation&&(s=t.activation.apply(s)),[s,s]})},e.prototype.getConfig=function(){var e={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="SimpleRNNCell",e}(RNNCell);serialization.registerClass(SimpleRNNCell);var SimpleRNN=function(s){function e(e){return e.cell=new SimpleRNNCell(e),s.call(this,e)||this}return __extends$1(e,s),e.prototype.call=function(e,t){var n=this;return tidy(function(){null!=n.cell.dropoutMask&&(dispose(n.cell.dropoutMask),n.cell.dropoutMask=null),null!=n.cell.recurrentDropoutMask&&(dispose(n.cell.recurrentDropoutMask),n.cell.recurrentDropoutMask=null);var r=null==t?null:t.mask,i=null==t?null:t.training,a=null==t?null:t.initialState;return s.prototype.call.call(n,e,{mask:r,training:i,initialState:a})})},Object.defineProperty(e.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),e.prototype.getConfig=function(){var e={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},t=s.prototype.getConfig.call(this);return delete t.cell,Object.assign(e,t),e},e.className="SimpleRNN",e}(RNN);serialization.registerClass(SimpleRNN);var GRUCell=function(a){function e(e){var t=a.call(this,e)||this;return t.DEFAULT_ACTIVATION="tanh",t.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",t.DEFAULT_KERNEL_INITIALIZER="glorotNormal",t.DEFAULT_RECURRENT_INITIALIZER="orthogonal",t.DEFAULT_BIAS_INITIALIZER="zeros",t.units=e.units,t.activation=getActivation(void 0===e.activation?t.DEFAULT_ACTIVATION:e.activation),t.recurrentActivation=getActivation(void 0===e.recurrentActivation?t.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),t.useBias=null==e.useBias||e.useBias,t.kernelInitializer=getInitializer(e.kernelInitializer||t.DEFAULT_KERNEL_INITIALIZER),t.recurrentInitializer=getInitializer(e.recurrentInitializer||t.DEFAULT_RECURRENT_INITIALIZER),t.biasInitializer=getInitializer(e.biasInitializer||t.DEFAULT_BIAS_INITIALIZER),t.kernelRegularizer=getRegularizer(e.kernelRegularizer),t.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),t.biasRegularizer=getRegularizer(e.biasRegularizer),t.kernelConstraint=getConstraint(e.kernelConstraint),t.recurrentConstraint=getConstraint(e.recurrentConstraint),t.biasConstraint=getConstraint(e.biasConstraint),t.dropout=min$1([1,max$1([0,null==e.dropout?0:e.dropout])]),t.recurrentDropout=min$1([1,max$1([0,null==e.recurrentDropout?0:e.recurrentDropout])]),t.implementation=e.implementation,t.stateSize=t.units,t.dropoutMask=null,t.recurrentDropoutMask=null,t}return __extends$1(e,a),e.prototype.build=function(a){var n=(a=getExactlyOneShape(a))[a.length-1];this.kernel=this.addWeight("kernel",[n,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0},e.prototype.call=function(x,C){var t=this;return tidy(function(){if(2!==(x=x).length)throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got "+x.length+".");var e=null!=C.training&&C.training,n=x[1];x=x[0],0<t.dropout&&1>t.dropout&&null==t.dropoutMask&&(t.dropoutMask=generateDropoutMask(function(){return onesLike(x)},t.dropout,e,3)),0<t.recurrentDropout&&1>t.recurrentDropout&&null==t.recurrentDropoutMask&&(t.recurrentDropoutMask=generateDropoutMask(function(){return onesLike(n)},t.recurrentDropout,e,3));var r=t.dropoutMask,l=t.recurrentDropoutMask,u,k,T;0<t.dropout&&1>t.dropout&&(x=mul(x,r[0]));var E=dot$1(x,t.kernel.read());t.useBias&&(E=biasAdd(E,t.bias.read())),0<t.recurrentDropout&&1>t.recurrentDropout&&(n=mul(n,l[0]));var R=t.recurrentKernel.read(),p=split$1(R,[2*t.units,t.units],R.rank-1),h=p[0],d=p[1],f=dot$1(n,h),g=split$1(E,3,E.rank-1),m=g[0],y=g[1],v=g[2],b=split$1(f,2,f.rank-1),D=b[0],w=b[1];u=t.recurrentActivation.apply(add(m,D)),k=t.recurrentActivation.apply(add(y,w));var S=dot$1(mul(k,n),d);T=t.activation.apply(add(v,S));var I=add(mul(u,n),mul(add(getScalar(1),neg(u)),T));return[I,I]})},e.prototype.getConfig=function(){var e={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="GRUCell",e}(RNNCell);serialization.registerClass(GRUCell);var GRU=function(s){function e(e){return 0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new GRUCell(e),s.call(this,e)||this}return __extends$1(e,s),e.prototype.call=function(e,t){var n=this;return tidy(function(){null!=n.cell.dropoutMask&&(dispose(n.cell.dropoutMask),n.cell.dropoutMask=null),null!=n.cell.recurrentDropoutMask&&(dispose(n.cell.recurrentDropoutMask),n.cell.recurrentDropoutMask=null);var r=null==t?null:t.mask,i=null==t?null:t.training,a=null==t?null:t.initialState;return s.prototype.call.call(n,e,{mask:r,training:i,initialState:a})})},Object.defineProperty(e.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),e.prototype.getConfig=function(){var e={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},t=s.prototype.getConfig.call(this);return delete t.cell,Object.assign(e,t),e},e.fromConfig=function(a,e){return 0===e.implmentation&&(e.implementation=1),new a(e)},e.className="GRU",e}(RNN);serialization.registerClass(GRU);var LSTMCell=function(a){function e(e){var t=a.call(this,e)||this;return t.DEFAULT_ACTIVATION="tanh",t.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",t.DEFAULT_KERNEL_INITIALIZER="glorotNormal",t.DEFAULT_RECURRENT_INITIALIZER="orthogonal",t.DEFAULT_BIAS_INITIALIZER="zeros",t.units=e.units,t.activation=getActivation(void 0===e.activation?t.DEFAULT_ACTIVATION:e.activation),t.recurrentActivation=getActivation(void 0===e.recurrentActivation?t.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),t.useBias=null==e.useBias||e.useBias,t.kernelInitializer=getInitializer(e.kernelInitializer||t.DEFAULT_KERNEL_INITIALIZER),t.recurrentInitializer=getInitializer(e.recurrentInitializer||t.DEFAULT_RECURRENT_INITIALIZER),t.biasInitializer=getInitializer(e.biasInitializer||t.DEFAULT_BIAS_INITIALIZER),t.unitForgetBias=e.unitForgetBias,t.kernelRegularizer=getRegularizer(e.kernelRegularizer),t.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),t.biasRegularizer=getRegularizer(e.biasRegularizer),t.kernelConstraint=getConstraint(e.kernelConstraint),t.recurrentConstraint=getConstraint(e.recurrentConstraint),t.biasConstraint=getConstraint(e.biasConstraint),t.dropout=min$1([1,max$1([0,null==e.dropout?0:e.dropout])]),t.recurrentDropout=min$1([1,max$1([0,null==e.recurrentDropout?0:e.recurrentDropout])]),t.implementation=e.implementation,t.stateSize=[t.units,t.units],t.dropoutMask=null,t.recurrentDropoutMask=null,t}return __extends$1(e,a),e.prototype.build=function(o){var s=(o=getExactlyOneShape(o))[o.length-1],r,p;if(this.kernel=this.addWeight("kernel",[s,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){var l=this.biasInitializer,i=this.units;r=new((p=function(a){function e(){return null!==a&&a.apply(this,arguments)||this}return __extends$1(e,a),e.prototype.apply=function(){var e=l.apply([i]),t=new Ones().apply([i]),a=l.apply([2*i]);return concatAlongFirstAxis(concatAlongFirstAxis(e,t),a)},e}(Initializer)).className="CustomInit",p)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0},e.prototype.call=function(b,x){var t=this;return tidy(function(){var e=null!=x.training&&x.training;if(3!==(b=b).length)throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got "+b.length+".");var n=b[1],r=b[2];b=b[0],0<t.dropout&&1>t.dropout&&null==t.dropoutMask&&(t.dropoutMask=generateDropoutMask(function(){return onesLike(b)},t.dropout,e,4)),0<t.recurrentDropout&&1>t.recurrentDropout&&null==t.recurrentDropoutMask&&(t.recurrentDropoutMask=generateDropoutMask(function(){return onesLike(n)},t.recurrentDropout,e,4));var a=t.dropoutMask,c=t.recurrentDropoutMask,p,N,I,S;0<t.dropout&&1>t.dropout&&(b=mul(b,a[0]));var C=dot$1(b,t.kernel.read());0<t.recurrentDropout&&1>t.recurrentDropout&&(n=mul(n,c[0])),C=add(C,dot$1(n,t.recurrentKernel.read())),t.useBias&&(C=biasAdd(C,t.bias.read()));var k=split$1(C,4,C.rank-1),d=k[0],f=k[1],g=k[2],m=k[3];p=t.recurrentActivation.apply(d),N=t.recurrentActivation.apply(f),I=add(mul(N,r),mul(p,t.activation.apply(g))),S=t.recurrentActivation.apply(m);var y=mul(S,t.activation.apply(I));return[y,y,I]})},e.prototype.getConfig=function(){var e={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.className="LSTMCell",e}(RNNCell);serialization.registerClass(LSTMCell);var LSTM=function(s){function e(e){return 0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new LSTMCell(e),s.call(this,e)||this}return __extends$1(e,s),e.prototype.call=function(e,t){var n=this;return tidy(function(){null!=n.cell.dropoutMask&&(dispose(n.cell.dropoutMask),n.cell.dropoutMask=null),null!=n.cell.recurrentDropoutMask&&(dispose(n.cell.recurrentDropoutMask),n.cell.recurrentDropoutMask=null);var r=null==t?null:t.mask,i=null==t?null:t.training,a=null==t?null:t.initialState;return s.prototype.call.call(n,e,{mask:r,training:i,initialState:a})})},Object.defineProperty(e.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"unitForgetBias",{get:function(){return this.cell.unitForgetBias},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),e.prototype.getConfig=function(){var e={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},t=s.prototype.getConfig.call(this);return delete t.cell,Object.assign(e,t),e},e.fromConfig=function(a,e){return 0===e.implmentation&&(e.implementation=1),new a(e)},e.className="LSTM",e}(RNN);serialization.registerClass(LSTM);var StackedRNNCells=function(s){function e(e){var t=s.call(this,e)||this;return t.cells=e.cells,t}return __extends$1(e,s),Object.defineProperty(e.prototype,"stateSize",{get:function(){for(var a=[],e=0,o=this.cells.slice().reverse(),n;e<o.length;e++)n=o[e],Array.isArray(n.stateSize)?a.push.apply(a,n.stateSize):a.push(n.stateSize);return a},enumerable:!0,configurable:!0}),e.prototype.call=function(p,a){var t=this;return tidy(function(){for(var e=(p=p).slice(1),n=[],i=0,m=t.cells.slice().reverse(),o;i<m.length;i++)o=m[i],Array.isArray(o.stateSize)?n.push(e.splice(0,o.stateSize.length)):n.push(e.splice(0,1));n.reverse();for(var g=[],u=0,f;u<t.cells.length;++u)o=t.cells[u],e=n[u],f=0==u?[p[0]].concat(e):[f[0]].concat(e),f=o.call(f,a),g.push(f.slice(1));e=[];for(var y=0,b=g.slice().reverse(),h;y<b.length;y++)h=b[y],e.push.apply(e,h);return[f[0]].concat(e)})},e.prototype.build=function(a){var o;isArrayOfShapes(a)&&(a=a[0]),a=a;for(var s=0,p=this.cells,r;s<p.length;s++)r=p[s],r.build(a),o=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,a=[a[0],o];this.built=!0},e.prototype.getConfig=function(){for(var e=[],t=0,p=this.cells,r;t<p.length;t++)r=p[t],e.push({className:this.getClassName(),config:r.getConfig()});var l={cells:e},a=s.prototype.getConfig.call(this);return Object.assign(l,a),l},e.fromConfig=function(s,e,t){void 0===t&&(t={});for(var p=[],r=0,l=e.cells,a;r<l.length;r++)a=l[r],p.push(deserialize(a,t));return new s({cells:p})},Object.defineProperty(e.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var a=[],e=0,o=this.cells,n;e<o.length;e++)n=o[e],a.push.apply(a,n.trainableWeights);return a},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nonTrainableWeights",{get:function(){for(var s=[],e=0,p=this.cells,n;e<p.length;e++)n=p[e],s.push.apply(s,n.nonTrainableWeights);if(!this.trainable){for(var l=[],i=0,d=this.cells;i<d.length;i++)n=d[i],l.push.apply(l,n.trainableWeights);return l.concat(s)}return s},enumerable:!0,configurable:!0}),e.prototype.getWeights=function(){for(var a=[],e=0,o=this.cells,n;e<o.length;e++)n=o[e],a.push.apply(a,n.weights);return batchGetValue(a)},e.prototype.setWeights=function(p){for(var e=[],t=0,l=this.cells;t<l.length;t++)for(var r=l[t],i=r.weights.length,a=p.splice(i),o=0;o<r.weights.length;++o)e.push([r.weights[o],a[o]]);batchSetValue(e)},e.className="StackedRNNCells",e}(RNNCell);serialization.registerClass(StackedRNNCells);var Wrapper=function(a){function e(e){var t=a.call(this,e)||this;return t.layer=e.layer,t}return __extends$1(e,a),e.prototype.build=function(){this.built=!0},Object.defineProperty(e.prototype,"trainable",{get:function(){return null!=this.layer&&this.layer.trainable},set:function(t){null!=this.layer&&(this.layer.trainable=t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"updates",{get:function(){return this.layer._updates},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0}),e.prototype.getWeights=function(){return this.layer.getWeights()},e.prototype.setWeights=function(t){this.layer.setWeights(t)},e.prototype.getConfig=function(){var e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=a.prototype.getConfig.call(this);return Object.assign(e,t),e},e.fromConfig=function(a,e,t){void 0===t&&(t={});var o=deserialize(e.layer,t);delete e.layer;var r={layer:o};return Object.assign(r,e),new a(r)},e}(Layer),TimeDistributed=function(a){function e(e){var t=a.call(this,e)||this;return t.supportsMasking=!0,t}return __extends$1(e,a),e.prototype.build=function(e){if(3>(e=getExactlyOneShape(e)).length)throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(e));this.inputSpec=[{shape:e}];var r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),a.prototype.build.call(this,e)},e.prototype.computeOutputShape=function(a){var o=[(a=getExactlyOneShape(a))[0]].concat(a.slice(2)),t=this.layer.computeOutputShape(o),n=a[1];return[t[0],n].concat(t.slice(1))},e.prototype.call=function(a,r){var t=this;return tidy(function(){return rnn(function(a){return[getExactlyOneTensor(t.layer.call(a,r)),[]]},a=getExactlyOneTensor(a),[],!1,null,null,!1,!0)[1]})},e.className="TimeDistributed",e}(Wrapper);serialization.registerClass(TimeDistributed);var VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"],Bidirectional=function(y){function e(e){var t=y.call(this,e)||this,a=e.layer.getConfig();if(t.forwardLayer=deserialize({className:e.layer.getClassName(),config:a}),a.goBackwards=!0!==a.goBackwards,t.backwardLayer=deserialize({className:e.layer.getClassName(),config:a}),t.forwardLayer.name="forward_"+t.forwardLayer.name,t.backwardLayer.name="backward_"+t.backwardLayer.name,checkBidirectionalMergeMode(e.mergeMode),t.mergeMode=e.mergeMode,e.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");return t._stateful=e.layer.stateful,t.returnSequences=e.layer.returnSequences,t.returnState=e.layer.returnState,t.supportsMasking=!0,t._trainable=!0,t.inputSpec=e.layer.inputSpec,t.numConstants=null,t}return __extends$1(e,y),Object.defineProperty(e.prototype,"trainable",{get:function(){return this._trainable},set:function(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)},enumerable:!0,configurable:!0}),e.prototype.getWeights=function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())},e.prototype.setWeights=function(a){var e=a.length,t=_Mathfloor(e/2);this.forwardLayer.setWeights(a.slice(0,t)),this.backwardLayer.setWeights(a.slice(t))},e.prototype.computeOutputShape=function(a){var e=this.forwardLayer.computeOutputShape(a),o,s,p;return Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e,this.returnState?(p=e.slice(1),o=e[0]):o=e[0],o=o,"concat"===this.mergeMode?(o[o.length-1]*=2,s=[o]):s=null==this.mergeMode?[o,o.slice()]:[o],this.returnState?null==this.mergeMode?s.concat(p).concat(p.slice()):[o].concat(p).concat(p.slice()):singletonOrArray(s)},e.prototype.apply=function(e,b){var x=null==b?null:b.initialState,N=null==b?null:b.constants;null==b&&(b={});var I=standardizeArgs(e,x,N,this.numConstants);if(e=I.inputs,x=I.initialState,N=I.constants,Array.isArray(e)&&(x=e.slice(1),e=e[0]),(null==x||0===x.length)&&null==N)return y.prototype.apply.call(this,e,b);var a=[],o=[];if(null!=x){var s=x.length;if(0<s%2)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");b.initialState=x,a.push.apply(a,x);var l=x.map(function(t){return new InputSpec({shape:t.shape})});this.forwardLayer.stateSpec=l.slice(0,s/2),this.backwardLayer.stateSpec=l.slice(s/2),o.push.apply(o,l)}if(null!=N)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");for(var u=a[0]instanceof SymbolicTensor,c=0,v=a;c<v.length;c++)if(v[c]instanceof SymbolicTensor!=u)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){var h=[e].concat(a),d=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=d;var g=y.prototype.apply.call(this,h,b);return this.inputSpec=f,g}return y.prototype.apply.call(this,e,b)},e.prototype.call=function(p,e){var t=this;return tidy(function(){if(null!=e.mask)throw new NotImplementedError("The support for masking is not implemented for Bidirectional layers yet.");var n=e.initialState,s,d,c,m;if(null==n)s=t.forwardLayer.call(p,e),d=t.backwardLayer.call(p,e);else{var h=n.slice(0,n.length/2),l=n.slice(n.length/2);s=t.forwardLayer.call(p,Object.assign(e,{initialState:h})),d=t.backwardLayer.call(p,Object.assign(e,{initialState:l}))}return t.returnState&&(Array.isArray(s)&&(c=s.slice(1).concat(d.slice(1))),s=s[0],d=d[0]),t.returnSequences&&(d=reverse(d,1)),"concat"===t.mergeMode?m=concatenate([s,d]):"sum"===t.mergeMode?m=add(s,d):"ave"===t.mergeMode?m=mul(getScalar(.5),add(s,d)):"mul"===t.mergeMode?m=mul(s,d):null==t.mergeMode&&(m=[s,d]),t.returnState?null==t.mergeMode?m.concat(c):[m].concat(c):m})},e.prototype.resetStates=function(){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()},e.prototype.build=function(a){var e=this;nameScope(this.forwardLayer.name,function(){e.forwardLayer.build(a)}),nameScope(this.backwardLayer.name,function(){e.backwardLayer.build(a)}),this.built=!0},Object.defineProperty(e.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},enumerable:!0,configurable:!0}),e.prototype.getConfig=function(){var e={mergeMode:this.mergeMode},t=y.prototype.getConfig.call(this);return Object.assign(e,t),e},e.fromConfig=function(a,e){var t=deserialize(e.layer);if(delete e.layer,null!=e.numConstants)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");var n=e;return n.layer=t,new a(n)},e.className="Bidirectional",e}(Wrapper);serialization.registerClass(Bidirectional);var globalMaxPool1d=globalMaxPooling1d,globalMaxPool2d=globalMaxPooling2d,maxPool1d=maxPooling1d,maxPool2d=maxPooling2d,exports_layers=Object.freeze({inputLayer:inputLayer,elu:elu$2,reLU:reLU,leakyReLU:leakyReLU,softmax:softmax$1,thresholdedReLU:thresholdedReLU,conv1d:conv1d$2,conv2d:conv2d$2,conv2dTranspose:conv2dTranspose$1,separableConv2d:separableConv2d$1,cropping2D:cropping2D,upSampling2d:upSampling2d,depthwiseConv2d:depthwiseConv2d$2,activation:activation,dense:dense,dropout:dropout$1,flatten:flatten$1$1,repeatVector:repeatVector,reshape:reshape$1,permute:permute,embedding:embedding,add:add$2,average:average$1,concatenate:concatenate$2,maximum:maximum$2,minimum:minimum$2,multiply:multiply$1,dot:dot$1$1,batchNormalization:batchNormalization$1$1,zeroPadding2d:zeroPadding2d,averagePooling1d:averagePooling1d,avgPool1d:avgPool1d,avgPooling1d:avgPooling1d,averagePooling2d:averagePooling2d,avgPool2d:avgPool2d,avgPooling2d:avgPooling2d,globalAveragePooling1d:globalAveragePooling1d,globalAveragePooling2d:globalAveragePooling2d,globalMaxPooling1d:globalMaxPooling1d,globalMaxPooling2d:globalMaxPooling2d,maxPooling1d:maxPooling1d,maxPooling2d:maxPooling2d,gru:gru,gruCell:gruCell,lstm:lstm,lstmCell:lstmCell,simpleRNN:simpleRNN,simpleRNNCell:simpleRNNCell,rnn:rnn$1,stackedRNNCells:stackedRNNCells,bidirectional:bidirectional,timeDistributed:timeDistributed,globalMaxPool1d:globalMaxPool1d,globalMaxPool2d:globalMaxPool2d,maxPool1d:maxPool1d,maxPool2d:maxPool2d,Layer:Layer,RNN:RNN,RNNCell:RNNCell,input:input}),exports_models=Object.freeze({modelFromJSON:modelFromJSON}),exports_metrics=Object.freeze({binaryAccuracy:binaryAccuracy$1,binaryCrossentropy:binaryCrossentropy$2,categoricalAccuracy:categoricalAccuracy$1,categoricalCrossentropy:categoricalCrossentropy$2,precision:precision$1,recall:recall$1,cosineProximity:cosineProximity$1,meanAbsoluteError:meanAbsoluteError$1,meanAbsolutePercentageError:meanAbsolutePercentageError$1,MAPE:MAPE$2,mape:mape$2,meanSquaredError:meanSquaredError$1$1,MSE:MSE$2,mse:mse$2}),exports_regularizers=Object.freeze({l1l2:l1l2,l1:l1$1,l2:l2$1}),Callback=function(a){function e(){var e=null!==a&&a.apply(this,arguments)||this;return e.model=null,e}return __extends$1(e,a),e.prototype.setModel=function(t){if(!(t instanceof Model))throw new Error("model must be a Model, not some other Container");this.model=t},e}(BaseCallback),__assign$2=Object.assign||function(o){for(var e=1,s=arguments.length,r;e<s;e++)for(var i in r=arguments[e])Object.prototype.hasOwnProperty.call(r,i)&&(o[i]=r[i]);return o},commonjsGlobal$1="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?{}:self:global:window,aspromise=asPromise,base64_1=createCommonjsModule$1(function(s,e){var t=e;t.length=function(n){var e=n.length;if(!e)return 0;for(var r=0;1<--e%4&&"="===n.charAt(e);)++r;return _Mathceil(3*n.length)/4-r};for(var l=Array(64),i=Array(123),a=0;64>a;)i[l[a]=26>a?a+65:52>a?a+71:62>a?a-4:43|a-59]=a++;t.encode=function(r,e,d){for(var a=null,u=[],s=0,c=0,h,g;e<d;)g=r[e++],0==c?(u[s++]=l[g>>2],h=(3&g)<<4,c=1):1==c?(u[s++]=l[h|g>>4],h=(15&g)<<2,c=2):2==c?(u[s++]=l[h|g>>6],u[s++]=l[63&g],c=0):void 0,8191<s&&((a||(a=[])).push(_StringfromCharCode.apply(String,u)),s=0);return c&&(u[s++]=l[h],u[s++]=61,1==c&&(u[s++]=61)),a?(s&&a.push(_StringfromCharCode.apply(String,u.slice(0,s))),a.join("")):_StringfromCharCode.apply(String,u.slice(0,s))},t.decode=function(n,e,t){for(var l=t,o=0,d=0,u,c;d<n.length&&(c=n.charCodeAt(d++),!(61===c&&1<o));){if(void 0===(c=i[c]))throw Error("invalid encoding");0==o?(u=c,o=1):1==o?(e[t++]=u<<2|(48&c)>>4,u=c,o=2):2==o?(e[t++]=(15&u)<<4|(60&c)>>2,u=c,o=3):3==o?(e[t++]=(3&u)<<6|c,o=0):void 0}if(1==o)throw Error("invalid encoding");return t-l},t.test=function(t){return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}}),eventemitter=EventEmitter;EventEmitter.prototype.on=function(n,e,t){return(this._listeners[n]||(this._listeners[n]=[])).push({fn:e,ctx:t||this}),this},EventEmitter.prototype.off=function(n,e){if(void 0===n)this._listeners={};else if(void 0===e)this._listeners[n]=[];else for(var t=this._listeners[n],a=0;a<t.length;)t[a].fn===e?t.splice(a,1):++a;return this},EventEmitter.prototype.emit=function(n){var e=this._listeners[n];if(e){for(var t=[],a=1;a<arguments.length;)t.push(arguments[a++]);for(a=0;a<e.length;)e[a].fn.apply(e[a++].ctx,t)}return this};var float_1=factory(factory),inquire_1=inquire,utf8_1=createCommonjsModule$1(function(n,e){var t=e;t.length=function(n){for(var e=0,o=0,s=0;s<n.length;++s)128>(o=n.charCodeAt(s))?e+=1:2048>o?e+=2:55296==(64512&o)&&56320==(64512&n.charCodeAt(s+1))?(++s,e+=4):e+=3;return e},t.read=function(i,e,p){if(1>p-e)return"";for(var a=null,l=[],o=0,d;e<p;)128>(d=i[e++])?l[o++]=d:191<d&&224>d?l[o++]=(31&d)<<6|63&i[e++]:239<d&&365>d?(d=((7&d)<<18|(63&i[e++])<<12|(63&i[e++])<<6|63&i[e++])-65536,l[o++]=55296+(d>>10),l[o++]=56320+(1023&d)):l[o++]=(15&d)<<12|(63&i[e++])<<6|63&i[e++],8191<o&&((a||(a=[])).push(_StringfromCharCode.apply(String,l)),o=0);return a?(o&&a.push(_StringfromCharCode.apply(String,l.slice(0,o))),a.join("")):_StringfromCharCode.apply(String,l.slice(0,o))},t.write=function(i,e,t){for(var p=t,o=0,l,d;o<i.length;++o)128>(l=i.charCodeAt(o))?e[t++]=l:2048>l?(e[t++]=192|l>>6,e[t++]=128|63&l):55296==(64512&l)&&56320==(64512&(d=i.charCodeAt(o+1)))?(l=65536+((1023&l)<<10)+(1023&d),++o,e[t++]=240|l>>18,e[t++]=128|63&l>>12,e[t++]=128|63&l>>6,e[t++]=128|63&l):(e[t++]=224|l>>12,e[t++]=128|63&l>>6,e[t++]=128|63&l);return t-p}}),pool_1=pool$1,longbits=LongBits,zero=LongBits.zero=new LongBits(0,0);zero.toNumber=function(){return 0},zero.zzEncode=zero.zzDecode=function(){return this},zero.length=function(){return 1};var zeroHash=LongBits.zeroHash="\0\0\0\0\0\0\0\0";LongBits.fromNumber=function(n){if(0===n)return zero;var o=0>n;o&&(n=-n);var t=n>>>0,s=(n-t)/4294967296>>>0;return o&&(s=~s>>>0,t=~t>>>0,4294967295<++t&&(t=0,4294967295<++s&&(s=0))),new LongBits(t,s)},LongBits.from=function(t){if("number"==typeof t)return LongBits.fromNumber(t);if(minimal.isString(t)){if(!minimal.Long)return LongBits.fromNumber(parseInt(t,10));t=minimal.Long.fromString(t)}return t.low||t.high?new LongBits(t.low>>>0,t.high>>>0):zero},LongBits.prototype.toNumber=function(n){if(!n&&this.hi>>>31){var e=1+~this.lo>>>0,t=~this.hi>>>0;return e||(t=t+1>>>0),-(e+4294967296*t)}return this.lo+4294967296*this.hi},LongBits.prototype.toLong=function(t){return minimal.Long?new minimal.Long(0|this.lo,0|this.hi,!!t):{low:0|this.lo,high:0|this.hi,unsigned:!!t}};var charCodeAt=String.prototype.charCodeAt;LongBits.fromHash=function(t){return t===zeroHash?zero:new LongBits((charCodeAt.call(t,0)|charCodeAt.call(t,1)<<8|charCodeAt.call(t,2)<<16|charCodeAt.call(t,3)<<24)>>>0,(charCodeAt.call(t,4)|charCodeAt.call(t,5)<<8|charCodeAt.call(t,6)<<16|charCodeAt.call(t,7)<<24)>>>0)},LongBits.prototype.toHash=function(){return _StringfromCharCode(255&this.lo,255&this.lo>>>8,255&this.lo>>>16,this.lo>>>24,255&this.hi,255&this.hi>>>8,255&this.hi>>>16,this.hi>>>24)},LongBits.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},LongBits.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},LongBits.prototype.length=function(){var n=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return 0==t?0==e?16384>n?128>n?1:2:2097152>n?3:4:16384>e?128>e?5:6:2097152>e?7:8:128>t?9:10};var minimal=createCommonjsModule$1(function(o,e){function s(o,e,t){for(var a=Object.keys(e),r=0;r<a.length;++r)void 0!==o[a[r]]&&t||(o[a[r]]=e[a[r]]);return o}function t(a){function n(t,e){return this instanceof n?void(Object.defineProperty(this,"message",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,n):Object.defineProperty(this,"stack",{value:new Error().stack||""}),e&&s(this,e)):new n(t,e)}return(n.prototype=Object.create(Error.prototype)).constructor=n,Object.defineProperty(n.prototype,"name",{get:function(){return a}}),n.prototype.toString=function(){return this.name+": "+this.message},n}var n=e;n.asPromise=aspromise,n.base64=base64_1,n.EventEmitter=eventemitter,n.float=float_1,n.inquire=inquire_1,n.utf8=utf8_1,n.pool=pool_1,n.LongBits=longbits,n.emptyArray=Object.freeze?Object.freeze([]):[],n.emptyObject=Object.freeze?Object.freeze({}):{},n.isNode=!!(commonjsGlobal$1.process&&commonjsGlobal$1.process.versions&&commonjsGlobal$1.process.versions.node),n.isInteger=_NumberisInteger||function(t){return"number"==typeof t&&isFinite(t)&&_Mathfloor(t)===t},n.isString=function(t){return"string"==typeof t||t instanceof String},n.isObject=function(t){return t&&"object"==typeof t},n.isset=n.isSet=function(n,e){var t=n[e];return null!=t&&n.hasOwnProperty(e)&&("object"!=typeof t||0<(Array.isArray(t)?t.length:Object.keys(t).length))},n.Buffer=function(){try{var t=n.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),n._Buffer_from=null,n._Buffer_allocUnsafe=null,n.newBuffer=function(t){return"number"==typeof t?n.Buffer?n._Buffer_allocUnsafe(t):new n.Array(t):n.Buffer?n._Buffer_from(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},n.Array="undefined"==typeof Uint8Array?Array:Uint8Array,n.Long=commonjsGlobal$1.dcodeIO&&commonjsGlobal$1.dcodeIO.Long||n.inquire("long"),n.key2Re=/^true|false|0|1$/,n.key32Re=/^-?(?:0|[1-9][0-9]*)$/,n.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,n.longToHash=function(t){return t?n.LongBits.from(t).toHash():n.LongBits.zeroHash},n.longFromHash=function(a,e){var t=n.LongBits.fromHash(a);return n.Long?n.Long.fromBits(t.lo,t.hi,e):t.toNumber(!!e)},n.merge=s,n.lcFirst=function(t){return t.charAt(0).toLowerCase()+t.substring(1)},n.newError=t,n.ProtocolError=t("ProtocolError"),n.oneOfGetter=function(n){for(var r={},e=0;e<n.length;++e)r[n[e]]=1;return function(){for(var t=Object.keys(this),e=t.length-1;-1<e;--e)if(1===r[t[e]]&&void 0!==this[t[e]]&&null!==this[t[e]])return t[e]}},n.oneOfSetter=function(n){return function(e){for(var t=0;t<n.length;++t)n[t]!==e&&delete this[n[t]]}},n.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},n._configure=function(){var r=n.Buffer;r?(n._Buffer_from=r.from!==Uint8Array.from&&r.from||function(e,t){return new r(e,t)},n._Buffer_allocUnsafe=r.allocUnsafe||function(e){return new r(e)}):n._Buffer_from=n._Buffer_allocUnsafe=null}}),writer=Writer,LongBits$1=minimal.LongBits,base64=minimal.base64,utf8=minimal.utf8,BufferWriter;Writer.create=minimal.Buffer?function(){return(Writer.create=function(){return new BufferWriter})()}:function(){return new Writer},Writer.alloc=function(t){return new minimal.Array(t)},minimal.Array!==Array&&(Writer.alloc=minimal.pool(Writer.alloc,minimal.Array.prototype.subarray)),Writer.prototype._push=function(n,e,t){return this.tail=this.tail.next=new Op(n,e,t),this.len+=e,this},VarintOp.prototype=Object.create(Op.prototype),VarintOp.prototype.fn=writeVarint32,Writer.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new VarintOp(128>(t>>>=0)?1:16384>t?2:2097152>t?3:268435456>t?4:5,t)).len,this},Writer.prototype.int32=function(t){return 0>t?this._push(writeVarint64,10,LongBits$1.fromNumber(t)):this.uint32(t)},Writer.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},Writer.prototype.uint64=function(a){var e=LongBits$1.from(a);return this._push(writeVarint64,e.length(),e)},Writer.prototype.int64=Writer.prototype.uint64,Writer.prototype.sint64=function(a){var e=LongBits$1.from(a).zzEncode();return this._push(writeVarint64,e.length(),e)},Writer.prototype.bool=function(t){return this._push(writeByte,1,t?1:0)},Writer.prototype.fixed32=function(t){return this._push(writeFixed32,4,t>>>0)},Writer.prototype.sfixed32=Writer.prototype.fixed32,Writer.prototype.fixed64=function(a){var e=LongBits$1.from(a);return this._push(writeFixed32,4,e.lo)._push(writeFixed32,4,e.hi)},Writer.prototype.sfixed64=Writer.prototype.fixed64,Writer.prototype.float=function(t){return this._push(minimal.float.writeFloatLE,4,t)},Writer.prototype.double=function(t){return this._push(minimal.float.writeDoubleLE,8,t)};var writeBytes=minimal.Array.prototype.set?function(n,e,t){e.set(n,t)}:function(n,e,t){for(var a=0;a<n.length;++a)e[t+a]=n[a]};Writer.prototype.bytes=function(n){var r=n.length>>>0;if(!r)return this._push(writeByte,1,0);if(minimal.isString(n)){var o=Writer.alloc(r=base64.length(n));base64.decode(n,o,0),n=o}return this.uint32(r)._push(writeBytes,r,n)},Writer.prototype.string=function(a){var e=utf8.length(a);return e?this.uint32(e)._push(utf8.write,e,a):this._push(writeByte,1,0)},Writer.prototype.fork=function(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this},Writer.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this},Writer.prototype.ldelim=function(){var n=this.head,e=this.tail,t=this.len;return this.reset().uint32(t),t&&(this.tail.next=n.next,this.tail=e,this.len+=t),this},Writer.prototype.finish=function(){for(var n=this.head.next,r=this.constructor.alloc(this.len),t=0;n;)n.fn(n.val,r,t),t+=n.len,n=n.next;return r},Writer._configure=function(t){BufferWriter=t};var writer_buffer=BufferWriter$1;(BufferWriter$1.prototype=Object.create(writer.prototype)).constructor=BufferWriter$1;var Buffer$1=minimal.Buffer;BufferWriter$1.alloc=function(t){return(BufferWriter$1.alloc=minimal._Buffer_allocUnsafe)(t)};var writeBytesBuffer=Buffer$1&&Buffer$1.prototype instanceof Uint8Array&&"set"===Buffer$1.prototype.set.name?function(n,e,t){e.set(n,t)}:function(n,e,t){if(n.copy)n.copy(e,t,0,n.length);else for(var o=0;o<n.length;)e[t++]=n[o++]};BufferWriter$1.prototype.bytes=function(a){minimal.isString(a)&&(a=minimal._Buffer_from(a,"base64"));var n=a.length>>>0;return this.uint32(n),n&&this._push(writeBytesBuffer,n,a),this},BufferWriter$1.prototype.string=function(a){var e=Buffer$1.byteLength(a);return this.uint32(e),e&&this._push(writeStringBuffer,e,a),this};var reader=Reader,LongBits$2=minimal.LongBits,utf8$1=minimal.utf8,create_array="undefined"==typeof Uint8Array?function(t){if(Array.isArray(t))return new Reader(t);throw Error("illegal buffer")}:function(t){if(t instanceof Uint8Array||Array.isArray(t))return new Reader(t);throw Error("illegal buffer")},BufferReader;Reader.create=minimal.Buffer?function(t){return(Reader.create=function(t){return minimal.Buffer.isBuffer(t)?new BufferReader(t):create_array(t)})(t)}:create_array,Reader.prototype._slice=minimal.Array.prototype.subarray||minimal.Array.prototype.slice,Reader.prototype.uint32=function(){var t=4294967295;return function(){if(t=(127&this.buf[this.pos])>>>0,128>this.buf[this.pos++])return t;if(t=(t|(127&this.buf[this.pos])<<7)>>>0,128>this.buf[this.pos++])return t;if(t=(t|(127&this.buf[this.pos])<<14)>>>0,128>this.buf[this.pos++])return t;if(t=(t|(127&this.buf[this.pos])<<21)>>>0,128>this.buf[this.pos++])return t;if(t=(t|(15&this.buf[this.pos])<<28)>>>0,128>this.buf[this.pos++])return t;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return t}}(),Reader.prototype.int32=function(){return 0|this.uint32()},Reader.prototype.sint32=function(){var t=this.uint32();return 0|t>>>1^-(1&t)},Reader.prototype.bool=function(){return 0!==this.uint32()},Reader.prototype.fixed32=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)},Reader.prototype.sfixed32=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return 0|readFixed32_end(this.buf,this.pos+=4)},Reader.prototype.float=function(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var t=minimal.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},Reader.prototype.double=function(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var t=minimal.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},Reader.prototype.bytes=function(){var n=this.uint32(),e=this.pos,t=this.pos+n;if(t>this.len)throw indexOutOfRange(this,n);return this.pos+=n,Array.isArray(this.buf)?this.buf.slice(e,t):e===t?new this.buf.constructor(0):this._slice.call(this.buf,e,t)},Reader.prototype.string=function(){var t=this.bytes();return utf8$1.read(t,0,t.length)},Reader.prototype.skip=function(t){if("number"==typeof t){if(this.pos+t>this.len)throw indexOutOfRange(this,t);this.pos+=t}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(128&this.buf[this.pos++]);return this},Reader.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;;){if(4==(t=7&this.uint32()))break;this.skipType(t)}break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos);}return this},Reader._configure=function(a){BufferReader=a;var e=minimal.Long?"toLong":"toNumber";minimal.merge(Reader.prototype,{int64:function(){return readLongVarint.call(this)[e](!1)},uint64:function(){return readLongVarint.call(this)[e](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[e](!1)},fixed64:function(){return readFixed64.call(this)[e](!0)},sfixed64:function(){return readFixed64.call(this)[e](!1)}})};var reader_buffer=BufferReader$1;(BufferReader$1.prototype=Object.create(reader.prototype)).constructor=BufferReader$1,minimal.Buffer&&(BufferReader$1.prototype._slice=minimal.Buffer.prototype.slice),BufferReader$1.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice(this.pos,this.pos=_Mathmin(this.pos+t,this.len))};var service=Service;(Service.prototype=Object.create(minimal.EventEmitter.prototype)).constructor=Service,Service.prototype.rpcCall=function i(p,e,t,a,n){if(!a)throw TypeError("request must be specified");var r=this;if(!n)return minimal.asPromise(i,r,p,e,t,a);if(r.rpcImpl)try{return r.rpcImpl(p,e[r.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(o,e){if(o)return r.emit("error",o,p),n(o);if(null!==e){if(!(e instanceof t))try{e=t[r.responseDelimited?"decodeDelimited":"decode"](e)}catch(t){return r.emit("error",t,p),n(t)}return r.emit("data",e,p),n(null,e)}r.end(!0)})}catch(t){return r.emit("error",t,p),void setTimeout(function(){n(t)},0)}else setTimeout(function(){n(Error("already ended"))},0)},Service.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this};var rpc_1=createCommonjsModule$1(function(a,e){e.Service=service}),roots={},indexMinimal=createCommonjsModule$1(function(n,e){function t(){r.Reader._configure(r.BufferReader),r.util._configure()}var r=e;r.build="minimal",r.Writer=writer,r.BufferWriter=writer_buffer,r.Reader=reader,r.BufferReader=reader_buffer,r.util=minimal,r.rpc=rpc_1,r.roots=roots,r.configure=t,r.Writer._configure(r.BufferWriter),t()}),minimal$1=indexMinimal,minimal_1=minimal$1.roots,minimal_2=minimal$1.Reader,minimal_3=minimal$1.util,$Reader=minimal$1.Reader,$util=minimal$1.util,$root=minimal$1.roots.default||(minimal$1.roots.default={});$root.tensorflow=function(){var n={},a,r;return n.Any=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.typeUrl="",t.prototype.value=$util.newBuffer([]),t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.Any,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.typeUrl=o.string();break;case 2:a.value=o.bytes();break;default:o.skipType(7&r);}return a},t}(),n.DataType=(a={},(r=Object.create(a))[a[0]="DT_INVALID"]=0,r[a[1]="DT_FLOAT"]=1,r[a[2]="DT_DOUBLE"]=2,r[a[3]="DT_INT32"]=3,r[a[4]="DT_UINT8"]=4,r[a[5]="DT_INT16"]=5,r[a[6]="DT_INT8"]=6,r[a[7]="DT_STRING"]=7,r[a[8]="DT_COMPLEX64"]=8,r[a[9]="DT_INT64"]=9,r[a[10]="DT_BOOL"]=10,r[a[11]="DT_QINT8"]=11,r[a[12]="DT_QUINT8"]=12,r[a[13]="DT_QINT32"]=13,r[a[14]="DT_BFLOAT16"]=14,r[a[101]="DT_FLOAT_REF"]=101,r[a[102]="DT_DOUBLE_REF"]=102,r[a[103]="DT_INT32_REF"]=103,r[a[104]="DT_UINT8_REF"]=104,r[a[105]="DT_INT16_REF"]=105,r[a[106]="DT_INT8_REF"]=106,r[a[107]="DT_STRING_REF"]=107,r[a[108]="DT_COMPLEX64_REF"]=108,r[a[109]="DT_INT64_REF"]=109,r[a[110]="DT_BOOL_REF"]=110,r[a[111]="DT_QINT8_REF"]=111,r[a[112]="DT_QUINT8_REF"]=112,r[a[113]="DT_QINT32_REF"]=113,r[a[114]="DT_BFLOAT16_REF"]=114,r),n.TensorShape=function(){function t(n){if(this.dim=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.dim=$util.emptyArray,t.prototype.unknownRank=!1,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.TensorShape,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 2:a.dim&&a.dim.length||(a.dim=[]),a.dim.push($root.tensorflow.TensorShape.Dim.decode(o,o.uint32()));break;case 3:a.unknownRank=o.bool();break;default:o.skipType(7&r);}return a},t.Dim=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.size=$util.Long?$util.Long.fromBits(0,0,!1):0,t.prototype.name="",t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.TensorShape.Dim,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.size=o.int64();break;case 2:a.name=o.string();break;default:o.skipType(7&r);}return a},t}(),t}(),n.Tensor=function(){function t(n){if(this.floatVal=[],this.doubleVal=[],this.intVal=[],this.stringVal=[],this.scomplexVal=[],this.int64Val=[],this.boolVal=[],this.uint32Val=[],this.uint64Val=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.dtype=0,t.prototype.tensorShape=null,t.prototype.versionNumber=0,t.prototype.tensorContent=$util.newBuffer([]),t.prototype.floatVal=$util.emptyArray,t.prototype.doubleVal=$util.emptyArray,t.prototype.intVal=$util.emptyArray,t.prototype.stringVal=$util.emptyArray,t.prototype.scomplexVal=$util.emptyArray,t.prototype.int64Val=$util.emptyArray,t.prototype.boolVal=$util.emptyArray,t.prototype.uint32Val=$util.emptyArray,t.prototype.uint64Val=$util.emptyArray,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,a=new $root.tensorflow.Tensor,r;s.pos<t;)switch(r=s.uint32(),r>>>3){case 1:a.dtype=s.int32();break;case 2:a.tensorShape=$root.tensorflow.TensorShape.decode(s,s.uint32());break;case 3:a.versionNumber=s.int32();break;case 4:a.tensorContent=s.bytes();break;case 5:if(a.floatVal&&a.floatVal.length||(a.floatVal=[]),2==(7&r))for(var p=s.uint32()+s.pos;s.pos<p;)a.floatVal.push(s.float());else a.floatVal.push(s.float());break;case 6:if(a.doubleVal&&a.doubleVal.length||(a.doubleVal=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.doubleVal.push(s.double());else a.doubleVal.push(s.double());break;case 7:if(a.intVal&&a.intVal.length||(a.intVal=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.intVal.push(s.int32());else a.intVal.push(s.int32());break;case 8:a.stringVal&&a.stringVal.length||(a.stringVal=[]),a.stringVal.push(s.bytes());break;case 9:if(a.scomplexVal&&a.scomplexVal.length||(a.scomplexVal=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.scomplexVal.push(s.float());else a.scomplexVal.push(s.float());break;case 10:if(a.int64Val&&a.int64Val.length||(a.int64Val=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.int64Val.push(s.int64());else a.int64Val.push(s.int64());break;case 11:if(a.boolVal&&a.boolVal.length||(a.boolVal=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.boolVal.push(s.bool());else a.boolVal.push(s.bool());break;case 16:if(a.uint32Val&&a.uint32Val.length||(a.uint32Val=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.uint32Val.push(s.uint32());else a.uint32Val.push(s.uint32());break;case 17:if(a.uint64Val&&a.uint64Val.length||(a.uint64Val=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.uint64Val.push(s.uint64());else a.uint64Val.push(s.uint64());break;default:s.skipType(7&r);}return a},t}(),n.AttrValue=function(){function a(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}var e;return a.prototype.list=null,a.prototype.s=$util.newBuffer([]),a.prototype.i=$util.Long?$util.Long.fromBits(0,0,!1):0,a.prototype.f=0,a.prototype.b=!1,a.prototype.type=0,a.prototype.shape=null,a.prototype.tensor=null,a.prototype.placeholder="",a.prototype.func=null,Object.defineProperty(a.prototype,"value",{get:$util.oneOfGetter(e=["list","s","i","f","b","type","shape","tensor","placeholder","func"]),set:$util.oneOfSetter(e)}),a.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.AttrValue,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.list=$root.tensorflow.AttrValue.ListValue.decode(o,o.uint32());break;case 2:a.s=o.bytes();break;case 3:a.i=o.int64();break;case 4:a.f=o.float();break;case 5:a.b=o.bool();break;case 6:a.type=o.int32();break;case 7:a.shape=$root.tensorflow.TensorShape.decode(o,o.uint32());break;case 8:a.tensor=$root.tensorflow.Tensor.decode(o,o.uint32());break;case 9:a.placeholder=o.string();break;case 10:a.func=$root.tensorflow.NameAttrList.decode(o,o.uint32());break;default:o.skipType(7&r);}return a},a.ListValue=function(){function t(n){if(this.s=[],this.i=[],this.f=[],this.b=[],this.type=[],this.shape=[],this.tensor=[],this.func=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.s=$util.emptyArray,t.prototype.i=$util.emptyArray,t.prototype.f=$util.emptyArray,t.prototype.b=$util.emptyArray,t.prototype.type=$util.emptyArray,t.prototype.shape=$util.emptyArray,t.prototype.tensor=$util.emptyArray,t.prototype.func=$util.emptyArray,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,a=new $root.tensorflow.AttrValue.ListValue,r;s.pos<t;)switch(r=s.uint32(),r>>>3){case 2:a.s&&a.s.length||(a.s=[]),a.s.push(s.bytes());break;case 3:if(a.i&&a.i.length||(a.i=[]),2==(7&r))for(var p=s.uint32()+s.pos;s.pos<p;)a.i.push(s.int64());else a.i.push(s.int64());break;case 4:if(a.f&&a.f.length||(a.f=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.f.push(s.float());else a.f.push(s.float());break;case 5:if(a.b&&a.b.length||(a.b=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.b.push(s.bool());else a.b.push(s.bool());break;case 6:if(a.type&&a.type.length||(a.type=[]),2==(7&r))for(p=s.uint32()+s.pos;s.pos<p;)a.type.push(s.int32());else a.type.push(s.int32());break;case 7:a.shape&&a.shape.length||(a.shape=[]),a.shape.push($root.tensorflow.TensorShape.decode(s,s.uint32()));break;case 8:a.tensor&&a.tensor.length||(a.tensor=[]),a.tensor.push($root.tensorflow.Tensor.decode(s,s.uint32()));break;case 9:a.func&&a.func.length||(a.func=[]),a.func.push($root.tensorflow.NameAttrList.decode(s,s.uint32()));break;default:s.skipType(7&r);}return a},t}(),a}(),n.NameAttrList=function(){function t(n){if(this.attr={},n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.name="",t.prototype.attr=$util.emptyObject,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,r=new $root.tensorflow.NameAttrList,n,p;s.pos<t;)switch(p=s.uint32(),p>>>3){case 1:r.name=s.string();break;case 2:s.skip().pos++,r.attr===$util.emptyObject&&(r.attr={}),n=s.string(),s.pos++,r.attr[n]=$root.tensorflow.AttrValue.decode(s,s.uint32());break;default:s.skipType(7&p);}return r},t}(),n.NodeDef=function(){function t(n){if(this.input=[],this.attr={},n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.name="",t.prototype.op="",t.prototype.input=$util.emptyArray,t.prototype.device="",t.prototype.attr=$util.emptyObject,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,r=new $root.tensorflow.NodeDef,n,p;s.pos<t;)switch(p=s.uint32(),p>>>3){case 1:r.name=s.string();break;case 2:r.op=s.string();break;case 3:r.input&&r.input.length||(r.input=[]),r.input.push(s.string());break;case 4:r.device=s.string();break;case 5:s.skip().pos++,r.attr===$util.emptyObject&&(r.attr={}),n=s.string(),s.pos++,r.attr[n]=$root.tensorflow.AttrValue.decode(s,s.uint32());break;default:s.skipType(7&p);}return r},t}(),n.VersionDef=function(){function t(n){if(this.badConsumers=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.producer=0,t.prototype.minConsumer=0,t.prototype.badConsumers=$util.emptyArray,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,a=new $root.tensorflow.VersionDef,r;s.pos<t;)switch(r=s.uint32(),r>>>3){case 1:a.producer=s.int32();break;case 2:a.minConsumer=s.int32();break;case 3:if(a.badConsumers&&a.badConsumers.length||(a.badConsumers=[]),2==(7&r))for(var p=s.uint32()+s.pos;s.pos<p;)a.badConsumers.push(s.int32());else a.badConsumers.push(s.int32());break;default:s.skipType(7&r);}return a},t}(),n.GraphDef=function(){function t(n){if(this.node=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.node=$util.emptyArray,t.prototype.versions=null,t.prototype.library=null,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.GraphDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.node&&a.node.length||(a.node=[]),a.node.push($root.tensorflow.NodeDef.decode(o,o.uint32()));break;case 4:a.versions=$root.tensorflow.VersionDef.decode(o,o.uint32());break;case 2:a.library=$root.tensorflow.FunctionDefLibrary.decode(o,o.uint32());break;default:o.skipType(7&r);}return a},t}(),n.CollectionDef=function(){function a(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}var e;return a.prototype.nodeList=null,a.prototype.bytesList=null,a.prototype.int64List=null,a.prototype.floatList=null,a.prototype.anyList=null,Object.defineProperty(a.prototype,"kind",{get:$util.oneOfGetter(e=["nodeList","bytesList","int64List","floatList","anyList"]),set:$util.oneOfSetter(e)}),a.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.CollectionDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.nodeList=$root.tensorflow.CollectionDef.NodeList.decode(o,o.uint32());break;case 2:a.bytesList=$root.tensorflow.CollectionDef.BytesList.decode(o,o.uint32());break;case 3:a.int64List=$root.tensorflow.CollectionDef.Int64List.decode(o,o.uint32());break;case 4:a.floatList=$root.tensorflow.CollectionDef.FloatList.decode(o,o.uint32());break;case 5:a.anyList=$root.tensorflow.CollectionDef.AnyList.decode(o,o.uint32());break;default:o.skipType(7&r);}return a},a.NodeList=function(){function t(n){if(this.value=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.value=$util.emptyArray,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.CollectionDef.NodeList,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.value&&a.value.length||(a.value=[]),a.value.push(o.string());break;default:o.skipType(7&r);}return a},t}(),a.BytesList=function(){function t(n){if(this.value=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.value=$util.emptyArray,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.CollectionDef.BytesList,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.value&&a.value.length||(a.value=[]),a.value.push(o.bytes());break;default:o.skipType(7&r);}return a},t}(),a.Int64List=function(){function t(n){if(this.value=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.value=$util.emptyArray,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,a=new $root.tensorflow.CollectionDef.Int64List,r;s.pos<t;)switch(r=s.uint32(),r>>>3){case 1:if(a.value&&a.value.length||(a.value=[]),2==(7&r))for(var p=s.uint32()+s.pos;s.pos<p;)a.value.push(s.int64());else a.value.push(s.int64());break;default:s.skipType(7&r);}return a},t}(),a.FloatList=function(){function t(n){if(this.value=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.value=$util.emptyArray,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,a=new $root.tensorflow.CollectionDef.FloatList,r;s.pos<t;)switch(r=s.uint32(),r>>>3){case 1:if(a.value&&a.value.length||(a.value=[]),2==(7&r))for(var p=s.uint32()+s.pos;s.pos<p;)a.value.push(s.float());else a.value.push(s.float());break;default:s.skipType(7&r);}return a},t}(),a.AnyList=function(){function t(n){if(this.value=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.value=$util.emptyArray,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.CollectionDef.AnyList,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.value&&a.value.length||(a.value=[]),a.value.push($root.tensorflow.Any.decode(o,o.uint32()));break;default:o.skipType(7&r);}return a},t}(),a}(),n.SaverDef=function(){function n(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}var e,r;return n.prototype.filenameTensorName="",n.prototype.saveTensorName="",n.prototype.restoreOpName="",n.prototype.maxToKeep=0,n.prototype.sharded=!1,n.prototype.keepCheckpointEveryNHours=0,n.prototype.version=0,n.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.SaverDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.filenameTensorName=o.string();break;case 2:a.saveTensorName=o.string();break;case 3:a.restoreOpName=o.string();break;case 4:a.maxToKeep=o.int32();break;case 5:a.sharded=o.bool();break;case 6:a.keepCheckpointEveryNHours=o.float();break;case 7:a.version=o.int32();break;default:o.skipType(7&r);}return a},n.CheckpointFormatVersion=(e={},(r=Object.create(e))[e[0]="LEGACY"]=0,r[e[1]="V1"]=1,r[e[2]="V2"]=2,r),n}(),n.TensorInfo=function(){function a(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}var e;return a.prototype.name="",a.prototype.cooSparse=null,a.prototype.dtype=0,a.prototype.tensorShape=null,Object.defineProperty(a.prototype,"encoding",{get:$util.oneOfGetter(e=["name","cooSparse"]),set:$util.oneOfSetter(e)}),a.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.TensorInfo,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.name=o.string();break;case 4:a.cooSparse=$root.tensorflow.TensorInfo.CooSparse.decode(o,o.uint32());break;case 2:a.dtype=o.int32();break;case 3:a.tensorShape=$root.tensorflow.TensorShape.decode(o,o.uint32());break;default:o.skipType(7&r);}return a},a.CooSparse=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.valuesTensorName="",t.prototype.indicesTensorName="",t.prototype.denseShapeTensorName="",t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.TensorInfo.CooSparse,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.valuesTensorName=o.string();break;case 2:a.indicesTensorName=o.string();break;case 3:a.denseShapeTensorName=o.string();break;default:o.skipType(7&r);}return a},t}(),a}(),n.SignatureDef=function(){function t(n){if(this.inputs={},this.outputs={},n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.inputs=$util.emptyObject,t.prototype.outputs=$util.emptyObject,t.prototype.methodName="",t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,r=new $root.tensorflow.SignatureDef,n,p;s.pos<t;)switch(p=s.uint32(),p>>>3){case 1:s.skip().pos++,r.inputs===$util.emptyObject&&(r.inputs={}),n=s.string(),s.pos++,r.inputs[n]=$root.tensorflow.TensorInfo.decode(s,s.uint32());break;case 2:s.skip().pos++,r.outputs===$util.emptyObject&&(r.outputs={}),n=s.string(),s.pos++,r.outputs[n]=$root.tensorflow.TensorInfo.decode(s,s.uint32());break;case 3:r.methodName=s.string();break;default:s.skipType(7&p);}return r},t}(),n.AssetFileDef=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.tensorInfo=null,t.prototype.filename="",t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.AssetFileDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.tensorInfo=$root.tensorflow.TensorInfo.decode(o,o.uint32());break;case 2:a.filename=o.string();break;default:o.skipType(7&r);}return a},t}(),n.OpDef=function(){function t(n){if(this.inputArg=[],this.outputArg=[],this.attr=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.name="",t.prototype.inputArg=$util.emptyArray,t.prototype.outputArg=$util.emptyArray,t.prototype.attr=$util.emptyArray,t.prototype.deprecation=null,t.prototype.summary="",t.prototype.description="",t.prototype.isCommutative=!1,t.prototype.isAggregate=!1,t.prototype.isStateful=!1,t.prototype.allowsUninitializedInput=!1,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.OpDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.name=o.string();break;case 2:a.inputArg&&a.inputArg.length||(a.inputArg=[]),a.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(o,o.uint32()));break;case 3:a.outputArg&&a.outputArg.length||(a.outputArg=[]),a.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(o,o.uint32()));break;case 4:a.attr&&a.attr.length||(a.attr=[]),a.attr.push($root.tensorflow.OpDef.AttrDef.decode(o,o.uint32()));break;case 8:a.deprecation=$root.tensorflow.OpDef.OpDeprecation.decode(o,o.uint32());break;case 5:a.summary=o.string();break;case 6:a.description=o.string();break;case 18:a.isCommutative=o.bool();break;case 16:a.isAggregate=o.bool();break;case 17:a.isStateful=o.bool();break;case 19:a.allowsUninitializedInput=o.bool();break;default:o.skipType(7&r);}return a},t.ArgDef=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.name="",t.prototype.description="",t.prototype.type=0,t.prototype.typeAttr="",t.prototype.numberAttr="",t.prototype.typeListAttr="",t.prototype.isRef=!1,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.OpDef.ArgDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.name=o.string();break;case 2:a.description=o.string();break;case 3:a.type=o.int32();break;case 4:a.typeAttr=o.string();break;case 5:a.numberAttr=o.string();break;case 6:a.typeListAttr=o.string();break;case 16:a.isRef=o.bool();break;default:o.skipType(7&r);}return a},t}(),t.AttrDef=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.name="",t.prototype.type="",t.prototype.defaultValue=null,t.prototype.description="",t.prototype.hasMinimum=!1,t.prototype.minimum=$util.Long?$util.Long.fromBits(0,0,!1):0,t.prototype.allowedValues=null,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.OpDef.AttrDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.name=o.string();break;case 2:a.type=o.string();break;case 3:a.defaultValue=$root.tensorflow.AttrValue.decode(o,o.uint32());break;case 4:a.description=o.string();break;case 5:a.hasMinimum=o.bool();break;case 6:a.minimum=o.int64();break;case 7:a.allowedValues=$root.tensorflow.AttrValue.decode(o,o.uint32());break;default:o.skipType(7&r);}return a},t}(),t.OpDeprecation=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.version=0,t.prototype.explanation="",t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.OpDef.OpDeprecation,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.version=o.int32();break;case 2:a.explanation=o.string();break;default:o.skipType(7&r);}return a},t}(),t}(),n.OpList=function(){function t(n){if(this.op=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.op=$util.emptyArray,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.OpList,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.op&&a.op.length||(a.op=[]),a.op.push($root.tensorflow.OpDef.decode(o,o.uint32()));break;default:o.skipType(7&r);}return a},t}(),n.MetaGraphDef=function(){function t(n){if(this.collectionDef={},this.signatureDef={},this.assetFileDef=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.metaInfoDef=null,t.prototype.graphDef=null,t.prototype.saverDef=null,t.prototype.collectionDef=$util.emptyObject,t.prototype.signatureDef=$util.emptyObject,t.prototype.assetFileDef=$util.emptyArray,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,r=new $root.tensorflow.MetaGraphDef,n,p;s.pos<t;)switch(p=s.uint32(),p>>>3){case 1:r.metaInfoDef=$root.tensorflow.MetaGraphDef.MetaInfoDef.decode(s,s.uint32());break;case 2:r.graphDef=$root.tensorflow.GraphDef.decode(s,s.uint32());break;case 3:r.saverDef=$root.tensorflow.SaverDef.decode(s,s.uint32());break;case 4:s.skip().pos++,r.collectionDef===$util.emptyObject&&(r.collectionDef={}),n=s.string(),s.pos++,r.collectionDef[n]=$root.tensorflow.CollectionDef.decode(s,s.uint32());break;case 5:s.skip().pos++,r.signatureDef===$util.emptyObject&&(r.signatureDef={}),n=s.string(),s.pos++,r.signatureDef[n]=$root.tensorflow.SignatureDef.decode(s,s.uint32());break;case 6:r.assetFileDef&&r.assetFileDef.length||(r.assetFileDef=[]),r.assetFileDef.push($root.tensorflow.AssetFileDef.decode(s,s.uint32()));break;default:s.skipType(7&p);}return r},t.MetaInfoDef=function(){function t(n){if(this.tags=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.metaGraphVersion="",t.prototype.strippedOpList=null,t.prototype.anyInfo=null,t.prototype.tags=$util.emptyArray,t.prototype.tensorflowVersion="",t.prototype.tensorflowGitVersion="",t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.MetaGraphDef.MetaInfoDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.metaGraphVersion=o.string();break;case 2:a.strippedOpList=$root.tensorflow.OpList.decode(o,o.uint32());break;case 3:a.anyInfo=$root.tensorflow.Any.decode(o,o.uint32());break;case 4:a.tags&&a.tags.length||(a.tags=[]),a.tags.push(o.string());break;case 5:a.tensorflowVersion=o.string();break;case 6:a.tensorflowGitVersion=o.string();break;default:o.skipType(7&r);}return a},t}(),t}(),n.SavedModel=function(){function t(n){if(this.metaGraphs=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.savedModelSchemaVersion=$util.Long?$util.Long.fromBits(0,0,!1):0,t.prototype.metaGraphs=$util.emptyArray,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.SavedModel,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.savedModelSchemaVersion=o.int64();break;case 2:a.metaGraphs&&a.metaGraphs.length||(a.metaGraphs=[]),a.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(o,o.uint32()));break;default:o.skipType(7&r);}return a},t}(),n.FunctionDefLibrary=function(){function t(n){if(this.function=[],this.gradient=[],n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.function=$util.emptyArray,t.prototype.gradient=$util.emptyArray,t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.FunctionDefLibrary,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.function&&a.function.length||(a.function=[]),a.function.push($root.tensorflow.FunctionDef.decode(o,o.uint32()));break;case 2:a.gradient&&a.gradient.length||(a.gradient=[]),a.gradient.push($root.tensorflow.GradientDef.decode(o,o.uint32()));break;default:o.skipType(7&r);}return a},t}(),n.FunctionDef=function(){function t(n){if(this.attr={},this.nodeDef=[],this.ret={},n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.signature=null,t.prototype.attr=$util.emptyObject,t.prototype.nodeDef=$util.emptyArray,t.prototype.ret=$util.emptyObject,t.decode=function(s,i){s instanceof $Reader||(s=$Reader.create(s));for(var t=void 0===i?s.len:s.pos+i,r=new $root.tensorflow.FunctionDef,n,p;s.pos<t;)switch(p=s.uint32(),p>>>3){case 1:r.signature=$root.tensorflow.OpDef.decode(s,s.uint32());break;case 5:s.skip().pos++,r.attr===$util.emptyObject&&(r.attr={}),n=s.string(),s.pos++,r.attr[n]=$root.tensorflow.AttrValue.decode(s,s.uint32());break;case 3:r.nodeDef&&r.nodeDef.length||(r.nodeDef=[]),r.nodeDef.push($root.tensorflow.NodeDef.decode(s,s.uint32()));break;case 4:s.skip().pos++,r.ret===$util.emptyObject&&(r.ret={}),n=s.string(),s.pos++,r.ret[n]=s.string();break;default:s.skipType(7&p);}return r},t}(),n.GradientDef=function(){function t(n){if(n)for(var e=Object.keys(n),t=0;t<e.length;++t)null!=n[e[t]]&&(this[e[t]]=n[e[t]])}return t.prototype.functionName="",t.prototype.gradientFunc="",t.decode=function(o,s){o instanceof $Reader||(o=$Reader.create(o));for(var t=void 0===s?o.len:o.pos+s,a=new $root.tensorflow.GradientDef,r;o.pos<t;)switch(r=o.uint32(),r>>>3){case 1:a.functionName=o.string();break;case 2:a.gradientFunc=o.string();break;default:o.skipType(7&r);}return a},t}(),n}();var compiled_api=$root,compiled_api_1=compiled_api.tensorflow,json=[{tfOpName:"Add",dlOpName:"add",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",dlOpName:"addN",category:"arithmetic",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",dlOpName:"add",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",dlOpName:"sub",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",dlOpName:"div",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",dlOpName:"div",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",dlOpName:"floorDiv",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",dlOpName:"mul",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",dlOpName:"maximum",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"}]},{tfOpName:"Minimum",dlOpName:"minimum",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"}]},{tfOpName:"Pow",dlOpName:"pow",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",dlOpName:"squaredDifference",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",dlOpName:"mod",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",dlOpName:"mod",category:"arithmetic",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],arithmetic=Object.freeze({json:json}),json$1=[{tfOpName:"Abs",dlOpName:"abs",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",dlOpName:"acos",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",dlOpName:"asin",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",dlOpName:"atan",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",dlOpName:"atan2",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"y",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",dlOpName:"ceil",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",dlOpName:"clipByValue",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"clip_value_min",dlParamName:"clipValueMin",type:"number"},{tfParamName:"clip_value_max",dlParamName:"clipValueMax",type:"number"}]},{tfOpName:"Cos",dlOpName:"cos",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",dlOpName:"cosh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",dlOpName:"elu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",dlOpName:"exp",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",dlOpName:"floor",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",dlOpName:"log",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",dlOpName:"neg",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",dlOpName:"relu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",dlOpName:"clipByValue",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{dlParamName:"clipValueMin",type:"number",defaultValue:0},{dlParamName:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",dlOpName:"selu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",dlOpName:"sigmoid",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",dlOpName:"sin",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",dlOpName:"sinh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",dlOpName:"sqrt",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",dlOpName:"rsqrt",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",dlOpName:"square",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",dlOpName:"tan",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",dlOpName:"tanh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",dlOpName:"sign",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",dlOpName:"round",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",dlOpName:"expm1",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",dlOpName:"log1p",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",dlOpName:"reciprocal",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",dlOpName:"reciprocal",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",dlOpName:"softplus",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",dlOpName:"asinh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",dlOpName:"acosh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",dlOpName:"atanh",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",dlOpName:"erf",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",dlOpName:"prod",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axes",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool",notSupported:!0},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",dlOpName:"leakyRelu",category:"basic_math",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"alpha",dlParamName:"alpha",type:"number",defaultValue:.2},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],basicMath=Object.freeze({json:json$1}),json$2=[{tfOpName:"LoopCond",dlOpName:"loopCond",category:"control",params:[{tfInputIndex:0,dlParamName:"pred",type:"tensor"}]},{tfOpName:"Switch",dlOpName:"switch",category:"control",params:[{tfInputIndex:0,dlParamName:"data",type:"tensor"},{tfInputIndex:1,dlParamName:"pred",type:"tensor"}]},{tfOpName:"Merge",dlOpName:"merge",category:"control",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"}]},{tfOpName:"Enter",dlOpName:"enter",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{tfParamName:"frame_name",dlParamName:"frameName",type:"string"},{tfParamName:"is_constant",dlParamName:"isConstant",type:"bool"}]},{tfOpName:"Exit",dlOpName:"exit",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",dlOpName:"nextIteration",category:"control",params:[{tfInputIndex:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",dlOpName:"tensorArray",category:"control",params:[{tfInputIndex:0,dlParamName:"size",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape",dlParamName:"elementShape",type:"shape"},{tfParamName:"dynamic_size",dlParamName:"dynamicSize",type:"bool"},{tfParamName:"clear_after_read",dlParamName:"clearAfterRead",type:"bool"},{tfParamName:"identical_element_shapes",dlParamName:"identicalElementShapes",type:"bool"},{tfParamName:"tensor_array_name",dlParamName:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",dlOpName:"tensorArrayWrite",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"index",type:"number"},{tfInputIndex:2,dlParamName:"tensor",type:"tensor"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",dlOpName:"tensorArrayRead",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"index",type:"number"},{tfInputIndex:2,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",dlOpName:"tensorArrayGather",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"indices",type:"number[]"},{tfInputIndex:2,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape",dlParamName:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",dlOpName:"tensorArrayScatter",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"indices",type:"number[]"},{tfInputIndex:2,dlParamName:"tensor",type:"tensor"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",dlOpName:"tensorArrayConcat",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"flowIn",type:"number"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"element_shape_except0",dlParamName:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",dlOpName:"tensorArraySplit",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"tensor",type:"tensor"},{tfInputIndex:2,dlParamName:"lengths",type:"number[]"},{tfInputIndex:3,dlParamName:"flowIn",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",dlOpName:"tensorArraySize",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"},{tfInputIndex:1,dlParamName:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",dlOpName:"tensorArrayClose",category:"control",params:[{tfInputIndex:0,dlParamName:"tensorArrayId",type:"number"}]}],control=Object.freeze({json:json$2}),json$3=[{tfOpName:"AvgPool",dlOpName:"avgPool",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0},{tfParamName:"ksize",dlParamName:"kernelSize",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",dlOpName:"maxPool",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0},{tfParamName:"ksize",dlParamName:"kernelSize",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",dlOpName:"conv1d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"stride",dlParamName:"stride",type:"number"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NWC"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{tfParamName:"dilation",dlParamName:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",dlOpName:"conv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"useCudnnOnGpu",dlParamName:"useCudnnOnGpu",type:"bool"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]},{tfOpName:"Conv2DBackpropInput",dlOpName:"conv2dTranspose",category:"convolution",params:[{tfInputIndex:2,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfInputIndex:0,dlParamName:"outputShape",type:"number[]"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",dlOpName:"depthwiseConv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"input",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",dlOpName:"depthwiseConv2d",category:"convolution",params:[{tfInputIndex:0,dlParamName:"input",type:"tensor"},{tfInputIndex:1,dlParamName:"filter",type:"tensor"},{tfParamName:"strides",dlParamName:"strides",type:"number[]"},{tfParamName:"padding",dlParamName:"pad",type:"string"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",defaultValue:"NHWC"},{tfParamName:"dilations",dlParamName:"dilations",type:"number[]"}]}],convolution=Object.freeze({json:json$3}),json$4=[{tfOpName:"Fill",dlOpName:"fill",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfInputIndex:1,dlParamName:"value",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",dlOpName:"linspace",category:"creation",params:[{tfInputIndex:0,dlParamName:"start",type:"number"},{tfInputIndex:1,dlParamName:"stop",type:"number"},{tfInputIndex:2,dlParamName:"num",type:"number"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",dlOpName:"oneHot",category:"creation",params:[{tfInputIndex:0,dlParamName:"indices",type:"tensor"},{tfInputIndex:1,dlParamName:"depth",type:"number"},{tfInputIndex:2,dlParamName:"onValue",type:"number",defaultValue:1},{tfInputIndex:3,dlParamName:"offValue",type:"number",defaultValue:0},{tfParamName:"axis",dlParamName:"axis",type:"number",notSupported:!0},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",dlOpName:"ones",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",dlOpName:"onesLike",category:"creation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",dlOpName:"randomUniform",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"minval",dlParamName:"minval",type:"number",defaultValue:0},{tfParamName:"maxval",dlParamName:"maxval",type:"number",defaultValue:1},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"seed",dlParamName:"seed",type:"number",defaultValue:0},{tfParamName:"seed2",dlParamName:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfParamName:"T",dlParamName:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",dlOpName:"range",category:"creation",params:[{tfInputIndex:0,dlParamName:"start",type:"number"},{tfInputIndex:1,dlParamName:"stop",type:"number"},{tfInputIndex:2,dlParamName:"step",type:"number",defaultValue:0},{tfParamName:"Tidx",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"truncatedNormal",dlOpName:"truncatedNormal",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"means",dlParamName:"mean",type:"number",defaultValue:0},{tfParamName:"stddev",dlParamName:"stdDev",type:"number",defaultValue:1},{tfParamName:"seed",dlParamName:"seed",type:"number"},{tfParamName:"seed2",dlParamName:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"},{tfParamName:"T",dlParamName:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",dlOpName:"zeros",category:"creation",params:[{tfInputIndex:0,dlParamName:"shape",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",dlOpName:"zerosLike",category:"creation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype"}]}],creation=Object.freeze({json:json$4}),json$5=[{tfOpName:"NonMaxSuppressionV2",dlOpName:"nonMaxSuppression",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"boxes",type:"tensor"},{tfInputIndex:1,dlParamName:"scores",type:"tensor"},{tfInputIndex:2,dlParamName:"maxOutputSize",type:"number"},{tfInputIndex:3,dlParamName:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",dlOpName:"nonMaxSuppression",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"boxes",type:"tensor"},{tfInputIndex:1,dlParamName:"scores",type:"tensor"},{tfInputIndex:2,dlParamName:"maxOutputSize",type:"number"},{tfInputIndex:3,dlParamName:"iouThreshold",type:"number"},{tfInputIndex:4,dlParamName:"scoreThreshold",type:"number"}]},{tfOpName:"Where",dlOpName:"whereAsync",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"condition",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",dlOpName:"setdiff1dAsync",category:"dynamic",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"y",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],dynamic=Object.freeze({json:json$5}),json$6=[{tfOpName:"TopKV2",dlOpName:"topK",category:"evaluation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"k",type:"number"},{tfParamName:"sorted",dlParamName:"sorted",type:"bool"}]}],evaluation=Object.freeze({json:json$6}),json$7=[{tfOpName:"PlaceholderWithDefault",dlOpName:"placeholder",category:"graph",params:[{tfInputIndex:0,dlParamName:"default",type:"tensor"},{tfParamName:"shape",dlParamName:"shape",type:"shape"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",dlOpName:"placeholder",category:"graph",params:[{tfParamName:"shape",dlParamName:"shape",type:"shape"},{tfParamName:"dtype",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"Const",dlOpName:"const",category:"graph"},{tfOpName:"Identity",dlOpName:"identity",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Snapshot",dlOpName:"snapshot",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Rank",dlOpName:"rank",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Size",dlOpName:"size",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"Shape",dlOpName:"shape",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"ShapeN",dlOpName:"shapeN",category:"graph",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"x",type:"tensors"}]},{tfOpName:"Print",dlOpName:"print",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,tfInputParamLength:1,dlParamName:"data",type:"tensors"},{tfParamName:"message",dlParamName:"message",type:"string"},{tfParamName:"first_n",dlParamName:"firstN",type:"number",notSupprted:!0},{tfParamName:"summarize",dlParamName:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",dlOpName:"noop",category:"graph",params:[]},{tfOpName:"StopGradient",dlOpName:"stopGradient",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",dlOpName:"fakeQuantWithMinMaxVars",category:"graph",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"min",dlParamName:"min",type:"number"},{tfParamName:"max",dlParamName:"max",type:"number"}]}],graph=Object.freeze({json:json$7}),json$8=[{tfOpName:"ResizeBilinear",dlOpName:"resizeBilinear",category:"image",params:[{tfInputIndex:0,dlParamName:"images",type:"tensor"},{tfInputIndex:1,dlParamName:"size",type:"number[]"},{tfParamName:"align_corners",dlParamName:"alignCorners",type:"bool"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",dlOpName:"resizeNearestNeighbor",category:"image",params:[{tfInputIndex:0,dlParamName:"images",type:"tensor"},{tfInputIndex:1,dlParamName:"size",type:"number[]"},{tfParamName:"align_corners",dlParamName:"alignCorners",type:"bool"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",dlOpName:"cropAndResize",category:"image",params:[{tfInputIndex:0,dlParamName:"image",type:"tensor"},{tfInputIndex:1,dlParamName:"boxes",type:"tensor"},{tfInputIndex:2,dlParamName:"boxInd",type:"tensor"},{tfInputIndex:3,dlParamName:"cropSize",type:"number[]"},{tfParamName:"method",dlParamName:"method",type:"string"},{tfParamName:"extrapolation_value",dlParamName:"extrapolationValue",type:"number"}]}],image$1=Object.freeze({json:json$8}),json$9=[{tfOpName:"Equal",dlOpName:"equal",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",dlOpName:"notEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",dlOpName:"greater",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",dlOpName:"greaterEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",dlOpName:"less",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",dlOpName:"lessEqual",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",dlOpName:"logicalAnd",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",dlOpName:"logicalNot",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",dlOpName:"logicalOr",category:"logical",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",dlOpName:"where",category:"logical",params:[{tfInputIndex:0,dlParamName:"condition",type:"tensor"},{tfInputIndex:1,dlParamName:"a",type:"tensor"},{tfInputIndex:2,dlParamName:"b",type:"tensor"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],logical=Object.freeze({json:json$9}),json$10=[{tfOpName:"MatMul",dlOpName:"matMul",category:"matrices",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"transpose_a",dlParamName:"transposeA",type:"bool",defaultValue:!1},{tfParamName:"transpose_b",dlParamName:"transposeB",type:"bool",defaultValue:!1},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",dlOpName:"matMul",category:"matrices",params:[{tfInputIndex:0,dlParamName:"a",type:"tensor"},{tfInputIndex:1,dlParamName:"b",type:"tensor"},{tfParamName:"adj_x",dlParamName:"transposeA",type:"bool",defaultValue:!1},{tfParamName:"adj_y",dlParamName:"transposeB",type:"bool",defaultValue:!1},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",dlOpName:"transpose",category:"matrices",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"perm",type:"number[]"},{tfParamName:"T",dlParamName:"dtype",type:"dtype",notSupported:!0}]}],matrices=Object.freeze({json:json$10}),json$11=[{tfOpName:"FusedBatchNorm",dlOpName:"batchNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"scale",type:"tensor"},{tfInputIndex:2,dlParamName:"offset",type:"tensor"},{tfInputIndex:3,dlParamName:"mean",type:"tensor"},{tfInputIndex:4,dlParamName:"variance",type:"tensor"},{tfParamName:"epsilon",dlParamName:"epsilon",type:"number",defaultValue:.001},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",dlOpName:"batchNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"scale",type:"tensor"},{tfInputIndex:2,dlParamName:"offset",type:"tensor"},{tfInputIndex:3,dlParamName:"mean",type:"tensor"},{tfInputIndex:4,dlParamName:"variance",type:"tensor"},{tfParamName:"epsilon",dlParamName:"epsilon",type:"number",defaultValue:.001},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",dlOpName:"localResponseNormalization",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"depth_radius",dlParamName:"radius",type:"number",defaultValue:5},{tfParamName:"bias",dlParamName:"bias",type:"number",defaultValue:1},{tfParamName:"alpha",dlParamName:"alpha",type:"number",defaultValue:1},{tfParamName:"beta",dlParamName:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",dlOpName:"softmax",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",dlOpName:"logSoftmax",category:"normalization",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"}]},{tfOpName:"SparseToDense",dlOpName:"sparseToDense",category:"normalization",params:[{tfInputIndex:0,dlParamName:"sparseIndices",type:"tensor"},{tfInputIndex:1,dlParamName:"outputShape",type:"number[]"},{tfInputIndex:2,dlParamName:"sparseValues",type:"tensor"},{tfInputIndex:3,dlParamName:"defaultValue",type:"tensor"},{tfParamName:"validate_indices",dlParamName:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],normalization=Object.freeze({json:json$11}),json$12=[{tfOpName:"Max",dlOpName:"max",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Mean",dlOpName:"mean",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Min",dlOpName:"min",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Sum",dlOpName:"sum",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"All",dlOpName:"all",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"Any",dlOpName:"any",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",dlOpName:"argMax",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]},{tfOpName:"ArgMin",dlOpName:"argMin",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number"}]},{tfOpName:"Prod",dlOpName:"prod",category:"reduction",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"},{tfParamName:"keep_dims",dlParamName:"keepDims",type:"bool"}]}],reduction=Object.freeze({json:json$12}),json$13=[{tfOpName:"ConcatV2",dlOpName:"concat",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:1,dlParamName:"tensors",type:"tensors"},{tfInputIndex:-1,dlParamName:"axis",type:"number"}]},{tfOpName:"Concat",dlOpName:"concat",category:"slice_join",params:[{tfInputIndex:1,tfInputParamLength:1,dlParamName:"tensors",type:"tensors"},{tfInputIndex:0,dlParamName:"axis",type:"number"}]},{tfOpName:"GatherV2",dlOpName:"gather",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"},{tfInputIndex:2,dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",dlOpName:"gather",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0},{tfParamName:"validate_indices",dlParamName:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",dlOpName:"reverse",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",dlOpName:"reverse",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"axis",type:"number[]"}]},{tfOpName:"Slice",dlOpName:"slice",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"begin",type:"number[]"},{tfInputIndex:2,dlParamName:"size",type:"number[]"}]},{tfOpName:"StridedSlice",dlOpName:"stridedSlice",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"begin",type:"number[]"},{tfInputIndex:2,dlParamName:"end",type:"number[]"},{tfInputIndex:3,dlParamName:"strides",type:"number[]"},{tfParamName:"begin_mask",dlParamName:"beginMask",type:"number",defaultValue:0},{tfParamName:"end_mask",dlParamName:"endMask",type:"number",defaultValue:0},{tfParamName:"new_axis_mask",dlParamName:"newAxisMask",type:"number",defaultValue:0},{tfParamName:"ellipsis_mask",dlParamName:"ellipsisMask",type:"number",defaultValue:0},{tfParamName:"shrink_axis_mask",dlParamName:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",dlOpName:"stack",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensors",type:"tensors"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",dlOpName:"unstack",category:"slice_join",params:[{tfInputIndex:0,tfInputParamLength:0,dlParamName:"tensor",type:"tensor"},{tfParamName:"axis",dlParamName:"axis",type:"number",defaultValue:0},{tfParamName:"num",dlParamName:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",dlOpName:"tile",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"reps",type:"number[]"}]},{tfOpName:"Split",dlOpName:"split",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"axis",type:"number",defaultValue:0},{tfInputIndex:1,dlParamName:"x",type:"tensor"},{tfParamName:"num_split",dlParamName:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",dlOpName:"split",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"numOrSizeSplits",type:"number[]"},{tfInputIndex:2,dlParamName:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",dlOpName:"scatterNd",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"indices",type:"tensor"},{tfInputIndex:1,dlParamName:"values",type:"tensor"},{tfInputIndex:2,dlParamName:"shape",type:"number[]"}]},{tfOpName:"GatherNd",dlOpName:"gatherNd",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",dlOpName:"sparseToDense",category:"slice_join",params:[{tfInputIndex:0,dlParamName:"sparseIndices",type:"tensor"},{tfInputIndex:1,dlParamName:"outputShape",type:"number[]"},{tfInputIndex:2,dlParamName:"sparseValues",type:"tensor"},{tfInputIndex:3,dlParamName:"defaultValue",type:"tensor"},{tfParamName:"validate_indices",dlParamName:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sliceJoin=Object.freeze({json:json$13}),json$14=[{tfOpName:"Cast",dlOpName:"cast",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"SrcT",dlParamName:"sdtype",type:"dtype",notSupported:!0},{tfParamName:"DstT",dlParamName:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",dlOpName:"expandDims",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,tfParamNameDeprecated:"dim",dlParamName:"axis",type:"number"}]},{tfOpName:"Pad",dlOpName:"pad",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"padding",type:"number[]"},{tfParamName:"constant_value",dlParamName:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",dlOpName:"pad",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"padding",type:"number[]"},{tfInputIndex:2,dlParamName:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",dlOpName:"reshape",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"shape",type:"number[]"}]},{tfOpName:"Squeeze",dlOpName:"squeeze",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"axis",tfParamNameDeprecated:"squeeze_dims",dlParamName:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",dlOpName:"spaceToBatchND",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"blockShape",type:"number[]"},{tfInputIndex:2,dlParamName:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",dlOpName:"batchToSpaceND",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfInputIndex:1,dlParamName:"blockShape",type:"number[]"},{tfInputIndex:2,dlParamName:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",dlOpName:"depthToSpace",category:"transformation",params:[{tfInputIndex:0,dlParamName:"x",type:"tensor"},{tfParamName:"block_size",dlParamName:"blockSize",type:"number"},{tfParamName:"data_format",dlParamName:"dataFormat",type:"string"}]}],transformation=Object.freeze({json:json$14}),CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","Where"],OperationMapper=function(){function t(){var e=[].concat.apply([],[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image$1,graph,matrices,normalization,reduction,sliceJoin,transformation].map(function(t){return t.json}));this.opMappers=e.reduce(function(a,e){return a[e.tfOpName]=e,a},{})}return Object.defineProperty(t,"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:!0,configurable:!0}),t.prototype.isControlFlow=function(a){return CONTROL_FLOW_OPS.some(function(e){return e===a.op})},t.prototype.isDynamicShape=function(a){return DYNAMIC_SHAPE_OPS.some(function(e){return e===a.op})},t.prototype.transformGraph=function(l){var d=this,t=!1,u=!1,c=[],n=[],o=l.node.reduce(function(a,e){return a[e.name]=d.mapNode(e),d.isControlFlow(e)&&(t=!0),d.isDynamicShape(e)&&(u=!0),"Placeholder"===e.op&&c.push(a[e.name]),"Const"===e.op&&n.push(a[e.name]),a},{}),s=[],i=[];return Object.keys(o).forEach(function(a){var n=o[a];n.inputNames.forEach(function(t){var e=getNodeNameAndIndex(t)[0];n.inputs.push(o[e]),o[e].children.push(n)}),0===n.inputs.length&&s.push(n)}),Object.keys(o).forEach(function(a){var e=o[a];0===e.children.length&&i.push(e)}),{nodes:o,inputs:s,outputs:i,weights:n,placeholders:c,withControlFlow:t,withDynamicShape:u}},t.prototype.mapNode=function(n){var e=this,t=this.opMappers[n.op];if(void 0===t)throw new Error("Tensorflow Op is not supported: "+n.op);var a={name:n.name,op:t.dlOpName,category:t.category,inputNames:(n.input||[]).map(function(t){return t.startsWith("^")?t.substr(1):t}),inputs:[],children:[],params:{}};return t.params&&(a.params=t.params.reduce(function(t,a){var r=a.tfInputIndex,p=a.tfInputParamLength,o=a.type,s;if(void 0===r)switch(a.type){case"string":void 0===(s=e.getStringParam(n.attr,a.tfParamName,a.defaultValue))&&a.tfParamNameDeprecated&&(s=e.getStringParam(n.attr,a.tfParamNameDeprecated,a.defaultValue));break;case"number":void 0===(s=e.getNumberParam(n.attr,a.tfParamName,a.defaultValue))&&a.tfParamNameDeprecated&&(s=e.getNumberParam(n.attr,a.tfParamNameDeprecated,a.defaultValue));break;case"number[]":void 0===(s=e.getNumericArrayParam(n.attr,a.tfParamName,a.defaultValue))&&a.tfParamNameDeprecated&&(s=e.getNumericArrayParam(n.attr,a.tfParamNameDeprecated,a.defaultValue));break;case"bool":void 0===(s=e.getBoolParam(n.attr,a.tfParamName,a.defaultValue))&&a.tfParamNameDeprecated&&(s=e.getBoolParam(n.attr,a.tfParamNameDeprecated,a.defaultValue));break;case"shape":void 0===(s=e.getTensorShapeParam(n.attr,a.tfParamName,a.defaultValue))&&a.tfParamNameDeprecated&&(s=e.getTensorShapeParam(n.attr,a.tfParamNameDeprecated,a.defaultValue));break;case"dtype":void 0===(s=e.getDtypeParam(n.attr,a.tfParamName,a.defaultValue))&&a.tfParamNameDeprecated&&(s=e.getDtypeParam(n.attr,a.tfParamNameDeprecated,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+a.type+" for op: "+n.op);}return t[a.dlParamName]={value:s,inputIndex:r,type:o,inputParamLength:p},t},{})),a},t.prototype.getStringParam=function(s,e,t,a){void 0===a&&(a=!1);var i=s[e];if(void 0!==i){var n=_StringfromCharCode.apply(null,i.s);return a?n:n.toLowerCase()}return t},t.prototype.getBoolParam=function(n,e,t){var a=n[e];return a?a.b:t},t.prototype.getNumberParam=function(o,e,t){var a=o[e],r=a?a[a.value]:t;return"number"==typeof r?r:r.toInt()},t.prototype.getDtypeParam=function(n,e,t){var a=n[e];if(a&&a.type)switch(a.type){case compiled_api_1.DataType.DT_FLOAT:return"float32";case compiled_api_1.DataType.DT_INT32:return"int32";case compiled_api_1.DataType.DT_BOOL:return"bool";default:return t;}return t},t.prototype.getTensorShapeParam=function(n,e,t){var a=n[e];return a&&a.shape?a.shape.dim.map(function(t){return"number"==typeof t.size?t.size:t.size.toInt()}):t},t.prototype.getNumericArrayParam=function(n,e,t){var a=n[e];return a?(a.list.f&&a.list.f.length?a.list.f:a.list.i).map(function(t){return"number"==typeof t?t:t.toInt()}):t},t}(),executeOp=function(n,e,t){switch(n.op){case"add":return[add(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"addN":return[addN(getParamValue("tensors",n,e,t))];case"mod":return[mod(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"mul":return[mul(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"div":return[div(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"floorDiv":return[floorDiv(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"sub":return[sub(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"minimum":return[minimum(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"maximum":return[maximum(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"pow":return[pow(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"squaredDifference":return[squaredDifference(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];default:throw TypeError("Node type "+n.op+" is not implemented");}},executeOp$1=function(n,e,t){switch(n.op){case"abs":return[abs(getParamValue("x",n,e,t))];case"acos":return[acos(getParamValue("x",n,e,t))];case"acosh":return[acosh(getParamValue("x",n,e,t))];case"asin":return[asin(getParamValue("x",n,e,t))];case"asinh":return[asinh(getParamValue("x",n,e,t))];case"atan":return[atan(getParamValue("x",n,e,t))];case"atan2":return[atan2(getParamValue("x",n,e,t),getParamValue("y",n,e,t))];case"atanh":return[atanh(getParamValue("x",n,e,t))];case"ceil":return[ceil(getParamValue("x",n,e,t))];case"cos":return[cos(getParamValue("x",n,e,t))];case"cosh":return[cosh(getParamValue("x",n,e,t))];case"elu":return[elu(getParamValue("x",n,e,t))];case"erf":return[erf(getParamValue("x",n,e,t))];case"exp":return[exp(getParamValue("x",n,e,t))];case"expm1":return[expm1(getParamValue("x",n,e,t))];case"floor":return[floor(getParamValue("x",n,e,t))];case"log":return[log$1(getParamValue("x",n,e,t))];case"log1p":return[log1p(getParamValue("x",n,e,t))];case"neg":return[neg(getParamValue("x",n,e,t))];case"reciprocal":return[reciprocal(getParamValue("x",n,e,t))];case"relu":return[relu(getParamValue("x",n,e,t))];case"round":return[round(getParamValue("x",n,e,t))];case"selu":return[selu(getParamValue("x",n,e,t))];case"sigmoid":return[sigmoid(getParamValue("x",n,e,t))];case"sin":return[sin(getParamValue("x",n,e,t))];case"sign":return[sign(getParamValue("x",n,e,t))];case"sinh":return[sinh(getParamValue("x",n,e,t))];case"softplus":return[softplus(getParamValue("x",n,e,t))];case"sqrt":return[sqrt(getParamValue("x",n,e,t))];case"square":return[square(getParamValue("x",n,e,t))];case"tanh":return[tanh$1(getParamValue("x",n,e,t))];case"tan":return[tan(getParamValue("x",n,e,t))];case"clipByValue":return[clipByValue(getParamValue("x",n,e,t),getParamValue("clipValueMin",n,e,t),getParamValue("clipValueMax",n,e,t))];case"rsqrt":return[div(scalar(1,"float32"),sqrt(getTensor(n.inputNames[0],e,t)))];case"prod":return[prod(getParamValue("x",n,e,t),getParamValue("axes",n,e,t))];case"leakyRelu":return[leakyRelu(getParamValue("x",n,e,t),getParamValue("alpha",n,e,t))];default:throw TypeError("Node type "+n.op+" is not implemented");}},TensorArray=function(){function p(e,t,a,r,n,o,s){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=r,this.identicalElementShapes=n,this.dynamicSize=o,this.clearAfterRead=s,this.tensors=[],this.closed_=!1,this.id=p.nextId++}return Object.defineProperty(p.prototype,"closed",{get:function(){return this.closed_},enumerable:!0,configurable:!0}),p.prototype.clearAndClose=function(){this.tensors.forEach(function(t){return t.tensor.dispose()}),this.tensors=[],this.closed_=!0},p.prototype.size=function(){return this.tensors.length},p.prototype.read=function(a){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(0>a||a>=this.tensors.length)throw new Error("Tried to read from index "+a+", but array size is: "+this.tensors.length);var e=this.tensors[a];if(e.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+a+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor},p.prototype.readMany=function(a){var n=this;return a.map(function(t){return n.read(t)})},p.prototype.write=function(n,e){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(0>n||!this.dynamicSize&&n>=this.maxSize)throw new Error("Tried to write to index "+n+", but array is not resizeable and size is: "+this.maxSize);var t=this.tensors[n]||{};if(e.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+n+",\n          because the value dtype is "+e.dtype+", but TensorArray dtype is "+this.dtype+".");if(0===this.size()&&0===this.elementShape.length&&(this.elementShape=e.shape),this.assertShapesMatch(this.elementShape,e.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+n+"."),t&&t.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+n+", because it has already been read.");if(t&&t.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+n+", because it has already been written.");t.tensor=e,t.written=!0,this.tensors[n]=t},p.prototype.writeMany=function(n,o){var t=this;if(n.length!==o.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+n.length+" is not the same as tensors size: "+o.length+".");n.forEach(function(a,e){return t.write(a,o[e])})},p.prototype.gather=function(n,o){if(o&&o!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+o);if(!n){n=[];for(var t=0;t<this.size();t++)n.push(t)}if(0===n.length)return tensor([],[0].concat(this.elementShape));var s=this.readMany(n);return this.assertShapesMatch(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),stack(s,0)},p.prototype.concat=function(n){if(n&&n!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+n);if(0===this.size())return tensor([],[0].concat(this.elementShape));for(var e=[],t=0;t<this.size();t++)e.push(t);var o=this.readMany(e);return this.assertShapesMatch(this.elementShape,o[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+o[0].shape+")"),concat(o,0)},p.prototype.scatter=function(n,e){if(e.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+e.dtype);if(n.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+n.length+" vs. "+e.shape[0]);var t=_Mathmax.apply(Math,n);if(!this.dynamicSize&&t>=this.maxSize)throw new Error("Max index must be < array size ("+t+"  vs. "+this.maxSize+")");this.writeMany(n,unstack(e,0))},p.prototype.split=function(l,e){var d=this;if(e.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+e.dtype);var a=0,u=l.map(function(t){return a+=t});if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+a+", and tensor's shape is: "+e.shape);if(!this.dynamicSize&&l.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+l.length+"), and the TensorArray is not marked as dynamically resizeable");var n=0===a?0:e.size/a,o=[];tidy(function(){e=e.reshape([1,a,n]);for(var t=0;t<l.length;++t){var r=[0,0==t?0:u[t-1],0],s=[1,l[t],n];o[t]=slice(e,r,s).reshape(d.elementShape)}return o});for(var s=[],i=0;i<l.length;i++)s[i]=i;this.writeMany(s,o)},p.prototype.assertShapesMatch=function(n,e,t){void 0===t&&(t=""),util.assert(this.arraysEqual(n,e),t+" Shapes "+n+" and "+e+" must match")},p.prototype.arraysEqual=function(n,e){if(n.length!==e.length)return!1;for(var t=0;t<n.length;t++)if(-1!==n[t]&&-1!==e[t]&&n[t]!==e[t])return!1;return!0},p.nextId=0,p}(),executeOp$3=function(l,e,t){switch(l.op){case"conv1d":var a=getParamValue("stride",l,e,t),d=getParamValue("pad",l,e,t),u=getParamValue("dataFormat",l,e,t).toUpperCase(),c=getParamValue("dilation",l,e,t);return[conv1d(getParamValue("x",l,e,t),getParamValue("filter",l,e,t),a,d,u,c)];case"conv2d":a=getParamValue("strides",l,e,t),d=getParamValue("pad",l,e,t),u=getParamValue("dataFormat",l,e,t).toUpperCase();var s=getParamValue("dilations",l,e,t);return[conv2d(getParamValue("x",l,e,t),getParamValue("filter",l,e,t),[a[1],a[2]],d,u,[s[0],s[1]])];case"conv2dTranspose":var h=getParamValue("outputShape",l,e,t);return a=getParamValue("strides",l,e,t),d=getParamValue("pad",l,e,t),[conv2dTranspose(getParamValue("x",l,e,t),getParamValue("filter",l,e,t),h,[a[1],a[2]],d)];case"depthwiseConv2d":return a=getParamValue("strides",l,e,t),d=getParamValue("pad",l,e,t),s=getParamValue("dilations",l,e,t),u=getParamValue("dataFormat",l,e,t).toUpperCase(),[depthwiseConv2d(getParamValue("input",l,e,t),getParamValue("filter",l,e,t),[a[1],a[2]],d,u,[s[0],s[1]])];case"avgPool":a=getParamValue("strides",l,e,t),d=getParamValue("pad",l,e,t);var p=getParamValue("kernelSize",l,e,t);return[avgPool(getParamValue("x",l,e,t),[p[1],p[2]],[a[1],a[2]],d)];case"maxPool":return a=getParamValue("strides",l,e,t),d=getParamValue("pad",l,e,t),p=getParamValue("kernelSize",l,e,t),[maxPool(getParamValue("x",l,e,t),[p[1],p[2]],[a[1],a[2]],d)];default:throw TypeError("Node type "+l.op+" is not implemented");}},executeOp$4=function(b,e,t){switch(b.op){case"fill":var a=getParamValue("shape",b,e,t),x=getParamValue("dtype",b,e,t),n=getParamValue("value",b,e,t);return[fill(a,n,x)];case"linspace":var o=getParamValue("start",b,e,t),N=getParamValue("stop",b,e,t),i=getParamValue("num",b,e,t);return[linspace(o,N,i)];case"oneHot":var p=getParamValue("indices",b,e,t),m=getParamValue("depth",b,e,t),u=getParamValue("onValue",b,e,t),l=getParamValue("offValue",b,e,t);return[oneHot(p,m,u,l)];case"ones":return[ones$1(getParamValue("shape",b,e,t),getParamValue("dtype",b,e,t))];case"onesLike":return[onesLike(getParamValue("x",b,e,t))];case"randomUniform":return[randomUniform(getParamValue("shape",b,e,t),getParamValue("minval",b,e,t),getParamValue("maxval",b,e,t),getParamValue("dtype",b,e,t))];case"range":o=getParamValue("start",b,e,t);var d=getParamValue("stop",b,e,t),c=getParamValue("step",b,e,t);return[range(o,d,c,getParamValue("dtype",b,e,t))];case"truncatedNormal":a=getParamValue("shape",b,e,t);var f=getParamValue("mean",b,e,t),y=getParamValue("stdDev",b,e,t),h=getParamValue("seed",b,e,t);return[truncatedNormal(a,f,y,getParamValue("dtype",b,e,t),h)];case"zeros":return[zeros(getParamValue("shape",b,e,t),getParamValue("dtype",b,e,t))];case"zerosLike":return[zerosLike(getParamValue("x",b,e,t))];default:throw TypeError("Node type "+b.op+" is not implemented");}},executeOp$6=function(i,e,t){switch(i.op){case"topK":var a=getParamValue("x",i,e,t),r=getParamValue("k",i,e,t),n=getParamValue("sorted",i,e,t),o=topk(a,r,n);return[o.values,o.indices];default:throw TypeError("Node type "+i.op+" is not implemented");}},executeOp$7=function(l,e,t){switch(l.op){case"const":return e[l.name];case"placeholder":var a=getParamValue("default",l,e,t);return[getTensor(l.name,e,t)||a];case"identity":case"stopGradient":case"fakeQuantWithMinMaxVars":return[getParamValue("x",l,e,t).clone()];case"snapshot":return[getParamValue("x",l,e,t).clone()];case"shape":return[tensor1d(getParamValue("x",l,e,t).shape,"int32")];case"shapeN":return getParamValue("x",l,e,t).map(function(t){return tensor1d(t.shape)});case"size":return[scalar(getParamValue("x",l,e,t).size,"int32")];case"rank":return[scalar(getParamValue("x",l,e,t).rank,"int32")];case"noop":return[];case"print":var r=getParamValue("x",l,e,t),n=getParamValue("data",l,e,t),o=getParamValue("message",l,e,t),s=getParamValue("summarize",l,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(var i=0;i<n.length;i++)console.log(Array.prototype.slice.call(n[0].dataSync()).slice(0,s));return[r];default:throw TypeError("Node type "+l.op+" is not implemented");}},executeOp$8=function(d,e,t){switch(d.op){case"resizeBilinear":var a=getParamValue("images",d,e,t),c=getParamValue("size",d,e,t),h=getParamValue("alignCorners",d,e,t);return[image_ops.resizeBilinear(a,[c[0],c[1]],h)];case"resizeNearestNeighbor":return a=getParamValue("images",d,e,t),c=getParamValue("size",d,e,t),h=getParamValue("alignCorners",d,e,t),[image_ops.resizeNearestNeighbor(a,[c[0],c[1]],h)];case"cropAndResize":var g=getParamValue("image",d,e,t),s=getParamValue("boxes",d,e,t),i=getParamValue("boxInd",d,e,t),p=getParamValue("cropSize",d,e,t),m=getParamValue("method",d,e,t),u=getParamValue("extrapolationValue",d,e,t);return[image_ops.cropAndResize(g,s,i,p,m,u)];default:throw TypeError("Node type "+d.op+" is not implemented");}},executeOp$9=function(n,e,t){switch(n.op){case"equal":return[equal(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"notEqual":return[notEqual(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"greater":return[greater(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"greaterEqual":return[greaterEqual(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"less":return[less(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"lessEqual":return[lessEqual(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"logicalAnd":return[logicalAnd(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"logicalNot":return[logicalNot(getParamValue("a",n,e,t))];case"logicalOr":return[logicalOr(getParamValue("a",n,e,t),getParamValue("b",n,e,t))];case"where":return[where(getParamValue("condition",n,e,t),getParamValue("a",n,e,t),getParamValue("b",n,e,t))];default:throw TypeError("Node type "+n.op+" is not implemented");}},executeOp$10=function(n,e,t){switch(n.op){case"matMul":return[matMul(getParamValue("a",n,e,t),getParamValue("b",n,e,t),getParamValue("transposeA",n,e,t),getParamValue("transposeB",n,e,t))];case"transpose":return[transpose(getParamValue("x",n,e,t),getParamValue("perm",n,e,t))];default:throw TypeError("Node type "+n.op+" is not implemented");}},executeOp$11=function(n,e,t){switch(n.op){case"batchNormalization":return[batchNormalization(getParamValue("x",n,e,t),getParamValue("mean",n,e,t),getParamValue("variance",n,e,t),getParamValue("epsilon",n,e,t),getParamValue("scale",n,e,t),getParamValue("offset",n,e,t))];case"localResponseNormalization":return[localResponseNormalization(getParamValue("x",n,e,t),getParamValue("radius",n,e,t),getParamValue("bias",n,e,t),getParamValue("alpha",n,e,t),getParamValue("beta",n,e,t))];case"softmax":return[softmax(getParamValue("x",n,e,t))];case"logSoftmax":return[logSoftmax(getParamValue("x",n,e,t))];case"sparseToDense":return[sparseToDense(getParamValue("sparseIndices",n,e,t),getParamValue("outputShape",n,e,t),getParamValue("sparseValues",n,e,t),getParamValue("defaultValue",n,e,t))];default:throw TypeError("Node type "+n.op+" is not implemented");}},executeOp$12=function(o,e,t){switch(o.op){case"max":var a=getParamValue("axis",o,e,t),s=getParamValue("keepDims",o,e,t);return[max(getParamValue("x",o,e,t),a,s)];case"mean":return a=getParamValue("axis",o,e,t),s=getParamValue("keepDims",o,e,t),[mean(getParamValue("x",o,e,t),a,s)];case"min":return a=getParamValue("axis",o,e,t),s=getParamValue("keepDims",o,e,t),[min(getParamValue("x",o,e,t),a,s)];case"sum":return a=getParamValue("axis",o,e,t),s=getParamValue("keepDims",o,e,t),[sum$1(getParamValue("x",o,e,t),a,s)];case"all":return a=getParamValue("axis",o,e,t),s=getParamValue("keepDims",o,e,t),[all(getParamValue("x",o,e,t),a,s)];case"any":return a=getParamValue("axis",o,e,t),s=getParamValue("keepDims",o,e,t),[any(getParamValue("x",o,e,t),a,s)];case"argMax":return a=getParamValue("axis",o,e,t),[argMax(getParamValue("x",o,e,t),a)];case"argMin":return a=getParamValue("axis",o,e,t),[argMin(getParamValue("x",o,e,t),a)];case"prod":return a=getParamValue("axis",o,e,t),s=getParamValue("keepDims",o,e,t),[prod(getParamValue("x",o,e,t),a,s)];default:throw TypeError("Node type "+o.op+" is not implemented");}},executeOp$13=function(S,e,t){switch(S.op){case"concat":var a=getParamValue("axis",S,e,t),C=getParamValue("tensors",S,e,t);return[concat(C,a)];case"gather":a=getParamValue("axis",S,e,t);var n=getParamValue("x",S,e,t),k=getParamValue("indices",S,e,t);return[gather(n,k,a)];case"reverse":return a=getParamValue("axis",S,e,t),n=getParamValue("x",S,e,t),[reverse(n,a)];case"slice":var T=getParamValue("begin",S,e,t),E=getParamValue("size",S,e,t);return[slice(getParamValue("x",S,e,t),T,E)];case"stridedSlice":T=getParamValue("begin",S,e,t);var p=getParamValue("end",S,e,t),m=getParamValue("strides",S,e,t),u=getParamValue("beginMask",S,e,t),l=getParamValue("endMask",S,e,t),d=getParamValue("ellipsisMask",S,e,t),c=getParamValue("newAxisMask",S,e,t),f=getParamValue("shrinkAxisMask",S,e,t),y=getParamValue("x",S,e,t);if(1===T.length&&1<y.shape.length)for(var h=1;h<y.shape.length;h++)T.push(0),p.push(y.shape[h]),m.push(m[0]);return[stridedSlice(y,T,p,m,u,l,d,c,f)];case"stack":return tidy(function(){var a=getParamValue("axis",S,e,t),r=getParamValue("tensors",S,e,t),n=r[0].shape,o=r[0].squeeze().shape,s=r.map(function(a){var e=util.arraysEqual(a.shape,n);if(!e&&!util.arraysEqual(a.squeeze().shape,o))throw new Error("the input tensors shape does not match");return e?a:a.reshape(n)});return[stack(s,a)]});case"unstack":return tidy(function(){var a=getParamValue("axis",S,e,t),r=getParamValue("tensor",S,e,t);return unstack(r,a)});case"tile":var R=getParamValue("reps",S,e,t);return[tile(getParamValue("x",S,e,t),R)];case"split":a=getParamValue("axis",S,e,t);var N=getParamValue("numOrSizeSplits",S,e,t);return split$1(getParamValue("x",S,e,t),N,a);case"scatterNd":k=getParamValue("indices",S,e,t);var D=getParamValue("values",S,e,t),x=getParamValue("shape",S,e,t);return[scatterND(k,D,x)];case"gatherNd":var w=getParamValue("x",S,e,t);return k=getParamValue("indices",S,e,t),[gatherND(w,k)];case"sparseToDense":k=getParamValue("sparseIndices",S,e,t),x=getParamValue("outputShape",S,e,t);var I=getParamValue("sparseValues",S,e,t),v=getParamValue("defaultValue",S,e,t);return[sparseToDense(k,I,x,v)];default:throw TypeError("Node type "+S.op+" is not implemented");}},executeOp$14=function(l,e,t){switch(l.op){case"cast":return[cast(getParamValue("x",l,e,t),getParamValue("dtype",l,e,t))];case"expandDims":var a=getParamValue("axis",l,e,t);return[expandDims(getParamValue("x",l,e,t),a)];case"squeeze":return a=getParamValue("axis",l,e,t),[squeeze(getParamValue("x",l,e,t),a)];case"reshape":return[reshape(getParamValue("x",l,e,t),getParamValue("shape",l,e,t))];case"pad":return[pad(getParamValue("x",l,e,t),split$1$1(getParamValue("padding",l,e,t),2),getParamValue("constantValue",l,e,t))];case"spaceToBatchND":var d=getParamValue("blockShape",l,e,t),u=split$1$1(getParamValue("paddings",l,e,t),2);return[spaceToBatchND(getParamValue("x",l,e,t),d,u)];case"batchToSpaceND":d=getParamValue("blockShape",l,e,t);var o=split$1$1(getParamValue("crops",l,e,t),2);return[batchToSpaceND(getParamValue("x",l,e,t),d,o)];case"depthToSpace":var s=getParamValue("blockSize",l,e,t),i=getParamValue("dataFormat",l,e,t);return[depthToSpace(getParamValue("x",l,e,t),s,i)];default:throw TypeError("Node type "+l.op+" is not implemented");}},ExecutionContext=function(){function t(a,e){this.weightMap=a,this.tensorArrayMap=e,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}return t.prototype.newFrame=function(a,e){return{id:a,frameName:e,iterationId:0}},Object.defineProperty(t.prototype,"currentContext",{get:function(){return this.contexts},set:function(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"currentContextIds",{get:function(){return this._currentContextIds},enumerable:!0,configurable:!0}),t.prototype.generateCurrentContextIds=function(){for(var n=[],e=0,r;e<this.contexts.length-1;e++)r=this.contexts.slice(0,this.contexts.length-e),n.push(this.contextIdforContexts(r));n.push(""),this._currentContextIds=n},t.prototype.contextIdforContexts=function(t){return t?t.map(function(t){return 0===t.id&&0===t.iterationId?"":t.frameName+"-"+t.iterationId}).join("/"):""},t.prototype.enterFrame=function(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))},t.prototype.exitFrame=function(){if(!(this.contexts&&1<this.contexts.length))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()},t.prototype.nextIteration=function(){if(!(this.contexts&&0<this.contexts.length))throw new Error("Cannot increase frame iteration, the context is empty");this.contexts=this.contexts.slice(),this.lastId++;var t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))},t.prototype.getWeight=function(t){return this.weightMap[t]},t.prototype.addTensorArray=function(t){this.tensorArrayMap[t.id]=t},t.prototype.getTensorArray=function(t){return this.tensorArrayMap[t]},t}(),GraphExecutor=function(){function t(t){this.graph=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this.placeholders=t.placeholders,this._outputs=t.outputs,this.compile()}return Object.defineProperty(t.prototype,"weightMap",{get:function(){return this._weightMap},set:function(a){var e=Object.keys(a).map(function(e){return a[e].map(function(t){return t.id})});this.weightIds=[].concat.apply([],e),this._weightMap=a},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"inputs",{get:function(){return this.placeholders.map(function(t){return{name:t.name,shape:t.params.shape?t.params.shape.value:void 0,dtype:t.params.dtype?t.params.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"outputs",{get:function(){return this._outputs.map(function(t){return{name:t.name,shape:t.params.shape?t.params.shape.value:void 0,dtype:t.params.dtype?t.params.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"inputNodes",{get:function(){return this.placeholders.map(function(t){return t.name})},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"outputNodes",{get:function(){return this.outputs.map(function(t){return t.name})},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isControlFlowModel",{get:function(){return this.graph.withControlFlow},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isDynamicShapeModel",{get:function(){return this.graph.withDynamicShape},enumerable:!0,configurable:!0}),t.prototype.compile=function(i){if(!this.graph.withControlFlow&&!this.graph.withDynamicShape){var e=[],t=i||this.graph.placeholders,a=t.map(function(t){return t.name}).sort().join(this.SEPERATOR);if(!this.compiledMap.get(a)){for(var r=t.concat(this.graph.weights),n={},o;0<r.length;)o=r.pop(),n[o.name]=!0,e.push(o),o.children.forEach(function(t){!n[t.name]&&t.inputNames.every(function(a){var e=getNodeNameAndIndex(a)[0];return n[e]})&&r.push(t)});this.compiledMap.set(a,e)}}},t.prototype.execute=function(d,e,i){var c=this;void 0===e&&(e=!0);var r=Object.keys(d).sort();this.checkInput(d,e),this.checkInputShapeAndType(d,e),this.compile(r.map(function(t){return c.graph.nodes[t]}));var n=this.calculateOutputs(i);this.checkOutput(this.compiledMap.get(r.join(this.SEPERATOR)),n);var o={};return tidy(function(){for(var e=new ExecutionContext(c._weightMap,o),t=__assign$2({},c.weightMap,d),a=c.getFrozenTensorIds(t),s={},i=c.compiledMap.get(r.join(c.SEPERATOR)),p=0,m;p<i.length&&(m=i[p],t[m.name]||(t[m.name]=executeOp$15(m,t,e),c.checkTensorForDisposal(m.name,m,t,e,a,s)),!n.every(function(a){return!!t[a]}));p++);return c.findOutputs(t,e,n)})},t.prototype.getFrozenTensorIds=function(a){var e=[].concat.apply([],Object.keys(a).map(function(e){return a[e]}).map(function(t){return t.map(function(t){return t.id})}));return new Set(e)},t.prototype.checkTensorForDisposal=function(s,i,p,a,r,n){"control"!==i.category&&(p[s].forEach(function(t){null!=t&&(n[t.id]=(n[t.id]||0)+i.children.length)}),i.inputs.forEach(function(o){if("control"!==o.category){var e=getTensorsForCurrentContenxt(o.name,p,a);null!=e&&e.forEach(function(a){if(a&&!r.has(a.id)){var e=n[a.id];1===e?(a.dispose(),delete n[a.id]):null!=e&&n[a.id]--}})}}))},t.prototype.executeAsync=function(l,e){return __awaiter$2(this,void 0,void 0,function(){var t=this,d,c,m,h,g,f,y;return __generator$2(this,function(a){switch(a.label){case 0:return this.checkInput(l,!1),this.checkInputShapeAndType(l,!1),d={},c=new ExecutionContext(this._weightMap,d),[4,this.executeWithControlFlow(l,c)];case 1:return m=a.sent(),h=this.findOutputs(m,c,e),g=Object.keys(h).map(function(t){return h[t].id}),f=Object.keys(l).map(function(e){return l[e].map(function(t){return t.id})}),y=[].concat.apply([],f),Object.keys(m).forEach(function(a){m[a].forEach(function(a){a&&-1===g.indexOf(a.id)&&-1===y.indexOf(a.id)&&-1===t.weightIds.indexOf(a.id)&&a.dispose()})}),[2,h];}})})},t.prototype.executeWithControlFlow=function(d,c){return __awaiter$2(this,void 0,void 0,function(){var t=this,e,u,h,g,f,y,b,x;return __generator$2(this,function(a){switch(a.label){case 0:e=Object.keys(d),u=e.map(function(a){return t.graph.nodes[a]}),h=u.concat(this.graph.weights).map(function(t){return{node:t,contexts:c.currentContext}}),g=__assign$2({},this.weightMap,d),f={},y=this.getFrozenTensorIds(g),b={},a.label=1;case 1:return 0<h.length?(x=this.processStack(u,h,c,g,b,y,f),[4,Promise.all(x)]):[3,3];case 2:return a.sent(),[3,1];case 3:return[2,g];}})})},t.prototype.processStack=function(h,g,t,a,r,n,o){for(var s=this,e=[],i=function(){var i=g.pop();t.currentContext=i.contexts;var u="";if("enter"===i.node.op&&getParamValue("isConstant",i.node,a,t)&&(u=getNodeNameAndIndex(i.node.name,t)[0]),-1===h.indexOf(i.node)){var m=executeOp$15(i.node,a,t);u||(u=getNodeNameAndIndex(i.node.name,t)[0]);var d=t.currentContext;m instanceof Promise?e.push(m.then(function(p){return a[u]=p,t.currentContext=d,s.checkTensorForDisposal(u,i.node,a,t,n,o),s.processChildNodes(i.node,g,t,a,r),p})):(a[u]=m,p.checkTensorForDisposal(u,i.node,a,t,n,o),p.processChildNodes(i.node,g,t,a,r))}else p.processChildNodes(i.node,g,t,a,r)},p=this;0<g.length;)i();return e},t.prototype.processChildNodes=function(o,s,t,a,r){o.children.forEach(function(n){var e=getNodeNameAndIndex(n.name,t)[0];r[e]||("merge"===n.op?n.inputNames.some(function(n){return!!getTensor(n,a,t)})&&(r[e]=!0,s.push({contexts:t.currentContext,node:n})):n.inputNames.every(function(n){return!!getTensor(n,a,t)})&&(r[e]=!0,s.push({contexts:t.currentContext,node:n})))})},t.prototype.calculateOutputs=function(t){return!t||t instanceof Array||(t=[t]),t||this.graph.outputs.map(function(t){return t.name})},t.prototype.findOutputs=function(n,e,t){return this.calculateOutputs(t).reduce(function(t,a){return t[a]=getTensor(a,n,e),t},{})},t.prototype.dispose=function(){var a=this;Object.keys(this.weightMap).forEach(function(e){return a.weightMap[e].forEach(function(t){return t.dispose()})})},t.prototype.checkInputShapeAndType=function(i,e){void 0===e&&(e=!0),this.placeholders.forEach(function(t){var a=i[t.name];if(e||a){var r=a[0];if(t.params.shape&&t.params.shape.value){var n=t.params.shape.value,o=n.length===r.shape.length&&r.shape.every(function(a,e){return-1===n[e]||n[e]===a});util.assert(o,"The shape of dict['"+t.name+"'] provided in model.execute(dict) must be ["+n+"], but was ["+r.shape+"]")}t.params.dtype&&t.params.dtype.value&&util.assert(r.dtype===t.params.dtype.value,"The dtype of dict['"+t.name+"'] provided in model.execute(dict) must be "+t.params.dtype.value+", but was "+r.dtype)}})},t.prototype.checkInput=function(i,e){var p=this;void 0===e&&(e=!0);var a=Object.keys(i),r=[],n=[];this.inputNodes.forEach(function(t){-1===a.indexOf(t)&&r.push(t)}),a.forEach(function(t){-1===p.inputNodes.indexOf(t)&&n.push(t)});var o=n.filter(function(t){return!p.graph.nodes[t]});if(0<r.length&&e)throw new Error("The dict provided in model.execute(dict) has the keys ["+a+"], but is missing the required keys: ["+r+"].");if(0<n.length&&e)throw new Error("The dict provided in model.execute(dict) has unused keys: []. Please provide only the following keys: ["+this.inputNodes+"].");if(0<o.length)throw new Error("The dict provided in model.execute(dict) has keys: ["+o+"] not part of model graph.")},t.prototype.checkOutput=function(n,e){var t=n.map(function(t){return t.name}),a=[];if(e.forEach(function(n){-1===t.indexOf(n)&&a.push(n)}),0<a.length)throw new Error("The following outputs are not be generated by the execution: [].")},t}(),FrozenModel=function(){function t(n,e,t){this.modelUrl=n,this.weightManifestUrl=e,this.requestOption=t,this.version="n/a"}return Object.defineProperty(t.prototype,"modelVersion",{get:function(){return this.version},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:!0,configurable:!0}),t.prototype.findIOHandler=function(){var a=[this.modelUrl,this.weightManifestUrl];if(this.requestOption)this.handler=io.browserHTTPRequest(a,this.requestOption);else{var e=io.getLoadHandlers(a);if(0===e.length)e.push(io.browserHTTPRequest(a,this.requestOption));else if(1<e.length)throw new Error("Found more than one ("+e.length+") load handlers for URL '"+[a]+"'");this.handler=e[0]}},t.prototype.load=function(){return __awaiter$2(this,void 0,void 0,function(){var n,o,s;return __generator$2(this,function(e){switch(e.label){case 0:if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,this.handler.load()];case 1:return n=e.sent(),o=compiled_api_1.GraphDef.decode(new Uint8Array(n.modelTopology)),this.version=o.versions.producer+"."+o.versions.minConsumer,s=io.decodeWeights(n.weightData,n.weightSpecs),this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(o)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),[2,!0];}})})},t.prototype.predict=function(t){return this.execute_(t,!0,this.outputNodes)},t.prototype.constructTensorMap=function(a){var n=a instanceof Tensor?[a]:a;if(n.length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,the frozen model has "+this.inputNodes.length+" placeholders, while there are "+n.length+" input tensors.");return this.inputNodes.reduce(function(t,e,a){return t[e]=n[a],t},{})},t.prototype.execute=function(a,e){return this.execute_(a,!1,e)},t.prototype.execute_=function(o,s,i){if(void 0===s&&(s=!0),i=i||this.outputNodes,(o instanceof Tensor||Array.isArray(o))&&(o=this.constructTensorMap(o)),this.executor.isControlFlowModel||this.executor.isDynamicShapeModel)throw new Error("The model contains control flow or dynamic shape ops, please use executeAsync method");var p=this.executor.execute(this.convertTensorMapToTensorsMap(o),s,i),r=Object.keys(p);return Array.isArray(i)&&1<i.length?i.map(function(t){return p[t]}):p[r[0]]},t.prototype.executeAsync=function(o,s){return __awaiter$2(this,void 0,void 0,function(){var t,e;return __generator$2(this,function(a){switch(a.label){case 0:if(!this.executor.isControlFlowModel&&!this.executor.isDynamicShapeModel)throw new Error("The model does not contain control flow or dynamic shape ops, please use execute method for better performance.");return s=s||this.outputNodes,(o instanceof Tensor||Array.isArray(o))&&(o=this.constructTensorMap(o)),[4,this.executor.executeAsync(this.convertTensorMapToTensorsMap(o),s)];case 1:return t=a.sent(),e=Object.keys(t),[2,Array.isArray(s)&&1<s.length?s.map(function(a){return t[a]}):t[e[0]]];}})})},t.prototype.convertTensorMapToTensorsMap=function(n){return Object.keys(n).reduce(function(e,t){return e[t]=[n[t]],e},{})},t.prototype.dispose=function(){this.executor.dispose()},t}();const basePath="https://cdn.jsdelivr.net/npm/handtrackjs/models/web/",defaultParams={flipHorizontal:!0,outputStride:16,imageScaleFactor:.7,maxNumBoxes:20,iouThreshold:.5,scoreThreshold:.99,modelType:"ssdlitemobilenetv2"};class ObjectDetection{constructor(e){this.modelPath=basePath+e.modelType+"/tensorflowjs_model.pb",this.weightPath=basePath+e.modelType+"/weights_manifest.json",this.modelParams=e}async load(){this.fps=0,this.model=await loadFrozenModel(this.modelPath,this.weightPath);// Warmup the model.
const e=await this.model.executeAsync(zeros([1,300,300,3]));e.map(async e=>await e.data()),e.map(async e=>e.dispose())}async detect(e){let t=Date.now();const[a,n]=getInputTensorDimensions(e),r=getValidResolution(this.modelParams.imageScaleFactor,a,this.modelParams.outputStride),o=getValidResolution(this.modelParams.imageScaleFactor,n,this.modelParams.outputStride),s=tidy(()=>{const t=fromPixels(e);return this.modelParams.flipHorizontal?t.reverse(1).resizeBilinear([r,o]).expandDims(0):t.resizeBilinear([r,o]).expandDims(0)});return self=this,this.model.executeAsync(s).then(function(e){const r=e[0].dataSync(),o=e[1].dataSync();s.dispose(),dispose(e);// console.log("scores result",scores, boxes)
const[i,p]=calculateMaxScores(r,e[0].shape[1],e[0].shape[2]),l=getBackend();setBackend("cpu");const d=tidy(()=>{const t=tensor2d(o,[e[1].shape[1],e[1].shape[3]]);return image_ops.nonMaxSuppression(t,r,self.modelParams.maxNumBoxes,// maxNumBoxes
self.modelParams.iouThreshold,// iou_threshold
self.modelParams.scoreThreshold// score_threshold
)}),u=d.dataSync();d.dispose(),setBackend(l);const c=self.buildDetectedObjects(n,a,o,r,u,p);let m=Date.now();return self.fps=_Mathround(1e3/(m-t)),c})}buildDetectedObjects(e,t,a,n,r,o){const s=r.length,p=[];for(let l=0;l<s;l++){const s=[];for(let e=0;4>e;e++)s[e]=a[4*r[l]+e];const i=s[0]*t,d=s[1]*e,u=s[2]*t,c=s[3]*e;s[0]=d,s[1]=i,s[2]=c-d,s[3]=u-i,p.push({bbox:s,class:o[r[l]],score:n[r[l]]})}return p}getFPS(){return this.fps}setModelParameters(e){this.modelParams=Object.assign({},this.modelParams,e)}getModelParameters(){return this.modelParams}renderPredictions(e,t,a,n){a.clearRect(0,0,t.width,t.height),t.width=n.width,t.height=n.height,a.save(),this.modelParams.flipHorizontal&&(a.scale(-1,1),a.translate(-n.width,0)),a.drawImage(n,0,0,n.width,n.height),a.restore(),a.font="10px Arial";// console.log('number of detections: ', predictions.length);
for(let r=0;r<e.length;r++)// draw a dot at the center of bounding box
// "rgba(244,247,251,1)";
a.beginPath(),a.fillStyle="rgba(255, 255, 255, 0.6)",a.fillRect(e[r].bbox[0],e[r].bbox[1]-17,e[r].bbox[2],17),a.rect(...e[r].bbox),a.lineWidth=1,a.strokeStyle="#0063FF",a.fillStyle="#0063FF",a.fillRect(e[r].bbox[0]+e[r].bbox[2]/2,e[r].bbox[1]+e[r].bbox[3]/2,5,5),a.stroke(),a.fillText(e[r].score.toFixed(3)+"  | hand",e[r].bbox[0]+5,10<e[r].bbox[1]?e[r].bbox[1]-5:10);// Write FPS to top left
a.font="bold 12px Arial",a.fillText("[FPS]: "+this.fps,10,20)}dispose(){this.model&&this.model.dispose()}}exports.load=load,exports.startVideo=startVideo,exports.stopVideo=stopVideo,exports.ObjectDetection=ObjectDetection,Object.defineProperty(exports,"__esModule",{value:!0})});

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate)

},{"_process":146,"buffer":76,"crypto":84,"timers":203}],3:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill.js');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill.js":4}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var symbol_observable_1 = require("symbol-observable");
var NO = {};
exports.NO = NO;
function noop() { }
function cp(a) {
    var l = a.length;
    var b = Array(l);
    for (var i = 0; i < l; ++i)
        b[i] = a[i];
    return b;
}
function and(f1, f2) {
    return function andFn(t) {
        return f1(t) && f2(t);
    };
}
function _try(c, t, u) {
    try {
        return c.f(t);
    }
    catch (e) {
        u._e(e);
        return NO;
    }
}
var NO_IL = {
    _n: noop,
    _e: noop,
    _c: noop,
};
exports.NO_IL = NO_IL;
// mutates the input
function internalizeProducer(producer) {
    producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
    };
    producer._stop = producer.stop;
}
var StreamSub = /** @class */ (function () {
    function StreamSub(_stream, _listener) {
        this._stream = _stream;
        this._listener = _listener;
    }
    StreamSub.prototype.unsubscribe = function () {
        this._stream._remove(this._listener);
    };
    return StreamSub;
}());
var Observer = /** @class */ (function () {
    function Observer(_listener) {
        this._listener = _listener;
    }
    Observer.prototype.next = function (value) {
        this._listener._n(value);
    };
    Observer.prototype.error = function (err) {
        this._listener._e(err);
    };
    Observer.prototype.complete = function () {
        this._listener._c();
    };
    return Observer;
}());
var FromObservable = /** @class */ (function () {
    function FromObservable(observable) {
        this.type = 'fromObservable';
        this.ins = observable;
        this.active = false;
    }
    FromObservable.prototype._start = function (out) {
        this.out = out;
        this.active = true;
        this._sub = this.ins.subscribe(new Observer(out));
        if (!this.active)
            this._sub.unsubscribe();
    };
    FromObservable.prototype._stop = function () {
        if (this._sub)
            this._sub.unsubscribe();
        this.active = false;
    };
    return FromObservable;
}());
var Merge = /** @class */ (function () {
    function Merge(insArr) {
        this.type = 'merge';
        this.insArr = insArr;
        this.out = NO;
        this.ac = 0;
    }
    Merge.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var L = s.length;
        this.ac = L;
        for (var i = 0; i < L; i++)
            s[i]._add(this);
    };
    Merge.prototype._stop = function () {
        var s = this.insArr;
        var L = s.length;
        for (var i = 0; i < L; i++)
            s[i]._remove(this);
        this.out = NO;
    };
    Merge.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    Merge.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Merge.prototype._c = function () {
        if (--this.ac <= 0) {
            var u = this.out;
            if (u === NO)
                return;
            u._c();
        }
    };
    return Merge;
}());
var CombineListener = /** @class */ (function () {
    function CombineListener(i, out, p) {
        this.i = i;
        this.out = out;
        this.p = p;
        p.ils.push(this);
    }
    CombineListener.prototype._n = function (t) {
        var p = this.p, out = this.out;
        if (out === NO)
            return;
        if (p.up(t, this.i)) {
            var a = p.vals;
            var l = a.length;
            var b = Array(l);
            for (var i = 0; i < l; ++i)
                b[i] = a[i];
            out._n(b);
        }
    };
    CombineListener.prototype._e = function (err) {
        var out = this.out;
        if (out === NO)
            return;
        out._e(err);
    };
    CombineListener.prototype._c = function () {
        var p = this.p;
        if (p.out === NO)
            return;
        if (--p.Nc === 0)
            p.out._c();
    };
    return CombineListener;
}());
var Combine = /** @class */ (function () {
    function Combine(insArr) {
        this.type = 'combine';
        this.insArr = insArr;
        this.out = NO;
        this.ils = [];
        this.Nc = this.Nn = 0;
        this.vals = [];
    }
    Combine.prototype.up = function (t, i) {
        var v = this.vals[i];
        var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
        this.vals[i] = t;
        return Nn === 0;
    };
    Combine.prototype._start = function (out) {
        this.out = out;
        var s = this.insArr;
        var n = this.Nc = this.Nn = s.length;
        var vals = this.vals = new Array(n);
        if (n === 0) {
            out._n([]);
            out._c();
        }
        else {
            for (var i = 0; i < n; i++) {
                vals[i] = NO;
                s[i]._add(new CombineListener(i, out, this));
            }
        }
    };
    Combine.prototype._stop = function () {
        var s = this.insArr;
        var n = s.length;
        var ils = this.ils;
        for (var i = 0; i < n; i++)
            s[i]._remove(ils[i]);
        this.out = NO;
        this.ils = [];
        this.vals = [];
    };
    return Combine;
}());
var FromArray = /** @class */ (function () {
    function FromArray(a) {
        this.type = 'fromArray';
        this.a = a;
    }
    FromArray.prototype._start = function (out) {
        var a = this.a;
        for (var i = 0, n = a.length; i < n; i++)
            out._n(a[i]);
        out._c();
    };
    FromArray.prototype._stop = function () {
    };
    return FromArray;
}());
var FromPromise = /** @class */ (function () {
    function FromPromise(p) {
        this.type = 'fromPromise';
        this.on = false;
        this.p = p;
    }
    FromPromise.prototype._start = function (out) {
        var prod = this;
        this.on = true;
        this.p.then(function (v) {
            if (prod.on) {
                out._n(v);
                out._c();
            }
        }, function (e) {
            out._e(e);
        }).then(noop, function (err) {
            setTimeout(function () { throw err; });
        });
    };
    FromPromise.prototype._stop = function () {
        this.on = false;
    };
    return FromPromise;
}());
var Periodic = /** @class */ (function () {
    function Periodic(period) {
        this.type = 'periodic';
        this.period = period;
        this.intervalID = -1;
        this.i = 0;
    }
    Periodic.prototype._start = function (out) {
        var self = this;
        function intervalHandler() { out._n(self.i++); }
        this.intervalID = setInterval(intervalHandler, this.period);
    };
    Periodic.prototype._stop = function () {
        if (this.intervalID !== -1)
            clearInterval(this.intervalID);
        this.intervalID = -1;
        this.i = 0;
    };
    return Periodic;
}());
var Debug = /** @class */ (function () {
    function Debug(ins, arg) {
        this.type = 'debug';
        this.ins = ins;
        this.out = NO;
        this.s = noop;
        this.l = '';
        if (typeof arg === 'string')
            this.l = arg;
        else if (typeof arg === 'function')
            this.s = arg;
    }
    Debug.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Debug.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Debug.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var s = this.s, l = this.l;
        if (s !== noop) {
            try {
                s(t);
            }
            catch (e) {
                u._e(e);
            }
        }
        else if (l)
            console.log(l + ':', t);
        else
            console.log(t);
        u._n(t);
    };
    Debug.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Debug.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Debug;
}());
var Drop = /** @class */ (function () {
    function Drop(max, ins) {
        this.type = 'drop';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.dropped = 0;
    }
    Drop.prototype._start = function (out) {
        this.out = out;
        this.dropped = 0;
        this.ins._add(this);
    };
    Drop.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Drop.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        if (this.dropped++ >= this.max)
            u._n(t);
    };
    Drop.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Drop.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Drop;
}());
var EndWhenListener = /** @class */ (function () {
    function EndWhenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    EndWhenListener.prototype._n = function () {
        this.op.end();
    };
    EndWhenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    EndWhenListener.prototype._c = function () {
        this.op.end();
    };
    return EndWhenListener;
}());
var EndWhen = /** @class */ (function () {
    function EndWhen(o, ins) {
        this.type = 'endWhen';
        this.ins = ins;
        this.out = NO;
        this.o = o;
        this.oil = NO_IL;
    }
    EndWhen.prototype._start = function (out) {
        this.out = out;
        this.o._add(this.oil = new EndWhenListener(out, this));
        this.ins._add(this);
    };
    EndWhen.prototype._stop = function () {
        this.ins._remove(this);
        this.o._remove(this.oil);
        this.out = NO;
        this.oil = NO_IL;
    };
    EndWhen.prototype.end = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    EndWhen.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    EndWhen.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    EndWhen.prototype._c = function () {
        this.end();
    };
    return EndWhen;
}());
var Filter = /** @class */ (function () {
    function Filter(passes, ins) {
        this.type = 'filter';
        this.ins = ins;
        this.out = NO;
        this.f = passes;
    }
    Filter.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    Filter.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Filter.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO || !r)
            return;
        u._n(t);
    };
    Filter.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Filter.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Filter;
}());
var FlattenListener = /** @class */ (function () {
    function FlattenListener(out, op) {
        this.out = out;
        this.op = op;
    }
    FlattenListener.prototype._n = function (t) {
        this.out._n(t);
    };
    FlattenListener.prototype._e = function (err) {
        this.out._e(err);
    };
    FlattenListener.prototype._c = function () {
        this.op.inner = NO;
        this.op.less();
    };
    return FlattenListener;
}());
var Flatten = /** @class */ (function () {
    function Flatten(ins) {
        this.type = 'flatten';
        this.ins = ins;
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    }
    Flatten.prototype._start = function (out) {
        this.out = out;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
        this.ins._add(this);
    };
    Flatten.prototype._stop = function () {
        this.ins._remove(this);
        if (this.inner !== NO)
            this.inner._remove(this.il);
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
    };
    Flatten.prototype.less = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (!this.open && this.inner === NO)
            u._c();
    };
    Flatten.prototype._n = function (s) {
        var u = this.out;
        if (u === NO)
            return;
        var _a = this, inner = _a.inner, il = _a.il;
        if (inner !== NO && il !== NO_IL)
            inner._remove(il);
        (this.inner = s)._add(this.il = new FlattenListener(u, this));
    };
    Flatten.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Flatten.prototype._c = function () {
        this.open = false;
        this.less();
    };
    return Flatten;
}());
var Fold = /** @class */ (function () {
    function Fold(f, seed, ins) {
        var _this = this;
        this.type = 'fold';
        this.ins = ins;
        this.out = NO;
        this.f = function (t) { return f(_this.acc, t); };
        this.acc = this.seed = seed;
    }
    Fold.prototype._start = function (out) {
        this.out = out;
        this.acc = this.seed;
        out._n(this.acc);
        this.ins._add(this);
    };
    Fold.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.acc = this.seed;
    };
    Fold.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(this.acc = r);
    };
    Fold.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Fold.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Fold;
}());
var Last = /** @class */ (function () {
    function Last(ins) {
        this.type = 'last';
        this.ins = ins;
        this.out = NO;
        this.has = false;
        this.val = NO;
    }
    Last.prototype._start = function (out) {
        this.out = out;
        this.has = false;
        this.ins._add(this);
    };
    Last.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
        this.val = NO;
    };
    Last.prototype._n = function (t) {
        this.has = true;
        this.val = t;
    };
    Last.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Last.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        if (this.has) {
            u._n(this.val);
            u._c();
        }
        else
            u._e(new Error('last() failed because input stream completed'));
    };
    return Last;
}());
var MapOp = /** @class */ (function () {
    function MapOp(project, ins) {
        this.type = 'map';
        this.ins = ins;
        this.out = NO;
        this.f = project;
    }
    MapOp.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    MapOp.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    MapOp.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var r = _try(this, t, u);
        if (r === NO)
            return;
        u._n(r);
    };
    MapOp.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    MapOp.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return MapOp;
}());
var Remember = /** @class */ (function () {
    function Remember(ins) {
        this.type = 'remember';
        this.ins = ins;
        this.out = NO;
    }
    Remember.prototype._start = function (out) {
        this.out = out;
        this.ins._add(out);
    };
    Remember.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return Remember;
}());
var ReplaceError = /** @class */ (function () {
    function ReplaceError(replacer, ins) {
        this.type = 'replaceError';
        this.ins = ins;
        this.out = NO;
        this.f = replacer;
    }
    ReplaceError.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    ReplaceError.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    ReplaceError.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        u._n(t);
    };
    ReplaceError.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
        }
        catch (e) {
            u._e(e);
        }
    };
    ReplaceError.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return ReplaceError;
}());
var StartWith = /** @class */ (function () {
    function StartWith(ins, val) {
        this.type = 'startWith';
        this.ins = ins;
        this.out = NO;
        this.val = val;
    }
    StartWith.prototype._start = function (out) {
        this.out = out;
        this.out._n(this.val);
        this.ins._add(out);
    };
    StartWith.prototype._stop = function () {
        this.ins._remove(this.out);
        this.out = NO;
    };
    return StartWith;
}());
var Take = /** @class */ (function () {
    function Take(max, ins) {
        this.type = 'take';
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.taken = 0;
    }
    Take.prototype._start = function (out) {
        this.out = out;
        this.taken = 0;
        if (this.max <= 0)
            out._c();
        else
            this.ins._add(this);
    };
    Take.prototype._stop = function () {
        this.ins._remove(this);
        this.out = NO;
    };
    Take.prototype._n = function (t) {
        var u = this.out;
        if (u === NO)
            return;
        var m = ++this.taken;
        if (m < this.max)
            u._n(t);
        else if (m === this.max) {
            u._n(t);
            u._c();
        }
    };
    Take.prototype._e = function (err) {
        var u = this.out;
        if (u === NO)
            return;
        u._e(err);
    };
    Take.prototype._c = function () {
        var u = this.out;
        if (u === NO)
            return;
        u._c();
    };
    return Take;
}());
var Stream = /** @class */ (function () {
    function Stream(producer) {
        this._prod = producer || NO;
        this._ils = [];
        this._stopID = NO;
        this._dl = NO;
        this._d = false;
        this._target = NO;
        this._err = NO;
    }
    Stream.prototype._n = function (t) {
        var a = this._ils;
        var L = a.length;
        if (this._d)
            this._dl._n(t);
        if (L == 1)
            a[0]._n(t);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._n(t);
        }
    };
    Stream.prototype._e = function (err) {
        if (this._err !== NO)
            return;
        this._err = err;
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._e(err);
        if (L == 1)
            a[0]._e(err);
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._e(err);
        }
        if (!this._d && L == 0)
            throw this._err;
    };
    Stream.prototype._c = function () {
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
            this._dl._c();
        if (L == 1)
            a[0]._c();
        else if (L == 0)
            return;
        else {
            var b = cp(a);
            for (var i = 0; i < L; i++)
                b[i]._c();
        }
    };
    Stream.prototype._x = function () {
        if (this._ils.length === 0)
            return;
        if (this._prod !== NO)
            this._prod._stop();
        this._err = NO;
        this._ils = [];
    };
    Stream.prototype._stopNow = function () {
        // WARNING: code that calls this method should
        // first check if this._prod is valid (not `NO`)
        this._prod._stop();
        this._err = NO;
        this._stopID = NO;
    };
    Stream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1)
            return;
        if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    Stream.prototype._remove = function (il) {
        var _this = this;
        var ta = this._target;
        if (ta !== NO)
            return ta._remove(il);
        var a = this._ils;
        var i = a.indexOf(il);
        if (i > -1) {
            a.splice(i, 1);
            if (this._prod !== NO && a.length <= 0) {
                this._err = NO;
                this._stopID = setTimeout(function () { return _this._stopNow(); });
            }
            else if (a.length === 1) {
                this._pruneCycles();
            }
        }
    };
    // If all paths stemming from `this` stream eventually end at `this`
    // stream, then we remove the single listener of `this` stream, to
    // force it to end its execution and dispose resources. This method
    // assumes as a precondition that this._ils has just one listener.
    Stream.prototype._pruneCycles = function () {
        if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
    };
    // Checks whether *there is no* path starting from `x` that leads to an end
    // listener (sink) in the stream graph, following edges A->B where B is a
    // listener of A. This means these paths constitute a cycle somehow. Is given
    // a trace of all visited nodes so far.
    Stream.prototype._hasNoSinks = function (x, trace) {
        if (trace.indexOf(x) !== -1)
            return true;
        else if (x.out === this)
            return true;
        else if (x.out && x.out !== NO)
            return this._hasNoSinks(x.out, trace.concat(x));
        else if (x._ils) {
            for (var i = 0, N = x._ils.length; i < N; i++)
                if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
                    return false;
            return true;
        }
        else
            return false;
    };
    Stream.prototype.ctor = function () {
        return this instanceof MemoryStream ? MemoryStream : Stream;
    };
    /**
     * Adds a Listener to the Stream.
     *
     * @param {Listener} listener
     */
    Stream.prototype.addListener = function (listener) {
        listener._n = listener.next || noop;
        listener._e = listener.error || noop;
        listener._c = listener.complete || noop;
        this._add(listener);
    };
    /**
     * Removes a Listener from the Stream, assuming the Listener was added to it.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.removeListener = function (listener) {
        this._remove(listener);
    };
    /**
     * Adds a Listener to the Stream returning a Subscription to remove that
     * listener.
     *
     * @param {Listener} listener
     * @returns {Subscription}
     */
    Stream.prototype.subscribe = function (listener) {
        this.addListener(listener);
        return new StreamSub(this, listener);
    };
    /**
     * Add interop between most.js and RxJS 5
     *
     * @returns {Stream}
     */
    Stream.prototype[symbol_observable_1.default] = function () {
        return this;
    };
    /**
     * Creates a new Stream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {Stream}
     */
    Stream.create = function (producer) {
        if (producer) {
            if (typeof producer.start !== 'function'
                || typeof producer.stop !== 'function')
                throw new Error('producer requires both start and stop functions');
            internalizeProducer(producer); // mutates the input
        }
        return new Stream(producer);
    };
    /**
     * Creates a new MemoryStream given a Producer.
     *
     * @factory true
     * @param {Producer} producer An optional Producer that dictates how to
     * start, generate events, and stop the Stream.
     * @return {MemoryStream}
     */
    Stream.createWithMemory = function (producer) {
        if (producer)
            internalizeProducer(producer); // mutates the input
        return new MemoryStream(producer);
    };
    /**
     * Creates a Stream that does nothing when started. It never emits any event.
     *
     * Marble diagram:
     *
     * ```text
     *          never
     * -----------------------
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.never = function () {
        return new Stream({ _start: noop, _stop: noop });
    };
    /**
     * Creates a Stream that immediately emits the "complete" notification when
     * started, and that's it.
     *
     * Marble diagram:
     *
     * ```text
     * empty
     * -|
     * ```
     *
     * @factory true
     * @return {Stream}
     */
    Stream.empty = function () {
        return new Stream({
            _start: function (il) { il._c(); },
            _stop: noop,
        });
    };
    /**
     * Creates a Stream that immediately emits an "error" notification with the
     * value you passed as the `error` argument when the stream starts, and that's
     * it.
     *
     * Marble diagram:
     *
     * ```text
     * throw(X)
     * -X
     * ```
     *
     * @factory true
     * @param error The error event to emit on the created stream.
     * @return {Stream}
     */
    Stream.throw = function (error) {
        return new Stream({
            _start: function (il) { il._e(error); },
            _stop: noop,
        });
    };
    /**
     * Creates a stream from an Array, Promise, or an Observable.
     *
     * @factory true
     * @param {Array|PromiseLike|Observable} input The input to make a stream from.
     * @return {Stream}
     */
    Stream.from = function (input) {
        if (typeof input[symbol_observable_1.default] === 'function')
            return Stream.fromObservable(input);
        else if (typeof input.then === 'function')
            return Stream.fromPromise(input);
        else if (Array.isArray(input))
            return Stream.fromArray(input);
        throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    };
    /**
     * Creates a Stream that immediately emits the arguments that you give to
     * *of*, then completes.
     *
     * Marble diagram:
     *
     * ```text
     * of(1,2,3)
     * 123|
     * ```
     *
     * @factory true
     * @param a The first value you want to emit as an event on the stream.
     * @param b The second value you want to emit as an event on the stream. One
     * or more of these values may be given as arguments.
     * @return {Stream}
     */
    Stream.of = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        return Stream.fromArray(items);
    };
    /**
     * Converts an array to a stream. The returned stream will emit synchronously
     * all the items in the array, and then complete.
     *
     * Marble diagram:
     *
     * ```text
     * fromArray([1,2,3])
     * 123|
     * ```
     *
     * @factory true
     * @param {Array} array The array to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromArray = function (array) {
        return new Stream(new FromArray(array));
    };
    /**
     * Converts a promise to a stream. The returned stream will emit the resolved
     * value of the promise, and then complete. However, if the promise is
     * rejected, the stream will emit the corresponding error.
     *
     * Marble diagram:
     *
     * ```text
     * fromPromise( ----42 )
     * -----------------42|
     * ```
     *
     * @factory true
     * @param {PromiseLike} promise The promise to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromPromise = function (promise) {
        return new Stream(new FromPromise(promise));
    };
    /**
     * Converts an Observable into a Stream.
     *
     * @factory true
     * @param {any} observable The observable to be converted as a stream.
     * @return {Stream}
     */
    Stream.fromObservable = function (obs) {
        if (obs.endWhen)
            return obs;
        var o = typeof obs[symbol_observable_1.default] === 'function' ? obs[symbol_observable_1.default]() : obs;
        return new Stream(new FromObservable(o));
    };
    /**
     * Creates a stream that periodically emits incremental numbers, every
     * `period` milliseconds.
     *
     * Marble diagram:
     *
     * ```text
     *     periodic(1000)
     * ---0---1---2---3---4---...
     * ```
     *
     * @factory true
     * @param {number} period The interval in milliseconds to use as a rate of
     * emission.
     * @return {Stream}
     */
    Stream.periodic = function (period) {
        return new Stream(new Periodic(period));
    };
    Stream.prototype._map = function (project) {
        return new (this.ctor())(new MapOp(project, this));
    };
    /**
     * Transforms each event from the input Stream through a `project` function,
     * to get a Stream that emits those transformed events.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7------
     *    map(i => i * 10)
     * --10--30-50----70-----
     * ```
     *
     * @param {Function} project A function of type `(t: T) => U` that takes event
     * `t` of type `T` from the input Stream and produces an event of type `U`, to
     * be emitted on the output Stream.
     * @return {Stream}
     */
    Stream.prototype.map = function (project) {
        return this._map(project);
    };
    /**
     * It's like `map`, but transforms each input event to always the same
     * constant value on the output Stream.
     *
     * Marble diagram:
     *
     * ```text
     * --1---3--5-----7-----
     *       mapTo(10)
     * --10--10-10----10----
     * ```
     *
     * @param projectedValue A value to emit on the output Stream whenever the
     * input Stream emits any value.
     * @return {Stream}
     */
    Stream.prototype.mapTo = function (projectedValue) {
        var s = this.map(function () { return projectedValue; });
        var op = s._prod;
        op.type = 'mapTo';
        return s;
    };
    /**
     * Only allows events that pass the test given by the `passes` argument.
     *
     * Each event from the input stream is given to the `passes` function. If the
     * function returns `true`, the event is forwarded to the output stream,
     * otherwise it is ignored and not forwarded.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2--3-----4-----5---6--7-8--
     *     filter(i => i % 2 === 0)
     * ------2--------4---------6----8--
     * ```
     *
     * @param {Function} passes A function of type `(t: T) => boolean` that takes
     * an event from the input stream and checks if it passes, by returning a
     * boolean.
     * @return {Stream}
     */
    Stream.prototype.filter = function (passes) {
        var p = this._prod;
        if (p instanceof Filter)
            return new Stream(new Filter(and(p.f, passes), p.ins));
        return new Stream(new Filter(passes, this));
    };
    /**
     * Lets the first `amount` many events from the input stream pass to the
     * output stream, then makes the output stream complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *    take(3)
     * --a---b--c|
     * ```
     *
     * @param {number} amount How many events to allow from the input stream
     * before completing the output stream.
     * @return {Stream}
     */
    Stream.prototype.take = function (amount) {
        return new (this.ctor())(new Take(amount, this));
    };
    /**
     * Ignores the first `amount` many events from the input stream, and then
     * after that starts forwarding events from the input stream to the output
     * stream.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c----d---e--
     *       drop(3)
     * --------------d---e--
     * ```
     *
     * @param {number} amount How many events to ignore from the input stream
     * before forwarding all events from the input stream to the output stream.
     * @return {Stream}
     */
    Stream.prototype.drop = function (amount) {
        return new Stream(new Drop(amount, this));
    };
    /**
     * When the input stream completes, the output stream will emit the last event
     * emitted by the input stream, and then will also complete.
     *
     * Marble diagram:
     *
     * ```text
     * --a---b--c--d----|
     *       last()
     * -----------------d|
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.last = function () {
        return new Stream(new Last(this));
    };
    /**
     * Prepends the given `initial` value to the sequence of events emitted by the
     * input stream. The returned stream is a MemoryStream, which means it is
     * already `remember()`'d.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3---
     *   startWith(0)
     * 0--1---2-----3---
     * ```
     *
     * @param initial The value or event to prepend.
     * @return {MemoryStream}
     */
    Stream.prototype.startWith = function (initial) {
        return new MemoryStream(new StartWith(this, initial));
    };
    /**
     * Uses another stream to determine when to complete the current stream.
     *
     * When the given `other` stream emits an event or completes, the output
     * stream will complete. Before that happens, the output stream will behaves
     * like the input stream.
     *
     * Marble diagram:
     *
     * ```text
     * ---1---2-----3--4----5----6---
     *   endWhen( --------a--b--| )
     * ---1---2-----3--4--|
     * ```
     *
     * @param other Some other stream that is used to know when should the output
     * stream of this operator complete.
     * @return {Stream}
     */
    Stream.prototype.endWhen = function (other) {
        return new (this.ctor())(new EndWhen(other, this));
    };
    /**
     * "Folds" the stream onto itself.
     *
     * Combines events from the past throughout
     * the entire execution of the input stream, allowing you to accumulate them
     * together. It's essentially like `Array.prototype.reduce`. The returned
     * stream is a MemoryStream, which means it is already `remember()`'d.
     *
     * The output stream starts by emitting the `seed` which you give as argument.
     * Then, when an event happens on the input stream, it is combined with that
     * seed value through the `accumulate` function, and the output value is
     * emitted on the output stream. `fold` remembers that output value as `acc`
     * ("accumulator"), and then when a new input event `t` happens, `acc` will be
     * combined with that to produce the new `acc` and so forth.
     *
     * Marble diagram:
     *
     * ```text
     * ------1-----1--2----1----1------
     *   fold((acc, x) => acc + x, 3)
     * 3-----4-----5--7----8----9------
     * ```
     *
     * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that
     * takes the previous accumulated value `acc` and the incoming event from the
     * input stream and produces the new accumulated value.
     * @param seed The initial accumulated value, of type `R`.
     * @return {MemoryStream}
     */
    Stream.prototype.fold = function (accumulate, seed) {
        return new MemoryStream(new Fold(accumulate, seed, this));
    };
    /**
     * Replaces an error with another stream.
     *
     * When (and if) an error happens on the input stream, instead of forwarding
     * that error to the output stream, *replaceError* will call the `replace`
     * function which returns the stream that the output stream will replicate.
     * And, in case that new stream also emits an error, `replace` will be called
     * again to get another stream to start replicating.
     *
     * Marble diagram:
     *
     * ```text
     * --1---2-----3--4-----X
     *   replaceError( () => --10--| )
     * --1---2-----3--4--------10--|
     * ```
     *
     * @param {Function} replace A function of type `(err) => Stream` that takes
     * the error that occurred on the input stream or on the previous replacement
     * stream and returns a new stream. The output stream will behave like the
     * stream that this function returns.
     * @return {Stream}
     */
    Stream.prototype.replaceError = function (replace) {
        return new (this.ctor())(new ReplaceError(replace, this));
    };
    /**
     * Flattens a "stream of streams", handling only one nested stream at a time
     * (no concurrency).
     *
     * If the input stream is a stream that emits streams, then this operator will
     * return an output stream which is a flat stream: emits regular events. The
     * flattening happens without concurrency. It works like this: when the input
     * stream emits a nested stream, *flatten* will start imitating that nested
     * one. However, as soon as the next nested stream is emitted on the input
     * stream, *flatten* will forget the previous nested one it was imitating, and
     * will start imitating the new nested one.
     *
     * Marble diagram:
     *
     * ```text
     * --+--------+---------------
     *   \        \
     *    \       ----1----2---3--
     *    --a--b----c----d--------
     *           flatten
     * -----a--b------1----2---3--
     * ```
     *
     * @return {Stream}
     */
    Stream.prototype.flatten = function () {
        return new Stream(new Flatten(this));
    };
    /**
     * Passes the input stream to a custom operator, to produce an output stream.
     *
     * *compose* is a handy way of using an existing function in a chained style.
     * Instead of writing `outStream = f(inStream)` you can write
     * `outStream = inStream.compose(f)`.
     *
     * @param {function} operator A function that takes a stream as input and
     * returns a stream as well.
     * @return {Stream}
     */
    Stream.prototype.compose = function (operator) {
        return operator(this);
    };
    /**
     * Returns an output stream that behaves like the input stream, but also
     * remembers the most recent event that happens on the input stream, so that a
     * newly added listener will immediately receive that memorised event.
     *
     * @return {MemoryStream}
     */
    Stream.prototype.remember = function () {
        return new MemoryStream(new Remember(this));
    };
    /**
     * Returns an output stream that identically behaves like the input stream,
     * but also runs a `spy` function for each event, to help you debug your app.
     *
     * *debug* takes a `spy` function as argument, and runs that for each event
     * happening on the input stream. If you don't provide the `spy` argument,
     * then *debug* will just `console.log` each event. This helps you to
     * understand the flow of events through some operator chain.
     *
     * Please note that if the output stream has no listeners, then it will not
     * start, which means `spy` will never run because no actual event happens in
     * that case.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3-----4--
     *         debug
     * --1----2-----3-----4--
     * ```
     *
     * @param {function} labelOrSpy A string to use as the label when printing
     * debug information on the console, or a 'spy' function that takes an event
     * as argument, and does not need to return anything.
     * @return {Stream}
     */
    Stream.prototype.debug = function (labelOrSpy) {
        return new (this.ctor())(new Debug(this, labelOrSpy));
    };
    /**
     * *imitate* changes this current Stream to emit the same events that the
     * `other` given Stream does. This method returns nothing.
     *
     * This method exists to allow one thing: **circular dependency of streams**.
     * For instance, let's imagine that for some reason you need to create a
     * circular dependency where stream `first$` depends on stream `second$`
     * which in turn depends on `first$`:
     *
     * <!-- skip-example -->
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var first$ = second$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * ```
     *
     * However, that is invalid JavaScript, because `second$` is undefined
     * on the first line. This is how *imitate* can help solve it:
     *
     * ```js
     * import delay from 'xstream/extra/delay'
     *
     * var secondProxy$ = xs.create();
     * var first$ = secondProxy$.map(x => x * 10).take(3);
     * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
     * secondProxy$.imitate(second$);
     * ```
     *
     * We create `secondProxy$` before the others, so it can be used in the
     * declaration of `first$`. Then, after both `first$` and `second$` are
     * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell
     * that they are "the same". `imitate` will not trigger the start of any
     * stream, it just binds `secondProxy$` and `second$` together.
     *
     * The following is an example where `imitate()` is important in Cycle.js
     * applications. A parent component contains some child components. A child
     * has an action stream which is given to the parent to define its state:
     *
     * <!-- skip-example -->
     * ```js
     * const childActionProxy$ = xs.create();
     * const parent = Parent({...sources, childAction$: childActionProxy$});
     * const childAction$ = parent.state$.map(s => s.child.action$).flatten();
     * childActionProxy$.imitate(childAction$);
     * ```
     *
     * Note, though, that **`imitate()` does not support MemoryStreams**. If we
     * would attempt to imitate a MemoryStream in a circular dependency, we would
     * either get a race condition (where the symptom would be "nothing happens")
     * or an infinite cyclic emission of values. It's useful to think about
     * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to
     * define a spreadsheet cell `A1` with a formula that depends on `B1` and
     * cell `B1` defined with a formula that depends on `A1`.
     *
     * If you find yourself wanting to use `imitate()` with a
     * MemoryStream, you should rework your code around `imitate()` to use a
     * Stream instead. Look for the stream in the circular dependency that
     * represents an event stream, and that would be a candidate for creating a
     * proxy Stream which then imitates the target Stream.
     *
     * @param {Stream} target The other stream to imitate on the current one. Must
     * not be a MemoryStream.
     */
    Stream.prototype.imitate = function (target) {
        if (target instanceof MemoryStream)
            throw new Error('A MemoryStream was given to imitate(), but it only ' +
                'supports a Stream. Read more about this restriction here: ' +
                'https://github.com/staltz/xstream#faq');
        this._target = target;
        for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
            target._add(ils[i]);
        this._ils = [];
    };
    /**
     * Forces the Stream to emit the given value to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param value The "next" value you want to broadcast to all listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendNext = function (value) {
        this._n(value);
    };
    /**
     * Forces the Stream to emit the given error to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     *
     * @param {any} error The error you want to broadcast to all the listeners of
     * this Stream.
     */
    Stream.prototype.shamefullySendError = function (error) {
        this._e(error);
    };
    /**
     * Forces the Stream to emit the "completed" event to its listeners.
     *
     * As the name indicates, if you use this, you are most likely doing something
     * The Wrong Way. Please try to understand the reactive way before using this
     * method. Use it only when you know what you are doing.
     */
    Stream.prototype.shamefullySendComplete = function () {
        this._c();
    };
    /**
     * Adds a "debug" listener to the stream. There can only be one debug
     * listener, that's why this is 'setDebugListener'. To remove the debug
     * listener, just call setDebugListener(null).
     *
     * A debug listener is like any other listener. The only difference is that a
     * debug listener is "stealthy": its presence/absence does not trigger the
     * start/stop of the stream (or the producer inside the stream). This is
     * useful so you can inspect what is going on without changing the behavior
     * of the program. If you have an idle stream and you add a normal listener to
     * it, the stream will start executing. But if you set a debug listener on an
     * idle stream, it won't start executing (not until the first normal listener
     * is added).
     *
     * As the name indicates, we don't recommend using this method to build app
     * logic. In fact, in most cases the debug operator works just fine. Only use
     * this one if you know what you're doing.
     *
     * @param {Listener<T>} listener
     */
    Stream.prototype.setDebugListener = function (listener) {
        if (!listener) {
            this._d = false;
            this._dl = NO;
        }
        else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
        }
    };
    /**
     * Blends multiple streams together, emitting events from all of them
     * concurrently.
     *
     * *merge* takes multiple streams as arguments, and creates a stream that
     * behaves like each of the argument streams, in parallel.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3--------4---
     * ----a-----b----c---d------
     *            merge
     * --1-a--2--b--3-c---d--4---
     * ```
     *
     * @factory true
     * @param {Stream} stream1 A stream to merge together with other streams.
     * @param {Stream} stream2 A stream to merge together with other streams. Two
     * or more streams may be given as arguments.
     * @return {Stream}
     */
    Stream.merge = function merge() {
        var streams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
        }
        return new Stream(new Merge(streams));
    };
    /**
     * Combines multiple input streams together to return a stream whose events
     * are arrays that collect the latest events from each input stream.
     *
     * *combine* internally remembers the most recent event from each of the input
     * streams. When any of the input streams emits an event, that event together
     * with all the other saved events are combined into an array. That array will
     * be emitted on the output stream. It's essentially a way of joining together
     * the events from multiple streams.
     *
     * Marble diagram:
     *
     * ```text
     * --1----2-----3--------4---
     * ----a-----b-----c--d------
     *          combine
     * ----1a-2a-2b-3b-3c-3d-4d--
     * ```
     *
     * @factory true
     * @param {Stream} stream1 A stream to combine together with other streams.
     * @param {Stream} stream2 A stream to combine together with other streams.
     * Multiple streams, not just two, may be given as arguments.
     * @return {Stream}
     */
    Stream.combine = function combine() {
        var streams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            streams[_i] = arguments[_i];
        }
        return new Stream(new Combine(streams));
    };
    return Stream;
}());
exports.Stream = Stream;
var MemoryStream = /** @class */ (function (_super) {
    __extends(MemoryStream, _super);
    function MemoryStream(producer) {
        var _this = _super.call(this, producer) || this;
        _this._has = false;
        return _this;
    }
    MemoryStream.prototype._n = function (x) {
        this._v = x;
        this._has = true;
        _super.prototype._n.call(this, x);
    };
    MemoryStream.prototype._add = function (il) {
        var ta = this._target;
        if (ta !== NO)
            return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1) {
            if (this._has)
                il._n(this._v);
            return;
        }
        if (this._stopID !== NO) {
            if (this._has)
                il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
        }
        else if (this._has)
            il._n(this._v);
        else {
            var p = this._prod;
            if (p !== NO)
                p._start(this);
        }
    };
    MemoryStream.prototype._stopNow = function () {
        this._has = false;
        _super.prototype._stopNow.call(this);
    };
    MemoryStream.prototype._x = function () {
        this._has = false;
        _super.prototype._x.call(this);
    };
    MemoryStream.prototype.map = function (project) {
        return this._map(project);
    };
    MemoryStream.prototype.mapTo = function (projectedValue) {
        return _super.prototype.mapTo.call(this, projectedValue);
    };
    MemoryStream.prototype.take = function (amount) {
        return _super.prototype.take.call(this, amount);
    };
    MemoryStream.prototype.endWhen = function (other) {
        return _super.prototype.endWhen.call(this, other);
    };
    MemoryStream.prototype.replaceError = function (replace) {
        return _super.prototype.replaceError.call(this, replace);
    };
    MemoryStream.prototype.remember = function () {
        return this;
    };
    MemoryStream.prototype.debug = function (labelOrSpy) {
        return _super.prototype.debug.call(this, labelOrSpy);
    };
    return MemoryStream;
}(Stream));
exports.MemoryStream = MemoryStream;
var xs = Stream;
exports.default = xs;

},{"symbol-observable":3}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xstream_1 = require("xstream");
var adapt_1 = require("@cycle/run/lib/adapt");
var fromEvent_1 = require("./fromEvent");
var BodyDOMSource = /** @class */ (function () {
    function BodyDOMSource(_name) {
        this._name = _name;
    }
    BodyDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    BodyDOMSource.prototype.elements = function () {
        var out = adapt_1.adapt(xstream_1.default.of([document.body]));
        out._isCycleSource = this._name;
        return out;
    };
    BodyDOMSource.prototype.element = function () {
        var out = adapt_1.adapt(xstream_1.default.of(document.body));
        out._isCycleSource = this._name;
        return out;
    };
    BodyDOMSource.prototype.events = function (eventType, options, bubbles) {
        if (options === void 0) { options = {}; }
        var stream;
        stream = fromEvent_1.fromEvent(document.body, eventType, options.useCapture, options.preventDefault);
        var out = adapt_1.adapt(stream);
        out._isCycleSource = this._name;
        return out;
    };
    return BodyDOMSource;
}());
exports.BodyDOMSource = BodyDOMSource;

},{"./fromEvent":17,"@cycle/run/lib/adapt":26,"xstream":212}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xstream_1 = require("xstream");
var adapt_1 = require("@cycle/run/lib/adapt");
var fromEvent_1 = require("./fromEvent");
var DocumentDOMSource = /** @class */ (function () {
    function DocumentDOMSource(_name) {
        this._name = _name;
    }
    DocumentDOMSource.prototype.select = function (selector) {
        // This functionality is still undefined/undecided.
        return this;
    };
    DocumentDOMSource.prototype.elements = function () {
        var out = adapt_1.adapt(xstream_1.default.of([document]));
        out._isCycleSource = this._name;
        return out;
    };
    DocumentDOMSource.prototype.element = function () {
        var out = adapt_1.adapt(xstream_1.default.of(document));
        out._isCycleSource = this._name;
        return out;
    };
    DocumentDOMSource.prototype.events = function (eventType, options, bubbles) {
        if (options === void 0) { options = {}; }
        var stream;
        stream = fromEvent_1.fromEvent(document, eventType, options.useCapture, options.preventDefault);
        var out = adapt_1.adapt(stream);
        out._isCycleSource = this._name;
        return out;
    };
    return DocumentDOMSource;
}());
exports.DocumentDOMSource = DocumentDOMSource;

},{"./fromEvent":17,"@cycle/run/lib/adapt":26,"xstream":212}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ScopeChecker_1 = require("./ScopeChecker");
var utils_1 = require("./utils");
function toElArray(input) {
    return Array.prototype.slice.call(input);
}
var ElementFinder = /** @class */ (function () {
    function ElementFinder(namespace, isolateModule) {
        this.namespace = namespace;
        this.isolateModule = isolateModule;
    }
    ElementFinder.prototype.call = function () {
        var namespace = this.namespace;
        var selector = utils_1.getSelectors(namespace);
        var scopeChecker = new ScopeChecker_1.ScopeChecker(namespace, this.isolateModule);
        var topNode = this.isolateModule.getElement(namespace.filter(function (n) { return n.type !== 'selector'; }));
        if (topNode === undefined) {
            return [];
        }
        if (selector === '') {
            return [topNode];
        }
        return toElArray(topNode.querySelectorAll(selector))
            .filter(scopeChecker.isDirectlyInScope, scopeChecker)
            .concat(topNode.matches(selector) ? [topNode] : []);
    };
    return ElementFinder;
}());
exports.ElementFinder = ElementFinder;

},{"./ScopeChecker":14,"./utils":25}],9:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var xstream_1 = require("xstream");
var ScopeChecker_1 = require("./ScopeChecker");
var utils_1 = require("./utils");
var ElementFinder_1 = require("./ElementFinder");
var SymbolTree_1 = require("./SymbolTree");
var RemovalSet_1 = require("./RemovalSet");
var PriorityQueue_1 = require("./PriorityQueue");
var fromEvent_1 = require("./fromEvent");
exports.eventTypesThatDontBubble = [
    "blur",
    "canplay",
    "canplaythrough",
    "durationchange",
    "emptied",
    "ended",
    "focus",
    "load",
    "loadeddata",
    "loadedmetadata",
    "mouseenter",
    "mouseleave",
    "pause",
    "play",
    "playing",
    "ratechange",
    "reset",
    "scroll",
    "seeked",
    "seeking",
    "stalled",
    "submit",
    "suspend",
    "timeupdate",
    "unload",
    "volumechange",
    "waiting",
];
/**
 * Manages "Event delegation", by connecting an origin with multiple
 * destinations.
 *
 * Attaches a DOM event listener to the DOM element called the "origin",
 * and delegates events to "destinations", which are subjects as outputs
 * for the DOMSource. Simulates bubbling or capturing, with regards to
 * isolation boundaries too.
 */
var EventDelegator = /** @class */ (function () {
    function EventDelegator(rootElement$, isolateModule) {
        var _this = this;
        this.rootElement$ = rootElement$;
        this.isolateModule = isolateModule;
        this.virtualListeners = new SymbolTree_1.default(function (x) { return x.scope; });
        this.nonBubblingListenersToAdd = new RemovalSet_1.default();
        this.virtualNonBubblingListener = [];
        this.isolateModule.setEventDelegator(this);
        this.domListeners = new Map();
        this.domListenersToAdd = new Map();
        this.nonBubblingListeners = new Map();
        rootElement$.addListener({
            next: function (el) {
                if (_this.origin !== el) {
                    _this.origin = el;
                    _this.resetEventListeners();
                    _this.domListenersToAdd.forEach(function (passive, type) {
                        return _this.setupDOMListener(type, passive);
                    });
                    _this.domListenersToAdd.clear();
                }
                _this.resetNonBubblingListeners();
                _this.nonBubblingListenersToAdd.forEach(function (arr) {
                    _this.setupNonBubblingListener(arr);
                });
            },
        });
    }
    EventDelegator.prototype.addEventListener = function (eventType, namespace, options, bubbles) {
        var subject = xstream_1.default.never();
        var scopeChecker = new ScopeChecker_1.ScopeChecker(namespace, this.isolateModule);
        var dest = this.insertListener(subject, scopeChecker, eventType, options);
        var shouldBubble = bubbles === undefined
            ? exports.eventTypesThatDontBubble.indexOf(eventType) === -1
            : bubbles;
        if (shouldBubble) {
            if (!this.domListeners.has(eventType)) {
                this.setupDOMListener(eventType, !!options.passive);
            }
        }
        else {
            var finder = new ElementFinder_1.ElementFinder(namespace, this.isolateModule);
            this.setupNonBubblingListener([eventType, finder, dest]);
        }
        return subject;
    };
    EventDelegator.prototype.removeElement = function (element, namespace) {
        if (namespace !== undefined) {
            this.virtualListeners.delete(namespace);
        }
        var toRemove = [];
        this.nonBubblingListeners.forEach(function (map, type) {
            if (map.has(element)) {
                toRemove.push([type, element]);
            }
        });
        for (var i = 0; i < toRemove.length; i++) {
            var map = this.nonBubblingListeners.get(toRemove[i][0]);
            if (!map) {
                continue;
            }
            map.delete(toRemove[i][1]);
            if (map.size === 0) {
                this.nonBubblingListeners.delete(toRemove[i][0]);
            }
            else {
                this.nonBubblingListeners.set(toRemove[i][0], map);
            }
        }
    };
    EventDelegator.prototype.insertListener = function (subject, scopeChecker, eventType, options) {
        var relevantSets = [];
        var n = scopeChecker._namespace;
        var max = n.length;
        do {
            relevantSets.push(this.getVirtualListeners(eventType, n, true, max));
            max--;
        } while (max >= 0 && n[max].type !== 'total');
        var destination = __assign({}, options, { scopeChecker: scopeChecker,
            subject: subject, bubbles: !!options.bubbles, useCapture: !!options.useCapture, passive: !!options.passive });
        for (var i = 0; i < relevantSets.length; i++) {
            relevantSets[i].add(destination, n.length);
        }
        return destination;
    };
    /**
     * Returns a set of all virtual listeners in the scope of the namespace
     * Set `exact` to true to treat sibiling isolated scopes as total scopes
     */
    EventDelegator.prototype.getVirtualListeners = function (eventType, namespace, exact, max) {
        if (exact === void 0) { exact = false; }
        var _max = max !== undefined ? max : namespace.length;
        if (!exact) {
            for (var i = _max - 1; i >= 0; i--) {
                if (namespace[i].type === 'total') {
                    _max = i + 1;
                    break;
                }
                _max = i;
            }
        }
        var map = this.virtualListeners.getDefault(namespace, function () { return new Map(); }, _max);
        if (!map.has(eventType)) {
            map.set(eventType, new PriorityQueue_1.default());
        }
        return map.get(eventType);
    };
    EventDelegator.prototype.setupDOMListener = function (eventType, passive) {
        var _this = this;
        if (this.origin) {
            var sub = fromEvent_1.fromEvent(this.origin, eventType, false, false, passive).subscribe({
                next: function (event) { return _this.onEvent(eventType, event, passive); },
                error: function () { },
                complete: function () { },
            });
            this.domListeners.set(eventType, { sub: sub, passive: passive });
        }
        else {
            this.domListenersToAdd.set(eventType, passive);
        }
    };
    EventDelegator.prototype.setupNonBubblingListener = function (input) {
        var _this = this;
        var eventType = input[0], elementFinder = input[1], destination = input[2];
        if (!this.origin) {
            this.nonBubblingListenersToAdd.add(input);
            return;
        }
        var element = elementFinder.call()[0];
        if (element) {
            this.nonBubblingListenersToAdd.delete(input);
            var sub = fromEvent_1.fromEvent(element, eventType, false, false, destination.passive).subscribe({
                next: function (ev) { return _this.onEvent(eventType, ev, !!destination.passive, false); },
                error: function () { },
                complete: function () { },
            });
            if (!this.nonBubblingListeners.has(eventType)) {
                this.nonBubblingListeners.set(eventType, new Map());
            }
            var map = this.nonBubblingListeners.get(eventType);
            if (!map) {
                return;
            }
            map.set(element, { sub: sub, destination: destination });
        }
        else {
            this.nonBubblingListenersToAdd.add(input);
        }
    };
    EventDelegator.prototype.resetEventListeners = function () {
        var iter = this.domListeners.entries();
        var curr = iter.next();
        while (!curr.done) {
            var _a = curr.value, type = _a[0], _b = _a[1], sub = _b.sub, passive = _b.passive;
            sub.unsubscribe();
            this.setupDOMListener(type, passive);
            curr = iter.next();
        }
    };
    EventDelegator.prototype.resetNonBubblingListeners = function () {
        var _this = this;
        var newMap = new Map();
        var insert = utils_1.makeInsert(newMap);
        this.nonBubblingListeners.forEach(function (map, type) {
            map.forEach(function (value, elm) {
                if (!document.body.contains(elm)) {
                    var sub = value.sub, destination_1 = value.destination;
                    if (sub) {
                        sub.unsubscribe();
                    }
                    var elementFinder = new ElementFinder_1.ElementFinder(destination_1.scopeChecker.namespace, _this.isolateModule);
                    var newElm = elementFinder.call()[0];
                    var newSub = fromEvent_1.fromEvent(newElm, type, false, false, destination_1.passive).subscribe({
                        next: function (event) {
                            return _this.onEvent(type, event, !!destination_1.passive, false);
                        },
                        error: function () { },
                        complete: function () { },
                    });
                    insert(type, newElm, { sub: newSub, destination: destination_1 });
                }
                else {
                    insert(type, elm, value);
                }
            });
            _this.nonBubblingListeners = newMap;
        });
    };
    EventDelegator.prototype.putNonBubblingListener = function (eventType, elm, useCapture, passive) {
        var map = this.nonBubblingListeners.get(eventType);
        if (!map) {
            return;
        }
        var listener = map.get(elm);
        if (listener &&
            listener.destination.passive === passive &&
            listener.destination.useCapture === useCapture) {
            this.virtualNonBubblingListener[0] = listener.destination;
        }
    };
    EventDelegator.prototype.onEvent = function (eventType, event, passive, bubbles) {
        if (bubbles === void 0) { bubbles = true; }
        var cycleEvent = this.patchEvent(event);
        var rootElement = this.isolateModule.getRootElement(event.target);
        if (bubbles) {
            var namespace = this.isolateModule.getNamespace(event.target);
            if (!namespace) {
                return;
            }
            var listeners = this.getVirtualListeners(eventType, namespace);
            this.bubble(eventType, event.target, rootElement, cycleEvent, listeners, namespace, namespace.length - 1, true, passive);
            this.bubble(eventType, event.target, rootElement, cycleEvent, listeners, namespace, namespace.length - 1, false, passive);
        }
        else {
            this.putNonBubblingListener(eventType, event.target, true, passive);
            this.doBubbleStep(eventType, event.target, rootElement, cycleEvent, this.virtualNonBubblingListener, true, passive);
            this.putNonBubblingListener(eventType, event.target, false, passive);
            this.doBubbleStep(eventType, event.target, rootElement, cycleEvent, this.virtualNonBubblingListener, false, passive);
            event.stopPropagation(); //fix reset event (spec'ed as non-bubbling, but bubbles in reality
        }
    };
    EventDelegator.prototype.bubble = function (eventType, elm, rootElement, event, listeners, namespace, index, useCapture, passive) {
        if (!useCapture && !event.propagationHasBeenStopped) {
            this.doBubbleStep(eventType, elm, rootElement, event, listeners, useCapture, passive);
        }
        var newRoot = rootElement;
        var newIndex = index;
        if (elm === rootElement) {
            if (index >= 0 && namespace[index].type === 'sibling') {
                newRoot = this.isolateModule.getElement(namespace, index);
                newIndex--;
            }
            else {
                return;
            }
        }
        if (elm.parentNode && newRoot) {
            this.bubble(eventType, elm.parentNode, newRoot, event, listeners, namespace, newIndex, useCapture, passive);
        }
        if (useCapture && !event.propagationHasBeenStopped) {
            this.doBubbleStep(eventType, elm, rootElement, event, listeners, useCapture, passive);
        }
    };
    EventDelegator.prototype.doBubbleStep = function (eventType, elm, rootElement, event, listeners, useCapture, passive) {
        if (!rootElement) {
            return;
        }
        this.mutateEventCurrentTarget(event, elm);
        listeners.forEach(function (dest) {
            if (dest.passive === passive && dest.useCapture === useCapture) {
                var sel = utils_1.getSelectors(dest.scopeChecker.namespace);
                if (!event.propagationHasBeenStopped &&
                    dest.scopeChecker.isDirectlyInScope(elm) &&
                    ((sel !== '' && elm.matches(sel)) ||
                        (sel === '' && elm === rootElement))) {
                    fromEvent_1.preventDefaultConditional(event, dest.preventDefault);
                    dest.subject.shamefullySendNext(event);
                }
            }
        });
    };
    EventDelegator.prototype.patchEvent = function (event) {
        var pEvent = event;
        pEvent.propagationHasBeenStopped = false;
        var oldStopPropagation = pEvent.stopPropagation;
        pEvent.stopPropagation = function stopPropagation() {
            oldStopPropagation.call(this);
            this.propagationHasBeenStopped = true;
        };
        return pEvent;
    };
    EventDelegator.prototype.mutateEventCurrentTarget = function (event, currentTargetElement) {
        try {
            Object.defineProperty(event, "currentTarget", {
                value: currentTargetElement,
                configurable: true,
            });
        }
        catch (err) {
            console.log("please use event.ownerTarget");
        }
        event.ownerTarget = currentTargetElement;
    };
    return EventDelegator;
}());
exports.EventDelegator = EventDelegator;

},{"./ElementFinder":8,"./PriorityQueue":12,"./RemovalSet":13,"./ScopeChecker":14,"./SymbolTree":15,"./fromEvent":17,"./utils":25,"xstream":212}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var SymbolTree_1 = require("./SymbolTree");
var IsolateModule = /** @class */ (function () {
    function IsolateModule() {
        this.namespaceTree = new SymbolTree_1.default(function (x) { return x.scope; });
        this.namespaceByElement = new Map();
        this.vnodesBeingRemoved = [];
    }
    IsolateModule.prototype.setEventDelegator = function (del) {
        this.eventDelegator = del;
    };
    IsolateModule.prototype.insertElement = function (namespace, el) {
        this.namespaceByElement.set(el, namespace);
        this.namespaceTree.set(namespace, el);
    };
    IsolateModule.prototype.removeElement = function (elm) {
        this.namespaceByElement.delete(elm);
        var namespace = this.getNamespace(elm);
        if (namespace) {
            this.namespaceTree.delete(namespace);
        }
    };
    IsolateModule.prototype.getElement = function (namespace, max) {
        return this.namespaceTree.get(namespace, undefined, max);
    };
    IsolateModule.prototype.getRootElement = function (elm) {
        if (this.namespaceByElement.has(elm)) {
            return elm;
        }
        //TODO: Add quick-lru or similar as additional O(1) cache
        var curr = elm;
        while (!this.namespaceByElement.has(curr)) {
            curr = curr.parentNode;
            if (!curr) {
                return undefined;
            }
            else if (curr.tagName === 'HTML') {
                throw new Error('No root element found, this should not happen at all');
            }
        }
        return curr;
    };
    IsolateModule.prototype.getNamespace = function (elm) {
        var rootElement = this.getRootElement(elm);
        if (!rootElement) {
            return undefined;
        }
        return this.namespaceByElement.get(rootElement);
    };
    IsolateModule.prototype.createModule = function () {
        var self = this;
        return {
            create: function (emptyVNode, vNode) {
                var elm = vNode.elm, _a = vNode.data, data = _a === void 0 ? {} : _a;
                var namespace = data.isolate;
                if (Array.isArray(namespace)) {
                    self.insertElement(namespace, elm);
                }
            },
            update: function (oldVNode, vNode) {
                var oldElm = oldVNode.elm, _a = oldVNode.data, oldData = _a === void 0 ? {} : _a;
                var elm = vNode.elm, _b = vNode.data, data = _b === void 0 ? {} : _b;
                var oldNamespace = oldData.isolate;
                var namespace = data.isolate;
                if (!utils_1.isEqualNamespace(oldNamespace, namespace)) {
                    if (Array.isArray(oldNamespace)) {
                        self.removeElement(oldElm);
                    }
                }
                if (Array.isArray(namespace)) {
                    self.insertElement(namespace, elm);
                }
            },
            destroy: function (vNode) {
                self.vnodesBeingRemoved.push(vNode);
            },
            remove: function (vNode, cb) {
                self.vnodesBeingRemoved.push(vNode);
                cb();
            },
            post: function () {
                var vnodesBeingRemoved = self.vnodesBeingRemoved;
                for (var i = vnodesBeingRemoved.length - 1; i >= 0; i--) {
                    var vnode = vnodesBeingRemoved[i];
                    var namespace = vnode.data !== undefined
                        ? vnode.data.isolation
                        : undefined;
                    if (namespace !== undefined) {
                        self.removeElement(namespace);
                    }
                    self.eventDelegator.removeElement(vnode.elm, namespace);
                }
                self.vnodesBeingRemoved = [];
            },
        };
    };
    return IsolateModule;
}());
exports.IsolateModule = IsolateModule;

},{"./SymbolTree":15,"./utils":25}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var adapt_1 = require("@cycle/run/lib/adapt");
var DocumentDOMSource_1 = require("./DocumentDOMSource");
var BodyDOMSource_1 = require("./BodyDOMSource");
var ElementFinder_1 = require("./ElementFinder");
var isolate_1 = require("./isolate");
var MainDOMSource = /** @class */ (function () {
    function MainDOMSource(_rootElement$, _sanitation$, _namespace, _isolateModule, _eventDelegator, _name) {
        if (_namespace === void 0) { _namespace = []; }
        this._rootElement$ = _rootElement$;
        this._sanitation$ = _sanitation$;
        this._namespace = _namespace;
        this._isolateModule = _isolateModule;
        this._eventDelegator = _eventDelegator;
        this._name = _name;
        this.isolateSource = function (source, scope) {
            return new MainDOMSource(source._rootElement$, source._sanitation$, source._namespace.concat(isolate_1.getScopeObj(scope)), source._isolateModule, source._eventDelegator, source._name);
        };
        this.isolateSink = isolate_1.makeIsolateSink(this._namespace);
    }
    MainDOMSource.prototype._elements = function () {
        if (this._namespace.length === 0) {
            return this._rootElement$.map(function (x) { return [x]; });
        }
        else {
            var elementFinder_1 = new ElementFinder_1.ElementFinder(this._namespace, this._isolateModule);
            return this._rootElement$.map(function () { return elementFinder_1.call(); });
        }
    };
    MainDOMSource.prototype.elements = function () {
        var out = adapt_1.adapt(this._elements().remember());
        out._isCycleSource = this._name;
        return out;
    };
    MainDOMSource.prototype.element = function () {
        var out = adapt_1.adapt(this._elements()
            .filter(function (arr) { return arr.length > 0; })
            .map(function (arr) { return arr[0]; })
            .remember());
        out._isCycleSource = this._name;
        return out;
    };
    Object.defineProperty(MainDOMSource.prototype, "namespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    MainDOMSource.prototype.select = function (selector) {
        if (typeof selector !== 'string') {
            throw new Error("DOM driver's select() expects the argument to be a " +
                "string as a CSS selector");
        }
        if (selector === 'document') {
            return new DocumentDOMSource_1.DocumentDOMSource(this._name);
        }
        if (selector === 'body') {
            return new BodyDOMSource_1.BodyDOMSource(this._name);
        }
        var namespace = selector === ':root'
            ? []
            : this._namespace.concat({ type: 'selector', scope: selector.trim() });
        return new MainDOMSource(this._rootElement$, this._sanitation$, namespace, this._isolateModule, this._eventDelegator, this._name);
    };
    MainDOMSource.prototype.events = function (eventType, options, bubbles) {
        if (options === void 0) { options = {}; }
        if (typeof eventType !== "string") {
            throw new Error("DOM driver's events() expects argument to be a " +
                "string representing the event type to listen for.");
        }
        var event$ = this._eventDelegator.addEventListener(eventType, this._namespace, options, bubbles);
        var out = adapt_1.adapt(event$);
        out._isCycleSource = this._name;
        return out;
    };
    MainDOMSource.prototype.dispose = function () {
        this._sanitation$.shamefullySendNext(null);
        //this._isolateModule.reset();
    };
    return MainDOMSource;
}());
exports.MainDOMSource = MainDOMSource;

},{"./BodyDOMSource":6,"./DocumentDOMSource":7,"./ElementFinder":8,"./isolate":20,"@cycle/run/lib/adapt":26}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PriorityQueue = /** @class */ (function () {
    function PriorityQueue() {
        this.arr = [];
        this.prios = [];
    }
    PriorityQueue.prototype.add = function (t, prio) {
        for (var i = 0; i < this.arr.length; i++) {
            if (this.prios[i] < prio) {
                this.arr.splice(i, 0, t);
                this.prios.splice(i, 0, prio);
                return;
            }
        }
        this.arr.push(t);
        this.prios.push(prio);
    };
    PriorityQueue.prototype.forEach = function (f) {
        for (var i = 0; i < this.arr.length; i++) {
            f(this.arr[i], i, this.arr);
        }
    };
    PriorityQueue.prototype.delete = function (t) {
        for (var i = 0; i < this.arr.length; i++) {
            if (this.arr[i] === t) {
                this.arr.splice(i, 1);
                this.prios.splice(i, 1);
                return;
            }
        }
    };
    return PriorityQueue;
}());
exports.default = PriorityQueue;

},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RemovalSet = /** @class */ (function () {
    function RemovalSet() {
        this.toDelete = [];
        this.toDeleteSize = 0;
        this._set = new Set();
    }
    RemovalSet.prototype.add = function (t) {
        this._set.add(t);
    };
    RemovalSet.prototype.forEach = function (f) {
        this._set.forEach(f);
        this.flush();
    };
    RemovalSet.prototype.delete = function (t) {
        if (this.toDelete.length === this.toDeleteSize) {
            this.toDelete.push(t);
        }
        else {
            this.toDelete[this.toDeleteSize] = t;
        }
        this.toDeleteSize++;
    };
    RemovalSet.prototype.flush = function () {
        for (var i = 0; i < this.toDelete.length; i++) {
            if (i < this.toDeleteSize) {
                this._set.delete(this.toDelete[i]);
            }
            this.toDelete[i] = undefined;
        }
        this.toDeleteSize = 0;
    };
    return RemovalSet;
}());
exports.default = RemovalSet;

},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var ScopeChecker = /** @class */ (function () {
    function ScopeChecker(namespace, isolateModule) {
        this.namespace = namespace;
        this.isolateModule = isolateModule;
        this._namespace = namespace.filter(function (n) { return n.type !== 'selector'; });
    }
    /**
     * Checks whether the given element is *directly* in the scope of this
     * scope checker. Being contained *indirectly* through other scopes
     * is not valid. This is crucial for implementing parent-child isolation,
     * so that the parent selectors don't search inside a child scope.
     */
    ScopeChecker.prototype.isDirectlyInScope = function (leaf) {
        var namespace = this.isolateModule.getNamespace(leaf);
        if (!namespace) {
            return false;
        }
        if (this._namespace.length > namespace.length ||
            !utils_1.isEqualNamespace(this._namespace, namespace.slice(0, this._namespace.length))) {
            return false;
        }
        for (var i = this._namespace.length; i < namespace.length; i++) {
            if (namespace[i].type === 'total') {
                return false;
            }
        }
        return true;
    };
    return ScopeChecker;
}());
exports.ScopeChecker = ScopeChecker;

},{"./utils":25}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SymbolTree = /** @class */ (function () {
    function SymbolTree(mapper) {
        this.mapper = mapper;
        this.tree = [undefined, {}];
    }
    SymbolTree.prototype.set = function (path, element, max) {
        var curr = this.tree;
        var _max = max !== undefined ? max : path.length;
        for (var i = 0; i < _max; i++) {
            var n = this.mapper(path[i]);
            var child = curr[1][n];
            if (!child) {
                child = [undefined, {}];
                curr[1][n] = child;
            }
            curr = child;
        }
        curr[0] = element;
    };
    SymbolTree.prototype.getDefault = function (path, mkDefaultElement, max) {
        return this.get(path, mkDefaultElement, max);
    };
    /**
     * Returns the payload of the path
     * If a default element creator is given, it will insert it at the path
     */
    SymbolTree.prototype.get = function (path, mkDefaultElement, max) {
        var curr = this.tree;
        var _max = max !== undefined ? max : path.length;
        for (var i = 0; i < _max; i++) {
            var n = this.mapper(path[i]);
            var child = curr[1][n];
            if (!child) {
                if (mkDefaultElement) {
                    child = [undefined, {}];
                    curr[1][n] = child;
                }
                else {
                    return undefined;
                }
            }
            curr = child;
        }
        if (mkDefaultElement && !curr[0]) {
            curr[0] = mkDefaultElement();
        }
        return curr[0];
    };
    SymbolTree.prototype.delete = function (path) {
        var curr = this.tree;
        for (var i = 0; i < path.length - 1; i++) {
            var child = curr[1][this.mapper(path[i])];
            if (!child) {
                return;
            }
            curr = child;
        }
        delete curr[1][this.mapper(path[path.length - 1])];
    };
    return SymbolTree;
}());
exports.default = SymbolTree;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("snabbdom/vnode");
var h_1 = require("snabbdom/h");
var snabbdom_selector_1 = require("snabbdom-selector");
var utils_1 = require("./utils");
var VNodeWrapper = /** @class */ (function () {
    function VNodeWrapper(rootElement) {
        this.rootElement = rootElement;
    }
    VNodeWrapper.prototype.call = function (vnode) {
        if (utils_1.isDocFrag(this.rootElement)) {
            return this.wrapDocFrag(vnode === null ? [] : [vnode]);
        }
        if (vnode === null) {
            return this.wrap([]);
        }
        var _a = snabbdom_selector_1.selectorParser(vnode), selTagName = _a.tagName, selId = _a.id;
        var vNodeClassName = snabbdom_selector_1.classNameFromVNode(vnode);
        var vNodeData = vnode.data || {};
        var vNodeDataProps = vNodeData.props || {};
        var _b = vNodeDataProps.id, vNodeId = _b === void 0 ? selId : _b;
        var isVNodeAndRootElementIdentical = typeof vNodeId === 'string' &&
            vNodeId.toUpperCase() === this.rootElement.id.toUpperCase() &&
            selTagName.toUpperCase() === this.rootElement.tagName.toUpperCase() &&
            vNodeClassName.toUpperCase() === this.rootElement.className.toUpperCase();
        if (isVNodeAndRootElementIdentical) {
            return vnode;
        }
        return this.wrap([vnode]);
    };
    VNodeWrapper.prototype.wrapDocFrag = function (children) {
        return vnode_1.vnode('', { isolate: [] }, children, undefined, this
            .rootElement);
    };
    VNodeWrapper.prototype.wrap = function (children) {
        var _a = this.rootElement, tagName = _a.tagName, id = _a.id, className = _a.className;
        var selId = id ? "#" + id : '';
        var selClass = className ? "." + className.split(" ").join(".") : '';
        var vnode = h_1.h("" + tagName.toLowerCase() + selId + selClass, {}, children);
        vnode.data = vnode.data || {};
        vnode.data.isolate = vnode.data.isolate || [];
        return vnode;
    };
    return VNodeWrapper;
}());
exports.VNodeWrapper = VNodeWrapper;

},{"./utils":25,"snabbdom-selector":183,"snabbdom/h":187,"snabbdom/vnode":198}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xstream_1 = require("xstream");
function fromEvent(element, eventName, useCapture, preventDefault, passive) {
    if (useCapture === void 0) { useCapture = false; }
    if (preventDefault === void 0) { preventDefault = false; }
    if (passive === void 0) { passive = false; }
    var next = null;
    return xstream_1.Stream.create({
        start: function start(listener) {
            if (preventDefault) {
                next = function _next(event) {
                    preventDefaultConditional(event, preventDefault);
                    listener.next(event);
                };
            }
            else {
                next = function _next(event) {
                    listener.next(event);
                };
            }
            element.addEventListener(eventName, next, {
                capture: useCapture,
                passive: passive,
            });
        },
        stop: function stop() {
            element.removeEventListener(eventName, next, useCapture);
            next = null;
        },
    });
}
exports.fromEvent = fromEvent;
function matchObject(matcher, obj) {
    var keys = Object.keys(matcher);
    var n = keys.length;
    for (var i = 0; i < n; i++) {
        var k = keys[i];
        if (typeof matcher[k] === 'object' && typeof obj[k] === 'object') {
            if (!matchObject(matcher[k], obj[k])) {
                return false;
            }
        }
        else if (matcher[k] !== obj[k]) {
            return false;
        }
    }
    return true;
}
function preventDefaultConditional(event, preventDefault) {
    if (preventDefault) {
        if (typeof preventDefault === 'boolean') {
            event.preventDefault();
        }
        else if (isPredicate(preventDefault)) {
            if (preventDefault(event)) {
                event.preventDefault();
            }
        }
        else if (typeof preventDefault === 'object') {
            if (matchObject(preventDefault, event)) {
                event.preventDefault();
            }
        }
        else {
            throw new Error('preventDefault has to be either a boolean, predicate function or object');
        }
    }
}
exports.preventDefaultConditional = preventDefaultConditional;
function isPredicate(fn) {
    return typeof fn === 'function';
}

},{"xstream":212}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:max-file-line-count
var h_1 = require("snabbdom/h");
function isValidString(param) {
    return typeof param === 'string' && param.length > 0;
}
function isSelector(param) {
    return isValidString(param) && (param[0] === '.' || param[0] === '#');
}
function createTagFunction(tagName) {
    return function hyperscript(a, b, c) {
        var hasA = typeof a !== 'undefined';
        var hasB = typeof b !== 'undefined';
        var hasC = typeof c !== 'undefined';
        if (isSelector(a)) {
            if (hasB && hasC) {
                return h_1.h(tagName + a, b, c);
            }
            else if (hasB) {
                return h_1.h(tagName + a, b);
            }
            else {
                return h_1.h(tagName + a, {});
            }
        }
        else if (hasC) {
            return h_1.h(tagName + a, b, c);
        }
        else if (hasB) {
            return h_1.h(tagName, a, b);
        }
        else if (hasA) {
            return h_1.h(tagName, a);
        }
        else {
            return h_1.h(tagName, {});
        }
    };
}
var SVG_TAG_NAMES = [
    'a',
    'altGlyph',
    'altGlyphDef',
    'altGlyphItem',
    'animate',
    'animateColor',
    'animateMotion',
    'animateTransform',
    'circle',
    'clipPath',
    'colorProfile',
    'cursor',
    'defs',
    'desc',
    'ellipse',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDistantLight',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotlight',
    'feTile',
    'feTurbulence',
    'filter',
    'font',
    'fontFace',
    'fontFaceFormat',
    'fontFaceName',
    'fontFaceSrc',
    'fontFaceUri',
    'foreignObject',
    'g',
    'glyph',
    'glyphRef',
    'hkern',
    'image',
    'line',
    'linearGradient',
    'marker',
    'mask',
    'metadata',
    'missingGlyph',
    'mpath',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'script',
    'set',
    'stop',
    'style',
    'switch',
    'symbol',
    'text',
    'textPath',
    'title',
    'tref',
    'tspan',
    'use',
    'view',
    'vkern',
];
var svg = createTagFunction('svg');
SVG_TAG_NAMES.forEach(function (tag) {
    svg[tag] = createTagFunction(tag);
});
var TAG_NAMES = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'dd',
    'del',
    'details',
    'dfn',
    'dir',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'menu',
    'meta',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'p',
    'param',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'u',
    'ul',
    'video',
];
var exported = {
    SVG_TAG_NAMES: SVG_TAG_NAMES,
    TAG_NAMES: TAG_NAMES,
    svg: svg,
    isSelector: isSelector,
    createTagFunction: createTagFunction,
};
TAG_NAMES.forEach(function (n) {
    exported[n] = createTagFunction(n);
});
exports.default = exported;

},{"snabbdom/h":187}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var thunk_1 = require("./thunk");
exports.thunk = thunk_1.thunk;
var MainDOMSource_1 = require("./MainDOMSource");
exports.MainDOMSource = MainDOMSource_1.MainDOMSource;
/**
 * A factory for the DOM driver function.
 *
 * Takes a `container` to define the target on the existing DOM which this
 * driver will operate on, and an `options` object as the second argument. The
 * input to this driver is a stream of virtual DOM objects, or in other words,
 * Snabbdom "VNode" objects. The output of this driver is a "DOMSource": a
 * collection of Observables queried with the methods `select()` and `events()`.
 *
 * **`DOMSource.select(selector)`** returns a new DOMSource with scope
 * restricted to the element(s) that matches the CSS `selector` given. To select
 * the page's `document`, use `.select('document')`. To select the container
 * element for this app, use `.select(':root')`.
 *
 * **`DOMSource.events(eventType, options)`** returns a stream of events of
 * `eventType` happening on the elements that match the current DOMSource. The
 * event object contains the `ownerTarget` property that behaves exactly like
 * `currentTarget`. The reason for this is that some browsers doesn't allow
 * `currentTarget` property to be mutated, hence a new property is created. The
 * returned stream is an *xstream* Stream if you use `@cycle/xstream-run` to run
 * your app with this driver, or it is an RxJS Observable if you use
 * `@cycle/rxjs-run`, and so forth.
 *
 * **options for DOMSource.events**
 *
 * The `options` parameter on `DOMSource.events(eventType, options)` is an
 * (optional) object with two optional fields: `useCapture` and
 * `preventDefault`.
 *
 * `useCapture` is by default `false`, except it is `true` for event types that
 * do not bubble. Read more here
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * about the `useCapture` and its purpose.
 *
 * `preventDefault` is by default `false`, and indicates to the driver whether
 * `event.preventDefault()` should be invoked. This option can be configured in
 * three ways:
 *
 * - `{preventDefault: boolean}` to invoke preventDefault if `true`, and not
 * invoke otherwise.
 * - `{preventDefault: (ev: Event) => boolean}` for conditional invocation.
 * - `{preventDefault: NestedObject}` uses an object to be recursively compared
 * to the `Event` object. `preventDefault` is invoked when all properties on the
 * nested object match with the properties on the event object.
 *
 * Here are some examples:
 * ```typescript
 * // always prevent default
 * DOMSource.select('input').events('keydown', {
 *   preventDefault: true
 * })
 *
 * // prevent default only when `ENTER` is pressed
 * DOMSource.select('input').events('keydown', {
 *   preventDefault: e => e.keyCode === 13
 * })
 *
 * // prevent defualt when `ENTER` is pressed AND target.value is 'HELLO'
 * DOMSource.select('input').events('keydown', {
 *   preventDefault: { keyCode: 13, ownerTarget: { value: 'HELLO' } }
 * });
 * ```
 *
 * **`DOMSource.elements()`** returns a stream of arrays containing the DOM
 * elements that match the selectors in the DOMSource (e.g. from previous
 * `select(x)` calls).
 *
 * **`DOMSource.element()`** returns a stream of DOM elements. Notice that this
 * is the singular version of `.elements()`, so the stream will emit an element,
 * not an array. If there is no element that matches the selected DOMSource,
 * then the returned stream will not emit anything.
 *
 * @param {(String|HTMLElement)} container the DOM selector for the element
 * (or the element itself) to contain the rendering of the VTrees.
 * @param {DOMDriverOptions} options an object with two optional properties:
 *
 *   - `modules: array` overrides `@cycle/dom`'s default Snabbdom modules as
 *     as defined in [`src/modules.ts`](./src/modules.ts).
 * @return {Function} the DOM driver function. The function expects a stream of
 * VNode as input, and outputs the DOMSource object.
 * @function makeDOMDriver
 */
var makeDOMDriver_1 = require("./makeDOMDriver");
exports.makeDOMDriver = makeDOMDriver_1.makeDOMDriver;
/**
 * A factory function to create mocked DOMSource objects, for testing purposes.
 *
 * Takes a `mockConfig` object as argument, and returns
 * a DOMSource that can be given to any Cycle.js app that expects a DOMSource in
 * the sources, for testing.
 *
 * The `mockConfig` parameter is an object specifying selectors, eventTypes and
 * their streams. Example:
 *
 * ```js
 * const domSource = mockDOMSource({
 *   '.foo': {
 *     'click': xs.of({target: {}}),
 *     'mouseover': xs.of({target: {}}),
 *   },
 *   '.bar': {
 *     'scroll': xs.of({target: {}}),
 *     elements: xs.of({tagName: 'div'}),
 *   }
 * });
 *
 * // Usage
 * const click$ = domSource.select('.foo').events('click');
 * const element$ = domSource.select('.bar').elements();
 * ```
 *
 * The mocked DOM Source supports isolation. It has the functions `isolateSink`
 * and `isolateSource` attached to it, and performs simple isolation using
 * classNames. *isolateSink* with scope `foo` will append the class `___foo` to
 * the stream of virtual DOM nodes, and *isolateSource* with scope `foo` will
 * perform a conventional `mockedDOMSource.select('.__foo')` call.
 *
 * @param {Object} mockConfig an object where keys are selector strings
 * and values are objects. Those nested objects have `eventType` strings as keys
 * and values are streams you created.
 * @return {Object} fake DOM source object, with an API containing `select()`
 * and `events()` and `elements()` which can be used just like the DOM Driver's
 * DOMSource.
 *
 * @function mockDOMSource
 */
var mockDOMSource_1 = require("./mockDOMSource");
exports.mockDOMSource = mockDOMSource_1.mockDOMSource;
exports.MockedDOMSource = mockDOMSource_1.MockedDOMSource;
/**
 * The hyperscript function `h()` is a function to create virtual DOM objects,
 * also known as VNodes. Call
 *
 * ```js
 * h('div.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * to create a VNode that represents a `DIV` element with className `myClass`,
 * styled with red color, and no children because the `[]` array was passed. The
 * API is `h(tagOrSelector, optionalData, optionalChildrenOrText)`.
 *
 * However, usually you should use "hyperscript helpers", which are shortcut
 * functions based on hyperscript. There is one hyperscript helper function for
 * each DOM tagName, such as `h1()`, `h2()`, `div()`, `span()`, `label()`,
 * `input()`. For instance, the previous example could have been written
 * as:
 *
 * ```js
 * div('.myClass', {style: {color: 'red'}}, [])
 * ```
 *
 * There are also SVG helper functions, which apply the appropriate SVG
 * namespace to the resulting elements. `svg()` function creates the top-most
 * SVG element, and `svg.g`, `svg.polygon`, `svg.circle`, `svg.path` are for
 * SVG-specific child elements. Example:
 *
 * ```js
 * svg({attrs: {width: 150, height: 150}}, [
 *   svg.polygon({
 *     attrs: {
 *       class: 'triangle',
 *       points: '20 0 20 150 150 20'
 *     }
 *   })
 * ])
 * ```
 *
 * @function h
 */
var h_1 = require("snabbdom/h");
exports.h = h_1.h;
var hyperscript_helpers_1 = require("./hyperscript-helpers");
exports.svg = hyperscript_helpers_1.default.svg;
exports.a = hyperscript_helpers_1.default.a;
exports.abbr = hyperscript_helpers_1.default.abbr;
exports.address = hyperscript_helpers_1.default.address;
exports.area = hyperscript_helpers_1.default.area;
exports.article = hyperscript_helpers_1.default.article;
exports.aside = hyperscript_helpers_1.default.aside;
exports.audio = hyperscript_helpers_1.default.audio;
exports.b = hyperscript_helpers_1.default.b;
exports.base = hyperscript_helpers_1.default.base;
exports.bdi = hyperscript_helpers_1.default.bdi;
exports.bdo = hyperscript_helpers_1.default.bdo;
exports.blockquote = hyperscript_helpers_1.default.blockquote;
exports.body = hyperscript_helpers_1.default.body;
exports.br = hyperscript_helpers_1.default.br;
exports.button = hyperscript_helpers_1.default.button;
exports.canvas = hyperscript_helpers_1.default.canvas;
exports.caption = hyperscript_helpers_1.default.caption;
exports.cite = hyperscript_helpers_1.default.cite;
exports.code = hyperscript_helpers_1.default.code;
exports.col = hyperscript_helpers_1.default.col;
exports.colgroup = hyperscript_helpers_1.default.colgroup;
exports.dd = hyperscript_helpers_1.default.dd;
exports.del = hyperscript_helpers_1.default.del;
exports.dfn = hyperscript_helpers_1.default.dfn;
exports.dir = hyperscript_helpers_1.default.dir;
exports.div = hyperscript_helpers_1.default.div;
exports.dl = hyperscript_helpers_1.default.dl;
exports.dt = hyperscript_helpers_1.default.dt;
exports.em = hyperscript_helpers_1.default.em;
exports.embed = hyperscript_helpers_1.default.embed;
exports.fieldset = hyperscript_helpers_1.default.fieldset;
exports.figcaption = hyperscript_helpers_1.default.figcaption;
exports.figure = hyperscript_helpers_1.default.figure;
exports.footer = hyperscript_helpers_1.default.footer;
exports.form = hyperscript_helpers_1.default.form;
exports.h1 = hyperscript_helpers_1.default.h1;
exports.h2 = hyperscript_helpers_1.default.h2;
exports.h3 = hyperscript_helpers_1.default.h3;
exports.h4 = hyperscript_helpers_1.default.h4;
exports.h5 = hyperscript_helpers_1.default.h5;
exports.h6 = hyperscript_helpers_1.default.h6;
exports.head = hyperscript_helpers_1.default.head;
exports.header = hyperscript_helpers_1.default.header;
exports.hgroup = hyperscript_helpers_1.default.hgroup;
exports.hr = hyperscript_helpers_1.default.hr;
exports.html = hyperscript_helpers_1.default.html;
exports.i = hyperscript_helpers_1.default.i;
exports.iframe = hyperscript_helpers_1.default.iframe;
exports.img = hyperscript_helpers_1.default.img;
exports.input = hyperscript_helpers_1.default.input;
exports.ins = hyperscript_helpers_1.default.ins;
exports.kbd = hyperscript_helpers_1.default.kbd;
exports.keygen = hyperscript_helpers_1.default.keygen;
exports.label = hyperscript_helpers_1.default.label;
exports.legend = hyperscript_helpers_1.default.legend;
exports.li = hyperscript_helpers_1.default.li;
exports.link = hyperscript_helpers_1.default.link;
exports.main = hyperscript_helpers_1.default.main;
exports.map = hyperscript_helpers_1.default.map;
exports.mark = hyperscript_helpers_1.default.mark;
exports.menu = hyperscript_helpers_1.default.menu;
exports.meta = hyperscript_helpers_1.default.meta;
exports.nav = hyperscript_helpers_1.default.nav;
exports.noscript = hyperscript_helpers_1.default.noscript;
exports.object = hyperscript_helpers_1.default.object;
exports.ol = hyperscript_helpers_1.default.ol;
exports.optgroup = hyperscript_helpers_1.default.optgroup;
exports.option = hyperscript_helpers_1.default.option;
exports.p = hyperscript_helpers_1.default.p;
exports.param = hyperscript_helpers_1.default.param;
exports.pre = hyperscript_helpers_1.default.pre;
exports.progress = hyperscript_helpers_1.default.progress;
exports.q = hyperscript_helpers_1.default.q;
exports.rp = hyperscript_helpers_1.default.rp;
exports.rt = hyperscript_helpers_1.default.rt;
exports.ruby = hyperscript_helpers_1.default.ruby;
exports.s = hyperscript_helpers_1.default.s;
exports.samp = hyperscript_helpers_1.default.samp;
exports.script = hyperscript_helpers_1.default.script;
exports.section = hyperscript_helpers_1.default.section;
exports.select = hyperscript_helpers_1.default.select;
exports.small = hyperscript_helpers_1.default.small;
exports.source = hyperscript_helpers_1.default.source;
exports.span = hyperscript_helpers_1.default.span;
exports.strong = hyperscript_helpers_1.default.strong;
exports.style = hyperscript_helpers_1.default.style;
exports.sub = hyperscript_helpers_1.default.sub;
exports.sup = hyperscript_helpers_1.default.sup;
exports.table = hyperscript_helpers_1.default.table;
exports.tbody = hyperscript_helpers_1.default.tbody;
exports.td = hyperscript_helpers_1.default.td;
exports.textarea = hyperscript_helpers_1.default.textarea;
exports.tfoot = hyperscript_helpers_1.default.tfoot;
exports.th = hyperscript_helpers_1.default.th;
exports.thead = hyperscript_helpers_1.default.thead;
exports.title = hyperscript_helpers_1.default.title;
exports.tr = hyperscript_helpers_1.default.tr;
exports.u = hyperscript_helpers_1.default.u;
exports.ul = hyperscript_helpers_1.default.ul;
exports.video = hyperscript_helpers_1.default.video;

},{"./MainDOMSource":11,"./hyperscript-helpers":18,"./makeDOMDriver":21,"./mockDOMSource":22,"./thunk":24,"snabbdom/h":187}],20:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
function makeIsolateSink(namespace) {
    return function (sink, scope) {
        if (scope === ':root') {
            return sink;
        }
        return sink.map(function (node) {
            if (!node) {
                return node;
            }
            var scopeObj = getScopeObj(scope);
            var newNode = __assign({}, node, { data: __assign({}, node.data, { isolate: !node.data || !Array.isArray(node.data.isolate)
                        ? namespace.concat([scopeObj])
                        : node.data.isolate }) });
            return __assign({}, newNode, { key: newNode.key !== undefined
                    ? newNode.key
                    : JSON.stringify(newNode.data.isolate) });
        });
    };
}
exports.makeIsolateSink = makeIsolateSink;
function getScopeObj(scope) {
    return {
        type: utils_1.isClassOrId(scope) ? 'sibling' : 'total',
        scope: scope,
    };
}
exports.getScopeObj = getScopeObj;

},{"./utils":25}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var snabbdom_1 = require("snabbdom");
var xstream_1 = require("xstream");
var concat_1 = require("xstream/extra/concat");
var sampleCombine_1 = require("xstream/extra/sampleCombine");
var MainDOMSource_1 = require("./MainDOMSource");
var tovnode_1 = require("snabbdom/tovnode");
var VNodeWrapper_1 = require("./VNodeWrapper");
var utils_1 = require("./utils");
var modules_1 = require("./modules");
var IsolateModule_1 = require("./IsolateModule");
var EventDelegator_1 = require("./EventDelegator");
function makeDOMDriverInputGuard(modules) {
    if (!Array.isArray(modules)) {
        throw new Error("Optional modules option must be an array for snabbdom modules");
    }
}
function domDriverInputGuard(view$) {
    if (!view$ ||
        typeof view$.addListener !== "function" ||
        typeof view$.fold !== "function") {
        throw new Error("The DOM driver function expects as input a Stream of " +
            "virtual DOM elements");
    }
}
function dropCompletion(input) {
    return xstream_1.default.merge(input, xstream_1.default.never());
}
function unwrapElementFromVNode(vnode) {
    return vnode.elm;
}
function reportSnabbdomError(err) {
    (console.error || console.log)(err);
}
function makeDOMReady$() {
    return xstream_1.default.create({
        start: function (lis) {
            if (document.readyState === 'loading') {
                document.addEventListener('readystatechange', function () {
                    var state = document.readyState;
                    if (state === 'interactive' || state === 'complete') {
                        lis.next(null);
                        lis.complete();
                    }
                });
            }
            else {
                lis.next(null);
                lis.complete();
            }
        },
        stop: function () { },
    });
}
function addRootScope(vnode) {
    vnode.data = vnode.data || {};
    vnode.data.isolate = [];
    return vnode;
}
function makeDOMDriver(container, options) {
    if (!options) {
        options = {};
    }
    utils_1.checkValidContainer(container);
    var modules = options.modules || modules_1.default;
    makeDOMDriverInputGuard(modules);
    var isolateModule = new IsolateModule_1.IsolateModule();
    var patch = snabbdom_1.init([isolateModule.createModule()].concat(modules));
    var domReady$ = makeDOMReady$();
    var vnodeWrapper;
    var mutationObserver;
    var mutationConfirmed$ = xstream_1.default.create({
        start: function (listener) {
            mutationObserver = new MutationObserver(function () { return listener.next(null); });
        },
        stop: function () {
            mutationObserver.disconnect();
        },
    });
    function DOMDriver(vnode$, name) {
        if (name === void 0) { name = 'DOM'; }
        domDriverInputGuard(vnode$);
        var sanitation$ = xstream_1.default.create();
        var firstRoot$ = domReady$.map(function () {
            var firstRoot = utils_1.getValidNode(container) || document.body;
            vnodeWrapper = new VNodeWrapper_1.VNodeWrapper(firstRoot);
            return firstRoot;
        });
        // We need to subscribe to the sink (i.e. vnode$) synchronously inside this
        // driver, and not later in the map().flatten() because this sink is in
        // reality a SinkProxy from @cycle/run, and we don't want to miss the first
        // emission when the main() is connected to the drivers.
        // Read more in issue #739.
        var rememberedVNode$ = vnode$.remember();
        rememberedVNode$.addListener({});
        // The mutation observer internal to mutationConfirmed$ should
        // exist before elementAfterPatch$ calls mutationObserver.observe()
        mutationConfirmed$.addListener({});
        var elementAfterPatch$ = firstRoot$
            .map(function (firstRoot) {
            return xstream_1.default
                .merge(rememberedVNode$.endWhen(sanitation$), sanitation$)
                .map(function (vnode) { return vnodeWrapper.call(vnode); })
                .startWith(addRootScope(tovnode_1.toVNode(firstRoot)))
                .fold(patch, tovnode_1.toVNode(firstRoot))
                .drop(1)
                .map(unwrapElementFromVNode)
                .startWith(firstRoot)
                .map(function (el) {
                mutationObserver.observe(el, {
                    childList: true,
                    attributes: true,
                    characterData: true,
                    subtree: true,
                    attributeOldValue: true,
                    characterDataOldValue: true,
                });
                return el;
            })
                .compose(dropCompletion);
        } // don't complete this stream
        )
            .flatten();
        var rootElement$ = concat_1.default(domReady$, mutationConfirmed$)
            .endWhen(sanitation$)
            .compose(sampleCombine_1.default(elementAfterPatch$))
            .map(function (arr) { return arr[1]; })
            .remember();
        // Start the snabbdom patching, over time
        rootElement$.addListener({ error: reportSnabbdomError });
        var delegator = new EventDelegator_1.EventDelegator(rootElement$, isolateModule);
        return new MainDOMSource_1.MainDOMSource(rootElement$, sanitation$, [], isolateModule, delegator, name);
    }
    return DOMDriver;
}
exports.makeDOMDriver = makeDOMDriver;

},{"./EventDelegator":9,"./IsolateModule":10,"./MainDOMSource":11,"./VNodeWrapper":16,"./modules":23,"./utils":25,"snabbdom":195,"snabbdom/tovnode":197,"xstream":212,"xstream/extra/concat":210,"xstream/extra/sampleCombine":211}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xstream_1 = require("xstream");
var adapt_1 = require("@cycle/run/lib/adapt");
var SCOPE_PREFIX = '___';
var MockedDOMSource = /** @class */ (function () {
    function MockedDOMSource(_mockConfig) {
        this._mockConfig = _mockConfig;
        if (_mockConfig.elements) {
            this._elements = _mockConfig.elements;
        }
        else {
            this._elements = adapt_1.adapt(xstream_1.default.empty());
        }
    }
    MockedDOMSource.prototype.elements = function () {
        var out = this
            ._elements;
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.element = function () {
        var output$ = this.elements()
            .filter(function (arr) { return arr.length > 0; })
            .map(function (arr) { return arr[0]; })
            .remember();
        var out = adapt_1.adapt(output$);
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.events = function (eventType, options, bubbles) {
        var streamForEventType = this._mockConfig[eventType];
        var out = adapt_1.adapt(streamForEventType || xstream_1.default.empty());
        out._isCycleSource = 'MockedDOM';
        return out;
    };
    MockedDOMSource.prototype.select = function (selector) {
        var mockConfigForSelector = this._mockConfig[selector] || {};
        return new MockedDOMSource(mockConfigForSelector);
    };
    MockedDOMSource.prototype.isolateSource = function (source, scope) {
        return source.select('.' + SCOPE_PREFIX + scope);
    };
    MockedDOMSource.prototype.isolateSink = function (sink, scope) {
        return adapt_1.adapt(xstream_1.default.fromObservable(sink).map(function (vnode) {
            if (vnode.sel && vnode.sel.indexOf(SCOPE_PREFIX + scope) !== -1) {
                return vnode;
            }
            else {
                vnode.sel += "." + SCOPE_PREFIX + scope;
                return vnode;
            }
        }));
    };
    return MockedDOMSource;
}());
exports.MockedDOMSource = MockedDOMSource;
function mockDOMSource(mockConfig) {
    return new MockedDOMSource(mockConfig);
}
exports.mockDOMSource = mockDOMSource;

},{"@cycle/run/lib/adapt":26,"xstream":212}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var class_1 = require("snabbdom/modules/class");
exports.ClassModule = class_1.default;
var props_1 = require("snabbdom/modules/props");
exports.PropsModule = props_1.default;
var attributes_1 = require("snabbdom/modules/attributes");
exports.AttrsModule = attributes_1.default;
var style_1 = require("snabbdom/modules/style");
exports.StyleModule = style_1.default;
var dataset_1 = require("snabbdom/modules/dataset");
exports.DatasetModule = dataset_1.default;
var modules = [
    style_1.default,
    class_1.default,
    props_1.default,
    attributes_1.default,
    dataset_1.default,
];
exports.default = modules;

},{"snabbdom/modules/attributes":190,"snabbdom/modules/class":191,"snabbdom/modules/dataset":192,"snabbdom/modules/props":193,"snabbdom/modules/style":194}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = require("snabbdom/h");
function copyToThunk(vnode, thunkVNode) {
    thunkVNode.elm = vnode.elm;
    vnode.data.fn = thunkVNode.data.fn;
    vnode.data.args = thunkVNode.data.args;
    vnode.data.isolate = thunkVNode.data.isolate;
    thunkVNode.data = vnode.data;
    thunkVNode.children = vnode.children;
    thunkVNode.text = vnode.text;
    thunkVNode.elm = vnode.elm;
}
function init(thunkVNode) {
    var cur = thunkVNode.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunkVNode);
}
function prepatch(oldVnode, thunkVNode) {
    var old = oldVnode.data, cur = thunkVNode.data;
    var i;
    var oldArgs = old.args, args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunkVNode);
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunkVNode);
            return;
        }
    }
    copyToThunk(oldVnode, thunkVNode);
}
function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return h_1.h(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args,
    });
}
exports.thunk = thunk;
exports.default = thunk;

},{"snabbdom/h":187}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isValidNode(obj) {
    var ELEM_TYPE = 1;
    var FRAG_TYPE = 11;
    return typeof HTMLElement === 'object'
        ? obj instanceof HTMLElement || obj instanceof DocumentFragment
        : obj &&
            typeof obj === 'object' &&
            obj !== null &&
            (obj.nodeType === ELEM_TYPE || obj.nodeType === FRAG_TYPE) &&
            typeof obj.nodeName === 'string';
}
function isClassOrId(str) {
    return str.length > 1 && (str[0] === '.' || str[0] === '#');
}
exports.isClassOrId = isClassOrId;
function isDocFrag(el) {
    return el.nodeType === 11;
}
exports.isDocFrag = isDocFrag;
function checkValidContainer(container) {
    if (typeof container !== 'string' && !isValidNode(container)) {
        throw new Error('Given container is not a DOM element neither a selector string.');
    }
}
exports.checkValidContainer = checkValidContainer;
function getValidNode(selectors) {
    var domElement = typeof selectors === 'string'
        ? document.querySelector(selectors)
        : selectors;
    if (typeof selectors === 'string' && domElement === null) {
        throw new Error("Cannot render into unknown element `" + selectors + "`");
    }
    return domElement;
}
exports.getValidNode = getValidNode;
function getSelectors(namespace) {
    var res = '';
    for (var i = namespace.length - 1; i >= 0; i--) {
        if (namespace[i].type !== 'selector') {
            break;
        }
        res = namespace[i].scope + ' ' + res;
    }
    return res.trim();
}
exports.getSelectors = getSelectors;
function isEqualNamespace(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {
        return false;
    }
    for (var i = 0; i < a.length; i++) {
        if (a[i].type !== b[i].type || a[i].scope !== b[i].scope) {
            return false;
        }
    }
    return true;
}
exports.isEqualNamespace = isEqualNamespace;
function makeInsert(map) {
    return function (type, elm, value) {
        if (map.has(type)) {
            var innerMap = map.get(type);
            innerMap.set(elm, value);
        }
        else {
            var innerMap = new Map();
            innerMap.set(elm, value);
            map.set(type, innerMap);
        }
    };
}
exports.makeInsert = makeInsert;

},{}],26:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getGlobal() {
    var globalObj;
    if (typeof window !== 'undefined') {
        globalObj = window;
    }
    else if (typeof global !== 'undefined') {
        globalObj = global;
    }
    else {
        globalObj = this;
    }
    globalObj.Cyclejs = globalObj.Cyclejs || {};
    globalObj = globalObj.Cyclejs;
    globalObj.adaptStream = globalObj.adaptStream || (function (x) { return x; });
    return globalObj;
}
function setAdapt(f) {
    getGlobal().adaptStream = f;
}
exports.setAdapt = setAdapt;
function adapt(stream) {
    return getGlobal().adaptStream(stream);
}
exports.adapt = adapt;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getGlobal() {
    var globalObj;
    if (typeof window !== 'undefined') {
        globalObj = window;
    }
    else if (typeof global !== 'undefined') {
        globalObj = global;
    }
    else {
        globalObj = this;
    }
    globalObj.Cyclejs = globalObj.Cyclejs || {};
    globalObj = globalObj.Cyclejs;
    globalObj.adaptStream = globalObj.adaptStream || (function (x) { return x; });
    return globalObj;
}
function setAdapt(f) {
    getGlobal().adaptStream = f;
}
exports.setAdapt = setAdapt;
function adapt(stream) {
    return getGlobal().adaptStream(stream);
}
exports.adapt = adapt;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var internals_1 = require("./internals");
/**
 * A function that prepares the Cycle application to be executed. Takes a `main`
 * function and prepares to circularly connects it to the given collection of
 * driver functions. As an output, `setup()` returns an object with three
 * properties: `sources`, `sinks` and `run`. Only when `run()` is called will
 * the application actually execute. Refer to the documentation of `run()` for
 * more details.
 *
 * **Example:**
 * ```js
 * import {setup} from '@cycle/run';
 * const {sources, sinks, run} = setup(main, drivers);
 * // ...
 * const dispose = run(); // Executes the application
 * // ...
 * dispose();
 * ```
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Object} an object with three properties: `sources`, `sinks` and
 * `run`. `sources` is the collection of driver sources, `sinks` is the
 * collection of driver sinks, these can be used for debugging or testing. `run`
 * is the function that once called will execute the application.
 * @function setup
 */
function setup(main, drivers) {
    if (typeof main !== "function") {
        throw new Error("First argument given to Cycle must be the 'main' " + "function.");
    }
    if (typeof drivers !== "object" || drivers === null) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with driver functions as properties.");
    }
    if (internals_1.isObjectEmpty(drivers)) {
        throw new Error("Second argument given to Cycle must be an object " +
            "with at least one driver function declared as a property.");
    }
    var engine = setupReusable(drivers);
    var sinks = main(engine.sources);
    if (typeof window !== 'undefined') {
        window.Cyclejs = window.Cyclejs || {};
        window.Cyclejs.sinks = sinks;
    }
    function _run() {
        var disposeRun = engine.run(sinks);
        return function dispose() {
            disposeRun();
            engine.dispose();
        };
    }
    return { sinks: sinks, sources: engine.sources, run: _run };
}
exports.setup = setup;
/**
 * A partially-applied variant of setup() which accepts only the drivers, and
 * allows many `main` functions to execute and reuse this same set of drivers.
 *
 * Takes an object with driver functions as input, and outputs an object which
 * contains the generated sources (from those drivers) and a `run` function
 * (which in turn expects sinks as argument). This `run` function can be called
 * multiple times with different arguments, and it will reuse the drivers that
 * were passed to `setupReusable`.
 *
 * **Example:**
 * ```js
 * import {setupReusable} from '@cycle/run';
 * const {sources, run, dispose} = setupReusable(drivers);
 * // ...
 * const sinks = main(sources);
 * const disposeRun = run(sinks);
 * // ...
 * disposeRun();
 * // ...
 * dispose(); // ends the reusability of drivers
 * ```
 *
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Object} an object with three properties: `sources`, `run` and
 * `dispose`. `sources` is the collection of driver sources, `run` is the
 * function that once called with 'sinks' as argument, will execute the
 * application, tying together sources with sinks. `dispose` terminates the
 * reusable resources used by the drivers. Note also that `run` returns a
 * dispose function which terminates resources that are specific (not reusable)
 * to that run.
 * @function setupReusable
 */
function setupReusable(drivers) {
    if (typeof drivers !== "object" || drivers === null) {
        throw new Error("Argument given to setupReusable must be an object " +
            "with driver functions as properties.");
    }
    if (internals_1.isObjectEmpty(drivers)) {
        throw new Error("Argument given to setupReusable must be an object " +
            "with at least one driver function declared as a property.");
    }
    var sinkProxies = internals_1.makeSinkProxies(drivers);
    var rawSources = internals_1.callDrivers(drivers, sinkProxies);
    var sources = internals_1.adaptSources(rawSources);
    function _run(sinks) {
        return internals_1.replicateMany(sinks, sinkProxies);
    }
    function disposeEngine() {
        internals_1.disposeSources(sources);
        internals_1.disposeSinkProxies(sinkProxies);
    }
    return { sources: sources, run: _run, dispose: disposeEngine };
}
exports.setupReusable = setupReusable;
/**
 * Takes a `main` function and circularly connects it to the given collection
 * of driver functions.
 *
 * **Example:**
 * ```js
 * import run from '@cycle/run';
 * const dispose = run(main, drivers);
 * // ...
 * dispose();
 * ```
 *
 * The `main` function expects a collection of "source" streams (returned from
 * drivers) as input, and should return a collection of "sink" streams (to be
 * given to drivers). A "collection of streams" is a JavaScript object where
 * keys match the driver names registered by the `drivers` object, and values
 * are the streams. Refer to the documentation of each driver to see more
 * details on what types of sources it outputs and sinks it receives.
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Function} a dispose function, used to terminate the execution of the
 * Cycle.js program, cleaning up resources used.
 * @function run
 */
function run(main, drivers) {
    var program = setup(main, drivers);
    if (typeof window !== 'undefined' &&
        window.CyclejsDevTool_startGraphSerializer) {
        window.CyclejsDevTool_startGraphSerializer(program.sinks);
    }
    return program.run();
}
exports.run = run;
exports.default = run;

},{"./internals":29}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xstream_1 = require("xstream");
var quicktask_1 = require("quicktask");
var adapt_1 = require("./adapt");
var scheduleMicrotask = quicktask_1.default();
function makeSinkProxies(drivers) {
    var sinkProxies = {};
    for (var name_1 in drivers) {
        if (drivers.hasOwnProperty(name_1)) {
            sinkProxies[name_1] = xstream_1.default.create();
        }
    }
    return sinkProxies;
}
exports.makeSinkProxies = makeSinkProxies;
function callDrivers(drivers, sinkProxies) {
    var sources = {};
    for (var name_2 in drivers) {
        if (drivers.hasOwnProperty(name_2)) {
            sources[name_2] = drivers[name_2](sinkProxies[name_2], name_2);
            if (sources[name_2] && typeof sources[name_2] === 'object') {
                sources[name_2]._isCycleSource = name_2;
            }
        }
    }
    return sources;
}
exports.callDrivers = callDrivers;
// NOTE: this will mutate `sources`.
function adaptSources(sources) {
    for (var name_3 in sources) {
        if (sources.hasOwnProperty(name_3) &&
            sources[name_3] &&
            typeof sources[name_3].shamefullySendNext ===
                'function') {
            sources[name_3] = adapt_1.adapt(sources[name_3]);
        }
    }
    return sources;
}
exports.adaptSources = adaptSources;
function replicateMany(sinks, sinkProxies) {
    var sinkNames = Object.keys(sinks).filter(function (name) { return !!sinkProxies[name]; });
    var buffers = {};
    var replicators = {};
    sinkNames.forEach(function (name) {
        buffers[name] = { _n: [], _e: [] };
        replicators[name] = {
            next: function (x) { return buffers[name]._n.push(x); },
            error: function (err) { return buffers[name]._e.push(err); },
            complete: function () { },
        };
    });
    var subscriptions = sinkNames.map(function (name) {
        return xstream_1.default.fromObservable(sinks[name]).subscribe(replicators[name]);
    });
    sinkNames.forEach(function (name) {
        var listener = sinkProxies[name];
        var next = function (x) {
            scheduleMicrotask(function () { return listener._n(x); });
        };
        var error = function (err) {
            scheduleMicrotask(function () {
                (console.error || console.log)(err);
                listener._e(err);
            });
        };
        buffers[name]._n.forEach(next);
        buffers[name]._e.forEach(error);
        replicators[name].next = next;
        replicators[name].error = error;
        // because sink.subscribe(replicator) had mutated replicator to add
        // _n, _e, _c, we must also update these:
        replicators[name]._n = next;
        replicators[name]._e = error;
    });
    buffers = null; // free up for GC
    return function disposeReplication() {
        subscriptions.forEach(function (s) { return s.unsubscribe(); });
    };
}
exports.replicateMany = replicateMany;
function disposeSinkProxies(sinkProxies) {
    Object.keys(sinkProxies).forEach(function (name) { return sinkProxies[name]._c(); });
}
exports.disposeSinkProxies = disposeSinkProxies;
function disposeSources(sources) {
    for (var k in sources) {
        if (sources.hasOwnProperty(k) &&
            sources[k] &&
            sources[k].dispose) {
            sources[k].dispose();
        }
    }
}
exports.disposeSources = disposeSources;
function isObjectEmpty(obj) {
    return Object.keys(obj).length === 0;
}
exports.isObjectEmpty = isObjectEmpty;

},{"./adapt":27,"quicktask":153,"xstream":212}],30:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":31,"./asn1/base":33,"./asn1/constants":37,"./asn1/decoders":39,"./asn1/encoders":42,"bn.js":45}],31:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":30,"inherits":128,"vm":209}],32:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":33,"buffer":76,"inherits":128}],33:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":32,"./node":34,"./reporter":35}],34:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var DecoderBuffer = require('../base').DecoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};

},{"../base":33,"minimalistic-assert":133}],35:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":128}],36:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":37}],37:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":36}],38:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":30,"inherits":128}],39:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":38,"./pem":40}],40:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":38,"buffer":76,"inherits":128}],41:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":30,"buffer":76,"inherits":128}],42:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":41,"./pem":43}],43:[function(require,module,exports){
var inherits = require('inherits');

var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":41,"inherits":128}],44:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],45:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buffer').Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":47}],46:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":47}],47:[function(require,module,exports){

},{}],48:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":171}],49:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":48,"./ghash":53,"./incr32":54,"buffer-xor":75,"cipher-base":77,"inherits":128,"safe-buffer":171}],50:[function(require,module,exports){
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":51,"./encrypter":52,"./modes/list.json":62}],51:[function(require,module,exports){
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./aes":48,"./authCipher":49,"./modes":61,"./streamCipher":64,"cipher-base":77,"evp_bytestokey":112,"inherits":128,"safe-buffer":171}],52:[function(require,module,exports){
var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./aes":48,"./authCipher":49,"./modes":61,"./streamCipher":64,"cipher-base":77,"evp_bytestokey":112,"inherits":128,"safe-buffer":171}],53:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":171}],54:[function(require,module,exports){
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],55:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":75}],56:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"buffer-xor":75,"safe-buffer":171}],57:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":171}],58:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":171}],59:[function(require,module,exports){
var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"../incr32":54,"buffer-xor":75,"safe-buffer":171}],60:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],61:[function(require,module,exports){
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./cbc":55,"./cfb":56,"./cfb1":57,"./cfb8":58,"./ctr":59,"./ecb":60,"./list.json":62,"./ofb":63}],62:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],63:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)

},{"buffer":76,"buffer-xor":75}],64:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":48,"cipher-base":77,"inherits":128,"safe-buffer":171}],65:[function(require,module,exports){
var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":50,"browserify-aes/modes":61,"browserify-des":66,"browserify-des/modes":67,"evp_bytestokey":112}],66:[function(require,module,exports){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

},{"cipher-base":77,"des.js":85,"inherits":128,"safe-buffer":171}],67:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],68:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

}).call(this,require("buffer").Buffer)

},{"bn.js":45,"buffer":76,"randombytes":154}],69:[function(require,module,exports){
module.exports = require('./browser/algorithms.json')

},{"./browser/algorithms.json":70}],70:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],71:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],72:[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash')
var stream = require('stream')
var inherits = require('inherits')
var sign = require('./sign')
var verify = require('./verify')

var algorithms = require('./algorithms.json')
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

}).call(this,require("buffer").Buffer)

},{"./algorithms.json":70,"./sign":73,"./verify":74,"buffer":76,"create-hash":80,"inherits":128,"stream":199}],73:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var EC = require('elliptic').ec
var BN = require('bn.js')
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

}).call(this,require("buffer").Buffer)

},{"./curves.json":71,"bn.js":45,"browserify-rsa":68,"buffer":76,"create-hmac":82,"elliptic":95,"parse-asn1":139}],74:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = require('bn.js')
var EC = require('elliptic').ec
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

}).call(this,require("buffer").Buffer)

},{"./curves.json":71,"bn.js":45,"buffer":76,"elliptic":95,"parse-asn1":139}],75:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)

},{"buffer":76}],76:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)

},{"base64-js":44,"buffer":76,"ieee754":127}],77:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":128,"safe-buffer":171,"stream":199,"string_decoder":200}],78:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":129}],79:[function(require,module,exports){
(function (Buffer){
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

}).call(this,require("buffer").Buffer)

},{"bn.js":45,"buffer":76,"elliptic":95}],80:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":77,"inherits":128,"md5.js":131,"ripemd160":170,"sha.js":173}],81:[function(require,module,exports){
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":131}],82:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"./legacy":83,"cipher-base":77,"create-hash/md5":81,"inherits":128,"ripemd160":170,"safe-buffer":171,"sha.js":173}],83:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"cipher-base":77,"inherits":128,"safe-buffer":171}],84:[function(require,module,exports){
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var algos = require('browserify-sign/algos')
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = require('diffie-hellman')

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = require('browserify-sign')

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill')

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}

},{"browserify-cipher":65,"browserify-sign":72,"browserify-sign/algos":69,"create-ecdh":79,"create-hash":80,"create-hmac":82,"diffie-hellman":91,"pbkdf2":140,"public-encrypt":147,"randombytes":154,"randomfill":155}],85:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":86,"./des/cipher":87,"./des/des":88,"./des/ede":89,"./des/utils":90}],86:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":128,"minimalistic-assert":133}],87:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":133}],88:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"../des":85,"inherits":128,"minimalistic-assert":133}],89:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"../des":85,"inherits":128,"minimalistic-assert":133}],90:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],91:[function(require,module,exports){
(function (Buffer){
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

}).call(this,require("buffer").Buffer)

},{"./lib/dh":92,"./lib/generatePrime":93,"./lib/primes.json":94,"buffer":76}],92:[function(require,module,exports){
(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this,require("buffer").Buffer)

},{"./generatePrime":93,"bn.js":45,"buffer":76,"miller-rabin":132,"randombytes":154}],93:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":45,"miller-rabin":132,"randombytes":154}],94:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],95:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":110,"./elliptic/curve":98,"./elliptic/curves":101,"./elliptic/ec":102,"./elliptic/eddsa":105,"./elliptic/utils":109,"brorand":46}],96:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":109,"bn.js":45}],97:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":109,"./base":96,"bn.js":45,"inherits":128}],98:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":96,"./edwards":97,"./mont":99,"./short":100}],99:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":109,"./base":96,"bn.js":45,"inherits":128}],100:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":109,"./base":96,"bn.js":45,"inherits":128}],101:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});

},{"./curve":98,"./precomputed/secp256k1":108,"./utils":109,"hash.js":114}],102:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":101,"../utils":109,"./key":103,"./signature":104,"bn.js":45,"brorand":46,"hmac-drbg":126}],103:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":109,"bn.js":45}],104:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":109,"bn.js":45}],105:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":101,"../utils":109,"./key":106,"./signature":107,"hash.js":114}],106:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":109}],107:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":109,"bn.js":45}],108:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};

},{}],109:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":45,"minimalistic-assert":133,"minimalistic-crypto-utils":134}],110:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "elliptic@6.5.0",
      "/Users/mjyc/hcrlab/cycle-robot-drivers/examples/demos/handtrack"
    ]
  ],
  "_development": true,
  "_from": "elliptic@6.5.0",
  "_id": "elliptic@6.5.0",
  "_inBundle": false,
  "_integrity": "sha512-eFOJTMyCYb7xtE/caJ6JJu+bhi67WCYNbkGSknu20pmM8Ke/bqOfdnZWxyoGN26JgfxTbXrsCkEw4KheCT/KGg==",
  "_location": "/elliptic",
  "_phantomChildren": {},
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "elliptic@6.5.0",
    "name": "elliptic",
    "escapedName": "elliptic",
    "rawSpec": "6.5.0",
    "saveSpec": null,
    "fetchSpec": "6.5.0"
  },
  "_requiredBy": [
    "/browserify-sign",
    "/create-ecdh"
  ],
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.0.tgz",
  "_spec": "6.5.0",
  "_where": "/Users/mjyc/hcrlab/cycle-robot-drivers/examples/demos/handtrack",
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "dependencies": {
    "bn.js": "^4.4.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.0",
    "inherits": "^2.0.1",
    "minimalistic-assert": "^1.0.0",
    "minimalistic-crypto-utils": "^1.0.0"
  },
  "description": "EC cryptography",
  "devDependencies": {
    "brfs": "^1.4.3",
    "coveralls": "^2.11.3",
    "grunt": "^0.4.5",
    "grunt-browserify": "^5.0.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-connect": "^1.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^1.0.1",
    "grunt-mocha-istanbul": "^3.0.1",
    "grunt-saucelabs": "^8.6.2",
    "istanbul": "^0.4.2",
    "jscs": "^2.9.0",
    "jshint": "^2.6.0",
    "mocha": "^2.1.0"
  },
  "files": [
    "lib"
  ],
  "homepage": "https://github.com/indutny/elliptic",
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "license": "MIT",
  "main": "lib/elliptic.js",
  "name": "elliptic",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "scripts": {
    "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "lint": "npm run jscs && npm run jshint",
    "test": "npm run lint && npm run unit",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "version": "grunt dist && git add dist/"
  },
  "version": "6.5.0"
}

},{}],111:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],112:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"md5.js":131,"safe-buffer":171}],113:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":128,"safe-buffer":171,"stream":199}],114:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":115,"./hash/hmac":116,"./hash/ripemd":117,"./hash/sha":118,"./hash/utils":125}],115:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":125,"minimalistic-assert":133}],116:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":125,"minimalistic-assert":133}],117:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":115,"./utils":125}],118:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":119,"./sha/224":120,"./sha/256":121,"./sha/384":122,"./sha/512":123}],119:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":115,"../utils":125,"./common":124}],120:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":125,"./256":121}],121:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":115,"../utils":125,"./common":124,"minimalistic-assert":133}],122:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":125,"./512":123}],123:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":115,"../utils":125,"minimalistic-assert":133}],124:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":125}],125:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":128,"minimalistic-assert":133}],126:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":114,"minimalistic-assert":133,"minimalistic-crypto-utils":134}],127:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],128:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],129:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],130:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],131:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":113,"inherits":128,"safe-buffer":171}],132:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":45,"brorand":46}],133:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],134:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],135:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],136:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
'use strict'

var asn1 = require('asn1.js')

exports.certificate = require('./certificate')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

},{"./certificate":137,"asn1.js":30}],137:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict'

var asn = require('asn1.js')

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate

},{"asn1.js":30}],138:[function(require,module,exports){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
var Buffer = require('safe-buffer').Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

},{"browserify-aes":50,"evp_bytestokey":112,"safe-buffer":171}],139:[function(require,module,exports){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
var Buffer = require('safe-buffer').Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

},{"./aesid.json":135,"./asn1":136,"./fixProc":138,"browserify-aes":50,"pbkdf2":140,"safe-buffer":171}],140:[function(require,module,exports){
exports.pbkdf2 = require('./lib/async')
exports.pbkdf2Sync = require('./lib/sync')

},{"./lib/async":141,"./lib/sync":144}],141:[function(require,module,exports){
(function (process,global){
var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var sync = require('./sync')
var Buffer = require('safe-buffer').Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(password, salt, iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./default-encoding":142,"./precondition":143,"./sync":144,"_process":146,"safe-buffer":171}],142:[function(require,module,exports){
(function (process){
var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

}).call(this,require('_process'))

},{"_process":146}],143:[function(require,module,exports){
(function (Buffer){
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":129}],144:[function(require,module,exports){
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var Buffer = require('safe-buffer').Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen)

  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2

},{"./default-encoding":142,"./precondition":143,"create-hash/md5":81,"ripemd160":170,"safe-buffer":171,"sha.js":173}],145:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":146}],146:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],147:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

},{"./privateDecrypt":149,"./publicEncrypt":150}],148:[function(require,module,exports){
var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

},{"create-hash":80,"safe-buffer":171}],149:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

},{"./mgf":148,"./withPublic":151,"./xor":152,"bn.js":45,"browserify-rsa":68,"create-hash":80,"parse-asn1":139,"safe-buffer":171}],150:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

},{"./mgf":148,"./withPublic":151,"./xor":152,"bn.js":45,"browserify-rsa":68,"create-hash":80,"parse-asn1":139,"randombytes":154,"safe-buffer":171}],151:[function(require,module,exports){
var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

},{"bn.js":45,"safe-buffer":171}],152:[function(require,module,exports){
module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

},{}],153:[function(require,module,exports){
(function (process,setImmediate){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function microtask() {
    if (typeof MutationObserver !== 'undefined') {
        var node_1 = document.createTextNode('');
        var queue_1 = [];
        var i_1 = 0;
        new MutationObserver(function () {
            while (queue_1.length) {
                queue_1.shift()();
            }
        }).observe(node_1, { characterData: true });
        return function (fn) {
            queue_1.push(fn);
            node_1.data = i_1 = 1 - i_1;
        };
    }
    else if (typeof setImmediate !== 'undefined') {
        return setImmediate;
    }
    else if (typeof process !== 'undefined') {
        return process.nextTick;
    }
    else {
        return setTimeout;
    }
}
exports.default = microtask;

}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":146,"timers":203}],154:[function(require,module,exports){
(function (process,global){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":146,"safe-buffer":171}],155:[function(require,module,exports){
(function (process,global){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":146,"randombytes":154,"safe-buffer":171}],156:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":157}],157:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":159,"./_stream_writable":161,"core-util-is":78,"inherits":128,"process-nextick-args":145}],158:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":160,"core-util-is":78,"inherits":128}],159:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":157,"./internal/streams/BufferList":162,"./internal/streams/destroy":163,"./internal/streams/stream":164,"_process":146,"core-util-is":78,"events":111,"inherits":128,"isarray":130,"process-nextick-args":145,"safe-buffer":171,"string_decoder/":165,"util":47}],160:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":157,"core-util-is":78,"inherits":128}],161:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":157,"./internal/streams/destroy":163,"./internal/streams/stream":164,"_process":146,"core-util-is":78,"inherits":128,"process-nextick-args":145,"safe-buffer":171,"timers":203,"util-deprecate":208}],162:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":171,"util":47}],163:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":145}],164:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":111}],165:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":171}],166:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":167}],167:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":157,"./lib/_stream_passthrough.js":158,"./lib/_stream_readable.js":159,"./lib/_stream_transform.js":160,"./lib/_stream_writable.js":161}],168:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":167}],169:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":161}],170:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":76,"hash-base":113,"inherits":128}],171:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":76}],172:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":171}],173:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":174,"./sha1":175,"./sha224":176,"./sha256":177,"./sha384":178,"./sha512":179}],174:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":172,"inherits":128,"safe-buffer":171}],175:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":172,"inherits":128,"safe-buffer":171}],176:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":172,"./sha256":177,"inherits":128,"safe-buffer":171}],177:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":172,"inherits":128,"safe-buffer":171}],178:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":172,"./sha512":179,"inherits":128,"safe-buffer":171}],179:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":172,"inherits":128,"safe-buffer":171}],180:[function(require,module,exports){
"use strict";
var selectorParser_1 = require('./selectorParser');
function classNameFromVNode(vNode) {
    var _a = selectorParser_1.selectorParser(vNode).className, cn = _a === void 0 ? '' : _a;
    if (!vNode.data) {
        return cn;
    }
    var _b = vNode.data, dataClass = _b.class, props = _b.props;
    if (dataClass) {
        var c = Object.keys(dataClass)
            .filter(function (cl) { return dataClass[cl]; });
        cn += " " + c.join(" ");
    }
    if (props && props.className) {
        cn += " " + props.className;
    }
    return cn && cn.trim();
}
exports.classNameFromVNode = classNameFromVNode;

},{"./selectorParser":186}],181:[function(require,module,exports){
"use strict";
function curry2(select) {
    return function selector(sel, vNode) {
        switch (arguments.length) {
            case 0: return select;
            case 1: return function (_vNode) { return select(sel, _vNode); };
            default: return select(sel, vNode);
        }
    };
}
exports.curry2 = curry2;
;

},{}],182:[function(require,module,exports){
"use strict";
var query_1 = require('./query');
var parent_symbol_1 = require('./parent-symbol');
function findMatches(cssSelector, vNode) {
    if (!vNode) {
        return [];
    }
    traverseVNode(vNode, addParent); // add mapping to the parent selectorParser
    return query_1.querySelector(cssSelector, vNode);
}
exports.findMatches = findMatches;
function traverseVNode(vNode, f) {
    function recurse(currentNode, isParent, parentVNode) {
        var length = currentNode.children && currentNode.children.length || 0;
        for (var i = 0; i < length; ++i) {
            var children = currentNode.children;
            if (children && children[i] && typeof children[i] !== 'string') {
                var child = children[i];
                recurse(child, false, currentNode);
            }
        }
        f(currentNode, isParent, isParent ? void 0 : parentVNode);
    }
    recurse(vNode, true);
}
function addParent(vNode, isParent, parent) {
    if (isParent) {
        return void 0;
    }
    if (!vNode.data) {
        vNode.data = {};
    }
    if (!vNode.data[parent_symbol_1.default]) {
        Object.defineProperty(vNode.data, parent_symbol_1.default, {
            value: parent,
        });
    }
}

},{"./parent-symbol":184,"./query":185}],183:[function(require,module,exports){
"use strict";
var curry2_1 = require('./curry2');
var findMatches_1 = require('./findMatches');
exports.select = curry2_1.curry2(findMatches_1.findMatches);
var selectorParser_1 = require('./selectorParser');
exports.selectorParser = selectorParser_1.selectorParser;
var classNameFromVNode_1 = require('./classNameFromVNode');
exports.classNameFromVNode = classNameFromVNode_1.classNameFromVNode;

},{"./classNameFromVNode":180,"./curry2":181,"./findMatches":182,"./selectorParser":186}],184:[function(require,module,exports){
(function (global){
"use strict";
var root;
if (typeof self !== 'undefined') {
    root = self;
}
else if (typeof window !== 'undefined') {
    root = window;
}
else if (typeof global !== 'undefined') {
    root = global;
}
else {
    root = Function('return this')();
}
var Symbol = root.Symbol;
var parentSymbol;
if (typeof Symbol === 'function') {
    parentSymbol = Symbol('parent');
}
else {
    parentSymbol = '@@snabbdom-selector-parent';
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = parentSymbol;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],185:[function(require,module,exports){
"use strict";
var tree_selector_1 = require('tree-selector');
var selectorParser_1 = require('./selectorParser');
var classNameFromVNode_1 = require('./classNameFromVNode');
var parent_symbol_1 = require('./parent-symbol');
var options = {
    tag: function (vNode) { return selectorParser_1.selectorParser(vNode).tagName; },
    className: function (vNode) { return classNameFromVNode_1.classNameFromVNode(vNode); },
    id: function (vNode) { return selectorParser_1.selectorParser(vNode).id || ''; },
    children: function (vNode) { return vNode.children || []; },
    parent: function (vNode) { return vNode.data[parent_symbol_1.default] || vNode; },
    contents: function (vNode) { return vNode.text || ''; },
    attr: function (vNode, attr) {
        if (vNode.data) {
            var _a = vNode.data, _b = _a.attrs, attrs = _b === void 0 ? {} : _b, _c = _a.props, props = _c === void 0 ? {} : _c, _d = _a.dataset, dataset = _d === void 0 ? {} : _d;
            if (attrs[attr]) {
                return attrs[attr];
            }
            if (props[attr]) {
                return props[attr];
            }
            if (attr.indexOf('data-') === 0 && dataset[attr.slice(5)]) {
                return dataset[attr.slice(5)];
            }
        }
    },
};
var matches = tree_selector_1.createMatches(options);
function customMatches(sel, vnode) {
    var data = vnode.data;
    var selector = matches.bind(null, sel);
    if (data && data.fn) {
        var n = void 0;
        if (Array.isArray(data.args)) {
            n = data.fn.apply(null, data.args);
        }
        else if (data.args) {
            n = data.fn.call(null, data.args);
        }
        else {
            n = data.fn();
        }
        return selector(n) ? n : false;
    }
    return selector(vnode);
}
exports.querySelector = tree_selector_1.createQuerySelector(options, customMatches);

},{"./classNameFromVNode":180,"./parent-symbol":184,"./selectorParser":186,"tree-selector":204}],186:[function(require,module,exports){
"use strict";
function selectorParser(node) {
    if (!node.sel) {
        return {
            tagName: '',
            id: '',
            className: '',
        };
    }
    var sel = node.sel;
    var hashIdx = sel.indexOf('#');
    var dotIdx = sel.indexOf('.', hashIdx);
    var hash = hashIdx > 0 ? hashIdx : sel.length;
    var dot = dotIdx > 0 ? dotIdx : sel.length;
    var tagName = hashIdx !== -1 || dotIdx !== -1 ?
        sel.slice(0, Math.min(hash, dot)) :
        sel;
    var id = hash < dot ? sel.slice(hash + 1, dot) : void 0;
    var className = dotIdx > 0 ? sel.slice(dot + 1).replace(/\./g, ' ') : void 0;
    return {
        tagName: tagName,
        id: id,
        className: className,
    };
}
exports.selectorParser = selectorParser;

},{}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {}, children, text, i;
    if (c !== undefined) {
        data = b;
        if (is.array(c)) {
            children = c;
        }
        else if (is.primitive(c)) {
            text = c;
        }
        else if (c && c.sel) {
            children = [c];
        }
    }
    else if (b !== undefined) {
        if (is.array(b)) {
            children = b;
        }
        else if (is.primitive(b)) {
            text = b;
        }
        else if (b && b.sel) {
            children = [b];
        }
        else {
            data = b;
        }
    }
    if (children !== undefined) {
        for (i = 0; i < children.length; ++i) {
            if (is.primitive(children[i]))
                children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i], undefined);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return vnode_1.vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
exports.default = h;

},{"./is":189,"./vnode":198}],188:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
exports.htmlDomApi = {
    createElement: createElement,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    getTextContent: getTextContent,
    isElement: isElement,
    isText: isText,
    isComment: isComment,
};
exports.default = exports.htmlDomApi;

},{}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
exports.primitive = primitive;

},{}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var colonChar = 58;
var xChar = 120;
function updateAttrs(oldVnode, vnode) {
    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs)
        return;
    if (oldAttrs === attrs)
        return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
            if (cur === true) {
                elm.setAttribute(key, "");
            }
            else if (cur === false) {
                elm.removeAttribute(key);
            }
            else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                }
                else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                }
                else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                }
                else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
exports.attributesModule = { create: updateAttrs, update: updateAttrs };
exports.default = exports.attributesModule;

},{}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function updateClass(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;
    if (!oldClass && !klass)
        return;
    if (oldClass === klass)
        return;
    oldClass = oldClass || {};
    klass = klass || {};
    for (name in oldClass) {
        if (!klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? 'add' : 'remove'](name);
        }
    }
}
exports.classModule = { create: updateClass, update: updateClass };
exports.default = exports.classModule;

},{}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CAPS_REGEX = /[A-Z]/g;
function updateDataset(oldVnode, vnode) {
    var elm = vnode.elm, oldDataset = oldVnode.data.dataset, dataset = vnode.data.dataset, key;
    if (!oldDataset && !dataset)
        return;
    if (oldDataset === dataset)
        return;
    oldDataset = oldDataset || {};
    dataset = dataset || {};
    var d = elm.dataset;
    for (key in oldDataset) {
        if (!dataset[key]) {
            if (d) {
                if (key in d) {
                    delete d[key];
                }
            }
            else {
                elm.removeAttribute('data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase());
            }
        }
    }
    for (key in dataset) {
        if (oldDataset[key] !== dataset[key]) {
            if (d) {
                d[key] = dataset[key];
            }
            else {
                elm.setAttribute('data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase(), dataset[key]);
            }
        }
    }
}
exports.datasetModule = { create: updateDataset, update: updateDataset };
exports.default = exports.datasetModule;

},{}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function updateProps(oldVnode, vnode) {
    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;
    if (!oldProps && !props)
        return;
    if (oldProps === props)
        return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
exports.propsModule = { create: updateProps, update: updateProps };
exports.default = exports.propsModule;

},{}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.
var raf = (typeof window !== 'undefined' && (window.requestAnimationFrame).bind(window)) || setTimeout;
var nextFrame = function (fn) { raf(function () { raf(fn); }); };
var reflowForced = false;
function setNextFrame(obj, prop, val) {
    nextFrame(function () { obj[prop] = val; });
}
function updateStyle(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;
    if (!oldStyle && !style)
        return;
    if (oldStyle === style)
        return;
    oldStyle = oldStyle || {};
    style = style || {};
    var oldHasDel = 'delayed' in oldStyle;
    for (name in oldStyle) {
        if (!style[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.removeProperty(name);
            }
            else {
                elm.style[name] = '';
            }
        }
    }
    for (name in style) {
        cur = style[name];
        if (name === 'delayed' && style.delayed) {
            for (var name2 in style.delayed) {
                cur = style.delayed[name2];
                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                    setNextFrame(elm.style, name2, cur);
                }
            }
        }
        else if (name !== 'remove' && cur !== oldStyle[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.setProperty(name, cur);
            }
            else {
                elm.style[name] = cur;
            }
        }
    }
}
function applyDestroyStyle(vnode) {
    var style, name, elm = vnode.elm, s = vnode.data.style;
    if (!s || !(style = s.destroy))
        return;
    for (name in style) {
        elm.style[name] = style[name];
    }
}
function applyRemoveStyle(vnode, rm) {
    var s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    if (!reflowForced) {
        getComputedStyle(document.body).transform;
        reflowForced = true;
    }
    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];
    for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
    }
    compStyle = getComputedStyle(elm);
    var props = compStyle['transition-property'].split(', ');
    for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1)
            amount++;
    }
    elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm)
            --amount;
        if (amount === 0)
            rm();
    });
}
function forceReflow() {
    reflowForced = false;
}
exports.styleModule = {
    pre: forceReflow,
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};
exports.default = exports.styleModule;

},{}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var is = require("./is");
var htmldomapi_1 = require("./htmldomapi");
function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }
var emptyNode = vnode_1.default('', {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, map = {}, key, ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined)
                map[key] = i;
        }
    }
    return map;
}
var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
var h_1 = require("./h");
exports.h = h_1.h;
var thunk_1 = require("./thunk");
exports.thunk = thunk_1.thunk;
function init(modules, domApi) {
    var i, j, cbs = {};
    var api = domApi !== undefined ? domApi : htmldomapi_1.default;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            var hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return vnode_1.default(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                var parent_1 = api.parentNode(childElm);
                api.removeChild(parent_1, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var i, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode);
                data = vnode.data;
            }
        }
        var children = vnode.children, sel = vnode.sel;
        if (sel === '!') {
            if (isUndef(vnode.text)) {
                vnode.text = '';
            }
            vnode.elm = api.createComment(vnode.text);
        }
        else if (sel !== undefined) {
            // Parse selector
            var hashIdx = sel.indexOf('#');
            var dotIdx = sel.indexOf('.', hashIdx);
            var hash = hashIdx > 0 ? hashIdx : sel.length;
            var dot = dotIdx > 0 ? dotIdx : sel.length;
            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                : api.createElement(tag);
            if (hash < dot)
                elm.setAttribute('id', sel.slice(hash + 1, dot));
            if (dotIdx > 0)
                elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
            for (i = 0; i < cbs.create.length; ++i)
                cbs.create[i](emptyNode, vnode);
            if (is.array(children)) {
                for (i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            }
            else if (is.primitive(vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create)
                    i.create(emptyNode, vnode);
                if (i.insert)
                    insertedVnodeQueue.push(vnode);
            }
        }
        else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        var i, j, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.destroy))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
            if (vnode.children !== undefined) {
                for (j = 0; j < vnode.children.length; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)
                        cbs.remove[i_1](ch, rm);
                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                        i_1(ch, rm);
                    }
                    else {
                        rm();
                    }
                }
                else {
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0, newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    }
                    else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;
        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
            i(oldVnode, vnode);
        }
        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode)
            return;
        if (vnode.data !== undefined) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            i = vnode.data.hook;
            if (isDef(i) && isDef(i = i.update))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            }
            else if (isDef(ch)) {
                if (isDef(oldVnode.text))
                    api.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef(i = hook.postpatch)) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i)
            cbs.pre[i]();
        if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        }
        else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i)
            cbs.post[i]();
        return vnode;
    };
}
exports.init = init;

},{"./h":187,"./htmldomapi":188,"./is":189,"./thunk":196,"./vnode":198}],196:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = require("./h");
function copyToThunk(vnode, thunk) {
    thunk.elm = vnode.elm;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
}
function init(thunk) {
    var cur = thunk.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunk);
}
function prepatch(oldVnode, thunk) {
    var i, old = oldVnode.data, cur = thunk.data;
    var oldArgs = old.args, args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunk);
        return;
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
    }
    copyToThunk(oldVnode, thunk);
}
exports.thunk = function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return h_1.h(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args
    });
};
exports.default = exports.thunk;

},{"./h":187}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = require("./vnode");
var htmldomapi_1 = require("./htmldomapi");
function toVNode(node, domApi) {
    var api = domApi !== undefined ? domApi : htmldomapi_1.default;
    var text;
    if (api.isElement(node)) {
        var id = node.id ? '#' + node.id : '';
        var cn = node.getAttribute('class');
        var c = cn ? '.' + cn.split(' ').join('.') : '';
        var sel = api.tagName(node).toLowerCase() + id + c;
        var attrs = {};
        var children = [];
        var name_1;
        var i = void 0, n = void 0;
        var elmAttrs = node.attributes;
        var elmChildren = node.childNodes;
        for (i = 0, n = elmAttrs.length; i < n; i++) {
            name_1 = elmAttrs[i].nodeName;
            if (name_1 !== 'id' && name_1 !== 'class') {
                attrs[name_1] = elmAttrs[i].nodeValue;
            }
        }
        for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
        }
        return vnode_1.default(sel, { attrs: attrs }, children, undefined, node);
    }
    else if (api.isText(node)) {
        text = api.getTextContent(node);
        return vnode_1.default(undefined, undefined, undefined, text, node);
    }
    else if (api.isComment(node)) {
        text = api.getTextContent(node);
        return vnode_1.default('!', {}, [], text, node);
    }
    else {
        return vnode_1.default('', {}, [], undefined, node);
    }
}
exports.toVNode = toVNode;
exports.default = toVNode;

},{"./htmldomapi":188,"./vnode":198}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
exports.vnode = vnode;
exports.default = vnode;

},{}],199:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":111,"inherits":128,"readable-stream/duplex.js":156,"readable-stream/passthrough.js":166,"readable-stream/readable.js":167,"readable-stream/transform.js":168,"readable-stream/writable.js":169}],200:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"dup":165,"safe-buffer":171}],201:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill.js');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill.js":202}],202:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],203:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":146,"timers":203}],204:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./selectorParser"));
var matches_1 = require("./matches");
exports.createMatches = matches_1.createMatches;
var querySelector_1 = require("./querySelector");
exports.createQuerySelector = querySelector_1.createQuerySelector;

},{"./matches":205,"./querySelector":206,"./selectorParser":207}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var selectorParser_1 = require("./selectorParser");
function createMatches(opts) {
    return function matches(selector, node) {
        var _a = typeof selector === 'object' ? selector : selectorParser_1.parseSelector(selector), tag = _a.tag, id = _a.id, classList = _a.classList, attributes = _a.attributes, nextSelector = _a.nextSelector, pseudos = _a.pseudos;
        if (nextSelector !== undefined) {
            throw new Error('matches can only process selectors that target a single element');
        }
        if (!node) {
            return false;
        }
        if (tag && tag.toLowerCase() !== opts.tag(node).toLowerCase()) {
            return false;
        }
        if (id && id !== opts.id(node)) {
            return false;
        }
        var classes = opts.className(node).split(' ');
        for (var i = 0; i < classList.length; i++) {
            if (classes.indexOf(classList[i]) === -1) {
                return false;
            }
        }
        for (var key in attributes) {
            var attr = opts.attr(node, key);
            var t = attributes[key][0];
            var v = attributes[key][1];
            if (attr === undefined) {
                return false;
            }
            if (t === 'has') {
                return true;
            }
            if (t === 'exact' && attr !== v) {
                return false;
            }
            else if (t !== 'exact') {
                if (typeof v !== 'string') {
                    throw new Error('All non-string values have to be an exact match');
                }
                if (t === 'startsWith' && !attr.startsWith(v)) {
                    return false;
                }
                if (t === 'endsWith' && !attr.endsWith(v)) {
                    return false;
                }
                if (t === 'contains' && attr.indexOf(v) === -1) {
                    return false;
                }
                if (t === 'whitespace' && attr.split(' ').indexOf(v) === -1) {
                    return false;
                }
                if (t === 'dash' && attr.split('-').indexOf(v) === -1) {
                    return false;
                }
            }
        }
        for (var i = 0; i < pseudos.length; i++) {
            var _b = pseudos[i], t = _b[0], data = _b[1];
            if (t === 'contains' && data !== opts.contents(node)) {
                return false;
            }
            if (t === 'empty' &&
                (opts.contents(node) || opts.children(node).length !== 0)) {
                return false;
            }
            if (t === 'root' && opts.parent(node) !== undefined) {
                return false;
            }
            if (t.indexOf('child') !== -1) {
                if (!opts.parent(node)) {
                    return false;
                }
                var siblings = opts.children(opts.parent(node));
                if (t === 'first-child' && siblings.indexOf(node) !== 0) {
                    return false;
                }
                if (t === 'last-child' &&
                    siblings.indexOf(node) !== siblings.length - 1) {
                    return false;
                }
                if (t === 'nth-child') {
                    var regex = /([\+-]?)(\d*)(n?)(\+\d+)?/;
                    var parseResult = regex.exec(data).slice(1);
                    var index = siblings.indexOf(node);
                    if (!parseResult[0]) {
                        parseResult[0] = '+';
                    }
                    var factor = parseResult[1]
                        ? parseInt(parseResult[0] + parseResult[1])
                        : undefined;
                    var add = parseInt(parseResult[3] || '0');
                    if (factor &&
                        parseResult[2] === 'n' &&
                        index % factor !== add) {
                        return false;
                    }
                    else if (!factor &&
                        parseResult[2] &&
                        ((parseResult[0] === '+' && index - add < 0) ||
                            (parseResult[0] === '-' && index - add >= 0))) {
                        return false;
                    }
                    else if (!parseResult[2] && factor &&
                        index !== factor - 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
}
exports.createMatches = createMatches;

},{"./selectorParser":207}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var selectorParser_1 = require("./selectorParser");
var matches_1 = require("./matches");
function createQuerySelector(options, matches) {
    var _matches = matches || matches_1.createMatches(options);
    function findSubtree(selector, depth, node) {
        if (!node) {
            return [];
        }
        var n = _matches(selector, node);
        var matched = n ? (typeof n === 'object' ? [n] : [node]) : [];
        if (depth === 0) {
            return matched;
        }
        var childMatched = options
            .children(node)
            .filter(function (c) { return typeof c !== 'string'; })
            .map(function (c) { return findSubtree(selector, depth - 1, c); })
            .reduce(function (acc, curr) { return acc.concat(curr); }, []);
        return matched.concat(childMatched);
    }
    function findSibling(selector, next, node) {
        if (!node || options.parent(node) === undefined) {
            return [];
        }
        var results = [];
        var siblings = options.children(options.parent(node));
        for (var i = siblings.indexOf(node) + 1; i < siblings.length; i++) {
            if (typeof siblings[i] === 'string') {
                continue;
            }
            var n = _matches(selector, siblings[i]);
            if (n) {
                if (typeof n === 'object') {
                    results.push(n);
                }
                else {
                    results.push(siblings[i]);
                }
            }
            if (next) {
                break;
            }
        }
        return results;
    }
    return function querySelector(selector, node) {
        if (!node) {
            return [];
        }
        var sel = typeof selector === 'object' ? selector : selectorParser_1.parseSelector(selector);
        var results = [node];
        var currentSelector = sel;
        var currentCombinator = 'subtree';
        var tail = undefined;
        var _loop_1 = function () {
            tail = currentSelector.nextSelector;
            currentSelector.nextSelector = undefined;
            if (currentCombinator === 'subtree' ||
                currentCombinator === 'child') {
                var depth_1 = currentCombinator === 'subtree' ? Infinity : 1;
                results = results
                    .map(function (n) { return findSubtree(currentSelector, depth_1, n); })
                    .reduce(function (acc, curr) { return acc.concat(curr); }, []);
            }
            else {
                var next_1 = currentCombinator === 'nextSibling';
                results = results
                    .map(function (n) { return findSibling(currentSelector, next_1, n); })
                    .reduce(function (acc, curr) { return acc.concat(curr); }, []);
            }
            if (tail) {
                currentSelector = tail[1];
                currentCombinator = tail[0];
            }
        };
        do {
            _loop_1();
        } while (tail !== undefined);
        return results;
    };
}
exports.createQuerySelector = createQuerySelector;

},{"./matches":205,"./selectorParser":207}],207:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var IDENT = '[\\w-]+';
var SPACE = '[ \t]*';
var VALUE = "[^\\]]+";
var CLASS = "(?:\\." + IDENT + ")";
var ID = "(?:#" + IDENT + ")";
var OP = "(?:=|\\$=|\\^=|\\*=|~=|\\|=)";
var ATTR = "(?:\\[" + SPACE + IDENT + SPACE + "(?:" + OP + SPACE + VALUE + SPACE + ")?\\])";
var SUBTREE = "(?:[ \t]+)";
var CHILD = "(?:" + SPACE + "(>)" + SPACE + ")";
var NEXT_SIBLING = "(?:" + SPACE + "(\\+)" + SPACE + ")";
var SIBLING = "(?:" + SPACE + "(~)" + SPACE + ")";
var COMBINATOR = "(?:" + SUBTREE + "|" + CHILD + "|" + NEXT_SIBLING + "|" + SIBLING + ")";
var CONTAINS = "contains\\(\"[^\"]*\"\\)";
var FORMULA = "(?:even|odd|\\d*(?:-?n(?:\\+\\d+)?)?)";
var NTH_CHILD = "nth-child\\(" + FORMULA + "\\)";
var PSEUDO = ":(?:first-child|last-child|" + NTH_CHILD + "|empty|root|" + CONTAINS + ")";
var TAG = "(:?" + IDENT + ")?";
var TOKENS = CLASS + "|" + ID + "|" + ATTR + "|" + PSEUDO + "|" + COMBINATOR;
var combinatorRegex = new RegExp("^" + COMBINATOR + "$");
/**
 * Parses a css selector into a normalized object.
 * Expects a selector for a single element only, no `>` or the like!
 */
function parseSelector(selector) {
    var sel = selector.trim();
    var tagRegex = new RegExp(TAG, 'y');
    var tag = tagRegex.exec(sel)[0];
    var regex = new RegExp(TOKENS, 'y');
    regex.lastIndex = tagRegex.lastIndex;
    var matches = [];
    var nextSelector = undefined;
    var lastCombinator = undefined;
    var index = -1;
    while (regex.lastIndex < sel.length) {
        var match = regex.exec(sel);
        if (!match && lastCombinator === undefined) {
            throw new Error('Parse error, invalid selector');
        }
        else if (match && combinatorRegex.test(match[0])) {
            var comb = combinatorRegex.exec(match[0])[0];
            lastCombinator = comb;
            index = regex.lastIndex;
        }
        else {
            if (lastCombinator !== undefined) {
                nextSelector = [
                    getCombinator(lastCombinator),
                    parseSelector(sel.substring(index))
                ];
                break;
            }
            matches.push(match[0]);
        }
    }
    var classList = matches
        .filter(function (s) { return s.startsWith('.'); })
        .map(function (s) { return s.substring(1); });
    var ids = matches.filter(function (s) { return s.startsWith('#'); }).map(function (s) { return s.substring(1); });
    if (ids.length > 1) {
        throw new Error('Invalid selector, only one id is allowed');
    }
    var postprocessRegex = new RegExp("(" + IDENT + ")" + SPACE + "(" + OP + ")?" + SPACE + "(" + VALUE + ")?");
    var attrs = matches
        .filter(function (s) { return s.startsWith('['); })
        .map(function (s) { return postprocessRegex.exec(s).slice(1, 4); })
        .map(function (_a) {
        var attr = _a[0], op = _a[1], val = _a[2];
        var _b;
        return (_b = {},
            _b[attr] = [getOp(op), val ? parseAttrValue(val) : val],
            _b);
    })
        .reduce(function (acc, curr) { return (__assign({}, acc, curr)); }, {});
    var pseudos = matches
        .filter(function (s) { return s.startsWith(':'); })
        .map(function (s) { return postProcessPseudos(s.substring(1)); });
    return {
        id: ids[0] || '',
        tag: tag,
        classList: classList,
        attributes: attrs,
        nextSelector: nextSelector,
        pseudos: pseudos
    };
}
exports.parseSelector = parseSelector;
function parseAttrValue(v) {
    if (v.startsWith('"')) {
        return v.slice(1, -1);
    }
    if (v === "true") {
        return true;
    }
    if (v === "false") {
        return false;
    }
    var f = parseFloat(v);
    if (isNaN(f)) {
        return v;
    }
    return f;
}
function postProcessPseudos(sel) {
    if (sel === 'first-child' ||
        sel === 'last-child' ||
        sel === 'root' ||
        sel === 'empty') {
        return [sel, undefined];
    }
    if (sel.startsWith('contains')) {
        var text = sel.slice(10, -2);
        return ['contains', text];
    }
    var content = sel.slice(10, -1);
    if (content === 'even') {
        content = '2n';
    }
    if (content === 'odd') {
        content = '2n+1';
    }
    return ['nth-child', content];
}
function getOp(op) {
    switch (op) {
        case '=':
            return 'exact';
        case '^=':
            return 'startsWith';
        case '$=':
            return 'endsWith';
        case '*=':
            return 'contains';
        case '~=':
            return 'whitespace';
        case '|=':
            return 'dash';
        default:
            return 'has';
    }
}
function getCombinator(comb) {
    switch (comb.trim()) {
        case '>':
            return 'child';
        case '+':
            return 'nextSibling';
        case '~':
            return 'sibling';
        default:
            return 'subtree';
    }
}

},{}],208:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],209:[function(require,module,exports){
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../index");
var ConcatProducer = /** @class */ (function () {
    function ConcatProducer(streams) {
        this.streams = streams;
        this.type = 'concat';
        this.out = null;
        this.i = 0;
    }
    ConcatProducer.prototype._start = function (out) {
        this.out = out;
        this.streams[this.i]._add(this);
    };
    ConcatProducer.prototype._stop = function () {
        var streams = this.streams;
        if (this.i < streams.length) {
            streams[this.i]._remove(this);
        }
        this.i = 0;
        this.out = null;
    };
    ConcatProducer.prototype._n = function (t) {
        var u = this.out;
        if (!u)
            return;
        u._n(t);
    };
    ConcatProducer.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    ConcatProducer.prototype._c = function () {
        var u = this.out;
        if (!u)
            return;
        var streams = this.streams;
        streams[this.i]._remove(this);
        if (++this.i < streams.length) {
            streams[this.i]._add(this);
        }
        else {
            u._c();
        }
    };
    return ConcatProducer;
}());
/**
 * Puts one stream after the other. *concat* is a factory that takes multiple
 * streams as arguments, and starts the `n+1`-th stream only when the `n`-th
 * stream has completed. It concatenates those streams together.
 *
 * Marble diagram:
 *
 * ```text
 * --1--2---3---4-|
 * ...............--a-b-c--d-|
 *           concat
 * --1--2---3---4---a-b-c--d-|
 * ```
 *
 * Example:
 *
 * ```js
 * import concat from 'xstream/extra/concat'
 *
 * const streamA = xs.of('a', 'b', 'c')
 * const streamB = xs.of(10, 20, 30)
 * const streamC = xs.of('X', 'Y', 'Z')
 *
 * const outputStream = concat(streamA, streamB, streamC)
 *
 * outputStream.addListener({
 *   next: (x) => console.log(x),
 *   error: (err) => console.error(err),
 *   complete: () => console.log('concat completed'),
 * })
 * ```
 *
 * @factory true
 * @param {Stream} stream1 A stream to concatenate together with other streams.
 * @param {Stream} stream2 A stream to concatenate together with other streams. Two
 * or more streams may be given as arguments.
 * @return {Stream}
 */
function concat() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return new index_1.Stream(new ConcatProducer(streams));
}
exports.default = concat;

},{"../index":212}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../index");
var NO = {};
var SampleCombineListener = /** @class */ (function () {
    function SampleCombineListener(i, p) {
        this.i = i;
        this.p = p;
        p.ils[i] = this;
    }
    SampleCombineListener.prototype._n = function (t) {
        var p = this.p;
        if (p.out === NO)
            return;
        p.up(t, this.i);
    };
    SampleCombineListener.prototype._e = function (err) {
        this.p._e(err);
    };
    SampleCombineListener.prototype._c = function () {
        this.p.down(this.i, this);
    };
    return SampleCombineListener;
}());
exports.SampleCombineListener = SampleCombineListener;
var SampleCombineOperator = /** @class */ (function () {
    function SampleCombineOperator(ins, streams) {
        this.type = 'sampleCombine';
        this.ins = ins;
        this.others = streams;
        this.out = NO;
        this.ils = [];
        this.Nn = 0;
        this.vals = [];
    }
    SampleCombineOperator.prototype._start = function (out) {
        this.out = out;
        var s = this.others;
        var n = this.Nn = s.length;
        var vals = this.vals = new Array(n);
        for (var i = 0; i < n; i++) {
            vals[i] = NO;
            s[i]._add(new SampleCombineListener(i, this));
        }
        this.ins._add(this);
    };
    SampleCombineOperator.prototype._stop = function () {
        var s = this.others;
        var n = s.length;
        var ils = this.ils;
        this.ins._remove(this);
        for (var i = 0; i < n; i++) {
            s[i]._remove(ils[i]);
        }
        this.out = NO;
        this.vals = [];
        this.ils = [];
    };
    SampleCombineOperator.prototype._n = function (t) {
        var out = this.out;
        if (out === NO)
            return;
        if (this.Nn > 0)
            return;
        out._n([t].concat(this.vals));
    };
    SampleCombineOperator.prototype._e = function (err) {
        var out = this.out;
        if (out === NO)
            return;
        out._e(err);
    };
    SampleCombineOperator.prototype._c = function () {
        var out = this.out;
        if (out === NO)
            return;
        out._c();
    };
    SampleCombineOperator.prototype.up = function (t, i) {
        var v = this.vals[i];
        if (this.Nn > 0 && v === NO) {
            this.Nn--;
        }
        this.vals[i] = t;
    };
    SampleCombineOperator.prototype.down = function (i, l) {
        this.others[i]._remove(l);
    };
    return SampleCombineOperator;
}());
exports.SampleCombineOperator = SampleCombineOperator;
var sampleCombine;
/**
 *
 * Combines a source stream with multiple other streams. The result stream
 * will emit the latest events from all input streams, but only when the
 * source stream emits.
 *
 * If the source, or any input stream, throws an error, the result stream
 * will propagate the error. If any input streams end, their final emitted
 * value will remain in the array of any subsequent events from the result
 * stream.
 *
 * The result stream will only complete upon completion of the source stream.
 *
 * Marble diagram:
 *
 * ```text
 * --1----2-----3--------4--- (source)
 * ----a-----b-----c--d------ (other)
 *      sampleCombine
 * -------2a----3b-------4d--
 * ```
 *
 * Examples:
 *
 * ```js
 * import sampleCombine from 'xstream/extra/sampleCombine'
 * import xs from 'xstream'
 *
 * const sampler = xs.periodic(1000).take(3)
 * const other = xs.periodic(100)
 *
 * const stream = sampler.compose(sampleCombine(other))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > [0, 8]
 * > [1, 18]
 * > [2, 28]
 * ```
 *
 * ```js
 * import sampleCombine from 'xstream/extra/sampleCombine'
 * import xs from 'xstream'
 *
 * const sampler = xs.periodic(1000).take(3)
 * const other = xs.periodic(100).take(2)
 *
 * const stream = sampler.compose(sampleCombine(other))
 *
 * stream.addListener({
 *   next: i => console.log(i),
 *   error: err => console.error(err),
 *   complete: () => console.log('completed')
 * })
 * ```
 *
 * ```text
 * > [0, 1]
 * > [1, 1]
 * > [2, 1]
 * ```
 *
 * @param {...Stream} streams One or more streams to combine with the sampler
 * stream.
 * @return {Stream}
 */
sampleCombine = function sampleCombine() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return function sampleCombineOperator(sampler) {
        return new index_1.Stream(new SampleCombineOperator(sampler, streams));
    };
};
exports.default = sampleCombine;

},{"../index":212}],212:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5,"symbol-observable":201}],213:[function(require,module,exports){
"use strict";

var _xstream = require("xstream");

var _xstream2 = _interopRequireDefault(_xstream);

var _dom = require("@cycle/dom");

var _run = require("@cycle/run");

var _cycleHandtrackDriver = require("cycle-handtrack-driver");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function main(sources) {
  sources.HandTrack.addListener({ next: console.log });

  var vdom$ = _xstream2.default.of((0, _dom.div)(".handtrack", [, (0, _dom.video)(".handtrack-video", {
    style: { display: "none", transform: "rotateY(180deg)" }
  }), (0, _dom.canvas)(".handtrack-canvas")])).startWith("");
  var command$ = _xstream2.default.combine(sources.DOM.select(".handtrack-video").element().take(1), sources.DOM.select(".handtrack-canvas").element().take(1)).map(function (x) {
    return { type: "start", elems: x };
  });
  return {
    DOM: vdom$,
    HandTrack: command$
  };
}

(0, _run.run)(main, {
  DOM: (0, _dom.makeDOMDriver)("#app"),
  HandTrack: (0, _cycleHandtrackDriver.makeHandTrackDriver)()
});

},{"@cycle/dom":19,"@cycle/run":28,"cycle-handtrack-driver":1,"xstream":212}]},{},[213])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8zcmRwYXJ0eS9jeWNsZS1oYW5kdHJhY2stZHJpdmVyL2xpYi9janMvaW5kZXguanMiLCIuLi8uLi8uLi8zcmRwYXJ0eS9jeWNsZS1oYW5kdHJhY2stZHJpdmVyL25vZGVfbW9kdWxlcy9oYW5kdHJhY2tqcy9kaXN0L2hhbmR0cmFjay5taW4uanMiLCIuLi8uLi8uLi8zcmRwYXJ0eS9jeWNsZS1oYW5kdHJhY2stZHJpdmVyL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi8zcmRwYXJ0eS9jeWNsZS1oYW5kdHJhY2stZHJpdmVyL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCIuLi8uLi8uLi8zcmRwYXJ0eS9jeWNsZS1oYW5kdHJhY2stZHJpdmVyL25vZGVfbW9kdWxlcy94c3RyZWFtL3NyYy9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvQm9keURPTVNvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvRG9jdW1lbnRET01Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvQGN5Y2xlL2RvbS9saWIvY2pzL0VsZW1lbnRGaW5kZXIuanMiLCJub2RlX21vZHVsZXMvQGN5Y2xlL2RvbS9saWIvY2pzL0V2ZW50RGVsZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9kb20vbGliL2Nqcy9Jc29sYXRlTW9kdWxlLmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9kb20vbGliL2Nqcy9NYWluRE9NU291cmNlLmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9kb20vbGliL2Nqcy9Qcmlvcml0eVF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9kb20vbGliL2Nqcy9SZW1vdmFsU2V0LmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9kb20vbGliL2Nqcy9TY29wZUNoZWNrZXIuanMiLCJub2RlX21vZHVsZXMvQGN5Y2xlL2RvbS9saWIvY2pzL1N5bWJvbFRyZWUuanMiLCJub2RlX21vZHVsZXMvQGN5Y2xlL2RvbS9saWIvY2pzL1ZOb2RlV3JhcHBlci5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvZnJvbUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9kb20vbGliL2Nqcy9oeXBlcnNjcmlwdC1oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9kb20vbGliL2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvaXNvbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvbWFrZURPTURyaXZlci5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvbW9ja0RPTVNvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvbW9kdWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvZG9tL2xpYi9janMvdGh1bmsuanMiLCJub2RlX21vZHVsZXMvQGN5Y2xlL2RvbS9saWIvY2pzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9ydW4vbGliL2FkYXB0LmpzIiwibm9kZV9tb2R1bGVzL0BjeWNsZS9ydW4vbGliL2Nqcy9hZGFwdC5qcyIsIm5vZGVfbW9kdWxlcy9AY3ljbGUvcnVuL2xpYi9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGN5Y2xlL3J1bi9saWIvY2pzL2ludGVybmFscy5qcyIsIm5vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYXBpLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9yZXBvcnRlci5qcyIsIm5vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanMiLCJub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanMiLCJub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL3BlbS5qcyIsIm5vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvcGVtLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanMiLCJub2RlX21vZHVsZXMvYnJvcmFuZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2F1dGhDaXBoZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9kZWNyeXB0ZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZW5jcnlwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2luY3IzMi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jYmMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjEuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvZWNiLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2xpc3QuanNvbiIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktY2lwaGVyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbW9kZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1yc2EvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2FsZ29zLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL2FsZ29yaXRobXMuanNvbiIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9jdXJ2ZXMuanNvbiIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9zaWduLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL3ZlcmlmeS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIteG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLWVjZGgvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL21kNS5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtaG1hYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2xlZ2FjeS5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9jYmMuanMiLCJub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvY2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9lZGUuanMiLCJub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9saWIvZGguanMiLCJub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL2dlbmVyYXRlUHJpbWUuanMiLCJub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL3ByaW1lcy5qc29uIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvZWR3YXJkcy5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL21vbnQuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9rZXkuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2EvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Evc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9wcmVjb21wdXRlZC9zZWNwMjU2azEuanMiLCJub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2VsbGlwdGljL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8xLmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzIyNC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8yNTYuanMiLCJub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMzg0LmpzIiwibm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzUxMi5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS9jb21tb24uanMiLCJub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9obWFjLWRyYmcvbGliL2htYWMtZHJiZy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWQ1LmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pbGxlci1yYWJpbi9saWIvbXIuanMiLCJub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2Flc2lkLmpzb24iLCJub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9hc24xLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvY2VydGlmaWNhdGUuanMiLCJub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGJrZGYyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9wYmtkZjIvbGliL2RlZmF1bHQtZW5jb2RpbmcuanMiLCJub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9wcmVjb25kaXRpb24uanMiLCJub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9zeW5jLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvbWdmLmpzIiwibm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3ByaXZhdGVEZWNyeXB0LmpzIiwibm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanMiLCJub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvd2l0aFB1YmxpYy5qcyIsIm5vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC94b3IuanMiLCJub2RlX21vZHVsZXMvcXVpY2t0YXNrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmRvbWJ5dGVzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFuZG9tZmlsbC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwibm9kZV9tb2R1bGVzL3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9jbGFzc05hbWVGcm9tVk5vZGUuanMiLCJub2RlX21vZHVsZXMvc25hYmJkb20tc2VsZWN0b3IvbGliL2N1cnJ5Mi5qcyIsIm5vZGVfbW9kdWxlcy9zbmFiYmRvbS1zZWxlY3Rvci9saWIvZmluZE1hdGNoZXMuanMiLCJub2RlX21vZHVsZXMvc25hYmJkb20tc2VsZWN0b3IvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9wYXJlbnQtc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL3NuYWJiZG9tLXNlbGVjdG9yL2xpYi9xdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy9zbmFiYmRvbS1zZWxlY3Rvci9saWIvc2VsZWN0b3JQYXJzZXIuanMiLCJub2RlX21vZHVsZXMvc25hYmJkb20vaC5qcyIsIm5vZGVfbW9kdWxlcy9zbmFiYmRvbS9odG1sZG9tYXBpLmpzIiwibm9kZV9tb2R1bGVzL3NuYWJiZG9tL2lzLmpzIiwibm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvYXR0cmlidXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9zbmFiYmRvbS9tb2R1bGVzL2NsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvZGF0YXNldC5qcyIsIm5vZGVfbW9kdWxlcy9zbmFiYmRvbS9tb2R1bGVzL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvc25hYmJkb20vc25hYmJkb20uanMiLCJub2RlX21vZHVsZXMvc25hYmJkb20vdGh1bmsuanMiLCJub2RlX21vZHVsZXMvc25hYmJkb20vdG92bm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9zbmFiYmRvbS92bm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90cmVlLXNlbGVjdG9yL2xpYi9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJlZS1zZWxlY3Rvci9saWIvY2pzL21hdGNoZXMuanMiLCJub2RlX21vZHVsZXMvdHJlZS1zZWxlY3Rvci9saWIvY2pzL3F1ZXJ5U2VsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvdHJlZS1zZWxlY3Rvci9saWIvY2pzL3NlbGVjdG9yUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdm0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94c3RyZWFtL3NyYy9leHRyYS9jb25jYXQudHMiLCJub2RlX21vZHVsZXMveHN0cmVhbS9zcmMvZXh0cmEvc2FtcGxlQ29tYmluZS50cyIsInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QkEsdURBQTZDO0FBRTdDLElBQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQztBQWdnRU4sZ0JBQUU7QUEvL0RWLFNBQVMsSUFBSSxLQUFJLENBQUM7QUFFbEIsU0FBUyxFQUFFLENBQUksQ0FBVztJQUN4QixJQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ25CLElBQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEMsT0FBTyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBRUQsU0FBUyxHQUFHLENBQUksRUFBcUIsRUFBRSxFQUFxQjtJQUMxRCxPQUFPLFNBQVMsS0FBSyxDQUFDLENBQUk7UUFDeEIsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFNRCxTQUFTLElBQUksQ0FBTyxDQUFtQixFQUFFLENBQUksRUFBRSxDQUFjO0lBQzNELElBQUk7UUFDRixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDZjtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNSLE9BQU8sRUFBRSxDQUFDO0tBQ1g7QUFDSCxDQUFDO0FBUUQsSUFBTSxLQUFLLEdBQTBCO0lBQ25DLEVBQUUsRUFBRSxJQUFJO0lBQ1IsRUFBRSxFQUFFLElBQUk7SUFDUixFQUFFLEVBQUUsSUFBSTtDQUNULENBQUM7QUF5OURVLHNCQUFLO0FBLzZEakIsb0JBQW9CO0FBQ3BCLFNBQVMsbUJBQW1CLENBQUksUUFBb0Q7SUFDbEYsUUFBUSxDQUFDLE1BQU0sR0FBRyxTQUFTLE1BQU0sQ0FBQyxFQUE4QztRQUM5RSxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDaEIsRUFBRSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ2pCLEVBQUUsQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNwQixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQWlCLENBQUMsQ0FBQztJQUNoQyxDQUFDLENBQUM7SUFDRixRQUFRLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFDakMsQ0FBQztBQUVEO0lBQ0UsbUJBQW9CLE9BQWtCLEVBQVUsU0FBOEI7UUFBMUQsWUFBTyxHQUFQLE9BQU8sQ0FBVztRQUFVLGNBQVMsR0FBVCxTQUFTLENBQXFCO0lBQUcsQ0FBQztJQUVsRiwrQkFBVyxHQUFYO1FBQ0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFDSCxnQkFBQztBQUFELENBTkEsQUFNQyxJQUFBO0FBRUQ7SUFDRSxrQkFBb0IsU0FBOEI7UUFBOUIsY0FBUyxHQUFULFNBQVMsQ0FBcUI7SUFBRyxDQUFDO0lBRXRELHVCQUFJLEdBQUosVUFBSyxLQUFRO1FBQ1gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVELHdCQUFLLEdBQUwsVUFBTSxHQUFRO1FBQ1osSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELDJCQUFRLEdBQVI7UUFDRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFDSCxlQUFDO0FBQUQsQ0FkQSxBQWNDLElBQUE7QUFFRDtJQU9FLHdCQUFZLFVBQXlCO1FBTjlCLFNBQUksR0FBRyxnQkFBZ0IsQ0FBQztRQU83QixJQUFJLENBQUMsR0FBRyxHQUFHLFVBQVUsQ0FBQztRQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQsK0JBQU0sR0FBTixVQUFPLEdBQWM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNO1lBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQsOEJBQUssR0FBTDtRQUNFLElBQUksSUFBSSxDQUFDLElBQUk7WUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFDSCxxQkFBQztBQUFELENBdkJBLEFBdUJDLElBQUE7QUF1RUQ7SUFNRSxlQUFZLE1BQXdCO1FBTDdCLFNBQUksR0FBRyxPQUFPLENBQUM7UUFNcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7UUFDM0IsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDZCxDQUFDO0lBRUQsc0JBQU0sR0FBTixVQUFPLEdBQWM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3RCLElBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDbkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDWixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELHFCQUFLLEdBQUw7UUFDRSxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3RCLElBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO0lBQzdCLENBQUM7SUFFRCxrQkFBRSxHQUFGLFVBQUcsQ0FBSTtRQUNMLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRCxrQkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRCxrQkFBRSxHQUFGO1FBQ0UsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFO1lBQ2xCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFBRSxPQUFPO1lBQ3JCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztTQUNSO0lBQ0gsQ0FBQztJQUNILFlBQUM7QUFBRCxDQTlDQSxBQThDQyxJQUFBO0FBdUVEO0lBS0UseUJBQVksQ0FBUyxFQUFFLEdBQXFCLEVBQUUsQ0FBYTtRQUN6RCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQsNEJBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ2pDLElBQUksR0FBRyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3ZCLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ25CLElBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDakIsSUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUNuQixJQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ1g7SUFDSCxDQUFDO0lBRUQsNEJBQUUsR0FBRixVQUFHLEdBQVE7UUFDVCxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3JCLElBQUksR0FBRyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3ZCLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDZCxDQUFDO0lBRUQsNEJBQUUsR0FBRjtRQUNFLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDakIsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3pCLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUM7WUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFDSCxzQkFBQztBQUFELENBbkNBLEFBbUNDLElBQUE7QUFFRDtJQVNFLGlCQUFZLE1BQTBCO1FBUi9CLFNBQUksR0FBRyxTQUFTLENBQUM7UUFTdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFzQixDQUFDO1FBQ2xDLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBQ2QsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBRUQsb0JBQUUsR0FBRixVQUFHLENBQU0sRUFBRSxDQUFTO1FBQ2xCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsSUFBTSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUN6RCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqQixPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVELHdCQUFNLEdBQU4sVUFBTyxHQUFxQjtRQUMxQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDdEIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDdkMsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDWCxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ1gsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDO1NBQ1Y7YUFBTTtZQUNMLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzFCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLGVBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDOUM7U0FDRjtJQUNILENBQUM7SUFFRCx1QkFBSyxHQUFMO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN0QixJQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ25CLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDckIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBc0IsQ0FBQztRQUNsQyxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNkLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFDSCxjQUFDO0FBQUQsQ0FqREEsQUFpREMsSUFBQTtBQUVEO0lBSUUsbUJBQVksQ0FBVztRQUhoQixTQUFJLEdBQUcsV0FBVyxDQUFDO1FBSXhCLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2IsQ0FBQztJQUVELDBCQUFNLEdBQU4sVUFBTyxHQUF3QjtRQUM3QixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RCxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDWCxDQUFDO0lBRUQseUJBQUssR0FBTDtJQUNBLENBQUM7SUFDSCxnQkFBQztBQUFELENBaEJBLEFBZ0JDLElBQUE7QUFFRDtJQUtFLHFCQUFZLENBQWlCO1FBSnRCLFNBQUksR0FBRyxhQUFhLENBQUM7UUFLMUIsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUM7UUFDaEIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDYixDQUFDO0lBRUQsNEJBQU0sR0FBTixVQUFPLEdBQXdCO1FBQzdCLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQztRQUNmLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNULFVBQUMsQ0FBSTtZQUNILElBQUksSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFDWCxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNWLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQzthQUNWO1FBQ0gsQ0FBQyxFQUNELFVBQUMsQ0FBTTtZQUNMLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDWixDQUFDLENBQ0YsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQUMsR0FBUTtZQUNwQixVQUFVLENBQUMsY0FBUSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELDJCQUFLLEdBQUw7UUFDRSxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQztJQUNsQixDQUFDO0lBQ0gsa0JBQUM7QUFBRCxDQS9CQSxBQStCQyxJQUFBO0FBRUQ7SUFNRSxrQkFBWSxNQUFjO1FBTG5CLFNBQUksR0FBRyxVQUFVLENBQUM7UUFNdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNyQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNiLENBQUM7SUFFRCx5QkFBTSxHQUFOLFVBQU8sR0FBNkI7UUFDbEMsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLFNBQVMsZUFBZSxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVELHdCQUFLLEdBQUw7UUFDRSxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssQ0FBQyxDQUFDO1lBQUUsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2IsQ0FBQztJQUNILGVBQUM7QUFBRCxDQXZCQSxBQXVCQyxJQUFBO0FBRUQ7SUFXRSxlQUFZLEdBQWMsRUFBRSxHQUEwQztRQVYvRCxTQUFJLEdBQUcsT0FBTyxDQUFDO1FBV3BCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7UUFDM0IsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDZCxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNaLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUTtZQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO2FBQU0sSUFBSSxPQUFPLEdBQUcsS0FBSyxVQUFVO1lBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDOUYsQ0FBQztJQUVELHNCQUFNLEdBQU4sVUFBTyxHQUFjO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVELHFCQUFLLEdBQUw7UUFDRSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQWUsQ0FBQztJQUM3QixDQUFDO0lBRUQsa0JBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3JCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFO1lBQ2QsSUFBSTtnQkFDRixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDTjtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDVDtTQUNGO2FBQU0sSUFBSSxDQUFDO1lBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDOztZQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRCxrQkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRCxrQkFBRSxHQUFGO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDVCxDQUFDO0lBQ0gsWUFBQztBQUFELENBdERBLEFBc0RDLElBQUE7QUFFRDtJQU9FLGNBQVksR0FBVyxFQUFFLEdBQWM7UUFOaEMsU0FBSSxHQUFHLE1BQU0sQ0FBQztRQU9uQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO1FBQzNCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVELHFCQUFNLEdBQU4sVUFBTyxHQUFjO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDakIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVELG9CQUFLLEdBQUw7UUFDRSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQWUsQ0FBQztJQUM3QixDQUFDO0lBRUQsaUJBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3JCLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHO1lBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQsaUJBQUUsR0FBRixVQUFHLEdBQVE7UUFDVCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3JCLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDWixDQUFDO0lBRUQsaUJBQUUsR0FBRjtRQUNFLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQ1QsQ0FBQztJQUNILFdBQUM7QUFBRCxDQTFDQSxBQTBDQyxJQUFBO0FBRUQ7SUFJRSx5QkFBWSxHQUFjLEVBQUUsRUFBYztRQUN4QyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQUVELDRCQUFFLEdBQUY7UUFDRSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLENBQUM7SUFFRCw0QkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRCw0QkFBRSxHQUFGO1FBQ0UsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBQ0gsc0JBQUM7QUFBRCxDQXBCQSxBQW9CQyxJQUFBO0FBRUQ7SUFPRSxpQkFBWSxDQUFjLEVBQUUsR0FBYztRQU5uQyxTQUFJLEdBQUcsU0FBUyxDQUFDO1FBT3RCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7UUFDM0IsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQztJQUNuQixDQUFDO0lBRUQsd0JBQU0sR0FBTixVQUFPLEdBQWM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksZUFBZSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFRCx1QkFBSyxHQUFMO1FBQ0UsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO1FBQzNCLElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO0lBQ25CLENBQUM7SUFFRCxxQkFBRyxHQUFIO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDVCxDQUFDO0lBRUQsb0JBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3JCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQsb0JBQUUsR0FBRixVQUFHLEdBQVE7UUFDVCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3JCLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDWixDQUFDO0lBRUQsb0JBQUUsR0FBRjtRQUNFLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNiLENBQUM7SUFDSCxjQUFDO0FBQUQsQ0FoREEsQUFnREMsSUFBQTtBQUVEO0lBTUUsZ0JBQVksTUFBeUIsRUFBRSxHQUFjO1FBTDlDLFNBQUksR0FBRyxRQUFRLENBQUM7UUFNckIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQWUsQ0FBQztRQUMzQixJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQsdUJBQU0sR0FBTixVQUFPLEdBQWM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQsc0JBQUssR0FBTDtRQUNFLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO0lBQzdCLENBQUM7SUFFRCxtQkFBRSxHQUFGLFVBQUcsQ0FBSTtRQUNMLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztZQUFFLE9BQU87UUFDM0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRCxtQkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRCxtQkFBRSxHQUFGO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDVCxDQUFDO0lBQ0gsYUFBQztBQUFELENBekNBLEFBeUNDLElBQUE7QUFFRDtJQUlFLHlCQUFZLEdBQWMsRUFBRSxFQUFjO1FBQ3hDLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFDZixDQUFDO0lBRUQsNEJBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqQixDQUFDO0lBRUQsNEJBQUUsR0FBRixVQUFHLEdBQVE7UUFDVCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQsNEJBQUUsR0FBRjtRQUNFLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxHQUFHLEVBQWUsQ0FBQztRQUNoQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFDSCxzQkFBQztBQUFELENBckJBLEFBcUJDLElBQUE7QUFFRDtJQVFFLGlCQUFZLEdBQXNCO1FBUDNCLFNBQUksR0FBRyxTQUFTLENBQUM7UUFRdEIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQWUsQ0FBQztRQUMzQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQWUsQ0FBQztRQUM3QixJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQztJQUNsQixDQUFDO0lBRUQsd0JBQU0sR0FBTixVQUFPLEdBQWM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQWUsQ0FBQztRQUM3QixJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQztRQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQsdUJBQUssR0FBTDtRQUNFLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO1FBQzNCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBZSxDQUFDO1FBQzdCLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDO0lBQ2xCLENBQUM7SUFFRCxzQkFBSSxHQUFKO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLEVBQUU7WUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDOUMsQ0FBQztJQUVELG9CQUFFLEdBQUYsVUFBRyxDQUFZO1FBQ2IsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNmLElBQUEsU0FBa0IsRUFBakIsZ0JBQUssRUFBRSxVQUFVLENBQUM7UUFDekIsSUFBSSxLQUFLLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxLQUFLO1lBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNwRCxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxlQUFlLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVELG9CQUFFLEdBQUYsVUFBRyxHQUFRO1FBQ1QsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUVELG9CQUFFLEdBQUY7UUFDRSxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNsQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBQ0gsY0FBQztBQUFELENBekRBLEFBeURDLElBQUE7QUFFRDtJQVFFLGNBQVksQ0FBc0IsRUFBRSxJQUFPLEVBQUUsR0FBYztRQUEzRCxpQkFLQztRQVpNLFNBQUksR0FBRyxNQUFNLENBQUM7UUFRbkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQWUsQ0FBQztRQUMzQixJQUFJLENBQUMsQ0FBQyxHQUFHLFVBQUMsQ0FBSSxJQUFLLE9BQUEsQ0FBQyxDQUFDLEtBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQWQsQ0FBYyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDOUIsQ0FBQztJQUVELHFCQUFNLEdBQU4sVUFBTyxHQUFjO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3JCLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFRCxvQkFBSyxHQUFMO1FBQ0UsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7UUFDM0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxpQkFBRSxHQUFGLFVBQUcsQ0FBSTtRQUNMLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQU0sQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCxpQkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRCxpQkFBRSxHQUFGO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDVCxDQUFDO0lBQ0gsV0FBQztBQUFELENBL0NBLEFBK0NDLElBQUE7QUFFRDtJQU9FLGNBQVksR0FBYztRQU5uQixTQUFJLEdBQUcsTUFBTSxDQUFDO1FBT25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7UUFDM0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7UUFDakIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFPLENBQUM7SUFDckIsQ0FBQztJQUVELHFCQUFNLEdBQU4sVUFBTyxHQUFjO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7UUFDakIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVELG9CQUFLLEdBQUw7UUFDRSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQWUsQ0FBQztRQUMzQixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQU8sQ0FBQztJQUNyQixDQUFDO0lBRUQsaUJBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztRQUNoQixJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNmLENBQUM7SUFFRCxpQkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRCxpQkFBRSxHQUFGO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDWixDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNmLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztTQUNSOztZQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFDSCxXQUFDO0FBQUQsQ0E3Q0EsQUE2Q0MsSUFBQTtBQUVEO0lBTUUsZUFBWSxPQUFvQixFQUFFLEdBQWM7UUFMekMsU0FBSSxHQUFHLEtBQUssQ0FBQztRQU1sQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO1FBQzNCLElBQUksQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFRCxzQkFBTSxHQUFOLFVBQU8sR0FBYztRQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFRCxxQkFBSyxHQUFMO1FBQ0UsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7SUFDN0IsQ0FBQztJQUVELGtCQUFFLEdBQUYsVUFBRyxDQUFJO1FBQ0wsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQU0sQ0FBQyxDQUFDO0lBQ2YsQ0FBQztJQUVELGtCQUFFLEdBQUYsVUFBRyxHQUFRO1FBQ1QsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUVELGtCQUFFLEdBQUY7UUFDRSxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3JCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNULENBQUM7SUFDSCxZQUFDO0FBQUQsQ0F6Q0EsQUF5Q0MsSUFBQTtBQUVEO0lBS0Usa0JBQVksR0FBYztRQUpuQixTQUFJLEdBQUcsVUFBVSxDQUFDO1FBS3ZCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7SUFDN0IsQ0FBQztJQUVELHlCQUFNLEdBQU4sVUFBTyxHQUFjO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUVELHdCQUFLLEdBQUw7UUFDRSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7SUFDN0IsQ0FBQztJQUNILGVBQUM7QUFBRCxDQW5CQSxBQW1CQyxJQUFBO0FBRUQ7SUFNRSxzQkFBWSxRQUFpQyxFQUFFLEdBQWM7UUFMdEQsU0FBSSxHQUFHLGNBQWMsQ0FBQztRQU0zQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO1FBQzNCLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDO0lBQ3BCLENBQUM7SUFFRCw2QkFBTSxHQUFOLFVBQU8sR0FBYztRQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFRCw0QkFBSyxHQUFMO1FBQ0UsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7SUFDN0IsQ0FBQztJQUVELHlCQUFFLEdBQUYsVUFBRyxDQUFJO1FBQ0wsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1YsQ0FBQztJQUVELHlCQUFFLEdBQUYsVUFBRyxHQUFRO1FBQ1QsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixJQUFJO1lBQ0YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkIsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckM7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDVDtJQUNILENBQUM7SUFFRCx5QkFBRSxHQUFGO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDVCxDQUFDO0lBQ0gsbUJBQUM7QUFBRCxDQTVDQSxBQTRDQyxJQUFBO0FBRUQ7SUFNRSxtQkFBWSxHQUFjLEVBQUUsR0FBTTtRQUwzQixTQUFJLEdBQUcsV0FBVyxDQUFDO1FBTXhCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFlLENBQUM7UUFDM0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7SUFDakIsQ0FBQztJQUVELDBCQUFNLEdBQU4sVUFBTyxHQUFjO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCx5QkFBSyxHQUFMO1FBQ0UsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO0lBQzdCLENBQUM7SUFDSCxnQkFBQztBQUFELENBdEJBLEFBc0JDLElBQUE7QUFFRDtJQU9FLGNBQVksR0FBVyxFQUFFLEdBQWM7UUFOaEMsU0FBSSxHQUFHLE1BQU0sQ0FBQztRQU9uQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO1FBQzNCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUVELHFCQUFNLEdBQU4sVUFBTyxHQUFjO1FBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDZixJQUFJLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQztZQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQzs7WUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQsb0JBQUssR0FBTDtRQUNFLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBZSxDQUFDO0lBQzdCLENBQUM7SUFFRCxpQkFBRSxHQUFGLFVBQUcsQ0FBSTtRQUNMLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDckIsSUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHO1lBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUFNLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDbEQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNSLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztTQUNSO0lBQ0gsQ0FBQztJQUVELGlCQUFFLEdBQUYsVUFBRyxHQUFRO1FBQ1QsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUNyQixDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUVELGlCQUFFLEdBQUY7UUFDRSxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3JCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNULENBQUM7SUFDSCxXQUFDO0FBQUQsQ0E5Q0EsQUE4Q0MsSUFBQTtBQUVEO0lBU0UsZ0JBQVksUUFBOEI7UUFDeEMsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLElBQUksRUFBeUIsQ0FBQztRQUNuRCxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBeUIsQ0FBQztRQUNyQyxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQztRQUNoQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQWUsQ0FBQztRQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBRUQsbUJBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3BCLElBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUMsRUFBRTtZQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQU0sSUFBSSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU87YUFBTTtZQUNwRCxJQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN4QztJQUNILENBQUM7SUFFRCxtQkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxFQUFFO1lBQUUsT0FBTztRQUM3QixJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztRQUNoQixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3BCLElBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDbkIsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ1YsSUFBSSxJQUFJLENBQUMsRUFBRTtZQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQU0sSUFBSSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU87YUFBTTtZQUN0RCxJQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQztRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzFDLENBQUM7SUFFRCxtQkFBRSxHQUFGO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNwQixJQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ25CLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNWLElBQUksSUFBSSxDQUFDLEVBQUU7WUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUM7WUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7YUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTzthQUFNO1lBQ25ELElBQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7U0FDdkM7SUFDSCxDQUFDO0lBRUQsbUJBQUUsR0FBRjtRQUNFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQztZQUFFLE9BQU87UUFDbkMsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLEVBQUU7WUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQzFDLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2YsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUVELHlCQUFRLEdBQVI7UUFDRSw4Q0FBOEM7UUFDOUMsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDZixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLEVBQXVCO1FBQzFCLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDeEIsSUFBSSxFQUFFLEtBQUssRUFBRTtZQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsQyxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3BCLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQztZQUFFLE9BQU87UUFDekIsSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLEVBQUUsRUFBRTtZQUN2QixZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzNCLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1NBQ25CO2FBQU07WUFDTCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM5QjtJQUNILENBQUM7SUFFRCx3QkFBTyxHQUFQLFVBQVEsRUFBdUI7UUFBL0IsaUJBY0M7UUFiQyxJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3hCLElBQUksRUFBRSxLQUFLLEVBQUU7WUFBRSxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckMsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNwQixJQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQ1YsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDZixJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO2dCQUN0QyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDZixJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLFFBQVEsRUFBRSxFQUFmLENBQWUsQ0FBQyxDQUFDO2FBQ2xEO2lCQUFNLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUNyQjtTQUNGO0lBQ0gsQ0FBQztJQUVELG9FQUFvRTtJQUNwRSxrRUFBa0U7SUFDbEUsbUVBQW1FO0lBQ25FLGtFQUFrRTtJQUNsRSw2QkFBWSxHQUFaO1FBQ0UsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUM7WUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQsMkVBQTJFO0lBQzNFLHlFQUF5RTtJQUN6RSw2RUFBNkU7SUFDN0UsdUNBQXVDO0lBQ3ZDLDRCQUFXLEdBQVgsVUFBWSxDQUF3QixFQUFFLEtBQWlCO1FBQ3JELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDekIsT0FBTyxJQUFJLENBQUM7YUFDZCxJQUFLLENBQTJCLENBQUMsR0FBRyxLQUFLLElBQUk7WUFDM0MsT0FBTyxJQUFJLENBQUM7YUFDZCxJQUFLLENBQTJCLENBQUMsR0FBRyxJQUFLLENBQTJCLENBQUMsR0FBRyxLQUFLLEVBQUU7WUFDN0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFFLENBQTJCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM3RSxJQUFLLENBQWlCLENBQUMsSUFBSSxFQUFFO1lBQzNCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBSSxDQUFpQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQzVELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFFLENBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2hFLE9BQU8sS0FBSyxDQUFDO1lBQ2pCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7O1lBQU0sT0FBTyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUVPLHFCQUFJLEdBQVo7UUFDRSxPQUFPLElBQUksWUFBWSxZQUFZLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQzlELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsNEJBQVcsR0FBWCxVQUFZLFFBQThCO1FBQ3ZDLFFBQWdDLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO1FBQzVELFFBQWdDLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDO1FBQzdELFFBQWdDLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDO1FBQ2pFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBK0IsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsK0JBQWMsR0FBZCxVQUFlLFFBQThCO1FBQzNDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBK0IsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCwwQkFBUyxHQUFULFVBQVUsUUFBOEI7UUFDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMzQixPQUFPLElBQUksU0FBUyxDQUFJLElBQUksRUFBRSxRQUErQixDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxpQkFBQywyQkFBWSxDQUFDLEdBQWQ7UUFDRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksYUFBTSxHQUFiLFVBQWlCLFFBQXNCO1FBQ3JDLElBQUksUUFBUSxFQUFFO1lBQ1osSUFBSSxPQUFPLFFBQVEsQ0FBQyxLQUFLLEtBQUssVUFBVTttQkFDckMsT0FBTyxRQUFRLENBQUMsSUFBSSxLQUFLLFVBQVU7Z0JBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQztZQUNyRSxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLG9CQUFvQjtTQUNwRDtRQUNELE9BQU8sSUFBSSxNQUFNLENBQUMsUUFBNkMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksdUJBQWdCLEdBQXZCLFVBQTJCLFFBQXNCO1FBQy9DLElBQUksUUFBUTtZQUFFLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsb0JBQW9CO1FBQ2pFLE9BQU8sSUFBSSxZQUFZLENBQUksUUFBNkMsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSSxZQUFLLEdBQVo7UUFDRSxPQUFPLElBQUksTUFBTSxDQUFNLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNJLFlBQUssR0FBWjtRQUNFLE9BQU8sSUFBSSxNQUFNLENBQU07WUFDckIsTUFBTSxZQUFDLEVBQXlCLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM5QyxLQUFLLEVBQUUsSUFBSTtTQUNaLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSSxZQUFLLEdBQVosVUFBYSxLQUFVO1FBQ3JCLE9BQU8sSUFBSSxNQUFNLENBQU07WUFDckIsTUFBTSxZQUFDLEVBQXlCLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkQsS0FBSyxFQUFFLElBQUk7U0FDWixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksV0FBSSxHQUFYLFVBQWUsS0FBNEQ7UUFDekUsSUFBSSxPQUFPLEtBQUssQ0FBQywyQkFBWSxDQUFDLEtBQUssVUFBVTtZQUMzQyxPQUFPLE1BQU0sQ0FBQyxjQUFjLENBQUksS0FBc0IsQ0FBQyxDQUFDO2FBQzFELElBQUksT0FBUSxLQUF3QixDQUFDLElBQUksS0FBSyxVQUFVO1lBQ3RELE9BQU8sTUFBTSxDQUFDLFdBQVcsQ0FBSSxLQUF1QixDQUFDLENBQUM7YUFDeEQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztZQUN0QixPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUksS0FBSyxDQUFDLENBQUM7UUFFcEMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO0lBQzFGLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNJLFNBQUUsR0FBVDtRQUFhLGVBQWtCO2FBQWxCLFVBQWtCLEVBQWxCLHFCQUFrQixFQUFsQixJQUFrQjtZQUFsQiwwQkFBa0I7O1FBQzdCLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBSSxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7O09BY0c7SUFDSSxnQkFBUyxHQUFoQixVQUFvQixLQUFlO1FBQ2pDLE9BQU8sSUFBSSxNQUFNLENBQUksSUFBSSxTQUFTLENBQUksS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0ksa0JBQVcsR0FBbEIsVUFBc0IsT0FBdUI7UUFDM0MsT0FBTyxJQUFJLE1BQU0sQ0FBSSxJQUFJLFdBQVcsQ0FBSSxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxxQkFBYyxHQUFyQixVQUF5QixHQUFxQjtRQUM1QyxJQUFLLEdBQWlCLENBQUMsT0FBTztZQUFFLE9BQU8sR0FBZ0IsQ0FBQztRQUN4RCxJQUFNLENBQUMsR0FBRyxPQUFPLEdBQUcsQ0FBQywyQkFBWSxDQUFDLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsMkJBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUM5RSxPQUFPLElBQUksTUFBTSxDQUFJLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7T0FlRztJQUNJLGVBQVEsR0FBZixVQUFnQixNQUFjO1FBQzVCLE9BQU8sSUFBSSxNQUFNLENBQVMsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBeURTLHFCQUFJLEdBQWQsVUFBa0IsT0FBb0I7UUFDcEMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUksSUFBSSxLQUFLLENBQU8sT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ0gsb0JBQUcsR0FBSCxVQUFPLE9BQW9CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0gsc0JBQUssR0FBTCxVQUFTLGNBQWlCO1FBQ3hCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBTSxPQUFBLGNBQWMsRUFBZCxDQUFjLENBQUMsQ0FBQztRQUN6QyxJQUFNLEVBQUUsR0FBbUIsQ0FBQyxDQUFDLEtBQXVCLENBQUM7UUFDckQsRUFBRSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7UUFDbEIsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkc7SUFDSCx1QkFBTSxHQUFOLFVBQU8sTUFBeUI7UUFDOUIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNyQixJQUFJLENBQUMsWUFBWSxNQUFNO1lBQ3JCLE9BQU8sSUFBSSxNQUFNLENBQUksSUFBSSxNQUFNLENBQzdCLEdBQUcsQ0FBRSxDQUFlLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUM5QixDQUFlLENBQUMsR0FBRyxDQUNyQixDQUFDLENBQUM7UUFDTCxPQUFPLElBQUksTUFBTSxDQUFJLElBQUksTUFBTSxDQUFJLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSCxxQkFBSSxHQUFKLFVBQUssTUFBYztRQUNqQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBSSxJQUFJLElBQUksQ0FBSSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSCxxQkFBSSxHQUFKLFVBQUssTUFBYztRQUNqQixPQUFPLElBQUksTUFBTSxDQUFJLElBQUksSUFBSSxDQUFJLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gscUJBQUksR0FBSjtRQUNFLE9BQU8sSUFBSSxNQUFNLENBQUksSUFBSSxJQUFJLENBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0gsMEJBQVMsR0FBVCxVQUFVLE9BQVU7UUFDbEIsT0FBTyxJQUFJLFlBQVksQ0FBSSxJQUFJLFNBQVMsQ0FBSSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNILHdCQUFPLEdBQVAsVUFBUSxLQUFrQjtRQUN4QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBSSxJQUFJLE9BQU8sQ0FBSSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0Qkc7SUFDSCxxQkFBSSxHQUFKLFVBQVEsVUFBK0IsRUFBRSxJQUFPO1FBQzlDLE9BQU8sSUFBSSxZQUFZLENBQUksSUFBSSxJQUFJLENBQU8sVUFBVSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNCRztJQUNILDZCQUFZLEdBQVosVUFBYSxPQUFnQztRQUMzQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBSSxJQUFJLFlBQVksQ0FBSSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXdCRztJQUNILHdCQUFPLEdBQVA7UUFDRSxPQUFPLElBQUksTUFBTSxDQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCx3QkFBTyxHQUFQLFVBQVcsUUFBa0M7UUFDM0MsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILHlCQUFRLEdBQVI7UUFDRSxPQUFPLElBQUksWUFBWSxDQUFJLElBQUksUUFBUSxDQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUtEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BeUJHO0lBQ0gsc0JBQUssR0FBTCxVQUFNLFVBQXFDO1FBQ3pDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFJLElBQUksS0FBSyxDQUFJLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0RHO0lBQ0gsd0JBQU8sR0FBUCxVQUFRLE1BQWlCO1FBQ3ZCLElBQUksTUFBTSxZQUFZLFlBQVk7WUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQ7Z0JBQ3JFLDREQUE0RDtnQkFDNUQsdUNBQXVDLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixLQUFLLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakYsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILG1DQUFrQixHQUFsQixVQUFtQixLQUFRO1FBQ3pCLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILG9DQUFtQixHQUFuQixVQUFvQixLQUFVO1FBQzVCLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILHVDQUFzQixHQUF0QjtRQUNFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW1CRztJQUNILGlDQUFnQixHQUFoQixVQUFpQixRQUFpRDtRQUNoRSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2IsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUM7WUFDaEIsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUF5QixDQUFDO1NBQ3RDO2FBQU07WUFDTCxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQztZQUNkLFFBQWdDLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO1lBQzVELFFBQWdDLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDO1lBQzdELFFBQWdDLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDO1lBQ2pFLElBQUksQ0FBQyxHQUFHLEdBQUcsUUFBK0IsQ0FBQztTQUM1QztJQUNILENBQUM7SUFqaEJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkc7SUFDSSxZQUFLLEdBQW1CLFNBQVMsS0FBSztRQUFDLGlCQUE4QjthQUE5QixVQUE4QixFQUE5QixxQkFBOEIsRUFBOUIsSUFBOEI7WUFBOUIsNEJBQThCOztRQUMxRSxPQUFPLElBQUksTUFBTSxDQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDN0MsQ0FBbUIsQ0FBQztJQUVwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JHO0lBQ0ksY0FBTyxHQUFxQixTQUFTLE9BQU87UUFBQyxpQkFBOEI7YUFBOUIsVUFBOEIsRUFBOUIscUJBQThCLEVBQTlCLElBQThCO1lBQTlCLDRCQUE4Qjs7UUFDaEYsT0FBTyxJQUFJLE1BQU0sQ0FBYSxJQUFJLE9BQU8sQ0FBTSxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQXFCLENBQUM7SUE2ZHhCLGFBQUM7Q0ExNEJELEFBMDRCQyxJQUFBO0FBMTRCWSx3QkFBTTtBQTQ0Qm5CO0lBQXFDLGdDQUFTO0lBRzVDLHNCQUFZLFFBQTZCO1FBQXpDLFlBQ0Usa0JBQU0sUUFBUSxDQUFDLFNBQ2hCO1FBSE8sVUFBSSxHQUFhLEtBQUssQ0FBQzs7SUFHL0IsQ0FBQztJQUVELHlCQUFFLEdBQUYsVUFBRyxDQUFJO1FBQ0wsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixpQkFBTSxFQUFFLFlBQUMsQ0FBQyxDQUFDLENBQUM7SUFDZCxDQUFDO0lBRUQsMkJBQUksR0FBSixVQUFLLEVBQXVCO1FBQzFCLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDeEIsSUFBSSxFQUFFLEtBQUssRUFBRTtZQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsQyxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3BCLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2hCLElBQUksSUFBSSxDQUFDLElBQUk7Z0JBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRyxDQUFDLENBQUM7WUFDL0IsT0FBTztTQUNSO1FBQ0QsSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLEVBQUUsRUFBRTtZQUN2QixJQUFJLElBQUksQ0FBQyxJQUFJO2dCQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUcsQ0FBQyxDQUFDO1lBQy9CLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7U0FDbkI7YUFBTSxJQUFJLElBQUksQ0FBQyxJQUFJO1lBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRyxDQUFDLENBQUM7YUFBTTtZQUMxQyxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM5QjtJQUNILENBQUM7SUFFRCwrQkFBUSxHQUFSO1FBQ0UsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDbEIsaUJBQU0sUUFBUSxXQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELHlCQUFFLEdBQUY7UUFDRSxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNsQixpQkFBTSxFQUFFLFdBQUUsQ0FBQztJQUNiLENBQUM7SUFFRCwwQkFBRyxHQUFILFVBQU8sT0FBb0I7UUFDekIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBb0IsQ0FBQztJQUMvQyxDQUFDO0lBRUQsNEJBQUssR0FBTCxVQUFTLGNBQWlCO1FBQ3hCLE9BQU8saUJBQU0sS0FBSyxZQUFDLGNBQWMsQ0FBb0IsQ0FBQztJQUN4RCxDQUFDO0lBRUQsMkJBQUksR0FBSixVQUFLLE1BQWM7UUFDakIsT0FBTyxpQkFBTSxJQUFJLFlBQUMsTUFBTSxDQUFvQixDQUFDO0lBQy9DLENBQUM7SUFFRCw4QkFBTyxHQUFQLFVBQVEsS0FBa0I7UUFDeEIsT0FBTyxpQkFBTSxPQUFPLFlBQUMsS0FBSyxDQUFvQixDQUFDO0lBQ2pELENBQUM7SUFFRCxtQ0FBWSxHQUFaLFVBQWEsT0FBZ0M7UUFDM0MsT0FBTyxpQkFBTSxZQUFZLFlBQUMsT0FBTyxDQUFvQixDQUFDO0lBQ3hELENBQUM7SUFFRCwrQkFBUSxHQUFSO1FBQ0UsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBS0QsNEJBQUssR0FBTCxVQUFNLFVBQWlEO1FBQ3JELE9BQU8saUJBQU0sS0FBSyxZQUFDLFVBQWlCLENBQW9CLENBQUM7SUFDM0QsQ0FBQztJQUNILG1CQUFDO0FBQUQsQ0F4RUEsQUF3RUMsQ0F4RW9DLE1BQU0sR0F3RTFDO0FBeEVZLG9DQUFZO0FBMkV6QixJQUFNLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFFbEIsa0JBQWUsRUFBRSxDQUFDOzs7QUNyZ0VsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4Q0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUdBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySkEsa0NBQStFO0FBRS9FO0lBS0Usd0JBQW1CLE9BQXlCO1FBQXpCLFlBQU8sR0FBUCxPQUFPLENBQWtCO1FBSnJDLFNBQUksR0FBRyxRQUFRLENBQUM7UUFDaEIsUUFBRyxHQUFjLElBQVcsQ0FBQztRQUM1QixNQUFDLEdBQVcsQ0FBQyxDQUFDO0lBR3RCLENBQUM7SUFFRCwrQkFBTSxHQUFOLFVBQU8sR0FBYztRQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsOEJBQUssR0FBTDtRQUNFLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDN0IsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDM0IsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDL0I7UUFDRCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBVyxDQUFDO0lBQ3pCLENBQUM7SUFFRCwyQkFBRSxHQUFGLFVBQUcsQ0FBSTtRQUNMLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLENBQUM7WUFBRSxPQUFPO1FBQ2YsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRCwyQkFBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLENBQUM7WUFBRSxPQUFPO1FBQ2YsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRCwyQkFBRSxHQUFGO1FBQ0UsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMsQ0FBQztZQUFFLE9BQU87UUFDZixJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzdCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlCLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDN0IsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUI7YUFBTTtZQUNMLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztTQUNSO0lBQ0gsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0E3Q0EsQUE2Q0MsSUFBQTtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUNHO0FBQ0gsU0FBd0IsTUFBTTtJQUFJLGlCQUE0QjtTQUE1QixVQUE0QixFQUE1QixxQkFBNEIsRUFBNUIsSUFBNEI7UUFBNUIsNEJBQTRCOztJQUM1RCxPQUFPLElBQUksY0FBTSxDQUFJLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUZELHlCQUVDOzs7OztBQ3pGRCxrQ0FBNEQ7QUFrRDVELElBQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUVkO0lBQ0UsK0JBQW9CLENBQVMsRUFBVSxDQUE2QjtRQUFoRCxNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBQVUsTUFBQyxHQUFELENBQUMsQ0FBNEI7UUFDbEUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDbEIsQ0FBQztJQUVELGtDQUFFLEdBQUYsVUFBRyxDQUFJO1FBQ0wsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRTtZQUFFLE9BQU87UUFDekIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFRCxrQ0FBRSxHQUFGLFVBQUcsR0FBUTtRQUNULElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxrQ0FBRSxHQUFGO1FBQ0UsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBQ0gsNEJBQUM7QUFBRCxDQWxCQSxBQWtCQyxJQUFBO0FBbEJZLHNEQUFxQjtBQW9CbEM7SUFTRSwrQkFBWSxHQUFjLEVBQUUsT0FBMkI7UUFSaEQsU0FBSSxHQUFHLGVBQWUsQ0FBQztRQVM1QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBd0IsQ0FBQztRQUNwQyxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNkLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUVELHNDQUFNLEdBQU4sVUFBTyxHQUF1QjtRQUM1QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDdEIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQzdCLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMxQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLHFCQUFxQixDQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3BEO1FBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVELHFDQUFLLEdBQUw7UUFDRSxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3RCLElBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDbkIsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzFCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEI7UUFDRCxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQXdCLENBQUM7UUFDcEMsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDZixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBRUQsa0NBQUUsR0FBRixVQUFHLENBQUk7UUFDTCxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3JCLElBQUksR0FBRyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3ZCLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDO1lBQUUsT0FBTztRQUN4QixHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsU0FBSyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELGtDQUFFLEdBQUYsVUFBRyxHQUFRO1FBQ1QsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNyQixJQUFJLEdBQUcsS0FBSyxFQUFFO1lBQUUsT0FBTztRQUN2QixHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsQ0FBQztJQUVELGtDQUFFLEdBQUY7UUFDRSxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3JCLElBQUksR0FBRyxLQUFLLEVBQUU7WUFBRSxPQUFPO1FBQ3ZCLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNYLENBQUM7SUFFRCxrQ0FBRSxHQUFGLFVBQUcsQ0FBTSxFQUFFLENBQVM7UUFDbEIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDM0IsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1NBQ1g7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQsb0NBQUksR0FBSixVQUFLLENBQVMsRUFBRSxDQUE2QjtRQUMzQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBQ0gsNEJBQUM7QUFBRCxDQXpFQSxBQXlFQyxJQUFBO0FBekVZLHNEQUFxQjtBQTJFbEMsSUFBSSxhQUFxQyxDQUFDO0FBRTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVFRztBQUNILGFBQWEsR0FBRyxTQUFTLGFBQWE7SUFBQyxpQkFBOEI7U0FBOUIsVUFBOEIsRUFBOUIscUJBQThCLEVBQTlCLElBQThCO1FBQTlCLDRCQUE4Qjs7SUFDbkUsT0FBTyxTQUFTLHFCQUFxQixDQUFDLE9BQW9CO1FBQ3hELE9BQU8sSUFBSSxjQUFNLENBQWEsSUFBSSxxQkFBcUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUM3RSxDQUFDLENBQUM7QUFDSixDQUEyQixDQUFDO0FBRTVCLGtCQUFlLGFBQWEsQ0FBQzs7Ozs7OztBQ25PN0I7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBLFNBQVMsSUFBVCxDQUFjLE9BQWQsRUFBdUI7QUFDckIsVUFBUSxTQUFSLENBQWtCLFdBQWxCLENBQThCLEVBQUUsTUFBTSxRQUFRLEdBQWhCLEVBQTlCOztBQUVBLE1BQU0sUUFBUSxrQkFDWCxFQURXLENBRVYsY0FBSSxZQUFKLEVBQWtCLEdBRWhCLGdCQUFNLGtCQUFOLEVBQTBCO0FBQ3hCLFdBQU8sRUFBRSxTQUFTLE1BQVgsRUFBbUIsV0FBVyxpQkFBOUI7QUFEaUIsR0FBMUIsQ0FGZ0IsRUFLaEIsaUJBQU8sbUJBQVAsQ0FMZ0IsQ0FBbEIsQ0FGVSxFQVVYLFNBVlcsQ0FVRCxFQVZDLENBQWQ7QUFXQSxNQUFNLFdBQVcsa0JBQ2QsT0FEYyxDQUViLFFBQVEsR0FBUixDQUFZLE1BQVosQ0FBbUIsa0JBQW5CLEVBQ0csT0FESCxHQUVHLElBRkgsQ0FFUSxDQUZSLENBRmEsRUFLYixRQUFRLEdBQVIsQ0FBWSxNQUFaLENBQW1CLG1CQUFuQixFQUNHLE9BREgsR0FFRyxJQUZILENBRVEsQ0FGUixDQUxhLEVBU2QsR0FUYyxDQVNWO0FBQUEsV0FBTSxFQUFFLE1BQU0sT0FBUixFQUFpQixPQUFPLENBQXhCLEVBQU47QUFBQSxHQVRVLENBQWpCO0FBVUEsU0FBTztBQUNMLFNBQUssS0FEQTtBQUVMLGVBQVc7QUFGTixHQUFQO0FBSUQ7O0FBRUQsY0FBSSxJQUFKLEVBQVU7QUFDUixPQUFLLHdCQUFjLE1BQWQsQ0FERztBQUVSLGFBQVc7QUFGSCxDQUFWIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhzID0gcmVxdWlyZShcInhzdHJlYW1cIikuZGVmYXVsdDtcbnZhciBoYW5kVHJhY2sgPSByZXF1aXJlKFwiaGFuZHRyYWNranMvZGlzdC9oYW5kdHJhY2subWluLmpzXCIpOyAvLyBjb3BpZWQgZnJvbSB2MC4wLjEzXG52YXIgbWFrZUhhbmRUcmFja0RyaXZlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLm1vZGVsLCBtb2RlbCA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2MsIF9kID0gX2IubW9kZWxQYXJhbXMsIG1vZGVsUGFyYW1zID0gX2QgPT09IHZvaWQgMCA/IHt9IDogX2Q7XG4gICAgbW9kZWxQYXJhbXMgPSBfX2Fzc2lnbih7IGZsaXBIb3Jpem9udGFsOiB0cnVlLCBtYXhOdW1Cb3hlczogMiwgaW91VGhyZXNob2xkOiAwLjUsIHNjb3JlVGhyZXNob2xkOiAwLjYgfSwgbW9kZWxQYXJhbXMpO1xuICAgIHZhciBydW5EZXRlY3Rpb24gPSBmdW5jdGlvbiAobW9kZWwsIHZpZGVvLCBjYW52YXMsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdmFyIHJ1bkRldGVjdGlvbkhlbHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1vZGVsLmRldGVjdCh2aWRlbykudGhlbihmdW5jdGlvbiAocHJlZGljdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5uZXh0KHByZWRpY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5yZW5kZXJQcmVkaWN0aW9ucyhwcmVkaWN0aW9ucywgY2FudmFzLCBjb250ZXh0LCB2aWRlbyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1bkRldGVjdGlvbkhlbHBlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVuRGV0ZWN0aW9uSGVscGVyKCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbW1hbmQkKSB7XG4gICAgICAgIHZhciBvdXRwdXQkID0geHMuY3JlYXRlKHtcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kJC5hZGRMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbWQudHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gY21kLmVsZW1zLCB2aWRlb18xID0gX2FbMF0sIGNhbnZhc18xID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZFRyYWNrLnN0YXJ0VmlkZW8odmlkZW9fMSkudGhlbihmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kVHJhY2subG9hZChtb2RlbFBhcmFtcykudGhlbihmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuRGV0ZWN0aW9uKG1vZGVsLCB2aWRlb18xLCBjYW52YXNfMSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuRGV0ZWN0aW9uKG1vZGVsLCB2aWRlb18xLCBjYW52YXNfMSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZXJyb3IoXCJDYW5ub3Qgc3RhcnQgdmlkZW9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dCQ7XG4gICAgfTtcbn07XG5leHBvcnRzLm1ha2VIYW5kVHJhY2tEcml2ZXIgPSBtYWtlSGFuZFRyYWNrRHJpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/dChleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sdCk6KGU9ZXx8c2VsZix0KGUuaGFuZFRyYWNrPXt9KSl9KSh0aGlzLGZ1bmN0aW9uKGV4cG9ydHMpe1widXNlIHN0cmljdFwiOy8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgKlxuICAgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICpcbiAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgKi92YXIgX01hdGhwb3c9TWF0aC5wb3csX01hdGhsb2c9TWF0aC5sb2csX051bWJlcmlzSW50ZWdlcj1OdW1iZXIuaXNJbnRlZ2VyLF9TdHJpbmdmcm9tQ2hhckNvZGU9U3RyaW5nLmZyb21DaGFyQ29kZSxfTnVtYmVyTkVHQVRJVkVfSU5GSU5JVFk9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLF9NYXRoc2luPU1hdGguc2luLF9NYXRoY29zPU1hdGguY29zLF9NYXRoUEk9TWF0aC5QSSxfTWF0aGFicz1NYXRoLmFicyxfTWF0aGNlaWw9TWF0aC5jZWlsLF9OdW1iZXJNQVhfU0FGRV9JTlRFR0VSPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLF9OdW1iZXJNSU5fU0FGRV9JTlRFR0VSPU51bWJlci5NSU5fU0FGRV9JTlRFR0VSLF9NYXRocm91bmQ9TWF0aC5yb3VuZCxfTWF0aGZsb29yPU1hdGguZmxvb3IsX01hdGhzcXJ0PU1hdGguc3FydCxfTWF0aGV4cD1NYXRoLmV4cCxfTWF0aG1heD1NYXRoLm1heCxfTWF0aG1pbj1NYXRoLm1pbjtmdW5jdGlvbiBfX2V4dGVuZHMoYSxlKXtmdW5jdGlvbiB0KCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWV4dGVuZFN0YXRpY3MoYSxlKSxhLnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOih0LnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gX19hd2FpdGVyKHAsZSx0LGwpe3JldHVybiBuZXcodHx8KHQ9UHJvbWlzZSkpKGZ1bmN0aW9uKG4scil7ZnVuY3Rpb24gYSh0KXt0cnl7cyhsLm5leHQodCkpfWNhdGNoKHQpe3IodCl9fWZ1bmN0aW9uIG8odCl7dHJ5e3MobC50aHJvdyh0KSl9Y2F0Y2godCl7cih0KX19ZnVuY3Rpb24gcyhyKXtyLmRvbmU/bihyLnZhbHVlKTpuZXcgdChmdW5jdGlvbihlKXtlKHIudmFsdWUpfSkudGhlbihhLG8pfXMoKGw9bC5hcHBseShwLGV8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHAsZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtzOyl0cnl7aWYobD0xLGQmJih1PTImdFswXT9kLnJldHVybjp0WzBdP2QudGhyb3d8fCgodT1kLnJldHVybikmJnUuY2FsbChkKSwwKTpkLm5leHQpJiYhKHU9dS5jYWxsKGQsdFsxXSkpLmRvbmUpcmV0dXJuIHU7c3dpdGNoKGQ9MCx1JiYodD1bMiZ0WzBdLHUudmFsdWVdKSx0WzBdKXtjYXNlIDA6Y2FzZSAxOnU9dDticmVhaztjYXNlIDQ6cmV0dXJuIHMubGFiZWwrKyx7dmFsdWU6dFsxXSxkb25lOiExfTtjYXNlIDU6cy5sYWJlbCsrLGQ9dFsxXSx0PVswXTtjb250aW51ZTtjYXNlIDc6dD1zLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKHU9MDwodT1zLnRyeXMpLmxlbmd0aCYmdVt1Lmxlbmd0aC0xXSkmJig2PT09dFswXXx8Mj09PXRbMF0pKXtzPTA7Y29udGludWV9aWYoMz09PXRbMF0mJighdXx8dFsxXT51WzBdJiZ0WzFdPHVbM10pKXtzLmxhYmVsPXRbMV07YnJlYWt9aWYoNj09PXRbMF0mJnMubGFiZWw8dVsxXSl7cy5sYWJlbD11WzFdLHU9dDticmVha31pZih1JiZzLmxhYmVsPHVbMl0pe3MubGFiZWw9dVsyXSxzLm9wcy5wdXNoKHQpO2JyZWFrfXVbMl0mJnMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZTt9dD1lLmNhbGwocCxzKX1jYXRjaChhKXt0PVs2LGFdLGQ9MH1maW5hbGx5e2w9dT0wfWlmKDUmdFswXSl0aHJvdyB0WzFdO3JldHVybnt2YWx1ZTp0WzBdP3RbMV06dm9pZCAwLGRvbmU6ITB9fShbdCxhXSl9fXZhciBzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJnVbMF0pdGhyb3cgdVsxXTtyZXR1cm4gdVsxXX0sdHJ5czpbXSxvcHM6W119LGwsZCx1LGM7cmV0dXJuIGM9e25leHQ6dCgwKSx0aHJvdzp0KDEpLHJldHVybjp0KDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihjW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGN9ZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGEpe2EgaW4gY29udGV4dHN8fChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGRlbGV0ZSBjb250ZXh0c1thXX0sITEpLGNvbnRleHRzW2FdPWdldFdlYkdMUmVuZGVyaW5nQ29udGV4dChhKSk7dmFyIGU9Y29udGV4dHNbYV07cmV0dXJuIGUuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgY29udGV4dHNbYV0sZ2V0V2ViR0xDb250ZXh0KGEpKTooZS5kaXNhYmxlKGUuREVQVEhfVEVTVCksZS5kaXNhYmxlKGUuU1RFTkNJTF9URVNUKSxlLmRpc2FibGUoZS5CTEVORCksZS5kaXNhYmxlKGUuRElUSEVSKSxlLmRpc2FibGUoZS5QT0xZR09OX09GRlNFVF9GSUxMKSxlLmRpc2FibGUoZS5TQU1QTEVfQ09WRVJBR0UpLGUuZW5hYmxlKGUuU0NJU1NPUl9URVNUKSxlLmVuYWJsZShlLkNVTExfRkFDRSksZS5jdWxsRmFjZShlLkJBQ0spLGNvbnRleHRzW2FdKX1mdW5jdGlvbiBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoYSl7aWYoMSE9PWEmJjIhPT1hKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIFdlYkdMIGlzIGRpc2FibGVkLlwiKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3JldHVybiAxPT09YT9lLmdldENvbnRleHQoXCJ3ZWJnbFwiLFdFQkdMX0FUVFJJQlVURVMpfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixXRUJHTF9BVFRSSUJVVEVTKTplLmdldENvbnRleHQoXCJ3ZWJnbDJcIixXRUJHTF9BVFRSSUJVVEVTKX1mdW5jdGlvbiBpc01vYmlsZSgpe3ZhciB0PW5hdmlnYXRvci51c2VyQWdlbnR8fG5hdmlnYXRvci52ZW5kb3J8fHdpbmRvdy5vcGVyYTtyZXR1cm4gLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QodCl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QodC5zdWJzdHIoMCw0KSl9ZnVuY3Rpb24gc2h1ZmZsZShhKXtmb3IodmFyIGU9YS5sZW5ndGgsbz0wLHM9MDswPGU7KXM9MHxNYXRoLnJhbmRvbSgpKmUsbz1hWy0tZV0sYVtlXT1hW3NdLGFbc109b31mdW5jdGlvbiBjbGFtcChhLGUsdCl7cmV0dXJuIF9NYXRobWF4KGEsX01hdGhtaW4oZSx0KSl9ZnVuY3Rpb24gbmVhcmVzdExhcmdlckV2ZW4odCl7cmV0dXJuIDA9PXQlMj90OnQrMX1mdW5jdGlvbiBzdW0oYSl7Zm9yKHZhciBlPTAsbj0wO248YS5sZW5ndGg7bisrKWUrPWFbbl07cmV0dXJuIGV9ZnVuY3Rpb24gcmFuZFVuaWZvcm0oYSxlKXt2YXIgdD1NYXRoLnJhbmRvbSgpO3JldHVybiBlKnQrKDEtdCkqYX1mdW5jdGlvbiBkaXN0U3F1YXJlZChhLGUpe2Zvcih2YXIgdD0wLHM9MCxpO3M8YS5sZW5ndGg7cysrKWk9K2Fbc10tK2Vbc10sdCs9aSppO3JldHVybiB0fWZ1bmN0aW9uIGFzc2VydChhLGUpe2lmKCFhKXRocm93IG5ldyBFcnJvcihcInN0cmluZ1wiPT10eXBlb2YgZT9lOmUoKSl9ZnVuY3Rpb24gYXNzZXJ0U2hhcGVzTWF0Y2goYSxlLHQpe3ZvaWQgMD09PXQmJih0PVwiXCIpLGFzc2VydChhcnJheXNFcXVhbChhLGUpLHQrXCIgU2hhcGVzIFwiK2ErXCIgYW5kIFwiK2UrXCIgbXVzdCBtYXRjaFwiKX1mdW5jdGlvbiBhc3NlcnROb25OdWxsKHQpe2Fzc2VydChudWxsIT10LFwiVGhlIGlucHV0IHRvIHRoZSB0ZW5zb3IgY29uc3RydWN0b3IgbXVzdCBiZSBhIG5vbi1udWxsIHZhbHVlLlwiKX1mdW5jdGlvbiBmbGF0dGVuKGEsZSl7aWYodm9pZCAwPT09ZSYmKGU9W10pLEFycmF5LmlzQXJyYXkoYSkpZm9yKHZhciBuPTA7bjxhLmxlbmd0aDsrK24pZmxhdHRlbihhW25dLGUpO2Vsc2UgZS5wdXNoKGEpO3JldHVybiBlfWZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoYSl7aWYoMD09PWEubGVuZ3RoKXJldHVybiAxO2Zvcih2YXIgZT1hWzBdLG49MTtuPGEubGVuZ3RoO24rKyllKj1hW25dO3JldHVybiBlfWZ1bmN0aW9uIGlzU2NhbGFyU2hhcGUodCl7cmV0dXJuIDA9PT10Lmxlbmd0aH1mdW5jdGlvbiBhcnJheXNFcXVhbChhLGUpe2lmKGE9PT1lKXJldHVybiEwO2lmKG51bGw9PWF8fG51bGw9PWUpcmV0dXJuITE7aWYoYS5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIHQ9MDt0PGEubGVuZ3RoO3QrKylpZihhW3RdIT09ZVt0XSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBpc0ludCh0KXtyZXR1cm4gMD09dCUxfWZ1bmN0aW9uIHRhbmgoYSl7dmFyIGU9TWF0aC50YW5oO2lmKG51bGwhPWUpcmV0dXJuIGUoYSk7aWYoYT09PTEvMClyZXR1cm4gMTtpZihhPT09LTEvMClyZXR1cm4tMTt2YXIgbj1fTWF0aGV4cCgyKmEpO3JldHVybihuLTEpLyhuKzEpfWZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoYSl7Zm9yKHZhciBlPV9NYXRoZmxvb3IoX01hdGhzcXJ0KGEpKTsxPGU7LS1lKWlmKDA9PWElZSlyZXR1cm5bZSxhL2VdO3JldHVyblsxLGFdfWZ1bmN0aW9uIGNyZWF0ZVNodWZmbGVkSW5kaWNlcyhhKXtmb3IodmFyIGU9bmV3IFVpbnQzMkFycmF5KGEpLHQ9MDt0PGE7Kyt0KWVbdF09dDtyZXR1cm4gc2h1ZmZsZShlKSxlfWZ1bmN0aW9uIHJpZ2h0UGFkKGEsZSl7cmV0dXJuIGU8PWEubGVuZ3RoP2E6YStcIiBcIi5yZXBlYXQoZS1hLmxlbmd0aCl9ZnVuY3Rpb24gcmVwZWF0ZWRUcnkocCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT1mdW5jdGlvbigpe3JldHVybiAwfSksbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgbz0wLGw9ZnVuY3Rpb24oKXtpZihwKCkpdCgpO2Vsc2V7dmFyIGE9ZSgrK28pO251bGwhPW4mJm8+PW4/cigpOnNldFRpbWVvdXQobCxhKX19O2woKX0pfWZ1bmN0aW9uIGluZmVyRnJvbUltcGxpY2l0U2hhcGUocyxlKXtmb3IodmFyIHQ9MSxpPS0xLHA9MDtwPHMubGVuZ3RoOysrcClpZigwPD1zW3BdKXQqPXNbcF07ZWxzZSBpZigtMT09PXNbcF0pe2lmKC0xIT1pKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBvbmx5IGhhdmUgMSBpbXBsaWNpdCBzaXplLiBGb3VuZCAtMSBhdCBkaW0gXCIraStcIiBhbmQgZGltIFwiK3ApO2k9cH1lbHNlIGlmKDA+c1twXSl0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gbm90IGJlIDwgMC4gRm91bmQgXCIrc1twXStcIiBhdCBkaW0gXCIrcCk7aWYoLTE9PWkpe2lmKDA8ZSYmZSE9PXQpdGhyb3cgRXJyb3IoXCJTaXplKFwiK2UrXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIrcyk7cmV0dXJuIHN9aWYoMD09PXQpdGhyb3cgRXJyb3IoXCJDYW5ub3QgaW5mZXIgdGhlIG1pc3Npbmcgc2l6ZSBpbiBbXCIrcytcIl0gd2hlbiB0aGVyZSBhcmUgMCBlbGVtZW50c1wiKTtpZigwIT1lJXQpdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gR290IFwiK2UrXCIgLyBcIit0KTt2YXIgbD1zLnNsaWNlKCk7cmV0dXJuIGxbaV09ZS90LGx9ZnVuY3Rpb24gc3F1ZWV6ZVNoYXBlKHMsZSl7Zm9yKHZhciB0PVtdLHI9W10sbj0wLGk9MDtpPHMubGVuZ3RoOysraSl7aWYobnVsbCE9ZSl7aWYoZVtuXT09PWkmJjEhPT1zW2ldKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHNxdWVlemUgYXhpcyBcIitpK1wiIHNpbmNlIGl0cyBkaW0gJ1wiK3NbaV0rXCInIGlzIG5vdCAxXCIpOyhudWxsPT1lW25dfHxlW25dPmkpJiYxPT09c1tpXSYmKHQucHVzaChzW2ldKSxyLnB1c2goaSkpLGVbbl08PWkmJm4rK30xIT09c1tpXSYmKHQucHVzaChzW2ldKSxyLnB1c2goaSkpfXJldHVybntuZXdTaGFwZTp0LGtlcHREaW1zOnJ9fWZ1bmN0aW9uIGdldFR5cGVkQXJyYXlGcm9tRFR5cGUoYSxlKXt2YXIgdD1udWxsO2lmKG51bGw9PWF8fFwiZmxvYXQzMlwiPT09YSl0PW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT1hKXQ9bmV3IEludDMyQXJyYXkoZSk7ZWxzZXtpZihcImJvb2xcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrYSk7dD1uZXcgVWludDhBcnJheShlKX1yZXR1cm4gdH1mdW5jdGlvbiBjaGVja0NvbXB1dGF0aW9uRm9yTmFOKGEsZSx0KXtpZihcImZsb2F0MzJcIj09PWUpZm9yKHZhciByPTA7cjxhLmxlbmd0aDtyKyspaWYoaXNOYU4oYVtyXSkpdGhyb3cgRXJyb3IoXCJUaGUgcmVzdWx0IG9mIHRoZSAnXCIrdCtcIicgaGFzIE5hTnMuXCIpfWZ1bmN0aW9uIGNoZWNrQ29udmVyc2lvbkZvck5hTihhLGUpe2lmKFwiZmxvYXQzMlwiIT09ZSlmb3IodmFyIHQ9MDt0PGEubGVuZ3RoO3QrKylpZihpc05hTihhW3RdKSl0aHJvdyBFcnJvcihcIk5hTiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZHR5cGU6ICdcIitlK1wiJy5cIil9ZnVuY3Rpb24gaGFzRW5jb2RpbmdMb3NzKGEsZSl7cmV0dXJuXCJjb21wbGV4NjRcIiE9PWUmJihcImZsb2F0MzJcIiE9PWV8fFwiY29tcGxleDY0XCI9PT1hKSYmKFwiaW50MzJcIiE9PWV8fFwiZmxvYXQzMlwiPT09YXx8XCJjb21wbGV4NjRcIj09PWEpJiYoXCJib29sXCIhPT1lfHxcImJvb2xcIiE9PWEpfWZ1bmN0aW9uIGNvcHlUeXBlZEFycmF5KGEsZSx0KXtpZihudWxsPT1lfHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KGEpO2lmKFwiaW50MzJcIj09PWUpcmV0dXJuIHQmJmNoZWNrQ29udmVyc2lvbkZvck5hTihhLGUpLG5ldyBJbnQzMkFycmF5KGEpO2lmKFwiYm9vbFwiPT09ZSl7Zm9yKHZhciByPW5ldyBVaW50OEFycmF5KGEubGVuZ3RoKSxuPTA7bjxyLmxlbmd0aDsrK24pMCE9PV9NYXRocm91bmQoYVtuXSkmJihyW25dPTEpO3JldHVybiByfXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfWZ1bmN0aW9uIGlzVHlwZWRBcnJheSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fWZ1bmN0aW9uIGJ5dGVzUGVyRWxlbWVudCh0KXtpZihcImZsb2F0MzJcIj09PXR8fFwiaW50MzJcIj09PXQpcmV0dXJuIDQ7aWYoXCJjb21wbGV4NjRcIj09PXQpcmV0dXJuIDg7aWYoXCJib29sXCI9PT10KXJldHVybiAxO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrdCl9ZnVuY3Rpb24gaXNGdW5jdGlvbih0KXtyZXR1cm4hISh0JiZ0LmNvbnN0cnVjdG9yJiZ0LmNhbGwmJnQuYXBwbHkpfWZ1bmN0aW9uIG5lYXJlc3REaXZpc29yKGEsZSl7Zm9yKHZhciB0PWU7dDxhOysrdClpZigwPT1hJXQpcmV0dXJuIHQ7cmV0dXJuIGF9ZnVuY3Rpb24gY29tcHV0ZVN0cmlkZXMoYSl7dmFyIGU9YS5sZW5ndGg7aWYoMj5lKXJldHVybltdO3ZhciB0PUFycmF5KGUtMSk7dFtlLTJdPWFbZS0xXTtmb3IodmFyIHI9ZS0zOzA8PXI7LS1yKXRbcl09dFtyKzFdKmFbcisxXTtyZXR1cm4gdH1mdW5jdGlvbiB0b1R5cGVkQXJyYXkoYSxuLHQpe3JldHVybiBub0NvbnZlcnNpb25OZWVkZWQoYSxuKT9hOihBcnJheS5pc0FycmF5KGEpJiYoYT1mbGF0dGVuKGEpKSxjb3B5VHlwZWRBcnJheShhLG4sdCkpfWZ1bmN0aW9uIG5vQ29udmVyc2lvbk5lZWRlZChhLGUpe3JldHVybiBhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5JiZcImZsb2F0MzJcIj09PWV8fGEgaW5zdGFuY2VvZiBJbnQzMkFycmF5JiZcImludDMyXCI9PT1lfHxhIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJib29sXCI9PT1lfWZ1bmN0aW9uIG1ha2VPbmVzVHlwZWRBcnJheShhLGUpe2Zvcih2YXIgdD1tYWtlWmVyb3NUeXBlZEFycmF5KGEsZSkscj0wO3I8dC5sZW5ndGg7cisrKXRbcl09MTtyZXR1cm4gdH1mdW5jdGlvbiBtYWtlWmVyb3NUeXBlZEFycmF5KGEsZSl7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhKTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheShhKTtpZihcImJvb2xcIj09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KGEpO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfWZ1bmN0aW9uIG5vdygpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwZXJmb3JtYW5jZSlyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3Mpe3ZhciB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyp0WzBdK3RbMV0vMWU2fXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZWFzdXJlIHRpbWUgaW4gdGhpcyBlbnZpcm9ubWVudC4gWW91IHNob3VsZCBydW4gdGYuanMgaW4gdGhlIGJyb3dzZXIgb3IgaW4gTm9kZS5qc1wiKX1mdW5jdGlvbiB0ZW5zb3JUb1N0cmluZyhwLGUsdCxyKXt2YXIgbj1jb21wdXRlU3RyaWRlcyhlKSxvPWNvbXB1dGVNYXhTaXplUGVyQ29sdW1uKHAsZSx0LG4pLGE9ZS5sZW5ndGgsaT1zdWJUZW5zb3JUb1N0cmluZyhwLGUsdCxuLG8pLHM9W1wiVGVuc29yXCJdO3JldHVybiByJiYocy5wdXNoKFwiICBkdHlwZTogXCIrdCkscy5wdXNoKFwiICByYW5rOiBcIithKSxzLnB1c2goXCIgIHNoYXBlOiBbXCIrZStcIl1cIikscy5wdXNoKFwiICB2YWx1ZXM6XCIpKSxzLnB1c2goaS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCIgICAgXCIrdH0pLmpvaW4oXCJcXG5cIikpLHMuam9pbihcIlxcblwiKX1mdW5jdGlvbiBjb21wdXRlTWF4U2l6ZVBlckNvbHVtbihkLGUsdCxyKXt2YXIgbj1zaXplRnJvbVNoYXBlKGUpLG89cltyLmxlbmd0aC0xXSxhPUFycmF5KG8pLmZpbGwoMCksaT1lLmxlbmd0aCxzPVwiY29tcGxleDY0XCI9PT10P2NyZWF0ZUNvbXBsZXhUdXBsZXMoZCk6ZDtpZigxPGkpZm9yKHZhciB1PTA7dTxuL287dSsrKWZvcih2YXIgbT11Km8sYz0wO2M8bztjKyspYVtjXT1fTWF0aG1heChhW2NdLHZhbFRvU3RyaW5nKHNbbStjXSwwKS5sZW5ndGgpO3JldHVybiBhfWZ1bmN0aW9uIHZhbFRvU3RyaW5nKGEsZSl7cmV0dXJuIHJpZ2h0UGFkKEFycmF5LmlzQXJyYXkoYSk/cGFyc2VGbG9hdChhWzBdLnRvRml4ZWQoNykpK1wiICsgXCIrcGFyc2VGbG9hdChhWzFdLnRvRml4ZWQoNykpK1wialwiOnBhcnNlRmxvYXQoYS50b0ZpeGVkKDcpKS50b1N0cmluZygpLGUpfWZ1bmN0aW9uIHN1YlRlbnNvclRvU3RyaW5nKGwsZSx0LHIsbixvKXt2b2lkIDA9PT1vJiYobz0hMCk7dmFyIGI9XCJjb21wbGV4NjRcIj09PXQ/MjoxLGk9ZVswXSxzPWUubGVuZ3RoO2lmKDA9PT1zKXJldHVyblwiY29tcGxleDY0XCI9PT10P1t2YWxUb1N0cmluZyhjcmVhdGVDb21wbGV4VHVwbGVzKGwpWzBdLDApXTpbbFswXS50b1N0cmluZygpXTtpZigxPT09cyl7aWYoMjA8aSl7dmFyIHU9QXJyYXkuZnJvbShsLnN1YmFycmF5KDAsMypiKSksTj1BcnJheS5mcm9tKGwuc3ViYXJyYXkoaS0zKmIsaSkpO3JldHVyblwiY29tcGxleDY0XCI9PT10JiYodT1jcmVhdGVDb21wbGV4VHVwbGVzKHUpLE49Y3JlYXRlQ29tcGxleFR1cGxlcyhOKSksW1wiW1wiK3UubWFwKGZ1bmN0aW9uKGEsZSl7cmV0dXJuIHZhbFRvU3RyaW5nKGEsbltlXSl9KS5qb2luKFwiLCBcIikrXCIsIC4uLiwgXCIrTi5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm4gdmFsVG9TdHJpbmcoYSxuW2ktMytlXSl9KS5qb2luKFwiLCBcIikrXCJdXCJdfXJldHVybltcIltcIisoXCJjb21wbGV4NjRcIj09PXQ/Y3JlYXRlQ29tcGxleFR1cGxlcyhsKTpBcnJheS5mcm9tKGwpKS5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm4gdmFsVG9TdHJpbmcoYSxuW2VdKX0pLmpvaW4oXCIsIFwiKStcIl1cIl19dmFyIEk9ZS5zbGljZSgxKSxkPXIuc2xpY2UoMSksaD1yWzBdKmIsZj1bXTtpZihpPjIwKXtmb3IodmFyIG09MCxTO208MzttKyspUz0oQz1tKmgpK2gsZi5wdXNoLmFwcGx5KGYsc3ViVGVuc29yVG9TdHJpbmcobC5zdWJhcnJheShDLFMpLEksdCxkLG4sITEpKTtmb3IoZi5wdXNoKFwiLi4uXCIpLG09aS0zO208aTttKyspUz0oQz1tKmgpK2gsZi5wdXNoLmFwcGx5KGYsc3ViVGVuc29yVG9TdHJpbmcobC5zdWJhcnJheShDLFMpLEksdCxkLG4sbT09aS0xKSl9ZWxzZSBmb3IobT0wO208aTttKyspe3ZhciBDO1M9KEM9bSpoKStoLGYucHVzaC5hcHBseShmLHN1YlRlbnNvclRvU3RyaW5nKGwuc3ViYXJyYXkoQyxTKSxJLHQsZCxuLG09PWktMSkpfXZhciBrPTI9PT1zP1wiLFwiOlwiXCI7Zm9yKGZbMF09XCJbXCIrZlswXStrLG09MTttPGYubGVuZ3RoLTE7bSsrKWZbbV09XCIgXCIrZlttXStrO3ZhciB4PVwiLFxcblwiO2ZvcihtPTI7bTxzO20rKyl4Kz1cIlxcblwiO3JldHVybiBmW2YubGVuZ3RoLTFdPVwiIFwiK2ZbZi5sZW5ndGgtMV0rXCJdXCIrKG8/XCJcIjp4KSxmfWZ1bmN0aW9uIGNyZWF0ZUNvbXBsZXhUdXBsZXMoYSl7Zm9yKHZhciBlPVtdLHQ9MDt0PGEubGVuZ3RoO3QrPTIpZS5wdXNoKFthW3RdLGFbdCsxXV0pO3JldHVybiBlfWZ1bmN0aW9uIHNldFRlbnNvclRyYWNrZXIodCl7dHJhY2tlckZuPXR9ZnVuY3Rpb24gc2V0T3BIYW5kbGVyKHQpe29wSGFuZGxlcj10fWZ1bmN0aW9uIGdldEZpbHRlcmVkTm9kZXNYVG9ZKHksZSx0KXtmb3IodmFyIHI9e30sbj17fSxvPTA7bzxlLmxlbmd0aDtvKyspcltlW29dLmlkXT0hMDtmb3Iobz0wO288eS5sZW5ndGg7bysrKXt2YXIgYj0oaD15W29dKS5pbnB1dHM7Zm9yKHZhciB4IGluIGIpe2Zvcih2YXIgTj1iW3hdLHU9ITEsST0wO0k8ZS5sZW5ndGg7SSsrKWlmKHJbTi5pZF0pe2gub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiByW3QuaWRdPSEwfSksdT0hMCxuW2guaWRdPSEwO2JyZWFrfWlmKHUpYnJlYWt9fXZhciBTPXt9O1NbdC5pZF09ITA7dmFyIHA9e307Zm9yKG89eS5sZW5ndGgtMTswPD1vO28tLSlmb3IoYj0oaD15W29dKS5pbnB1dHMsST0wO0k8aC5vdXRwdXRzLmxlbmd0aDtJKyspaWYoU1toLm91dHB1dHNbSV0uaWRdKXtmb3IodmFyIHggaW4gYilTW2JbeF0uaWRdPSEwLHBbaC5pZF09ITA7YnJlYWt9dmFyIGQ9W107Zm9yKG89MDtvPHkubGVuZ3RoO28rKyl7dmFyIGg7aWYoblsoaD15W29dKS5pZF0mJnBbaC5pZF0pe3ZhciBDPXt9O2Zvcih2YXIgeCBpbiBoLmlucHV0cyl7dmFyIG09aC5pbnB1dHNbeF07clttLmlkXSYmKENbeF09bSl9dmFyIGc9T2JqZWN0LmFzc2lnbih7fSxoKTtnLmlucHV0cz1DLGcub3V0cHV0cz1oLm91dHB1dHMsZC5wdXNoKGcpfX1yZXR1cm4gZH1mdW5jdGlvbiBiYWNrcHJvcGFnYXRlR3JhZGllbnRzKHAsZSl7Zm9yKHZhciB0PWZ1bmN0aW9uKHQpe3ZhciByPWVbdF0sZD1bXTtpZihyLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1wW2UuaWRdO2lmKG51bGwhPXQpZC5wdXNoKHQpO2Vsc2V7dmFyIGE9VGVuc29yLm1ha2UoZS5zaGFwZSx7dmFsdWVzOm1ha2VaZXJvc1R5cGVkQXJyYXkoZS5zaXplLGUuZHR5cGUpfSxlLmR0eXBlKTtkLnB1c2goYSl9fSksbnVsbD09ci5ncmFkaWVudCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudDogZ3JhZGllbnQgZnVuY3Rpb24gbm90IGZvdW5kIGZvciBcIityLm5hbWUrXCIuXCIpO3ZhciBuPXIuZ3JhZGllbnQoMT09PXIub3V0cHV0cy5sZW5ndGg/ZFswXTpkKTtmb3IodmFyIGEgaW4gci5pbnB1dHMpe2lmKCEoYSBpbiBuKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYmFja3Byb3AgdGhyb3VnaCBpbnB1dCBcIithK1wiLiBBdmFpbGFibGUgZ3JhZGllbnRzIGZvdW5kOiBcIitPYmplY3Qua2V5cyhuKStcIi5cIik7dmFyIG89blthXSgpLHM9ci5pbnB1dHNbYV07aWYoIWFycmF5c0VxdWFsKG8uc2hhcGUscy5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wIFwiK3IubmFtZStcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0ICdcIithK1wiJyBoYXMgc2hhcGUgJ1wiK28uc2hhcGUrXCInLCB3aGljaCBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIGlucHV0ICdcIitzLnNoYXBlK1wiJ1wiKTtpZihudWxsPT1wW3MuaWRdKXBbcy5pZF09bztlbHNle3ZhciBpPXBbcy5pZF07cFtzLmlkXT1pLmFkZChvKSxpLmRpc3Bvc2UoKX19fSxhPWUubGVuZ3RoLTE7MDw9YTthLS0pdChhKX1mdW5jdGlvbiBhc3NlcnRUeXBlc01hdGNoKGEsZSl7YXNzZXJ0KGEuZHR5cGU9PT1lLmR0eXBlLFwiVGhlIGR0eXBlcyBvZiB0aGUgZmlyc3QoXCIrYS5kdHlwZStcIikgYW5kIHNlY29uZChcIitlLmR0eXBlK1wiKSBpbnB1dCBtdXN0IG1hdGNoXCIpfWZ1bmN0aW9uIGlzVGVuc29ySW5MaXN0KGEsZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0KyspaWYoZVt0XS5pZD09PWEuaWQpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZ2V0VGVuc29yc0luQ29udGFpbmVyKGEpe3ZhciBlPVtdO3JldHVybiB3YWxrVGVuc29yQ29udGFpbmVyKGEsZSxuZXcgU2V0KSxlfWZ1bmN0aW9uIHdhbGtUZW5zb3JDb250YWluZXIocyxlLHQpe2lmKG51bGwhPXMpaWYocyBpbnN0YW5jZW9mIFRlbnNvcillLnB1c2gocyk7ZWxzZSBpZihpc0l0ZXJhYmxlKHMpKXt2YXIgcj1zO2Zvcih2YXIgbiBpbiByKXt2YXIgbz1yW25dO3QuaGFzKG8pfHwodC5hZGQobyksd2Fsa1RlbnNvckNvbnRhaW5lcihvLGUsdCkpfX19ZnVuY3Rpb24gaXNJdGVyYWJsZSh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KXx8XCJvYmplY3RcIj09dHlwZW9mIHR9ZnVuY3Rpb24gb25lcyhhKXt2YXIgZT1tYWtlT25lc1R5cGVkQXJyYXkoc2l6ZUZyb21TaGFwZShhKSxcImZsb2F0MzJcIik7cmV0dXJuIFRlbnNvci5tYWtlKGEse3ZhbHVlczplfSl9ZnVuY3Rpb24gaXNXZWJHTFZlcnNpb25FbmFibGVkKHQpe3RyeXtpZihudWxsIT1nZXRXZWJHTENvbnRleHQodCkpcmV0dXJuITB9Y2F0Y2godCl7cmV0dXJuITF9cmV0dXJuITF9ZnVuY3Rpb24gZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZShhKXtpZihudWxsPT1NQVhfVEVYVFVSRV9TSVpFKXt2YXIgZT1nZXRXZWJHTENvbnRleHQoYSk7TUFYX1RFWFRVUkVfU0laRT1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX1NJWkUpfXJldHVybiBNQVhfVEVYVFVSRV9TSVpFfWZ1bmN0aW9uIGdldFdlYkdMRGlzam9pbnRRdWVyeVRpbWVyVmVyc2lvbihhKXtpZigwPT09YSlyZXR1cm4gMDt2YXIgZT1nZXRXZWJHTENvbnRleHQoYSk7cmV0dXJuIGhhc0V4dGVuc2lvbihlLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSYmMj09PWE/MjpoYXNFeHRlbnNpb24oZSxcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKT8xOjB9ZnVuY3Rpb24gaXNSZW5kZXJUb0Zsb2F0VGV4dHVyZUVuYWJsZWQoYSl7aWYoMD09PWEpcmV0dXJuITE7dmFyIGU9Z2V0V2ViR0xDb250ZXh0KGEpO2lmKDE9PT1hKXtpZighaGFzRXh0ZW5zaW9uKGUsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSlyZXR1cm4hMTt9ZWxzZSBpZighaGFzRXh0ZW5zaW9uKGUsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExO3JldHVybiBjcmVhdGVGbG9hdFRleHR1cmVBbmRCaW5kVG9GcmFtZWJ1ZmZlcihlLGEpfWZ1bmN0aW9uIGlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkKGEpe2lmKDA9PT1hKXJldHVybiExO3ZhciBlPWdldFdlYkdMQ29udGV4dChhKTtpZigxPT09YSl7aWYoIWhhc0V4dGVuc2lvbihlLFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITE7aWYoIWhhc0V4dGVuc2lvbihlLFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExfWVsc2UgaWYoIWhhc0V4dGVuc2lvbihlLFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMTtyZXR1cm4gY3JlYXRlRmxvYXRUZXh0dXJlQW5kQmluZFRvRnJhbWVidWZmZXIoZSxhKX1mdW5jdGlvbiBpc1dlYkdMRmVuY2VFbmFibGVkKHQpe3JldHVybiAyPT09dCYmbnVsbCE9Z2V0V2ViR0xDb250ZXh0KHQpLmZlbmNlU3luY31mdW5jdGlvbiBpc0Nocm9tZSgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvciYmbnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmL0dvb2dsZSBJbmMvLnRlc3QobmF2aWdhdG9yLnZlbmRvcil9ZnVuY3Rpb24gZ2V0RmVhdHVyZXNGcm9tVVJMKCl7dmFyIGE9e307aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvd3x8dm9pZCAwPT09d2luZG93LmxvY2F0aW9ufHx2b2lkIDA9PT13aW5kb3cubG9jYXRpb24uc2VhcmNoKXJldHVybiBhO3ZhciBlPWdldFF1ZXJ5UGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO2lmKFwidGZqc2ZsYWdzXCJpbiBlKXt2YXIgcz17fTtlLnRmanNmbGFncy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgZT1hLnNwbGl0KFwiOlwiKSx0PWVbMF0sbj1lWzFdO3NbdF09bn0pLFVSTF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5uYW1lIGluIHMmJihjb25zb2xlLmxvZyhcIlNldHRpbmcgZmVhdHVyZSBvdmVycmlkZSBmcm9tIFVSTCBcIitlLm5hbWUrXCI6IFwiK3NbZS5uYW1lXSksZS50eXBlPT09VHlwZS5OVU1CRVI/YVtlLm5hbWVdPStzW2UubmFtZV06ZS50eXBlPT09VHlwZS5CT09MRUFOP2FbZS5uYW1lXT1cInRydWVcIj09PXNbZS5uYW1lXTplLnR5cGU9PT1UeXBlLlNUUklORz9hW2UubmFtZV09c1tlLm5hbWVdOmNvbnNvbGUud2FybihcIlVua25vd24gVVJMIHBhcmFtOiBcIitlLm5hbWUrXCIuXCIpKX0pfXJldHVybiBhfWZ1bmN0aW9uIGhhc0V4dGVuc2lvbihhLGUpe3JldHVybiBudWxsIT1hLmdldEV4dGVuc2lvbihlKX1mdW5jdGlvbiBjcmVhdGVGbG9hdFRleHR1cmVBbmRCaW5kVG9GcmFtZWJ1ZmZlcihzLGUpe3ZhciB0PXMuY3JlYXRlRnJhbWVidWZmZXIoKSxyPXMuY3JlYXRlVGV4dHVyZSgpO3MuYmluZFRleHR1cmUocy5URVhUVVJFXzJELHIpO3ZhciBuPTI9PT1lP3MuUkdCQTMyRjpzLlJHQkE7cy50ZXhJbWFnZTJEKHMuVEVYVFVSRV8yRCwwLG4sMSwxLDAscy5SR0JBLHMuRkxPQVQsbnVsbCkscy5iaW5kRnJhbWVidWZmZXIocy5GUkFNRUJVRkZFUix0KSxzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHMuRlJBTUVCVUZGRVIscy5DT0xPUl9BVFRBQ0hNRU5UMCxzLlRFWFRVUkVfMkQsciwwKTt2YXIgbz1zLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMocy5GUkFNRUJVRkZFUik9PT1zLkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiBzLmJpbmRUZXh0dXJlKHMuVEVYVFVSRV8yRCxudWxsKSxzLmJpbmRGcmFtZWJ1ZmZlcihzLkZSQU1FQlVGRkVSLG51bGwpLHMuZGVsZXRlVGV4dHVyZShyKSxzLmRlbGV0ZUZyYW1lYnVmZmVyKHQpLG99ZnVuY3Rpb24gZ2V0UXVlcnlQYXJhbXMoYSl7dmFyIGU9e307cmV0dXJuIGEucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZyxmdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxhPTE7YTxhcmd1bWVudHMubGVuZ3RoO2ErKyl0W2EtMV09YXJndW1lbnRzW2FdO3JldHVybiBkZWNvZGVQYXJhbShlLHRbMF0sdFsxXSksdC5qb2luKFwiPVwiKX0pLGV9ZnVuY3Rpb24gZGVjb2RlUGFyYW0oYSxlLHQpe2FbZGVjb2RlVVJJQ29tcG9uZW50KGUpXT1kZWNvZGVVUklDb21wb25lbnQodHx8XCJcIil9ZnVuY3Rpb24gZ2V0R2xvYmFsTmFtZXNwYWNlKCl7dmFyIHQ7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl0PXdpbmRvdztlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBwcm9jZXNzKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdFwiKTt0PXByb2Nlc3N9cmV0dXJuIHR9ZnVuY3Rpb24gZ2V0T3JNYWtlRW52aXJvbm1lbnQoKXt2YXIgdD1nZXRHbG9iYWxOYW1lc3BhY2UoKTtyZXR1cm4gbnVsbD09dC5FTlYmJih0LkVOVj1uZXcgRW52aXJvbm1lbnQoZ2V0RmVhdHVyZXNGcm9tVVJMKCkpLHNldFRlbnNvclRyYWNrZXIoZnVuY3Rpb24oKXtyZXR1cm4gdC5FTlYuZW5naW5lfSkpLHQuRU5WfWZ1bmN0aW9uIHZhcmlhYmxlR3JhZHMocCxlKXtpZihhc3NlcnQoaXNGdW5jdGlvbihwKSxcIlRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwiKSxhc3NlcnQobnVsbD09ZXx8QXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFZhcmlhYmxlfSksXCJUaGUgdmFyTGlzdCBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmLCB2YXJMaXN0KSBtdXN0IGJlIGFuIGFycmF5IG9mIHZhcmlhYmxlc1wiKSxudWxsPT1lKWZvcih2YXIgbCBpbiBlPVtdLEVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlcyllLnB1c2goRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW2xdKTt2YXIgcj1lLmxlbmd0aDthc3NlcnQoMDwoZT1lLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFpbmFibGV9KSkubGVuZ3RoLFwidmFyaWFibGVHcmFkcygpIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG9mIHRoZSBpbnB1dCB2YXJpYWJsZXMgdG8gYmUgdHJhaW5hYmxlLCBidXQgbm9uZSBvZiB0aGUgXCIrcitcIiB2YXJpYWJsZXMgaXMgdHJhaW5hYmxlLlwiKTt2YXIgbj1FTlYuZW5naW5lLmdyYWRpZW50cyhwLGUsbnVsbCwhMCksbz1uLnZhbHVlLGE9bi5ncmFkczthc3NlcnQoYS5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSksXCJDYW5ub3QgZmluZCBhIGNvbm5lY3Rpb24gYmV0d2VlbiBhbnkgdmFyaWFibGUgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGxvc3MgZnVuY3Rpb24geT1mKHgpLiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBvcGVyYXRpb25zIHRoYXQgdXNlIHZhcmlhYmxlcyBhcmUgaW5zaWRlIHRoZSBmdW5jdGlvbiBmIHBhc3NlZCB0byBtaW5pbWl6ZSgpLlwiKSxhc3NlcnQoMD09PW8ucmFuayxcIlRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgcmV0dXJuIGEgc2NhbGFyLCBidXQgaXQgcmV0dXJuZWQgYSByYW5rLVwiK28ucmFuaytcIiB0ZW5zb3JcIik7dmFyIGk9e307cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihuLGUpe251bGwhPWFbZV0mJihpW24ubmFtZV09YVtlXSl9KSx7dmFsdWU6byxncmFkczppfX1mdW5jdGlvbiBjdXN0b21HcmFkKHQpe3JldHVybiBFTlYuZW5naW5lLmN1c3RvbUdyYWQodCl9ZnVuY3Rpb24gd2Fybigpe2Zvcih2YXIgYT1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKylhW2VdPWFyZ3VtZW50c1tlXTtFTlYuZ2V0KFwiSVNfVEVTVFwiKXx8Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsYSl9ZnVuY3Rpb24gZ2V0UmVzaGFwZWQocyxlLHQscil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBwPVtdO2lmKHIpKHA9cC5jb25jYXQoZS5zbGljZSgwKSkpLnB1c2goc1swXS90KSxwPXAuY29uY2F0KHMuc2xpY2UoMSkpO2Vsc2V7cD1wLmNvbmNhdChzWzBdKTtmb3IodmFyIGw9ZS5sZW5ndGgsYT0wO2E8bDsrK2EpcD1wLmNvbmNhdChbc1thKzFdL2VbYV0sZVthXV0pO3A9cC5jb25jYXQocy5zbGljZShsKzEpKX1yZXR1cm4gcH1mdW5jdGlvbiBnZXRQZXJtdXRlZChzLGUsdCl7dm9pZCAwPT09dCYmKHQ9ITApO3ZhciBwPVtdO2lmKHQpe3AucHVzaChlKTtmb3IodmFyIG49ZSsxO248czsrK24pbjw9MiplPyhwLnB1c2gobikscC5wdXNoKG4tKGUrMSkpKTpwLnB1c2gobil9ZWxzZXt2YXIgbD1bXSxhPVtdO2ZvcihuPTE7bjxzOysrbiluPj0yKmUrMXx8MT09biUyP2EucHVzaChuKTpsLnB1c2gobik7cC5wdXNoLmFwcGx5KHAsbCkscC5wdXNoKDApLHAucHVzaC5hcHBseShwLGEpfXJldHVybiBwfWZ1bmN0aW9uIGdldFJlc2hhcGVkUGVybXV0ZWQocyxlLHQscil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBpPVtdO3I/aS5wdXNoKHNbMF0vdCk6aS5wdXNoKHNbMF0qdCk7Zm9yKHZhciBvPTE7bzxzLmxlbmd0aDsrK28pbzw9ZS5sZW5ndGg/cj9pLnB1c2goZVtvLTFdKnNbb10pOmkucHVzaChzW29dL2Vbby0xXSk6aS5wdXNoKHNbb10pO3JldHVybiBpfWZ1bmN0aW9uIGdldFNsaWNlQmVnaW5Db29yZHMoYSxlKXtmb3IodmFyIHQ9WzBdLHI9MDtyPGU7KytyKXQucHVzaChhW3JdWzBdKTtyZXR1cm4gdH1mdW5jdGlvbiBnZXRTbGljZVNpemUoYSxlLHQpe2Zvcih2YXIgcj1hLnNsaWNlKDAsMSksbj0wO248dDsrK24pci5wdXNoKGFbbisxXS1lW25dWzBdLWVbbl1bMV0pO3JldHVybiByfWZ1bmN0aW9uIGF4ZXNBcmVJbm5lck1vc3REaW1zKGEsZSl7Zm9yKHZhciB0PTA7dDxhLmxlbmd0aDsrK3QpaWYoYVthLmxlbmd0aC10LTFdIT09ZS0xLXQpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gY29tYmluZUxvY2F0aW9ucyhwLGUsdCl7Zm9yKHZhciByPXAubGVuZ3RoK2UubGVuZ3RoLG49W10sbz0wLGw9MCxkPTA7ZDxyO2QrKyktMT09PXQuaW5kZXhPZihkKT9uLnB1c2gocFtvKytdKTpuLnB1c2goZVtsKytdKTtyZXR1cm4gbn1mdW5jdGlvbiBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGEsZSl7Zm9yKHZhciB0PVtdLHI9YS5sZW5ndGgsbj0wO248cjtuKyspLTE9PT1lLmluZGV4T2YobikmJnQucHVzaChhW25dKTtyZXR1cm5bdCxlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gYVtlXX0pXX1mdW5jdGlvbiBleHBhbmRTaGFwZVRvS2VlcERpbShhLGUpe3JldHVybiBjb21iaW5lTG9jYXRpb25zKGEsZS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gMX0pLGUpfWZ1bmN0aW9uIHBhcnNlQXhpc1BhcmFtKGEsbil7dmFyIHQ9bi5sZW5ndGg7cmV0dXJuIGFzc2VydCgoYT1udWxsPT1hP24ubWFwKGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGV9KTpbXS5jb25jYXQoYSkpLmV2ZXJ5KGZ1bmN0aW9uKGEpe3JldHVybiBhPj0tdCYmYTx0fSksXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLVwiK3QrXCIsIFwiK3QrXCIpIGJ1dCBnb3QgYXhpcyBcIithKSxhc3NlcnQoYS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gaXNJbnQodCl9KSxcIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBnb3QgYXhpcyBcIithKSxhLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gMD5hP3QrYTphfSl9ZnVuY3Rpb24gYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoYSxlLHQpe2Fzc2VydChheGVzQXJlSW5uZXJNb3N0RGltcyhlLHQpLGErXCIgc3VwcG9ydHMgb25seSBpbm5lci1tb3N0IGF4ZXMgZm9yIG5vdy4gR290IGF4ZXMgXCIrZStcIiBhbmQgcmFuay1cIit0K1wiIGlucHV0LlwiKX1mdW5jdGlvbiBnZXRBeGVzUGVybXV0YXRpb24oYSxlKXtpZihheGVzQXJlSW5uZXJNb3N0RGltcyhhLGUpKXJldHVybiBudWxsO2Zvcih2YXIgdD1bXSxyPTA7cjxlOysrciktMT09PWEuaW5kZXhPZihyKSYmdC5wdXNoKHIpO3JldHVybiBhLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIHQucHVzaChhKX0pLHR9ZnVuY3Rpb24gZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm5bZSxhXX0pLnNvcnQoZnVuY3Rpb24oYSxlKXtyZXR1cm4gYVsxXS1lWzFdfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSl9ZnVuY3Rpb24gZ2V0SW5uZXJNb3N0QXhlcyhhLGUpe2Zvcih2YXIgdD1bXSxyPWUtYTtyPGU7KytyKXQucHVzaChyKTtyZXR1cm4gdH1mdW5jdGlvbiBhc3NlcnRQYXJhbXNDb25zaXN0ZW50KGEscyl7dmFyIGk9YVswXS5sZW5ndGg7YS5mb3JFYWNoKGZ1bmN0aW9uKGEsZSl7YXNzZXJ0KGEubGVuZ3RoPT09aSxcIkVycm9yIGluIGNvbmNhdFwiK2krXCJEOiByYW5rIG9mIHRlbnNvcnNbXCIrZStcIl0gbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgcmFuayBvZiB0aGUgcmVzdCAoXCIraStcIilcIil9KSxhc3NlcnQoMDw9cyYmczxpLFwiRXJyb3IgaW4gY29uY2F0XCIraStcIkQ6IGF4aXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiKyhpLTEpK1wiLlwiKTt2YXIgdD1hWzBdO2EuZm9yRWFjaChmdW5jdGlvbihuLGUpe2Zvcih2YXIgcj0wO3I8aTtyKyspYXNzZXJ0KHI9PT1zfHxuW3JdPT09dFtyXSxcIkVycm9yIGluIGNvbmNhdFwiK2krXCJEOiBTaGFwZSBvZiB0ZW5zb3JzW1wiK2UrXCJdIChcIituK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIHJlc3QgKFwiK3QrXCIpIGFsb25nIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4aXMgXCIrZStcIi5cIil9KX1mdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUoYSxlKXtmb3IodmFyIHQ9YVswXS5zbGljZSgpLHI9MTtyPGEubGVuZ3RoO3IrKyl0W2VdKz1hW3JdW2VdO3JldHVybiB0fWZ1bmN0aW9uIHByZXBhcmVBbmRWYWxpZGF0ZShwLGUpe2lmKDE+cC5yYW5rKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIitwLnJhbmsrXCIuXCIpO2lmKDE+ZS5yYW5rKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK2UucmFuaytcIi5cIik7aWYoXCJpbnQzMlwiIT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgaW50MzIgdHlwZSwgYnV0IHRoZSBkdHlwZSB3YXMgXCIrZS5kdHlwZStcIi5cIik7aWYoZS5zaGFwZVtlLnJhbmstMV0+cC5yYW5rKXRocm93IG5ldyBFcnJvcihcImluZGV4IGlubmVybW9zdCBkaW1lbnNpb24gbGVuZ3RoIG11c3QgYmUgPD0gdGVuc29yIHJhbms7IHNhdzogXCIrZS5zaGFwZVtlLnJhbmstMV0rXCIgdnMuIFwiK3AucmFuayk7aWYoMD09PXAuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgbW9yZSB0aGFuIDAgZW50cmllcywgYnV0IGlucHV0IGlzIGVtcHR5LiBJbnB1dCBzaGFwZTogXCIrcC5zaGFwZStcIi5cIik7Zm9yKHZhciB0PWUuc2hhcGUscj10W3QubGVuZ3RoLTFdLG49MSxkPTA7ZDx0Lmxlbmd0aC0xOysrZCluKj10W2RdO3ZhciBjPXAuc2hhcGUsaT10LnNsaWNlKCk7aS5wb3AoKTt2YXIgcz0xO2ZvcihkPXI7ZDxwLnJhbms7KytkKXMqPWNbZF0saS5wdXNoKGNbZF0pO3ZhciBtPWNvbXB1dGVTdHJpZGVzKHAuc2hhcGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC9zfSkuY29uY2F0KFsxXSkuc2xpY2UoMCxyKTtyZXR1cm5baSxuLHMsbV19ZnVuY3Rpb24gY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKHQpe3JldHVybiB0PD0zMD90Om5lYXJlc3REaXZpc29yKHQsX01hdGhmbG9vcihfTWF0aHNxcnQodCkpKX1mdW5jdGlvbiB2YWxpZGF0ZVVwZGF0ZVNoYXBlKHMsZSx0KXt2YXIgcj0xPGUucmFuaz9lLnNoYXBlW2UucmFuay0xXToxLG49MTxlLnJhbms/ZS5yYW5rLTE6MSxvPVwiTXVzdCBoYXZlIHVwZGF0ZXMuc2hhcGUgPSBpbmRpY2VzLnNoYXBlWzpiYXRjaERpbV0gKyBzaGFwZVtzbGljZURpbTpdLCBnb3QgdXBkYXRlcy5zaGFwZTogXCIrdC5zaGFwZStcIiwgaW5kaWNlcy5zaGFwZTogXCIrZS5zaGFwZStcIiwgc2hhcGU6IFwiK3MrXCIsIHNsaWNlRGltOiBcIityK1wiLCBhbmQgYmF0Y2hEaW06IFwiK24rXCIuXCI7aWYodC5yYW5rPG4pdGhyb3cgbmV3IEVycm9yKG8rXCIgdXBkYXRlLnJhbmsgPCBcIituK1wiLiBcIik7aWYocy5sZW5ndGg8cisodC5yYW5rLW4pKXRocm93IG5ldyBFcnJvcihvK1wiIE91dHB1dCBzaGFwZSBsZW5ndGggPCBcIisocisodC5yYW5rLW4pKSk7aWYodC5yYW5rIT09bitzLmxlbmd0aC1yKXRocm93IG5ldyBFcnJvcihvK1wiIHVwZGF0ZS5yYW5rICE9IFwiKyhuK3MubGVuZ3RoLXIpKTtmb3IodmFyIGE9MDthPG47KythKWlmKHQuc2hhcGVbYV0hPT1lLnNoYXBlW2FdKXRocm93IG5ldyBFcnJvcihvK1wiIHVwZGF0ZXMuc2hhcGVbXCIrYStcIl0gKFwiK3Quc2hhcGVbYV0rXCIpICE9IGluZGljZXMuc2hhcGVbXCIrYStcIl0gKFwiK2Uuc2hhcGVbYV0rXCIpLlwiKTtmb3IoYT0wO2E8dC5yYW5rLW47KythKWlmKHQuc2hhcGVbYStuXSE9PXNbYStyXSl0aHJvdyBuZXcgRXJyb3IobytcIiB1cGRhdGVzLnNoYXBlW1wiKyhhK24pK1wiXSAoXCIrdC5zaGFwZVthK25dK1wiKSAhPSBzaGFwZVtcIisoYStuKStcIl0gKFwiK3NbYStuXStcIilcIil9ZnVuY3Rpb24gdmFsaWRhdGVJbnB1dChhLGUsdCl7aWYoMT5lLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidGYuc2NhdHRlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK2UucmFuaytcIi5cIik7aWYoMT5hLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidGYuc2NhdHRlck5EKCkgZXhwZWN0cyB0aGUgdXBkYXRlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK2EucmFuaytcIi5cIik7aWYoXCJpbnQzMlwiIT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZHR5cGUgb2YgJ2luZGljZXMnIHNob3VsZCBiZSBpbnQzMiwgYnV0IGdvdCBkdHlwZTogXCIrZS5kdHlwZSk7aWYoMT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgcmFuayBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMSwgYnV0IGdvdCBzaGFwZTogXCIrdCk7aWYoMD09PXQubGVuZ3RoKXtpZigwPT09ZS5zaXplKXRocm93IG5ldyBFcnJvcihcIkluZGljZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIGluZGljZXMgc2hhcGU6IFwiK2Uuc2hhcGUpO2lmKDA9PT1hLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRlcyBzcGVjaWZpZWQgZm9yIGVtcHR5IG91dHB1dC4gdXBkYXRlcyBzaGFwZTogXCIrYS5zaGFwZSl9dmFsaWRhdGVVcGRhdGVTaGFwZSh0LGUsYSl9ZnVuY3Rpb24gY2FsY3VsYXRlU2hhcGVzKHAsZSx0KXtmb3IodmFyIHI9MTxlLnJhbms/ZS5zaGFwZVtlLnJhbmstMV06MSxuPXQubGVuZ3RoLG89MSxkPXI7ZDxuOysrZClvKj10W2RdO3ZhciBjPTE+cj8xOnIscz1lLnNpemUvYyx1PWNvbXB1dGVTdHJpZGVzKHQpLmNvbmNhdChbMV0pO3JldHVybntzbGljZVJhbms6cixudW1VcGRhdGVzOnMsc2xpY2VTaXplOm8sc3RyaWRlczp1LnNsaWNlKHUubGVuZ3RoLXIsdS5sZW5ndGgpLG91dHB1dFNpemU6c2l6ZUZyb21TaGFwZSh0KX19ZnVuY3Rpb24gc2VnT3BDb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoYSxlKXt2YXIgdD0hMSxvO2ZvcihhPD0zMD8obz1hLHQ9ITApOm89bmVhcmVzdERpdmlzb3IoYSxfTWF0aGZsb29yKF9NYXRoc3FydChhKSkpOyF0Oyl7aWYobz5lfHxvPT09YSl7dD0hMDticmVha31vPW5lYXJlc3REaXZpc29yKGEsbysxKX1yZXR1cm4gb31mdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUkMShzLGUsdCl7Zm9yKHZhciByPVtdLG49cy5sZW5ndGgsbz0wO288bjtvKyspbz09PWU/ci5wdXNoKHQpOnIucHVzaChzW29dKTtyZXR1cm4gcn1mdW5jdGlvbiBhc3NlcnRQYXJhbXNWYWxpZChhLGUsdCl7YXNzZXJ0KGEucmFuaz09PWUubGVuZ3RoLFwiRXJyb3IgaW4gc2xpY2VcIithLnJhbmsrXCJEOiBMZW5ndGggb2YgYmVnaW4gXCIrZStcIiBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIrYS5yYW5rK1wiKS5cIiksYXNzZXJ0KGEucmFuaz09PXQubGVuZ3RoLFwiRXJyb3IgaW4gc2xpY2VcIithLnJhbmsrXCJEOiBMZW5ndGggb2Ygc2l6ZSBcIit0K1wiIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIithLnJhbmsrXCIpLlwiKTtmb3IodmFyIHI9MDtyPGEucmFuazsrK3IpYXNzZXJ0KGVbcl0rdFtyXTw9YS5zaGFwZVtyXSxcIkVycm9yIGluIHNsaWNlXCIrYS5yYW5rK1wiRDogYmVnaW5bXCIrcitcIl0gKyBzaXplW1wiK3IrXCJdIChcIisoZVtyXSt0W3JdKStcIikgd291bGQgb3ZlcmZsb3cgaW5wdXQuc2hhcGVbXCIrcitcIl0gKFwiK2Euc2hhcGVbcl0rXCIpXCIpfWZ1bmN0aW9uIGdldFN0cmlkZWRTbGljZWRJbmZvKG0sZSx0LHIsbixnLGYseSxiKXtpZih2b2lkIDA9PT1uJiYobj0wKSx2b2lkIDA9PT1nJiYoZz0wKSx2b2lkIDA9PT1mJiYoZj0wKSx2b2lkIDA9PT15JiYoeT0wKSx2b2lkIDA9PT1iJiYoYj0wKSwwIT09Zil0aHJvdyBuZXcgRXJyb3IoXCJlbGxpcHNpcyBtYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDAhPT15KXRocm93IG5ldyBFcnJvcihcIm5ldyBheGlzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7Zm9yKHZhciB4PVtdLGw9W10sYz1bXSxwPTA7cDxtLmxlbmd0aDtwKyspeFtwXT1zdGFydEZvckF4aXMobixlLHIsbSxwKSxsW3BdPXN0b3BGb3JBeGlzKGcsdCxyLG0scCksYiYxPDxwJiYobFtwXT14W3BdKzEsYy5wdXNoKHApKTt2YXIgTj1BcnJheShtLmxlbmd0aCkuZmlsbCgwKTtyZXR1cm4gTj1OLm1hcChmdW5jdGlvbihhLGUpe2Zvcih2YXIgdD0wLG49eFtlXTswPHJbZV0/IShuPj1sW2VdKTohKG48PWxbZV0pO24rPXJbZV0pdCs9MTtyZXR1cm4gdH0pLFt4LE4sY119ZnVuY3Rpb24gc3RhcnRGb3JBeGlzKHMsZSx0LHIsbil7dmFyIG89ZVtuXTtzJjE8PG4mJihvPTA8dFtuXT9fTnVtYmVyTUlOX1NBRkVfSU5URUdFUjpfTnVtYmVyTUFYX1NBRkVfSU5URUdFUik7dmFyIHA9cltuXTtyZXR1cm4gMD5vJiYobys9cCksbz1jbGFtcCgwLG8scC0xKX1mdW5jdGlvbiBzdG9wRm9yQXhpcyhzLGUsdCxyLG4pe3ZhciBvPWVbbl07cyYxPDxuJiYobz0wPHRbbl0/X051bWJlck1BWF9TQUZFX0lOVEVHRVI6X051bWJlck1JTl9TQUZFX0lOVEVHRVIpO3ZhciBwPXJbbl07cmV0dXJuIDA+byYmKG8rPXApLG89MDx0W25dP2NsYW1wKDAsbyxwKTpjbGFtcCgtMSxvLHAtMSl9ZnVuY3Rpb24gaW5mZXJTaGFwZShhKXt2YXIgZT1hO2lmKGlzVHlwZWRBcnJheShhKSlyZXR1cm5bYS5sZW5ndGhdO2lmKCFBcnJheS5pc0FycmF5KGEpKXJldHVybltdO2Zvcih2YXIgbj1bXTtlIGluc3RhbmNlb2YgQXJyYXk7KW4ucHVzaChlLmxlbmd0aCksZT1lWzBdO3JldHVybiBhIGluc3RhbmNlb2YgQXJyYXkmJkVOVi5nZXQoXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIpJiZkZWVwQXNzZXJ0U2hhcGVDb25zaXN0ZW5jeShhLG4sW10pLG59ZnVuY3Rpb24gZGVlcEFzc2VydFNoYXBlQ29uc2lzdGVuY3koYSxlLHQpe2lmKHQ9dHx8W10sYSBpbnN0YW5jZW9mIEFycmF5KXthc3NlcnQoMDxlLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrdC5qb2luKFwiXVtcIikrXCJdIHNob3VsZCBiZSBhIHByaW1pdGl2ZSwgYnV0IGlzIGFuIGFycmF5IG9mIFwiK2EubGVuZ3RoK1wiIGVsZW1lbnRzXCJ9KSxhc3NlcnQoYS5sZW5ndGg9PT1lWzBdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIit0LmpvaW4oXCJdW1wiKStcIl0gc2hvdWxkIGhhdmUgXCIrZVswXStcIiBlbGVtZW50cywgYnV0IGhhcyBcIithLmxlbmd0aCtcIiBlbGVtZW50c1wifSk7Zm9yKHZhciBzPWUuc2xpY2UoMSksbj0wO248YS5sZW5ndGg7KytuKWRlZXBBc3NlcnRTaGFwZUNvbnNpc3RlbmN5KGFbbl0scyx0LmNvbmNhdChuKSl9ZWxzZSBhc3NlcnQoMD09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIit0LmpvaW4oXCJdW1wiKStcIl0gaXMgYSBwcmltaXRpdmUsIGJ1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgXCIrZVswXStcIiBlbGVtZW50c1wifSl9ZnVuY3Rpb24gY29udmVydFRvVGVuc29yKGEscyx0LHIpe2lmKHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSxyPXJ8fFwiZmxvYXQzMlwiLGEgaW5zdGFuY2VvZiBUZW5zb3IpcmV0dXJuIGE7aWYoIWlzVHlwZWRBcnJheShhKSYmIUFycmF5LmlzQXJyYXkoYSkmJlwibnVtYmVyXCIhPXR5cGVvZiBhJiZcImJvb2xlYW5cIiE9dHlwZW9mIGEpdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ1wiK3MrXCInIHBhc3NlZCB0byAnXCIrdCtcIicgbXVzdCBiZSBhIFRlbnNvciBvciBUZW5zb3JMaWtlLCBidXQgZ290IFwiK2EuY29uc3RydWN0b3IubmFtZSk7dmFyIGk9aW5mZXJTaGFwZShhKTtyZXR1cm4gaXNUeXBlZEFycmF5KGEpfHxBcnJheS5pc0FycmF5KGEpfHwoYT1bYV0pLFRlbnNvci5tYWtlKGkse3ZhbHVlczp0b1R5cGVkQXJyYXkoYSxyLEVOVi5nZXQoXCJERUJVR1wiKSl9LHIpfWZ1bmN0aW9uIGNvbnZlcnRUb1RlbnNvckFycmF5KGEsbyx0KXtpZighQXJyYXkuaXNBcnJheShhKSl0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBcIitvK1wiIHBhc3NlZCB0byBcIit0K1wiIG11c3QgYmUgYSBgVGVuc29yW11gIG9yIGBUZW5zb3JMaWtlW11gXCIpO3JldHVybiBhLm1hcChmdW5jdGlvbihhLGUpe3JldHVybiBjb252ZXJ0VG9UZW5zb3IoYSxvK1wiW1wiK2UrXCJdXCIsdCl9KX1mdW5jdGlvbiBvcChhKXt2YXIgZT1PYmplY3Qua2V5cyhhKTtpZigxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5IChvcGVyYXRpb24gbmFtZSkgbWFwcGluZyB0byBhIGZ1bmN0aW9uLiBHb3QgYW4gb2JqZWN0IHdpdGggXCIrZS5sZW5ndGgrXCIga2V5cy5cIik7dmFyIHM9ZVswXSx0PWFbc107cy5lbmRzV2l0aChcIl9cIikmJihzPXMuc3Vic3RyaW5nKDAscy5sZW5ndGgtMSkpO3ZhciBuPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKWFbZV09YXJndW1lbnRzW2VdO0VOVi5lbmdpbmUuc3RhcnRTY29wZShzKTt0cnl7dmFyIG49dC5hcHBseSh2b2lkIDAsYSk7cmV0dXJuIG4gaW5zdGFuY2VvZiBQcm9taXNlJiZjb25zb2xlLmVycm9yKFwiQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuXCIpLEVOVi5lbmdpbmUuZW5kU2NvcGUobiksbn1jYXRjaCh0KXt0aHJvdyBFTlYuZW5naW5lLmVuZFNjb3BlKG51bGwpLHR9fTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJuYW1lXCIse3ZhbHVlOnMsY29uZmlndXJhYmxlOiEwfSksbn1mdW5jdGlvbiBzb2Z0bWF4XyhhLG8pe3ZvaWQgMD09PW8mJihvPS0xKTt2YXIgZT1jb252ZXJ0VG9UZW5zb3IoYSxcImxvZ2l0c1wiLFwic29mdG1heFwiKTtpZigtMT09PW8mJihvPWUucmFuay0xKSxvIT09ZS5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgXCIrZS5yYW5rK1wiIGFuZCBkaW0gd2FzIFwiK28pO3JldHVybiBjdXN0b21HcmFkKGZ1bmN0aW9uKHQpe3ZhciBlPXQubG9nU3VtRXhwKFtvXSwhMCksYT10LnRvRmxvYXQoKS5zdWIoZSkuZXhwKCk7cmV0dXJue3ZhbHVlOmEsZ3JhZEZ1bmM6ZnVuY3Rpb24odCl7dmFyIGU9dC5tdWwoYSk7cmV0dXJuIGUuc3ViKGUuc3VtKFtvXSwhMCkubXVsKGEpKX19fSkoZSl9ZnVuY3Rpb24gbG9nU29mdG1heF8oYSxzKXt2b2lkIDA9PT1zJiYocz0tMSk7dmFyIGU9Y29udmVydFRvVGVuc29yKGEsXCJsb2dpdHNcIixcImxvZ1NvZnRtYXhcIik7aWYoLTE9PT1zJiYocz1lLnJhbmstMSkscyE9PWUucmFuay0xKXRocm93IEVycm9yKFwiTG9nIFNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIitlLnJhbmsrXCIgYW5kIGF4aXMgd2FzIFwiK3MpO3JldHVybiBjdXN0b21HcmFkKGZ1bmN0aW9uKHQpe3ZhciBlPXQubWF4KHMsITApLGE9dC5zdWIoZSksbj1hLnRvRmxvYXQoKS5zdWIoYS5leHAoKS5zdW0ocywhMCkubG9nKCkpO3JldHVybnt2YWx1ZTpuLGdyYWRGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPW4uZXhwKCk7cmV0dXJuIHQuc3ViKHQuc3VtKHMsITApLm11bChlKSl9fX0pKGUpfWZ1bmN0aW9uIGNvbXBsZXhfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJyZWFsXCIsXCJjb21wbGV4XCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJpbWFnXCIsXCJjb21wbGV4XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaCh0LnNoYXBlLHIuc2hhcGUsXCJyZWFsIGFuZCBpbWFnIHNoYXBlcywgXCIrdC5zaGFwZStcIiBhbmQgXCIrci5zaGFwZStcIiwgbXVzdCBtYXRjaCBpbiBjYWxsIHRvIHRmLmNvbXBsZXgoKS5cIiksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuY29tcGxleCh0LHIpfSx7JHJlYWw6dCwkaW1hZzpyfSl9ZnVuY3Rpb24gcmVhbF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJpbnB1dFwiLFwicmVhbFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhbChuKX0seyRpbnB1dDpufSl9ZnVuY3Rpb24gaW1hZ18oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJpbnB1dFwiLFwiaW1hZ1wiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaW1hZyhuKX0seyRpbnB1dDpufSl9ZnVuY3Rpb24gdGVuc29yKGEsbyxzKXtpZih2b2lkIDA9PT1zJiYocz1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PXMpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBhIGNvbXBsZXg2NCB0ZW5zb3IgZGlyZWN0bHkuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7aWYoIWlzVHlwZWRBcnJheShhKSYmIUFycmF5LmlzQXJyYXkoYSkmJlwibnVtYmVyXCIhPXR5cGVvZiBhJiZcImJvb2xlYW5cIiE9dHlwZW9mIGEpdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIHBhc3NlZCB0byB0ZW5zb3IodmFsdWVzKSBtdXN0IGJlIGFuIGFycmF5IG9mIG51bWJlcnMgb3IgYm9vbGVhbnMsIG9yIGEgVHlwZWRBcnJheVwiKTt2YXIgaT1pbmZlclNoYXBlKGEpO3JldHVybiBudWxsIT1vJiYxIT09aS5sZW5ndGgmJmFzc2VydFNoYXBlc01hdGNoKG8saSxcIkVycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvci4gSW5mZXJyZWQgc2hhcGUgKFwiK2krXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSAoXCIrbytcIikuIFwiKSxpc1R5cGVkQXJyYXkoYSl8fEFycmF5LmlzQXJyYXkoYSl8fChhPVthXSksbz1vfHxpLFRlbnNvci5tYWtlKG8se3ZhbHVlczp0b1R5cGVkQXJyYXkoYSxzLEVOVi5nZXQoXCJERUJVR1wiKSl9LHMpfWZ1bmN0aW9uIHNjYWxhcihhLGUpe2lmKHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSwoaXNUeXBlZEFycmF5KGEpfHxBcnJheS5pc0FycmF5KGEpKSYmXCJjb21wbGV4NjRcIiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgYSBuZXcgU2NhbGFyOiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlIChudW1iZXJ8Ym9vbGVhbilcIik7cmV0dXJuIHRlbnNvcihhLFtdLGUpfWZ1bmN0aW9uIHRlbnNvcjFkKGEsZSl7dm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLGFzc2VydE5vbk51bGwoYSk7dmFyIG49aW5mZXJTaGFwZShhKTtpZigxIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIHRlbnNvcihhLG4sZSl9ZnVuY3Rpb24gdGVuc29yMmQoYSxlLG8pe2lmKHZvaWQgMD09PW8mJihvPVwiZmxvYXQzMlwiKSxhc3NlcnROb25OdWxsKGEpLG51bGwhPWUmJjIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdHdvIG51bWJlcnNcIik7dmFyIHM9aW5mZXJTaGFwZShhKTtpZigyIT09cy5sZW5ndGgmJjEhPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09cy5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gdGVuc29yKGEsZT1lfHxzLG8pfWZ1bmN0aW9uIHRlbnNvcjNkKGEsZSxvKXtpZih2b2lkIDA9PT1vJiYobz1cImZsb2F0MzJcIiksYXNzZXJ0Tm9uTnVsbChhKSxudWxsIT1lJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHRocmVlIG51bWJlcnNcIik7dmFyIHM9aW5mZXJTaGFwZShhKTtpZigzIT09cy5sZW5ndGgmJjEhPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1zLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gdGVuc29yKGEsZT1lfHxzLG8pfWZ1bmN0aW9uIHRlbnNvcjRkKGEsZSxvKXtpZih2b2lkIDA9PT1vJiYobz1cImZsb2F0MzJcIiksYXNzZXJ0Tm9uTnVsbChhKSxudWxsIT1lJiY0IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZvdXIgbnVtYmVyc1wiKTt2YXIgcz1pbmZlclNoYXBlKGEpO2lmKDQhPT1zLmxlbmd0aCYmMSE9PXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09cy5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIHRlbnNvcihhLGU9ZXx8cyxvKX1mdW5jdGlvbiB0ZW5zb3I1ZChhLGUsbyl7aWYodm9pZCAwPT09byYmKG89XCJmbG9hdDMyXCIpLGFzc2VydE5vbk51bGwoYSksbnVsbCE9ZSYmNSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmaXZlIG51bWJlcnNcIik7dmFyIHM9aW5mZXJTaGFwZShhKTtpZig1IT09cy5sZW5ndGgmJjEhPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09cy5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIHRlbnNvcihhLGU9ZXx8cyxvKX1mdW5jdGlvbiB0ZW5zb3I2ZChhLGUsbyl7aWYodm9pZCAwPT09byYmKG89XCJmbG9hdDMyXCIpLGFzc2VydE5vbk51bGwoYSksbnVsbCE9ZSYmNiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBzaXggbnVtYmVyc1wiKTt2YXIgcz1pbmZlclNoYXBlKGEpO2lmKDYhPT1zLmxlbmd0aCYmMSE9PXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09cy5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIHRlbnNvcihhLGU9ZXx8cyxvKX1mdW5jdGlvbiBvbmVzJDEoYSxlKXtpZih2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PWUpe3ZhciBzPW9uZXMkMShhLFwiZmxvYXQzMlwiKSxyPW9uZXMkMShhLFwiZmxvYXQzMlwiKTtyZXR1cm4gY29tcGxleChzLHIpfXZhciBuPW1ha2VPbmVzVHlwZWRBcnJheShzaXplRnJvbVNoYXBlKGEpLGUpO3JldHVybiBUZW5zb3IubWFrZShhLHt2YWx1ZXM6bn0sZSl9ZnVuY3Rpb24gemVyb3MoYSxlKXtpZih2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PWUpe3ZhciBzPXplcm9zKGEsXCJmbG9hdDMyXCIpLHI9emVyb3MoYSxcImZsb2F0MzJcIik7cmV0dXJuIGNvbXBsZXgocyxyKX12YXIgbj1tYWtlWmVyb3NUeXBlZEFycmF5KHNpemVGcm9tU2hhcGUoYSksZSk7cmV0dXJuIFRlbnNvci5tYWtlKGEse3ZhbHVlczpufSxlKX1mdW5jdGlvbiBmaWxsKGEsZSx0KXt2b2lkIDA9PT10JiYodD1cImZsb2F0MzJcIik7dmFyIG89Z2V0VHlwZWRBcnJheUZyb21EVHlwZSh0LHNpemVGcm9tU2hhcGUoYSkpO3JldHVybiBvLmZpbGwoZSksVGVuc29yLm1ha2UoYSx7dmFsdWVzOm99LHQpfWZ1bmN0aW9uIG9uZXNMaWtlXyhhKXt2YXIgZT1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcIm9uZXNMaWtlXCIpO3JldHVybiBvbmVzJDEoZS5zaGFwZSxlLmR0eXBlKX1mdW5jdGlvbiB6ZXJvc0xpa2VfKGEpe3ZhciBlPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiemVyb3NMaWtlXCIpO3JldHVybiB6ZXJvcyhlLnNoYXBlLGUuZHR5cGUpfWZ1bmN0aW9uIGxpbnNwYWNlKG4sZSx0KXtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVxdWVzdCB6ZXJvIHNhbXBsZXNcIik7dmFyIHI9bWFrZVplcm9zVHlwZWRBcnJheSh0LFwiZmxvYXQzMlwiKTtyWzBdPW47Zm9yKHZhciBvPTE7bzxyLmxlbmd0aDtvKyspcltvXT1yW28tMV0rKGUtbikvKHQtMSk7cmV0dXJuIHRlbnNvcjFkKHIsXCJmbG9hdDMyXCIpfWZ1bmN0aW9uIHJhbmdlKHMsZSx0LGkpe2lmKHZvaWQgMD09PXQmJih0PTEpLHZvaWQgMD09PWkmJihpPVwiZmxvYXQzMlwiKSwwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBhIHN0ZXAgb2YgemVyb1wiKTtpZihzPT09ZXx8czxlJiYwPnR8fGU8cyYmMTx0KXJldHVybiB6ZXJvcyhbMF0saSk7dmFyIHA9bWFrZVplcm9zVHlwZWRBcnJheShfTWF0aGFicyhfTWF0aGNlaWwoKGUtcykvdCkpLGkpO2U8cyYmMT09PXQmJih0PS0xKSxwWzBdPXM7Zm9yKHZhciBvPTE7bzxwLmxlbmd0aDtvKyspcFtvXT1wW28tMV0rdDtyZXR1cm4gdGVuc29yMWQocCxpKX1mdW5jdGlvbiB1cGNhc3RUeXBlKGEsZSl7cmV0dXJuIHVwY2FzdFR5cGVNYXBbYV1bZV19ZnVuY3Rpb24gc3VtT3V0VHlwZSh0KXtyZXR1cm4gdXBjYXN0VHlwZSh0LFwiaW50MzJcIil9ZnVuY3Rpb24gY2FzdFRlbnNvcihwLGUsdCl7aWYoXCJjb21wbGV4NjRcIj09PWUpe2lmKFwiY29tcGxleDY0XCI9PT1wLmR0eXBlKXJldHVybiBwLmNsb25lKCk7dmFyIHI9emVyb3MocC5zaGFwZSksbj1wLnRvRmxvYXQoKSxvPXQuY29tcGxleChuLHIpO3JldHVybiByLmRpc3Bvc2UoKSxuLmRpc3Bvc2UoKSxvfWlmKCFoYXNFbmNvZGluZ0xvc3MocC5kdHlwZSxlKSlyZXR1cm4gVGVuc29yLm1ha2UocC5zaGFwZSx7ZGF0YUlkOnAuZGF0YUlkfSxlKTtpZihcImNvbXBsZXg2NFwiPT09cC5kdHlwZSl7dmFyIGw9dC5yZWFsKHApO3JldHVybiBvPWwuY2FzdChlKSxsLmRpc3Bvc2UoKSxvfWlmKFwiaW50MzJcIj09PWUpcmV0dXJuIHQuaW50KHApO2lmKFwiYm9vbFwiPT09ZSl7dmFyIGk9c2NhbGFyKDAscC5kdHlwZSk7cmV0dXJuIG89dC5ub3RFcXVhbChwLGkpLGkuZGlzcG9zZSgpLG99dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gQ2FzdDogdW5rbm93biBkdHlwZSBhcmd1bWVudCAoXCIrZStcIilcIil9ZnVuY3Rpb24gcmVzaGFwZVRlbnNvcihhLGUpe3JldHVybiBUZW5zb3IubWFrZShlLHtkYXRhSWQ6YS5kYXRhSWR9LGEuZHR5cGUpfWZ1bmN0aW9uIG1lcmdlUmVhbEFuZEltYWdBcnJheXMoYSxlKXtpZihhLmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSByZWFsIGFuZCBpbWFnIGFycmF5cyBvZiBkaWZmZXJlbnQgbGVuZ3Rocy4gcmVhbDpcIithLmxlbmd0aCtcIiwgaW1hZzogXCIrZS5sZW5ndGgrXCIuXCIpO2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KDIqYS5sZW5ndGgpLHI9MDtyPHQubGVuZ3RoO3IrPTIpdFtyXT1hW3IvMl0sdFtyKzFdPWVbci8yXTtyZXR1cm4gdH1mdW5jdGlvbiBzcGxpdFJlYWxBbmRJbWFnQXJyYXlzKGEpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KGEubGVuZ3RoLzIpLHQ9bmV3IEZsb2F0MzJBcnJheShhLmxlbmd0aC8yKSxyPTA7cjxhLmxlbmd0aDtyKz0yKWVbci8yXT1hW3JdLHRbci8yXT1hW3IrMV07cmV0dXJue3JlYWw6ZSxpbWFnOnR9fWZ1bmN0aW9uIGNvbXBsZXhXaXRoRXZlbkluZGV4KGEpe2Zvcih2YXIgZT1fTWF0aGNlaWwoYS5sZW5ndGgvNCksdD1uZXcgRmxvYXQzMkFycmF5KGUpLHI9bmV3IEZsb2F0MzJBcnJheShlKSxuPTA7bjxhLmxlbmd0aDtuKz00KXRbX01hdGhmbG9vcihuLzQpXT1hW25dLHJbX01hdGhmbG9vcihuLzQpXT1hW24rMV07cmV0dXJue3JlYWw6dCxpbWFnOnJ9fWZ1bmN0aW9uIGNvbXBsZXhXaXRoT2RkSW5kZXgoYSl7Zm9yKHZhciBlPV9NYXRoZmxvb3IoYS5sZW5ndGgvNCksdD1uZXcgRmxvYXQzMkFycmF5KGUpLHI9bmV3IEZsb2F0MzJBcnJheShlKSxuPTI7bjxhLmxlbmd0aDtuKz00KXRbX01hdGhmbG9vcihuLzQpXT1hW25dLHJbX01hdGhmbG9vcihuLzQpXT1hW24rMV07cmV0dXJue3JlYWw6dCxpbWFnOnJ9fWZ1bmN0aW9uIGdldENvbXBsZXhXaXRoSW5kZXgoYSxlKXtyZXR1cm57cmVhbDphWzIqZV0saW1hZzphWzIqZSsxXX19ZnVuY3Rpb24gYXNzaWduVG9UeXBlZEFycmF5KGEsZSx0LHIpe2FbMipyXT1lLGFbMipyKzFdPXR9ZnVuY3Rpb24gZXhwb25lbnRzKHMsZSl7Zm9yKHZhciB0PW5ldyBGbG9hdDMyQXJyYXkocy8yKSxyPW5ldyBGbG9hdDMyQXJyYXkocy8yKSxuPTAsaTtuPF9NYXRoY2VpbChzLzIpO24rKylpPShlPzI6LTIpKl9NYXRoUEkqKG4vcyksdFtuXT1fTWF0aGNvcyhpKSxyW25dPV9NYXRoc2luKGkpO3JldHVybntyZWFsOnQsaW1hZzpyfX1mdW5jdGlvbiBleHBvbmVudChhLGUsdCl7dmFyIHI9KHQ/MjotMikqX01hdGhQSSooYS9lKTtyZXR1cm57cmVhbDpfTWF0aGNvcyhyKSxpbWFnOl9NYXRoc2luKHIpfX1mdW5jdGlvbiBub25NYXhTdXBwcmVzc2lvbkltcGwobSxlLHQscixuKXtmb3IodmFyIG89QXJyYXkuZnJvbShlKS5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm57c2NvcmU6YSxib3hJbmRleDplfX0pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5zY29yZT5ufSkuc29ydChmdW5jdGlvbihhLGUpe3JldHVybiBlLnNjb3JlLWEuc2NvcmV9KSxhPVtdLGk9MDtpPG8ubGVuZ3RoO2krKyl7dmFyIGg9b1tpXSx1PWguc2NvcmUsbD1oLmJveEluZGV4O2lmKHU8bilicmVhaztmb3IodmFyIGM9ITEsZz1hLmxlbmd0aC0xOzA8PWc7LS1nKWlmKGludGVyc2VjdGlvbk92ZXJVbmlvbihtLGwsYVtnXSk+PXIpe2M9ITA7YnJlYWt9aWYoIWMmJihhLnB1c2gobCksYS5sZW5ndGg+PXQpKWJyZWFrfXJldHVybiB0ZW5zb3IxZChhLFwiaW50MzJcIil9ZnVuY3Rpb24gaW50ZXJzZWN0aW9uT3ZlclVuaW9uKGIsZSx0KXt2YXIgcj1iLnN1YmFycmF5KDQqZSw0KmUrNCksbj1iLnN1YmFycmF5KDQqdCw0KnQrNCksbz1fTWF0aG1pbihyWzBdLHJbMl0pLGE9X01hdGhtaW4oclsxXSxyWzNdKSxpPV9NYXRobWF4KHJbMF0sclsyXSkscz1fTWF0aG1heChyWzFdLHJbM10pLHU9X01hdGhtaW4oblswXSxuWzJdKSxsPV9NYXRobWluKG5bMV0sblszXSksYz1fTWF0aG1heChuWzBdLG5bMl0pLHA9X01hdGhtYXgoblsxXSxuWzNdKSxkPShpLW8pKihzLWEpLGg9KGMtdSkqKHAtbCk7aWYoMD49ZHx8MD49aClyZXR1cm4gMDt2YXIgZj1fTWF0aG1heChvLHUpLG09X01hdGhtYXgoYSxsKSxnPV9NYXRobWluKGksYyksTj1fTWF0aG1pbihzLHApLHk9X01hdGhtYXgoZy1mLDApKl9NYXRobWF4KE4tbSwwKTtyZXR1cm4geS8oZCtoLXkpfWZ1bmN0aW9uIHNwbGl0KHMsZSxpKXt2YXIgcj1BcnJheShzLnJhbmspLmZpbGwoMCksbj1zLnNoYXBlLnNsaWNlKCk7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe25baV09ZTt2YXIgdD1zLnNsaWNlKHIsbik7cmV0dXJuIHJbaV0rPWUsdH0pfWZ1bmN0aW9uIHRvcGtJbXBsKG8sZSx0LHIpe2Zvcih2YXIgbj1lW2UubGVuZ3RoLTFdLGE9W28ubGVuZ3RoL24sbl0saT1hWzBdLHM9YVsxXSx1PWdldFR5cGVkQXJyYXlGcm9tRFR5cGUodCxpKnIpLGw9Z2V0VHlwZWRBcnJheUZyb21EVHlwZShcImludDMyXCIsaSpyKSxjPTA7YzxpO2MrKyl7Zm9yKHZhciBiPWMqcyxkPW8uc3ViYXJyYXkoYixiK3MpLGg9W10sZj0wO2Y8ZC5sZW5ndGg7ZisrKWgucHVzaCh7dmFsdWU6ZFtmXSxpbmRleDpmfSk7aC5zb3J0KGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGUudmFsdWUtYS52YWx1ZX0pO3ZhciBOPWMqcixnPXUuc3ViYXJyYXkoTixOK3IpLEk9bC5zdWJhcnJheShOLE4rcik7Zm9yKGY9MDtmPHI7ZisrKWdbZl09aFtmXS52YWx1ZSxJW2ZdPWhbZl0uaW5kZXh9dmFyIHk9ZS5zbGljZSgpO3JldHVybiB5W3kubGVuZ3RoLTFdPXIsW3RlbnNvcih1LHksdCksdGVuc29yKGwseSxcImludDMyXCIpXX1mdW5jdGlvbiBnZXRCcm9hZGNhc3REaW1zKHMsZSl7Zm9yKHZhciB0PXMubGVuZ3RoLHI9W10sbj0wO248dDtuKyspe3ZhciBwPXQtMS1uLGE9c1twXXx8MTsxPChlW2UubGVuZ3RoLTEtbl18fDEpJiYxPT09YSYmci51bnNoaWZ0KHApfXJldHVybiByfWZ1bmN0aW9uIGdldFJlZHVjdGlvbkF4ZXMocyxlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgcD1zW3MubGVuZ3RoLXItMV0sbz1lLmxlbmd0aC1yLTEsYT1lW29dOyhudWxsPT1wfHwxPT09cCYmMTxhKSYmdC51bnNoaWZ0KG8pfXJldHVybiB0fWZ1bmN0aW9uIGJyb2FkY2FzdERpbXNBcmVPdXRlcihhKXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKylpZihhW2VdIT09ZSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShzLGUpe2Zvcih2YXIgdD1bXSxyPV9NYXRobWF4KHMubGVuZ3RoLGUubGVuZ3RoKSxuPTAscDtuPHI7bisrKXtwPXNbcy5sZW5ndGgtbi0xXSxudWxsPT1wJiYocD0xKTt2YXIgbD1lW2UubGVuZ3RoLW4tMV07aWYobnVsbD09bCYmKGw9MSksMT09cCl0LnVuc2hpZnQobCk7ZWxzZSBpZigxPT09bCl0LnVuc2hpZnQocCk7ZWxzZXtpZihwIT09bCl0aHJvdyBFcnJvcihcIk9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgXCIrcytcIiBhbmQgXCIrZStcIi5cIik7dC51bnNoaWZ0KHApfX1yZXR1cm4gdH1mdW5jdGlvbiBicm9hZGNhc3RTYW1wbGUoYSxlKXt2YXIgdD1cImdldFwiK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zbGljZSgxKTtyZXR1cm4gMT09PWU/XCJcXG4gICAgICB2ZWM0IFwiK2ErXCJTYW1wbGUgPSBcIit0K1wiKHJjLncpO1xcbiAgICAgIHZlYzQgXCIrYStcIiA9IHZlYzQoXCIrYStcIlNhbXBsZS54eSwgXCIrYStcIlNhbXBsZS54eSk7XFxuICAgIFwiOlwidmVjNCBcIithK1wiID0gXCIrdCtcIihyYy54LCByYy55LCByYy56LCByYy53KVwifWZ1bmN0aW9uIGdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoYSxlLHMpe3ZvaWQgMD09PXMmJihzPVwiaW5kZXhcIik7dmFyIGk9Y29tcHV0ZVN0cmlkZXMoZSk7cmV0dXJuIGkubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJpbnQgXCIrYVt0XStcIiA9IFwiK3MrXCIgLyBcIitlK1wiOyBcIisodD09PWkubGVuZ3RoLTE/XCJpbnQgXCIrYVt0KzFdK1wiID0gXCIrcytcIiAtIFwiK2FbdF0rXCIgKiBcIitlOlwiaW5kZXggLT0gXCIrYVt0XStcIiAqIFwiK2UpK1wiO1wifSkuam9pbihcIlwiKX1mdW5jdGlvbiBidWlsZFZlYyh0KXtyZXR1cm4gMT09PXQubGVuZ3RoP1wiXCIrdFswXTpcInZlY1wiK3QubGVuZ3RoK1wiKFwiK3Quam9pbihcIixcIikrXCIpXCJ9ZnVuY3Rpb24gZG90aWZ5KHAsZSl7aWYocC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJWZWN0b3JzIHRvIGJlIGRvdHRlZCBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aCAtZ290IFwiK3AubGVuZ3RoK1wiIGFuZCBcIitlLmxlbmd0aCk7Zm9yKHZhciB0PVtdLHI9X01hdGhmbG9vcihwLmxlbmd0aC80KSxuPXAubGVuZ3RoJTQsbz0wO288cjtvKyspe3ZhciBsPXAuc2xpY2UoNCpvLDQqbys0KSxkPWUuc2xpY2UoNCpvLDQqbys0KTt0LnB1c2goYnVpbGRWZWMobCkrXCIsIFwiK2J1aWxkVmVjKGQpKX1yZXR1cm4gMCE9biYmKGw9cC5zbGljZSg0KnIpLGQ9ZS5zbGljZSg0KnIpLDE9PT1sLmxlbmd0aCYmKGw9bC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJmbG9hdChcIit0K1wiKVwifSksZD1kLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImZsb2F0KFwiK3QrXCIpXCJ9KSksdC5wdXNoKGJ1aWxkVmVjKGwpK1wiLCBcIitidWlsZFZlYyhkKSkpLHQubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiZG90KFwiK3QrXCIpXCJ9KS5qb2luKFwiK1wiKX1mdW5jdGlvbiBtYWtlU2hhZGVyKHAsZCxlLHQsbil7dmFyIHI9cC5tYXAoZnVuY3Rpb24oYSl7dmFyIGU9c2l6ZUZyb21TaGFwZShhLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO3JldHVybiBhLnNoYXBlSW5mby5pc1VuaWZvcm0/XCJ1bmlmb3JtIGZsb2F0IFwiK2EubmFtZSsoMTxlP1wiW1wiK2UrXCJdXCI6XCJcIikrXCI7XCI6XCJ1bmlmb3JtIHNhbXBsZXIyRCBcIithLm5hbWUrXCI7XCJ9KTtyPXIuam9pbihcIlxcblwiKTt2YXIgbz1wLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoYSxkLHQpfSkuam9pbihcIlxcblwiKSx1PWQudGV4U2hhcGUsbD1TSEFERVJfUFJFRklYLG0saDtyZXR1cm4gZC5pc1BhY2tlZD8obT1nZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoZC5sb2dpY2FsU2hhcGUsdSksaD1GTE9BVF9URVhUVVJFX1NFVF9SR0JBX1NOSVBQRVQpOihtPWdldE91dHB1dFNhbXBsaW5nU25pcHBldChkLmxvZ2ljYWxTaGFwZSx1KSxoPUZMT0FUX1RFWFRVUkVfU0VUX1JfU05JUFBFVCksbiYmKGwrPVNIQURFUl9QQUNLRURfUFJFRklYKSxbbCxGTE9BVF9URVhUVVJFX1NBTVBMRV9TTklQUEVULGgscixtLG8sZV0uam9pbihcIlxcblwiKX1mdW5jdGlvbiBnZXRTYW1wbGVyRnJvbUluSW5mbyhhKXt2YXIgZT1hLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGdldFNhbXBsZXJTY2FsYXIoYSk7Y2FzZSAxOnJldHVybiBnZXRTYW1wbGVyMUQoYSk7Y2FzZSAyOnJldHVybiBnZXRTYW1wbGVyMkQoYSk7Y2FzZSAzOnJldHVybiBnZXRTYW1wbGVyM0QoYSk7Y2FzZSA0OnJldHVybiBnZXRTYW1wbGVyNEQoYSk7Y2FzZSA1OnJldHVybiBnZXRTYW1wbGVyNUQoYSk7Y2FzZSA2OnJldHVybiBnZXRTYW1wbGVyNkQoYSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoZS5sZW5ndGgrXCItRCBpbnB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt9fWZ1bmN0aW9uIGdldFBhY2tlZFNhbXBsZXJGcm9tSW5JbmZvKGEpe3ZhciBlPWEuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMTpyZXR1cm4gZ2V0UGFja2VkU2FtcGxlcjFEKGEpO2Nhc2UgMjpyZXR1cm4gZ2V0UGFja2VkU2FtcGxlcjJEKGEpO2Nhc2UgMzpyZXR1cm4gZ2V0UGFja2VkU2FtcGxlcjNEKGEpO2Nhc2UgNDpyZXR1cm4gZ2V0UGFja2VkU2FtcGxlcjREKGEpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIFwiK2UubGVuZ3RoK1wiLUQgaW5wdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7fX1mdW5jdGlvbiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldChhLGUsdCl7dmFyIHI9Z2V0U2FtcGxlckZsYXQoYSk7cmV0dXJuIHIrPWEuc2hhcGVJbmZvLmlzUGFja2VkP2dldFBhY2tlZFNhbXBsZXJGcm9tSW5JbmZvKGEpOmdldFNhbXBsZXJGcm9tSW5JbmZvKGEpLCh0fHxhcnJheXNFcXVhbChhLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpKSYmKHIrPWdldFNhbXBsZXJBdE91dHB1dENvb3JkcyhhLGUsdCkpLHJ9ZnVuY3Rpb24gZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KGEsZSl7c3dpdGNoKGEubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGdldE91dHB1dFNjYWxhckNvb3JkcygpO2Nhc2UgMTpyZXR1cm4gZ2V0T3V0cHV0UGFja2VkMURDb29yZHMoYSxlKTtjYXNlIDI6cmV0dXJuIGdldE91dHB1dFBhY2tlZDJEQ29vcmRzKGEsZSk7Y2FzZSAzOnJldHVybiBnZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhhLGUpO2Nhc2UgNDpyZXR1cm4gZ2V0T3V0cHV0UGFja2VkNERDb29yZHMoYSxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihhLmxlbmd0aCtcIi1EIHBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZSBmZXRjaGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt9fWZ1bmN0aW9uIGdldE91dHB1dFNhbXBsaW5nU25pcHBldChhLGUpe3N3aXRjaChhLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtjYXNlIDE6cmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKGEsZSk7Y2FzZSAyOnJldHVybiBnZXRPdXRwdXQyRENvb3JkcyhhLGUpO2Nhc2UgMzpyZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMoYSxlKTtjYXNlIDQ6cmV0dXJuIGdldE91dHB1dDREQ29vcmRzKGEsZSk7Y2FzZSA1OnJldHVybiBnZXRPdXRwdXQ1RENvb3JkcyhhLGUpO2Nhc2UgNjpyZXR1cm4gZ2V0T3V0cHV0NkRDb29yZHMoYSxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihhLmxlbmd0aCtcIi1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt9fWZ1bmN0aW9uIGdldE91dHB1dFNjYWxhckNvb3Jkcygpe3JldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGEsZSl7dmFyIHQ9W19NYXRoY2VpbChlWzBdLzIpLF9NYXRoY2VpbChlWzFdLzIpXTtyZXR1cm4gMT09PWVbMF0/XCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueCAqIFwiK3RbMV0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjoxPT09ZVsxXT9cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi55ICogXCIrdFswXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiK3RbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRPdXRwdXQxRENvb3JkcyhhLGUpe3JldHVybiAxPT09ZVswXT9cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBcIitlWzFdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI6MT09PWVbMV0/XCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi55ICogXCIrZVswXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhhLGUpe3ZhciB0PVtfTWF0aGNlaWwoZVswXS8yKSxfTWF0aGNlaWwoZVsxXS8yKV0scj1fTWF0aGNlaWwoYVsyXS8yKSxuPXIqX01hdGhjZWlsKGFbMV0vMik7cmV0dXJuXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIit0WzBdK1wiLCBcIit0WzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK3RbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIGludCBiID0gaW5kZXggLyBcIituK1wiO1xcbiAgICAgIGluZGV4IC09IGIgKiBcIituK1wiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK3IrXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrcitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0T3V0cHV0M0RDb29yZHMoYSxlKXt2YXIgdD1nZXRMb2dpY2FsQ29vcmRpbmF0ZXNGcm9tRmxhdEluZGV4KFtcInJcIixcImNcIixcImRcIl0sYSk7cmV0dXJuXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiK3QrXCJcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dFBhY2tlZDREQ29vcmRzKHMsZSl7dmFyIHQ9W19NYXRoY2VpbChlWzBdLzIpLF9NYXRoY2VpbChlWzFdLzIpXSxyPV9NYXRoY2VpbChzWzNdLzIpLG49cipfTWF0aGNlaWwoc1syXS8yKSxvPW4qc1sxXTtyZXR1cm5cIlxcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrdFsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IGIyID0gaW5kZXggLyBcIitvK1wiO1xcbiAgICAgIGluZGV4IC09IGIyICogXCIrbytcIjtcXG5cXG4gICAgICBpbnQgYiA9IGluZGV4IC8gXCIrbitcIjtcXG4gICAgICBpbmRleCAtPSBiICogXCIrbitcIjtcXG5cXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIityK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK3IrXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzQoYjIsIGIsIHIsIGMpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRPdXRwdXQ0RENvb3JkcyhhLGUpe3ZhciB0PWdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0sYSk7cmV0dXJuXCJcXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiK3QrXCJcXG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRPdXRwdXQ1RENvb3JkcyhhLGUpe3ZhciB0PWdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCJdLGEpO3JldHVyblwiXFxuICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIitlWzBdK1wiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrZVsxXStcIikpO1xcblxcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIit0K1wiXFxuXFxuICAgICAgaXZlYzUgb3V0U2hhcGUgPSBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xcbiAgICAgIHJldHVybiBvdXRTaGFwZTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0T3V0cHV0NkRDb29yZHMoYSxlKXt2YXIgdD1nZXRMb2dpY2FsQ29vcmRpbmF0ZXNGcm9tRmxhdEluZGV4KFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiLFwiZDRcIl0sYSk7cmV0dXJuXCJcXG4gICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK3QrXCJcXG5cXG4gICAgICBpdmVjNiByZXN1bHQgPSBpdmVjNihyLCBjLCBkLCBkMiwgZDMsIGQ0KTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhhLGUpe3ZhciB0PVtfTWF0aGNlaWwoZVswXS8yKSxfTWF0aGNlaWwoZVsxXS8yKV07aWYoYXJyYXlzRXF1YWwoYSxlKSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciByPV9NYXRoY2VpbChhWzFdLzIpO3JldHVyblwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrdFswXStcIiwgXCIrdFsxXStcIikpO1xcblxcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIit0WzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIityK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK3IrXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dDJEQ29vcmRzKGEsZSl7cmV0dXJuIGFycmF5c0VxdWFsKGEsZSk/XCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICB9XFxuICAgIFwiOjE9PT1hWzFdP1wiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcXG4gICAgICB9XFxuICAgIFwiOjE9PT1hWzBdP1wiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKDAsIGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIrYVsxXStcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqIFwiK2FbMV0rXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyU2NhbGFyKGEpe3ZhciBlPWEubmFtZSx0PVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpO3JldHVybiBhLnNoYXBlSW5mby5pc1VuaWZvcm0/XCJmbG9hdCBcIit0K1wiKCkge3JldHVybiBcIitlK1wiO31cIjpcIlxcbiAgICBmbG9hdCBcIit0K1wiKCkge1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFBhY2tlZFNhbXBsZXIxRChhKXt2YXIgZT1hLm5hbWUsdD1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxyPWEuc2hhcGVJbmZvLnRleFNoYXBlLG49W19NYXRoY2VpbChyWzBdLzIpLF9NYXRoY2VpbChyWzFdLzIpXTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK3QrXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxcbiAgICAgICAgXCIrblswXStcIiwgXCIrblsxXStcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiB0ZXh0dXJlMkQoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyMUQoYSl7dmFyIGU9YS5uYW1lLHQ9XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSk7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrdCtcIihpbnQgaW5kZXgpIHtcXG4gICAgICByZXR1cm4gXCIrdCtcIkZsYXQoaW5kZXgpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyMkQocCl7dmFyIGU9cC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQ9cC5uYW1lLHI9XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksbj1wLnNoYXBlSW5mby50ZXhTaGFwZSxvPW5bMF0sYT1uWzFdO2lmKG51bGwhPW4mJmFycmF5c0VxdWFsKGUsbikpcmV0dXJuXCJcXG4gICAgICB2ZWM0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiK2ErXCIuMCwgXCIrbytcIi4wKTtcXG5cXG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoXCIrdCtcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGk9W19NYXRoY2VpbChuWzBdLzIpLF9NYXRoY2VpbChuWzFdLzIpXTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRChcIitfTWF0aGNlaWwoZVsxXS8yKStcIiwgXCIraVswXStcIiwgXCIraVsxXStcIiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiB0ZXh0dXJlMkQoXCIrdCtcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyMkQoZCl7dmFyIGU9ZC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQ9ZC5uYW1lLHI9XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksbj1kLnNoYXBlSW5mby50ZXhTaGFwZTtpZihudWxsIT1uJiZhcnJheXNFcXVhbChlLG4pKXt2YXIgbz1uWzBdO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIituWzFdK1wiLjAsIFwiK28rXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgdXYpO1xcbiAgICB9XFxuICBcIn12YXIgYT1zcXVlZXplU2hhcGUoZSksaT1hLm5ld1NoYXBlLHM9YS5rZXB0RGltcyx1PWk7aWYodS5sZW5ndGg8ZS5sZW5ndGgpcmV0dXJuXCJcXG4gICAgICBcIitnZXRTYW1wbGVyRnJvbUluSW5mbyhzcXVlZXplSW5wdXRJbmZvKGQsdSkpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitnZXRTcXVlZXplZFBhcmFtcyhbXCJyb3dcIixcImNvbFwiXSxzKStcIik7XFxuICAgICAgfVxcbiAgICBcIjtpZihkLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK2VbMV0rXCIsIDEpKTtcXG4gICAgICAgIHJldHVybiBcIityK1wiRmxhdChyb3VuZChpbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGw9blswXSxjPW5bMV07cmV0dXJuIDE9PT1jP1wiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK2VbMV0rXCIsIDEpKTtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyBcIitsK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI6MT09PWw/XCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrZVsxXStcIiwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyBcIitjK1wiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgdXYpO1xcbiAgICB9XFxuICBcIjpcIlxcbiAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgIHZlYzIgdXYgPSBVVmZyb20yRChcIitsK1wiLCBcIitjK1wiLCBcIitlWzFdK1wiLCByb3csIGNvbCk7XFxuICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIHV2KTtcXG4gIH1cXG5cIn1mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyM0QocCl7dmFyIGU9cC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQ9cC5uYW1lLHI9XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksbj1wLnNoYXBlSW5mby50ZXhTaGFwZSxvPVtfTWF0aGNlaWwoblswXS8yKSxfTWF0aGNlaWwoblsxXS8yKV07aWYoMT09PWVbMF0pcmV0dXJuXCJcXG4gICAgICAgIFwiK2dldFBhY2tlZFNhbXBsZXJGcm9tSW5JbmZvKHNxdWVlemVJbnB1dEluZm8ocCxlLnNsaWNlKDEpKSkrXCJcXG4gICAgICAgIHZlYzQgXCIrcitcIihpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICByZXR1cm4gXCIrcitcIihcIitnZXRTcXVlZXplZFBhcmFtcyhbXCJiXCIsXCJyb3dcIixcImNvbFwiXSxbMSwyXSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO3ZhciBhPW9bMF0saT1vWzFdLHM9X01hdGhjZWlsKGVbMl0vMik7cmV0dXJuXCJcXG4gICAgdmVjNCBcIityK1wiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxcbiAgICAgICAgXCIrYStcIiwgXCIraStcIiwgXCIrcypfTWF0aGNlaWwoZVsxXS8yKStcIiwgXCIrcytcIiwgYiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiB0ZXh0dXJlMkQoXCIrdCtcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyM0QobSl7dmFyIGU9bS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQ9bS5uYW1lLHI9XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksbj1lWzFdKmVbMl0sbz1lWzJdLGE9c3F1ZWV6ZVNoYXBlKGUpLGk9YS5uZXdTaGFwZSxzPWEua2VwdERpbXMsdT1pO2lmKHUubGVuZ3RoPGUubGVuZ3RoKXJldHVyblwiXFxuICAgICAgICBcIitnZXRTYW1wbGVyRnJvbUluSW5mbyhzcXVlZXplSW5wdXRJbmZvKG0sdSkpK1wiXFxuICAgICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICByZXR1cm4gXCIrcitcIihcIitnZXRTcXVlZXplZFBhcmFtcyhbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIl0scykrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2lmKG0uc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKFwiK24rXCIsIFwiK28rXCIsIDEpKTtcXG4gICAgICAgIHJldHVybiBcIityK1wiRmxhdChyb3VuZChpbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGw9bS5zaGFwZUluZm8udGV4U2hhcGUsYz1sWzBdLHA9bFsxXTtyZXR1cm4gcD09PW4/XCJcXG4gICAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzIoY29sLCBkZXB0aCksIHZlYzIoXCIrbytcIiwgMSkpO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3ArXCIuMCwgXCIrYytcIi4wKTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiOnA9PT1vP1wiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMihcIitlWzFdK1wiLCAxKSk7XFxuICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoKTtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIitwK1wiLjAsIFwiK2MrXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgdXYpO1xcbiAgICB9XFxuICBcIjpcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gVVZmcm9tM0QoXFxuICAgICAgICAgICAgXCIrYytcIiwgXCIrcCtcIiwgXCIrbitcIiwgXCIrbytcIiwgcm93LCBjb2wsIGRlcHRoKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIHV2KTtcXG4gICAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyNEQocCl7dmFyIGU9cC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQ9cC5uYW1lLHI9XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksbj1wLnNoYXBlSW5mby50ZXhTaGFwZSxvPVtfTWF0aGNlaWwoblswXS8yKSxfTWF0aGNlaWwoblsxXS8yKV0sYT1vWzBdLGk9b1sxXSxzPV9NYXRoY2VpbChlWzNdLzIpLGQ9cypfTWF0aGNlaWwoZVsyXS8yKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK3IrXCIoaW50IGIyLCBpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb200RChcXG4gICAgICAgIFwiK2ErXCIsIFwiK2krXCIsIFwiK2QqZVsxXStcIixcXG4gICAgICAgIFwiK2QrXCIsIFwiK3MrXCIsIGIyLCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuIHRleHR1cmUyRChcIit0K1wiLCB1dik7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFNhbXBsZXI0RChtKXt2YXIgZT1tLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsdD1tLm5hbWUscj1cImdldFwiK3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKSxuPWVbM10sbz1lWzJdKm4sYT1lWzFdKm8saT1zcXVlZXplU2hhcGUoZSkscz1pLm5ld1NoYXBlLHU9aS5rZXB0RGltcztpZihzLmxlbmd0aDxlLmxlbmd0aClyZXR1cm5cIlxcbiAgICAgIFwiK2dldFNhbXBsZXJGcm9tSW5JbmZvKHNxdWVlemVJbnB1dEluZm8obSxzKSkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrZ2V0U3F1ZWV6ZWRQYXJhbXMoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIl0sdSkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYobS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNChcIithK1wiLCBcIitvK1wiLCBcIituK1wiLCAxKSk7XFxuICAgICAgICByZXR1cm4gXCIrcitcIkZsYXQocm91bmQoaW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBsPW0uc2hhcGVJbmZvLnRleFNoYXBlLGM9bFswXSxwPWxbMV07cmV0dXJuIHA9PT1hP1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgZmxvYXQgdGV4QyA9XFxuICAgICAgICAgICAgZG90KHZlYzMoY29sLCBkZXB0aCwgZGVwdGgyKSwgdmVjMyhcIitvK1wiLCBcIituK1wiLCAxKSk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIitwK1wiLjAsIFwiK2MrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIit0K1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjpwPT09bj9cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyhcIitlWzFdKmVbMl0rXCIsIFwiK2VbMl0rXCIsIDEpKTtcXG4gICAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aDIpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIitwK1wiLjAsIFwiK2MrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIit0K1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjpcIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb200RChcIitjK1wiLCBcIitwK1wiLCBcIithK1wiLCBcIitvK1wiLFxcbiAgICAgICAgICBcIituK1wiLCByb3csIGNvbCwgZGVwdGgsIGRlcHRoMik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgdXYpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRTYW1wbGVyNUQobSl7dmFyIGU9bS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQ9bS5uYW1lLHI9XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksbj1lWzRdLG89ZVszXSpuLGE9ZVsyXSpvLGk9ZVsxXSphLHM9c3F1ZWV6ZVNoYXBlKGUpLHU9cy5uZXdTaGFwZSxsPXMua2VwdERpbXM7aWYodS5sZW5ndGg8ZS5sZW5ndGgpcmV0dXJuXCJcXG4gICAgICBcIitnZXRTYW1wbGVyRnJvbUluSW5mbyhzcXVlZXplSW5wdXRJbmZvKG0sdSkpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK2dldFNxdWVlemVkUGFyYW1zKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIl0sbCkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYobS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitpK1wiLCBcIithK1wiLCBcIitvK1wiLCBcIituK1wiKSkgK1xcbiAgICAgICAgICBkZXB0aDM7XFxuICAgICAgICByZXR1cm4gXCIrcitcIkZsYXQoaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGM9bS5zaGFwZUluZm8udGV4U2hhcGUscD1jWzBdLGQ9Y1sxXTtyZXR1cm4gZD09PWk/XCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KFxcbiAgICAgICAgICB2ZWM0KGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKSxcXG4gICAgICAgICAgdmVjNChcIithK1wiLCBcIitvK1wiLCBcIituK1wiLCAxKSk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIit0K1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjpkPT09bj9cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitlWzFdKmVbMl0qZVszXStcIiwgXCIrZVsyXSplWzNdK1wiLFxcbiAgICAgICAgICAgIFwiK2VbM10rXCIsIDEpKTtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGgzO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIit0K1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjpcIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb201RChcIitwK1wiLCBcIitkK1wiLCBcIitpK1wiLCBcIithK1wiLFxcbiAgICAgICAgICBcIitvK1wiLCBcIituK1wiLCByb3csIGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIit0K1wiLCB1dik7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldFNhbXBsZXI2RChtKXt2YXIgZT1tLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsdD1tLm5hbWUscj1cImdldFwiK3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKSxuPWVbNV0sbz1lWzRdKm4sYT1lWzNdKm8saT1lWzJdKmEscz1lWzFdKmksdT1zcXVlZXplU2hhcGUoZSksbD11Lm5ld1NoYXBlLGM9dS5rZXB0RGltcztpZihsLmxlbmd0aDxlLmxlbmd0aClyZXR1cm5cIlxcbiAgICAgIFwiK2dldFNhbXBsZXJGcm9tSW5JbmZvKHNxdWVlemVJbnB1dEluZm8obSxsKSkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK2dldFNxdWVlemVkUGFyYW1zKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSxjKStcIik7XFxuICAgICAgfVxcbiAgICBcIjtpZihtLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBmbG9hdCBpbmRleCA9IGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrcytcIiwgXCIraStcIiwgXCIrYStcIiwgXCIrbytcIikpICtcXG4gICAgICAgICAgZG90KFxcbiAgICAgICAgICAgIHZlYzIoZGVwdGgzLCBkZXB0aDQpLFxcbiAgICAgICAgICAgIHZlYzIoXCIrbitcIiwgMSkpO1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCJGbGF0KGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBwPW0uc2hhcGVJbmZvLnRleFNoYXBlLGQ9cFswXSxoPXBbMV07cmV0dXJuIGg9PT1zP1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QoXFxuICAgICAgICAgIHZlYzQoY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpLFxcbiAgICAgICAgICB2ZWM0KFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIsIFwiK24rXCIpKSArIGRlcHRoNDtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2grXCIuMCwgXCIrZCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiOmg9PT1uP1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitlWzFdKmVbMl0qZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbMl0qZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzRdK1wiKSkgKyBkZXB0aDM7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoNDtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIraCtcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrdCtcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb202RChcIitkK1wiLCBcIitoK1wiLCBcIitzK1wiLCBcIitpK1wiLFxcbiAgICAgICAgICBcIithK1wiLCBcIitvK1wiLCBcIituK1wiXFxuICAgICAgICAgICxyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzLCBkZXB0aDQpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3QrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0U2FtcGxlckZsYXQocyl7dmFyIGU9cy5uYW1lLHQ9XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSkrXCJGbGF0XCIscj1zaXplRnJvbVNoYXBlKHMuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7aWYocy5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVybiAxPT09cj9cImZsb2F0IFwiK3QrXCIoaW50IGluZGV4KSB7cmV0dXJuIFwiK2UrXCI7fVwiOlwiXFxuICAgICAgZmxvYXQgXCIrdCtcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcitcIjsgaSsrKSB7XFxuICAgICAgICAgIGlmIChpID09IGluZGV4KSB7XFxuICAgICAgICAgICAgcmV0dXJuIFwiK2UrXCJbaV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiO3ZhciBuPXMuc2hhcGVJbmZvLnRleFNoYXBlLG89blswXSxhPW5bMV07cmV0dXJuIDE9PT1hJiYxPT09bz9cIlxcbiAgICAgIGZsb2F0IFwiK3QrXCIoaW50IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI6MT09PWE/XCJcXG4gICAgICBmbG9hdCBcIit0K1wiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiK28rXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjoxPT09bz9cIlxcbiAgICAgIGZsb2F0IFwiK3QrXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiK2ErXCIuMCwgMC41KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgIGZsb2F0IFwiK3QrXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IFVWZnJvbTFEKFwiK28rXCIsIFwiK2ErXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGdldEJyb2FkY2FzdE91dHB1dENvb3Jkc1NhbXBsZXIocCxlLHQscil7dmFyIG49cC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCxvPWUubG9naWNhbFNoYXBlLmxlbmd0aCxhPVwiaW50XCI7Mj09PW8/YT1cIml2ZWMyXCI6Mz09PW8/YT1cIml2ZWMzXCI6ND09PW8mJihhPVwiaXZlYzRcIik7dmFyIGw9Z2V0QnJvYWRjYXN0RGltcyhwLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpLHM9by1uO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoKSB7XFxuICAgICAgXCIrYStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIisoMD09PW4/XCJcIjoyPm8mJjE8PWwubGVuZ3RoP1wiY29vcmRzID0gMDtcIjpsLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImNvb3Jkc1tcIisodCtzKStcIl0gPSAwO1wifSkuam9pbihcIlxcblwiKSkrXCJcXG4gICAgICByZXR1cm4gZ2V0XCIrdCtcIihcIisoMj5vJiYwPG4/XCJjb29yZHNcIjpwLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKGZ1bmN0aW9uKGEsZSl7cmV0dXJuXCJjb29yZHNbXCIrKGUrcykrXCJdXCJ9KS5qb2luKFwiLCBcIikpK1wiKTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGcsZSx0KXt2YXIgcj1nLm5hbWUsbj1yLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksbz1cImdldFwiK24rXCJBdE91dENvb3Jkc1wiLGE9Z2V0QnJvYWRjYXN0RGltcyhnLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpLGk9Zy5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCxzPWUubG9naWNhbFNoYXBlLmxlbmd0aCx1PXQmJihzPml8fDA8YS5sZW5ndGgpLGw9YnJvYWRjYXN0RGltc0FyZU91dGVyKGEpLGM9Zy5zaGFwZUluZm8uaXNVbmlmb3JtO2lmKHUmJiFsKXJldHVybiBnZXRCcm9hZGNhc3RPdXRwdXRDb29yZHNTYW1wbGVyKGcsZSxuLG8pO3ZhciBwPXNpemVGcm9tU2hhcGUoZy5zaGFwZUluZm8ubG9naWNhbFNoYXBlKSxkPVwiXCI7dSYmbCYmKGQ9XCJcXG4gICAgICAgIGludCBtYWluUGFydCA9IGluZGV4IC8gXCIrcCtcIjtcXG4gICAgICAgIGluZGV4IC09IG1haW5QYXJ0ICogXCIrcCtcIjtcXG4gICAgICBcIik7dmFyIHk9ZS50ZXhTaGFwZTtpZihjKXJldHVybiAxPT09cD9cImZsb2F0IFwiK28rXCIoKSB7cmV0dXJuIFwiK3IrXCI7fVwiOlwiXFxuICAgICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIreVswXStcIiwgXCIreVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK3lbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgXCIrZCtcIlxcbiAgICAgICAgcmV0dXJuIGdldFwiK24rXCJGbGF0KGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBmPWcuc2hhcGVJbmZvLnRleFNoYXBlO3JldHVybiBhcnJheXNFcXVhbChmLHkpP1wiXFxuICAgICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3IrXCIsIHJlc3VsdFVWKTtcXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgIGZsb2F0IFwiK28rXCIoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3lbMF0rXCIsIFwiK3lbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIreVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIrZCtcIlxcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBcIitmWzFdK1wiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIrZlsxXStcIjtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgIHZlYzIoXCIrZlsxXStcIi4wLCBcIitmWzBdK1wiLjApO1xcblxcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK3IrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0Q29vcmRzRGF0YVR5cGUodCl7aWYoMT49dClyZXR1cm5cImludFwiO2lmKDI9PT10KXJldHVyblwiaXZlYzJcIjtpZigzPT09dClyZXR1cm5cIml2ZWMzXCI7aWYoND09PXQpcmV0dXJuXCJpdmVjNFwiO2lmKDU9PT10KXJldHVyblwiaXZlYzVcIjtpZig2PT09dClyZXR1cm5cIml2ZWM2XCI7dGhyb3cgRXJyb3IoXCJHUFUgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX1mdW5jdGlvbiBzcXVlZXplSW5wdXRJbmZvKGEsZSl7dmFyIHQ9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhKSk7cmV0dXJuIHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZT1lLHR9ZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMoYSxlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGFbZV19KS5qb2luKFwiLCBcIil9ZnVuY3Rpb24gZ2V0Q29vcmRzKGEsZSl7aWYoMT09PWEpcmV0dXJuXCJcIitlO2lmKDI9PT1hKXJldHVybiBlK1wiLngsIFwiK2UrXCIueVwiO2lmKDM9PT1hKXJldHVybiBlK1wiLngsIFwiK2UrXCIueSwgXCIrZStcIi56XCI7aWYoND09PWEpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55LCBcIitlK1wiLnosIFwiK2UrXCIud1wiO3Rocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIrYStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX1mdW5jdGlvbiBnZXRGaW5hbENvb3JkKGEsZSl7aWYoMT09PWEpcmV0dXJuXCJcIitlO2lmKDI9PT1hKXJldHVybiBlK1wiLnlcIjtpZigzPT09YSlyZXR1cm4gZStcIi56XCI7aWYoND09PWEpcmV0dXJuIGUrXCIud1wiO3Rocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIrYStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX1mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMocyxlKXt2YXIgdD1zLmxlbmd0aDtpZig0PHQpdGhyb3cgRXJyb3IoXCJHYXRoZXIgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09dClyZXR1cm5cImludChnZXRJbmRpY2VzKHJlc1JDKSlcIjtmb3IodmFyIHI9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxuPVtdLG89MDtvPHMubGVuZ3RoO28rKylvPT09ZT9uLnB1c2goXCJpbnQoZ2V0SW5kaWNlcyhcIityW29dK1wiKSlcIik6bi5wdXNoKFwiXCIrcltvXSk7cmV0dXJuIG4uam9pbigpfWZ1bmN0aW9uIGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQoYSxlKXtyZXR1cm5bZSxhXX1mdW5jdGlvbiBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKGEsZSl7cmV0dXJuIGEqZX1mdW5jdGlvbiBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKGEsZSl7aWYoMCE9YSVlKXRocm93IG5ldyBFcnJvcihcInVucGFja2VkU2l6ZSAoXCIrYStcIikgbXVzdCBiZSBhIG11bHRpcGxlIG9mIFwiK2UpO3JldHVybiBhL2V9ZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KHMsZSx0KXt2YXIgcj1nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKHMubGVuZ3RoLHQpO2lmKGUubGVuZ3RoPHIpdGhyb3cgbmV3IEVycm9yKFwidW5wYWNrZWRBcnJheSBsZW5ndGggKFwiK2UubGVuZ3RoK1wiKSBtdXN0IGJlID49IFwiK3IpO2Zvcih2YXIgbj0wLGk9MDtpPHMubGVuZ3RoOysraSllW25dPXNbaV0sbis9dH1mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheShzLGUsdCl7dmFyIHI9Z2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZShzLmxlbmd0aCx0KTtpZihlLmxlbmd0aDxyKXRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiK2UubGVuZ3RoK1wiKSBtdXN0IGJlID49IFwiK3IpO2Zvcih2YXIgbj0wLGk9MDtpPHMubGVuZ3RoO2krPXQpZVtuKytdPXNbaV19ZnVuY3Rpb24gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQoYSxlKXtyZXR1cm5bX01hdGhjZWlsKGUvMiksX01hdGhjZWlsKGEvMildfWZ1bmN0aW9uIGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUoYSxlKXt2YXIgdD1nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChhLGUpO3JldHVybiA0Kih0WzBdKnRbMV0pfWZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShiLGUsdCxyLG4pe3ZhciBvPWdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUodCxyKTtpZihuLmxlbmd0aDxvKXRocm93IG5ldyBFcnJvcihcInBhY2tlZFJHQkEgbGVuZ3RoIChcIituLmxlbmd0aCtcIikgbXVzdCBiZSA+PVxcbiAgICAgICAgXCIrbyk7Zm9yKHZhciBhPTE9PXIlMixpPTE9PXQlMixzPV9NYXRoZmxvb3Ioci8yKSx1PV9NYXRoZmxvb3IodC8yKSxsPV9NYXRoY2VpbChyLzIpLGM9bCpfTWF0aGNlaWwodC8yKSxwPW5lYXJlc3RMYXJnZXJFdmVuKHQpKm5lYXJlc3RMYXJnZXJFdmVuKHIpLGQ9MDtkPGU7ZCsrKXtmb3IodmFyIE49ZCp0KnIsZj1kKnAsbT1hPzQ6MCxJPXIsdj1mLFM9MDtTPHU7KytTKXtmb3IodmFyIEM9MipTKnIsaz0wLFQ7azxzOysraylUPU4rQysyKmssblt2XT1iW1RdLG5bdisxXT1iW1QrMV0sblt2KzJdPWJbVCtJXSxuW3YrM109YltUK0krMV0sdis9NDt2Kz1tfWlmKGEpe1Q9TityLTEsdj1mKzQqKGwtMSk7Zm9yKG09NCpsLFM9MDtTPHU7KytTKW5bdl09YltUXSxuW3YrMl09YltUK3JdLFQrPTIqcix2Kz1tfWlmKGkpe2ZvcihUPU4rKHQtMSkqcix2PWYrNCooYy1sKSxrPTA7azxzOysrayluW3YrK109YltUKytdLG5bdisrXT1iW1QrK10sdis9MjthJiZpJiYobltmK3AtNF09YltUXSl9fXJldHVybiBufWZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKHMsZSx0LHIsbil7dmFyIG89dCpyO2lmKG4ubGVuZ3RoPG8pdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIrbi5sZW5ndGgrXCIpIG11c3QgYmUgPj0gXCIrbyk7Zm9yKHZhciBhPTE9PXIlMixpPV9NYXRoZmxvb3Ioci8yKSx1PV9NYXRoZmxvb3IodC8yKSxsPV9NYXRoY2VpbChyLzIpLGM9bCpfTWF0aGNlaWwodC8yKSxwPW5lYXJlc3RMYXJnZXJFdmVuKHQpKm5lYXJlc3RMYXJnZXJFdmVuKHIpLGQ9MDtkPGU7ZCsrKXtmb3IodmFyIGI9ZCp0KnIsZj1kKnAsbT1hPzQ6MCxOPXIrKGE/MTowKSxJPWYsQz1iLGs9YityLFI9MDtSPHU7KytSKXtmb3IodmFyIEQ9MDtEPGk7KytEKW5bQysrXT1zW0krK10sbltDKytdPXNbSSsrXSxuW2srK109c1tJKytdLG5baysrXT1zW0krK107SSs9bSxDKz1OLGsrPU59aWYoYSl7ST1mKzQqKGwtMSk7dmFyIFA9YityLTE7Zm9yKG09NCpsLE49MipyLFI9MDtSPHU7KytSKW5bUF09c1tJXSxuW1Arcl09c1tJKzJdLEkrPW0sUCs9Tn1pZigxPT10JTIpe2ZvcihJPWYrNCooYy1sKSxQPWIrKHQtMSkqcixEPTA7RDxpOysrRCluW1ArK109c1tJKytdLG5bUCsrXT1zW0krK10sSSs9MjthJiYobltiK3Qqci0xXT1zW0ldKX19cmV0dXJuIG59ZnVuY3Rpb24gY2FsbEFuZENoZWNrKGEsZSl7dmFyIHQ9ZSgpO3JldHVybiBjaGVja1dlYkdMRXJyb3IoYSksdH1mdW5jdGlvbiBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyh0KXt3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQ9dH1mdW5jdGlvbiBjaGVja1dlYkdMRXJyb3IoYSl7aWYod2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkKXt2YXIgZT1hLmdldEVycm9yKCk7aWYoZSE9PWEuTk9fRVJST1IpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgRXJyb3I6IFwiK2dldFdlYkdMRXJyb3JNZXNzYWdlKGEsZSkpfX1mdW5jdGlvbiBnZXRXZWJHTEVycm9yTWVzc2FnZShhLGUpe3JldHVybiBlPT09YS5OT19FUlJPUj9cIk5PX0VSUk9SXCI6ZT09PWEuSU5WQUxJRF9FTlVNP1wiSU5WQUxJRF9FTlVNXCI6ZT09PWEuSU5WQUxJRF9WQUxVRT9cIklOVkFMSURfVkFMVUVcIjplPT09YS5JTlZBTElEX09QRVJBVElPTj9cIklOVkFMSURfT1BFUkFUSU9OXCI6ZT09PWEuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04/XCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiOmU9PT1hLk9VVF9PRl9NRU1PUlk/XCJPVVRfT0ZfTUVNT1JZXCI6ZT09PWEuQ09OVEVYVF9MT1NUX1dFQkdMP1wiQ09OVEVYVF9MT1NUX1dFQkdMXCI6XCJVbmtub3duIGVycm9yIGNvZGUgXCIrZX1mdW5jdGlvbiBnZXRFeHRlbnNpb25PclRocm93KGEsZSl7cmV0dXJuIHRocm93SWZOdWxsKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRFeHRlbnNpb24oZSl9LFwiRXh0ZW5zaW9uIFxcXCJcIitlK1wiXFxcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cIil9ZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyKGEsZSl7dmFyIHQ9dGhyb3dJZk51bGwoYSxmdW5jdGlvbigpe3JldHVybiBhLmNyZWF0ZVNoYWRlcihhLlZFUlRFWF9TSEFERVIpfSxcIlVuYWJsZSB0byBjcmVhdGUgdmVydGV4IFdlYkdMU2hhZGVyLlwiKTtpZihjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLnNoYWRlclNvdXJjZSh0LGUpfSksY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5jb21waWxlU2hhZGVyKHQpfSksITE9PT1hLmdldFNoYWRlclBhcmFtZXRlcih0LGEuQ09NUElMRV9TVEFUVVMpKXRocm93IGNvbnNvbGUubG9nKGEuZ2V0U2hhZGVySW5mb0xvZyh0KSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlci5cIik7cmV0dXJuIHR9ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRTaGFkZXIoYSxlKXt2YXIgdD10aHJvd0lmTnVsbChhLGZ1bmN0aW9uKCl7cmV0dXJuIGEuY3JlYXRlU2hhZGVyKGEuRlJBR01FTlRfU0hBREVSKX0sXCJVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLlwiKTtpZihjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLnNoYWRlclNvdXJjZSh0LGUpfSksY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5jb21waWxlU2hhZGVyKHQpfSksITE9PT1hLmdldFNoYWRlclBhcmFtZXRlcih0LGEuQ09NUElMRV9TVEFUVVMpKXRocm93IGxvZ1NoYWRlclNvdXJjZUFuZEluZm9Mb2coZSxhLmdldFNoYWRlckluZm9Mb2codCkpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci5cIik7cmV0dXJuIHR9ZnVuY3Rpb24gbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhkLGUpe3ZhciB0PWxpbmVOdW1iZXJSZWdleC5leGVjKGUpO2lmKG51bGw9PXQpcmV0dXJuIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiK2UpLHZvaWQgY29uc29sZS5sb2coZCk7Zm9yKHZhciByPSt0WzFdLG49ZC5zcGxpdChcIlxcblwiKSxvPW4ubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoKzIsYT1uLm1hcChmdW5jdGlvbihhLGUpe3JldHVybiByaWdodFBhZCgoZSsxKS50b1N0cmluZygpLG8pK2F9KSxpPTAsbT0wO208YS5sZW5ndGg7bSsrKWk9X01hdGhtYXgoYVttXS5sZW5ndGgsaSk7dmFyIGg9YS5zbGljZSgwLHItMSksbD1hLnNsaWNlKHItMSxyKSxjPWEuc2xpY2Uocik7Y29uc29sZS5sb2coaC5qb2luKFwiXFxuXCIpKSxjb25zb2xlLmxvZyhlLnNwbGl0KFwiXFxuXCIpWzBdKSxjb25zb2xlLmxvZyhcIiVjIFwiK3JpZ2h0UGFkKGxbMF0saSksXCJib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3XCIpLGNvbnNvbGUubG9nKGMuam9pbihcIlxcblwiKSl9ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSh0KXtyZXR1cm4gdGhyb3dJZk51bGwodCxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVByb2dyYW0oKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS5cIil9ZnVuY3Rpb24gbGlua1Byb2dyYW0oYSxlKXtpZihjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmxpbmtQcm9ncmFtKGUpfSksITE9PT1hLmdldFByb2dyYW1QYXJhbWV0ZXIoZSxhLkxJTktfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyhhLmdldFByb2dyYW1JbmZvTG9nKGUpKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbGluayB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXCIpfWZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3JhbShhLGUpe2lmKGNhbGxBbmRDaGVjayhhLGZ1bmN0aW9uKCl7cmV0dXJuIGEudmFsaWRhdGVQcm9ncmFtKGUpfSksITE9PT1hLmdldFByb2dyYW1QYXJhbWV0ZXIoZSxhLlZBTElEQVRFX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2coYS5nZXRQcm9ncmFtSW5mb0xvZyhlKSksbmV3IEVycm9yKFwiU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuXCIpfWZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihhLGUpe3ZhciB0PXRocm93SWZOdWxsKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5jcmVhdGVCdWZmZXIoKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyXCIpO3JldHVybiBjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmJpbmRCdWZmZXIoYS5BUlJBWV9CVUZGRVIsdCl9KSxjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmJ1ZmZlckRhdGEoYS5BUlJBWV9CVUZGRVIsZSxhLlNUQVRJQ19EUkFXKX0pLHR9ZnVuY3Rpb24gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoYSxlKXt2YXIgdD10aHJvd0lmTnVsbChhLGZ1bmN0aW9uKCl7cmV0dXJuIGEuY3JlYXRlQnVmZmVyKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5iaW5kQnVmZmVyKGEuRUxFTUVOVF9BUlJBWV9CVUZGRVIsdCl9KSxjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmJ1ZmZlckRhdGEoYS5FTEVNRU5UX0FSUkFZX0JVRkZFUixlLGEuU1RBVElDX0RSQVcpfSksdH1mdW5jdGlvbiBnZXROdW1DaGFubmVscygpe3JldHVybiAyPT09RU5WLmdldChcIldFQkdMX1ZFUlNJT05cIik/MTo0fWZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUodCl7cmV0dXJuIHRocm93SWZOdWxsKHQsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVUZXh0dXJlKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuXCIpfWZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVNpemUoYSxlKXt2YXIgdD1FTlYuZ2V0KFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZigwPj1hfHwwPj1lKXt2YXIgcj1cIltcIithK1wieFwiK2UrXCJdXCI7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIityK1wiIGlzIGludmFsaWQuXCIpfWlmKGE+dHx8ZT50KXRocm93IHI9XCJbXCIrYStcInhcIitlK1wiXVwiLG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgXCIrcitcIiBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgXCIrKFwiW1wiK3QrXCJ4XCIrdCtcIl0uXCIpKX1mdW5jdGlvbiBjcmVhdGVGcmFtZWJ1ZmZlcih0KXtyZXR1cm4gdGhyb3dJZk51bGwodCxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUZyYW1lYnVmZmVyKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEZyYW1lYnVmZmVyLlwiKX1mdW5jdGlvbiBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKHAsZSx0LHIsbixvLGEpe3ZhciBpPXAuZ2V0QXR0cmliTG9jYXRpb24oZSx0KTtyZXR1cm4tMSE9PWkmJihjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLmJpbmRCdWZmZXIocC5BUlJBWV9CVUZGRVIscil9KSxjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLnZlcnRleEF0dHJpYlBvaW50ZXIoaSxuLHAuRkxPQVQsITEsbyxhKX0pLGNhbGxBbmRDaGVjayhwLGZ1bmN0aW9uKCl7cmV0dXJuIHAuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSl9KSwhMCl9ZnVuY3Rpb24gYmluZFRleHR1cmVVbml0KGEsZSx0KXt2YWxpZGF0ZVRleHR1cmVVbml0KGEsdCksY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5hY3RpdmVUZXh0dXJlKGEuVEVYVFVSRTArdCl9KSxjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCxlKX0pfWZ1bmN0aW9uIHVuYmluZFRleHR1cmVVbml0KGEsZSl7dmFsaWRhdGVUZXh0dXJlVW5pdChhLGUpLGNhbGxBbmRDaGVjayhhLGZ1bmN0aW9uKCl7cmV0dXJuIGEuYWN0aXZlVGV4dHVyZShhLlRFWFRVUkUwK2UpfSksY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5iaW5kVGV4dHVyZShhLlRFWFRVUkVfMkQsbnVsbCl9KX1mdW5jdGlvbiBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyhhLGUsdCl7cmV0dXJuIHRocm93SWZOdWxsKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRVbmlmb3JtTG9jYXRpb24oZSx0KX0sXCJ1bmlmb3JtIFxcXCJcIit0K1wiXFxcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLlwiKX1mdW5jdGlvbiBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uKGEsZSx0KXtyZXR1cm4gYS5nZXRVbmlmb3JtTG9jYXRpb24oZSx0KX1mdW5jdGlvbiBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKGEsZSx0LHIsbil7Y2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYmluZFRleHR1cmVVbml0KGEsdCxuKX0pLGNhbGxBbmRDaGVjayhhLGZ1bmN0aW9uKCl7cmV0dXJuIGEudW5pZm9ybTFpKHIsbil9KX1mdW5jdGlvbiBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcih0KXtjYWxsQW5kQ2hlY2sodCxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpfSksY2FsbEFuZENoZWNrKHQsZnVuY3Rpb24oKXtyZXR1cm4gdC52aWV3cG9ydCgwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KX0pLGNhbGxBbmRDaGVjayh0LGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2Npc3NvcigwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KX0pfWZ1bmN0aW9uIGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKGEsZSx0KXtjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLHQpfSksY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLkZSQU1FQlVGRkVSLGEuQ09MT1JfQVRUQUNITUVOVDAsYS5URVhUVVJFXzJELGUsMCl9KX1mdW5jdGlvbiB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIoYSxlKXtjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmJpbmRGcmFtZWJ1ZmZlcihhLkZSQU1FQlVGRkVSLGUpfSksY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLkZSQU1FQlVGRkVSLGEuQ09MT1JfQVRUQUNITUVOVDAsYS5URVhUVVJFXzJELG51bGwsMCl9KX1mdW5jdGlvbiB2YWxpZGF0ZUZyYW1lYnVmZmVyKGEpe3ZhciBlPWEuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhhLkZSQU1FQlVGRkVSKTtpZihlIT09YS5GUkFNRUJVRkZFUl9DT01QTEVURSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBiaW5kaW5nIGZyYW1lYnVmZmVyOiBcIitnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShhLGUpKX1mdW5jdGlvbiBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShhLGUpe3JldHVybiBlPT09YS5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ/XCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIjplPT09YS5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVD9cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCI6ZT09PWEuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TP1wiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCI6ZT09PWEuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ/XCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiOlwidW5rbm93biBlcnJvciBcIitlfWZ1bmN0aW9uIHRocm93SWZOdWxsKGEsZSx0KXt2YXIgcj1jYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBlKCl9KTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcih0KTtyZXR1cm4gcn1mdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVVbml0KGEsZSl7dmFyIHQ9YS5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUy0xLHI9ZSthLlRFWFRVUkUwO2lmKHI8YS5URVhUVVJFMHx8cj50KXRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIrdCtcIl0uXCIpfWZ1bmN0aW9uIGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUoYSxzKXt2b2lkIDA9PT1zJiYocz0hMSk7dmFyIGk9RU5WLmdldChcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIik7aWYocyYmKGkqPTIsYT1hLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiB0Pj1hLmxlbmd0aC0yP25lYXJlc3RMYXJnZXJFdmVuKGFbdF0pOmFbdF19KSksMiE9PWEubGVuZ3RoKXt2YXIgcD1zcXVlZXplU2hhcGUoYSk7YT1wLm5ld1NoYXBlfXZhciBuPXNpemVGcm9tU2hhcGUoYSk7cmV0dXJuIDE+PWEubGVuZ3RoJiZuPD1pP1tuLDFdOjI9PT1hLmxlbmd0aCYmYVswXTw9aSYmYVsxXTw9aT9hOjM9PT1hLmxlbmd0aCYmYVswXSphWzFdPD1pJiZhWzJdPD1pP1thWzBdKmFbMV0sYVsyXV06Mz09PWEubGVuZ3RoJiZhWzBdPD1pJiZhWzFdKmFbMl08PWk/W2FbMF0sYVsxXSphWzJdXTo0PT09YS5sZW5ndGgmJmFbMF0qYVsxXSphWzJdPD1pJiZhWzNdPD1pP1thWzBdKmFbMV0qYVsyXSxhWzNdXTo0PT09YS5sZW5ndGgmJmFbMF08PWkmJmFbMV0qYVsyXSphWzNdPD1pP1thWzBdLGFbMV0qYVsyXSphWzNdXTpzaXplVG9TcXVhcmlzaFNoYXBlKG4pfWZ1bmN0aW9uIGlzRXZlbih0KXtyZXR1cm4gMD09dCUyfWZ1bmN0aW9uIGlzUmVzaGFwZUZyZWUoYSxuKXtpZihhcnJheXNFcXVhbChhPWEuc2xpY2UoLTIpLG49bi5zbGljZSgtMikpKXJldHVybiEwO2lmKCFhLmxlbmd0aHx8IW4ubGVuZ3RoKXJldHVybiEwO2lmKDA9PT1hWzBdfHwwPT09YVsxXXx8MD09PW5bMF18fDA9PT1uWzFdKXJldHVybiEwO2lmKGEubGVuZ3RoIT09bi5sZW5ndGgpe2lmKGFycmF5c0VxdWFsKHNxdWVlemVTaGFwZShhKS5uZXdTaGFwZSxzcXVlZXplU2hhcGUobikubmV3U2hhcGUpKXJldHVybiEwO31lbHNlIGlmKGlzRXZlbihhWzBdKSYmaXNFdmVuKG5bMF0pKXtpZihpc0V2ZW4oYVsxXSkmJmlzRXZlbihuWzFdKSlyZXR1cm4hMDtpZihhWzFdPT09blsxXSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIkMSh0KXtyZXR1cm4gY3JlYXRlVmVydGV4U2hhZGVyKHQsXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBhdHRyaWJ1dGUgdmVjMyBjbGlwU3BhY2VQb3M7XFxuICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcXG4gICAgICByZXN1bHRVViA9IHV2O1xcbiAgICB9XCIpfWZ1bmN0aW9uIGNyZWF0ZVZlcnRleEJ1ZmZlcih0KXtyZXR1cm4gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKHQsbmV3IEZsb2F0MzJBcnJheShbLTEsMSwwLDAsMSwtMSwtMSwwLDAsMCwxLDEsMCwxLDEsMSwtMSwwLDEsMF0pKX1mdW5jdGlvbiBjcmVhdGVJbmRleEJ1ZmZlcih0KXtyZXR1cm4gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIodCxuZXcgVWludDE2QXJyYXkoWzAsMSwyLDIsMSwzXSkpfWZ1bmN0aW9uIGdldFRleHR1cmVDb25maWcocCxlKXt2YXIgdD1wLGwsZCxjLG0saCxnLGY7cmV0dXJuIDI9PT1FTlYuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKT8obD10LlIzMkYsZD10LlIxNkYsYz10LlJHQkEzMkYsbT10LlJFRCxoPTQsZz0xLGY9dC5IQUxGX0ZMT0FUKToobD1wLlJHQkEsZD1wLlJHQkEsYz10LlJHQkEsbT1wLlJHQkEsaD00LGc9NCxmPW51bGw9PWU/bnVsbDplLkhBTEZfRkxPQVRfT0VTKSx7aW50ZXJuYWxGb3JtYXRGbG9hdDpsLGludGVybmFsRm9ybWF0SGFsZkZsb2F0OmQsaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdDpjLHRleHR1cmVGb3JtYXRGbG9hdDptLGRvd25sb2FkVGV4dHVyZUZvcm1hdDpwLlJHQkEsZG93bmxvYWRVbnBhY2tOdW1DaGFubmVsczpoLGRlZmF1bHROdW1DaGFubmVsczpnLHRleHR1cmVUeXBlSGFsZkZsb2F0OmZ9fWZ1bmN0aW9uIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUocCxlLHQscixuLG8pe3ZhbGlkYXRlVGV4dHVyZVNpemUoZSx0KTt2YXIgYT1jcmVhdGVUZXh0dXJlKHApLGk9cC5URVhUVVJFXzJEO3JldHVybiBjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLmJpbmRUZXh0dXJlKGksYSl9KSxjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLnRleFBhcmFtZXRlcmkoaSxwLlRFWFRVUkVfV1JBUF9TLHAuQ0xBTVBfVE9fRURHRSl9KSxjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLnRleFBhcmFtZXRlcmkoaSxwLlRFWFRVUkVfV1JBUF9ULHAuQ0xBTVBfVE9fRURHRSl9KSxjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLnRleFBhcmFtZXRlcmkoaSxwLlRFWFRVUkVfTUlOX0ZJTFRFUixwLk5FQVJFU1QpfSksY2FsbEFuZENoZWNrKHAsZnVuY3Rpb24oKXtyZXR1cm4gcC50ZXhQYXJhbWV0ZXJpKGkscC5URVhUVVJFX01BR19GSUxURVIscC5ORUFSRVNUKX0pLGNhbGxBbmRDaGVjayhwLGZ1bmN0aW9uKCl7cmV0dXJuIHAudGV4SW1hZ2UyRChpLDAscixlLHQsMCxuLG8sbnVsbCl9KSxjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLmJpbmRUZXh0dXJlKHAuVEVYVFVSRV8yRCxudWxsKX0pLGF9ZnVuY3Rpb24gY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUoYSxlLHQscil7dmFyIG49Z2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChlLHQpO3JldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGEsblswXSxuWzFdLHIuaW50ZXJuYWxGb3JtYXRGbG9hdCxyLnRleHR1cmVGb3JtYXRGbG9hdCxhLkZMT0FUKX1mdW5jdGlvbiBjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZShhLGUsdCxyKXt2YXIgbj1nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KGUsdCk7cmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoYSxuWzBdLG5bMV0sci5pbnRlcm5hbEZvcm1hdEZsb2F0LHIudGV4dHVyZUZvcm1hdEZsb2F0LHIudGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIGNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKGEsZSx0KXt2YXIgbj1nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KGUsdCk7cmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoYSxuWzBdLG5bMV0sYS5SR0JBLGEuUkdCQSxhLlVOU0lHTkVEX0JZVEUpfWZ1bmN0aW9uIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoYSxlLHQscil7dmFyIG49Z2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQoZSx0KTtyZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShhLG5bMF0sblsxXSxyLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQsYS5SR0JBLGEuRkxPQVQpfWZ1bmN0aW9uIGNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlKGEsZSx0LHIpe3ZhciBuPWdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KGUsdCk7cmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoYSxuWzBdLG5bMV0sci5pbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCxhLlJHQkEsci50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGEsZSx0KXtyZXR1cm4gY2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5iaW5kQnVmZmVyKGEuQVJSQVlfQlVGRkVSLHQpfSksYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShhLGUsXCJjbGlwU3BhY2VQb3NcIix0LDMsMjAsMCkmJmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoYSxlLFwidXZcIix0LDIsMjAsMTIpfWZ1bmN0aW9uIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShhLGUsdCl7Y2FsbEFuZENoZWNrKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5iaW5kVGV4dHVyZShhLlRFWFRVUkVfMkQsZSl9KSxjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLnRleEltYWdlMkQoYS5URVhUVVJFXzJELDAsYS5SR0JBLGEuUkdCQSxhLlVOU0lHTkVEX0JZVEUsdCl9KSxjYWxsQW5kQ2hlY2soYSxmdW5jdGlvbigpe3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCxudWxsKX0pfWZ1bmN0aW9uIHVwbG9hZERhdGFUb1RleHR1cmUocyxlLHQscixuLG8pe3ZhbGlkYXRlVGV4dHVyZVNpemUodCxyKSxjYWxsQW5kQ2hlY2socyxmdW5jdGlvbigpe3JldHVybiBzLmJpbmRUZXh0dXJlKHMuVEVYVFVSRV8yRCxlKX0pLGNhbGxBbmRDaGVjayhzLGZ1bmN0aW9uKCl7cmV0dXJuIHMudGV4U3ViSW1hZ2UyRChzLlRFWFRVUkVfMkQsMCwwLDAsdCxyLG8scy5GTE9BVCxuKX0pLGNhbGxBbmRDaGVjayhzLGZ1bmN0aW9uKCl7cmV0dXJuIHMuYmluZFRleHR1cmUocy5URVhUVVJFXzJELG51bGwpfSl9ZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9UZXh0dXJlKHAsZSx0LHIsbixvLGEpe3ZhciBpPWdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQodCxyKSxkPWlbMF0sbD1pWzFdLHU7MT09PWEuZGVmYXVsdE51bUNoYW5uZWxzP3U9bjplbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkobix1PW5ldyBGbG9hdDMyQXJyYXkoZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShuLmxlbmd0aCxvKSksbyksdXBsb2FkRGF0YVRvVGV4dHVyZShwLGUsZCxsLHUsYS50ZXh0dXJlRm9ybWF0RmxvYXQpfWZ1bmN0aW9uIHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShpLGUsdCxyLG4sbyl7dmFyIGE9Z2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocixuKSxzPWFbMF0scD1hWzFdLGw9bmV3IEZsb2F0MzJBcnJheShnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHIsbikpO2VuY29kZU1hdHJpeFRvUGFja2VkUkdCQShvLHQscixuLGwpLHVwbG9hZERhdGFUb1RleHR1cmUoaSxlLHMscCxsLGkuUkdCQSl9ZnVuY3Rpb24gbWF5YmVDcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZShwLGUsdCxyLG4pe3ZhciBvPWU7aWYoMj09PUVOVi5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpKXt2YXIgbD1wLGk9bC5jcmVhdGVCdWZmZXIoKTtjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLmJpbmRCdWZmZXIobC5QSVhFTF9QQUNLX0JVRkZFUixpKX0pO3ZhciBzPTQqZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZSh0KnIsbi5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKTtjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLmJ1ZmZlckRhdGEobC5QSVhFTF9QQUNLX0JVRkZFUixzLHAuU1RBVElDX0RSQVcpfSksY2FsbEFuZENoZWNrKHAsZnVuY3Rpb24oKXtyZXR1cm4gbC5yZWFkUGl4ZWxzKDAsMCxyLHQscC5SR0JBLHAuRkxPQVQsMCl9KSxjYWxsQW5kQ2hlY2socCxmdW5jdGlvbigpe3JldHVybiBwLmJpbmRCdWZmZXIobC5QSVhFTF9QQUNLX0JVRkZFUixudWxsKX0pLG89aX1yZXR1cm4gb31mdW5jdGlvbiBkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKHAsZSx0LHIsbil7dmFyIG89cCxhPW5ldyBGbG9hdDMyQXJyYXkoZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZSh0KnIsbi5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKSk7by5iaW5kQnVmZmVyKHAuQVJSQVlfQlVGRkVSLGUpLG8uZ2V0QnVmZmVyU3ViRGF0YShwLkFSUkFZX0JVRkZFUiwwLGEpLG8uYmluZEJ1ZmZlcihwLkFSUkFZX0JVRkZFUixudWxsKTt2YXIgaT1uZXcgRmxvYXQzMkFycmF5KHQqcik7cmV0dXJuIGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5KGEsaSxuLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpLGl9ZnVuY3Rpb24gZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbU91dHB1dFRleHR1cmUocCxlLHQscil7dmFyIG49Z2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChlLHQpLG89blswXSxhPW5bMV0saT1uZXcgRmxvYXQzMkFycmF5KGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUoZSp0LHIuZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscykpO2NhbGxBbmRDaGVjayhwLGZ1bmN0aW9uKCl7cmV0dXJuIHAucmVhZFBpeGVscygwLDAsbyxhLHIuZG93bmxvYWRUZXh0dXJlRm9ybWF0LHAuRkxPQVQsaSl9KTt2YXIgcz1uZXcgRmxvYXQzMkFycmF5KGUqdCk7cmV0dXJuIGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5KGkscyxyLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpLHN9ZnVuY3Rpb24gZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmUocCxlLHQscil7dmFyIG49Z2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChlLHQpLG89blswXSxhPW5bMV0saT1uZXcgVWludDhBcnJheShnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKGUqdCw0KSk7cmV0dXJuIGNhbGxBbmRDaGVjayhwLGZ1bmN0aW9uKCl7cmV0dXJuIHAucmVhZFBpeGVscygwLDAsbyxhLHIuZG93bmxvYWRUZXh0dXJlRm9ybWF0LHAuVU5TSUdORURfQllURSxpKX0pLG5ldyBGbG9hdDMyQXJyYXkoaS5idWZmZXIpfWZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoaSxlLHQscixuLG8pe3ZhciBhPWdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KG4sbykscz1hWzBdLGQ9YVsxXSxsPW5ldyBGbG9hdDMyQXJyYXkoZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShuLG8pKTtjYWxsQW5kQ2hlY2soaSxmdW5jdGlvbigpe3JldHVybiBpLnJlYWRQaXhlbHMoMCwwLHMsZCxpLlJHQkEsaS5GTE9BVCxsKX0pO3ZhciB1PW5ldyBGbG9hdDMyQXJyYXkoc2l6ZUZyb21TaGFwZShbZSx0LHJdKSk7cmV0dXJuIGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKGwsZSx0LHIsdSl9ZnVuY3Rpb24gYmluU2VhcmNoTGFzdFRydWUoYSl7Zm9yKHZhciBlPTAscz1hLmxlbmd0aC0xLGk9LTEscDtlPD1zOylwPWUrcz4+MSxhW3BdKCk/KGk9cCxlPXArMSk6cz1wLTE7cmV0dXJuIGl9ZnVuY3Rpb24gY29tcGlsZVByb2dyYW0obSxoLGUsdCl7Zm9yKHZhciBuPWgudXNlckNvZGUscj1lLm1hcChmdW5jdGlvbih0LGUpe3ZhciBhPXtsb2dpY2FsU2hhcGU6dC5zaGFwZSx0ZXhTaGFwZTp0LmlzVW5pZm9ybT9udWxsOnQudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06dC5pc1VuaWZvcm0saXNQYWNrZWQ6IXQuaXNVbmlmb3JtJiZ0LnRleERhdGEuaXNQYWNrZWR9O3JldHVybntuYW1lOmgudmFyaWFibGVOYW1lc1tlXSxzaGFwZUluZm86YX19KSxhPXIubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlSW5mb30pLG89e2xvZ2ljYWxTaGFwZTp0LnNoYXBlLHRleFNoYXBlOnQudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06ITEsaXNQYWNrZWQ6dC50ZXhEYXRhLmlzUGFja2VkfSxzPW1ha2VTaGFkZXIocixvLG4sITA9PT1oLnN1cHBvcnRzQnJvYWRjYXN0aW5nLGgudXNlc1BhY2tlZFRleHR1cmVzKSxpPW0uY3JlYXRlUHJvZ3JhbShzKSxsPXt9LHU9MCxjO3U8aC52YXJpYWJsZU5hbWVzLmxlbmd0aDt1KyspYz1oLnZhcmlhYmxlTmFtZXNbdV0sbFtjXT1tLmdldFVuaWZvcm1Mb2NhdGlvbihpLGMsITEpO3JldHVybntwcm9ncmFtOmgsc291cmNlOnMsd2ViR0xQcm9ncmFtOmksdW5pZm9ybUxvY2F0aW9uczpsLGdwZ3B1Om0saW5TaGFwZUluZm9zOmEsb3V0U2hhcGVJbmZvOm99fWZ1bmN0aW9uIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShhLHApe2lmKGEubGVuZ3RoIT09cC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggXCIrYS5sZW5ndGgrXCIgaW5wdXRzLCBidXQgd2FzIGV4ZWN1dGVkIHdpdGggXCIrcC5sZW5ndGgrXCIgaW5wdXRzXCIpO2EuZm9yRWFjaChmdW5jdGlvbih0LGUpe3ZhciByPXQubG9naWNhbFNoYXBlLG49cFtlXSxvPW4uc2hhcGU7aWYoIWFycmF5c0VxdWFsKHIsbykpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyBcIityK1wiIGFuZCBcIitvK1wiIG11c3QgbWF0Y2hcIik7aWYoIXQuaXNVbmlmb3JtfHwhbi5pc1VuaWZvcm0pe3ZhciBhPXQudGV4U2hhcGUsaT1uLmlzVW5pZm9ybT9udWxsOm4udGV4RGF0YS50ZXhTaGFwZTtpZighYXJyYXlzRXF1YWwoYSxpKSl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGUgY3VycmVudCBhcmdzLiBTaGFwZSBcIithK1wiIGFuZCBcIitpK1wiIG11c3QgbWF0Y2hcIil9fSl9ZnVuY3Rpb24gcnVuUHJvZ3JhbShwLGUsdCxyKXt2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0ocC5pblNoYXBlSW5mb3MsZSksdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKFtwLm91dFNoYXBlSW5mb10sW3RdKTt2YXIgbj10LnRleERhdGEudGV4dHVyZSxvPXQudGV4RGF0YS50ZXhTaGFwZSxsPXAuZ3BncHU7dC50ZXhEYXRhLmlzUGFja2VkP2wuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZShuLG9bMF0sb1sxXSk6bC5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKG4sb1swXSxvWzFdKSxsLnNldFByb2dyYW0ocC53ZWJHTFByb2dyYW0pLGUuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciByPXAucHJvZ3JhbS52YXJpYWJsZU5hbWVzW3RdLG49cC51bmlmb3JtTG9jYXRpb25zW3JdO2lmKG51bGwhPW4pe2lmKGUuaXNVbmlmb3JtKXtpZigxPT09c2l6ZUZyb21TaGFwZShlLnNoYXBlKSlsLmdsLnVuaWZvcm0xZihuLGUudW5pZm9ybVZhbHVlc1swXSk7ZWxzZXt2YXIgbz1lLnVuaWZvcm1WYWx1ZXM7byBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8KG89bmV3IEZsb2F0MzJBcnJheShvKSksbC5nbC51bmlmb3JtMWZ2KG4sbyl9cmV0dXJufXZhciBpPWUudGV4RGF0YS50ZXh0dXJlO2wuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGksbix0KX19KSxudWxsIT1yJiZyKGwscC53ZWJHTFByb2dyYW0pLGwuZXhlY3V0ZVByb2dyYW0oKX1mdW5jdGlvbiBtYWtlU2hhZGVyS2V5KHMsZSx0KXt2YXIgcj1cIlwiO2UuY29uY2F0KHQpLmZvckVhY2goZnVuY3Rpb24odCl7cis9dC5zaGFwZStcIl9cIisodC5pc1VuaWZvcm0/XCJ1bmlmb3JtXCI6dC50ZXhEYXRhLnRleFNoYXBlKX0pO3ZhciBwPXMudXNlckNvZGUsbz0oITA9PT1zLnN1cHBvcnRzQnJvYWRjYXN0aW5nKS50b1N0cmluZygpLGE9cy5jb25zdHJ1Y3Rvci5uYW1lO3JldHVybiBhKz1cIl9cIitvK1wiX1wiK3IrXCJfXCIrcH1mdW5jdGlvbiBnZXRWZWNDaGFubmVscyhhLGUpe3JldHVybltcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxlKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGErXCIuXCIrZX0pfWZ1bmN0aW9uIGdldENoYW5uZWxzKGEsZSl7cmV0dXJuIDE9PT1lP1thXTpnZXRWZWNDaGFubmVscyhhLGUpfWZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyQxKGEsZSl7aWYoMT09PWEpcmV0dXJuXCJyY1wiO2Zvcih2YXIgdD1cIlwiLG89MDtvPGE7bysrKXQrPWVbb10sbzxhLTEmJih0Kz1cIixcIik7cmV0dXJuIHR9ZnVuY3Rpb24gZ2V0U291cmNlQ29vcmRzQXJyKHMsZSl7Zm9yKHZhciB0PVtdLHI9MDsxPj1yO3IrKylmb3IodmFyIHA9MDsxPj1wO3ArKyl7Zm9yKHZhciBsPSgwPT1yP1wiclwiOlwicnAxXCIpK1wiLCBcIisoMD09cD9cImNcIjpcImNwMVwiKSxkPTI7ZDxzO2QrKylsPWVbZS5sZW5ndGgtMS1kXStcIixcIitsO3QucHVzaChsKX1yZXR1cm4gdH1mdW5jdGlvbiBnZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihhLGUsdCl7aWYoMT09PWEpcmV0dXJuXCJyYyA+IFwiK2VbMF07Zm9yKHZhciByPVwiXCIscz1hLTI7czxhO3MrKylyKz10W3NdK1wiID49IFwiK2Vbc10sczxhLTEmJihyKz1cInx8XCIpO3JldHVybiByfWZ1bmN0aW9uIGdldFNldHVwKGEsZSx0LHIpe2lmKDE9PT1hKXJldHVyblwiXCI7dmFyIG49ci5zbGljZSgtMik7cmV0dXJuXCJcXG4gICAgaW50IHIgPSBcIituWzBdK1wiO1xcbiAgICBpbnQgYyA9IFwiK25bMV0rXCI7XFxuICAgIGludCBycDEgPSByICsgMTtcXG4gICAgaW50IGNwMSA9IGMgKyAxO1xcblxcbiAgICBib29sIGNFZGdlID0gY3AxID49IFwiK2UrXCI7XFxuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gXCIrdCtcIjtcXG4gIFwifWZ1bmN0aW9uIGdldE91dHB1dChhLGUpe3ZhciB0PWEubGVuZ3RoLHI9Z2V0U291cmNlQ29vcmRzQXJyKHQsZSk7cmV0dXJuIDE9PT10P1wiZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49IFwiK2FbMF0rXCIgPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwXCI6XCJnZXRBKFwiK3JbMF0rXCIpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QShcIityWzFdK1wiKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoXCIrclsyXStcIiksXFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKFwiK3JbM10rXCIpXCJ9ZnVuY3Rpb24gZ2V0RmxhdEluZGV4KHQpe3JldHVyblwiXFxuICAgIGludCBnZXRGbGF0SW5kZXgoaXZlYzMgY29vcmRzKSB7XFxuICAgICAgcmV0dXJuIHJvdW5kKFwiK2RvdGlmeShbXCJjb29yZHMueFwiLFwiY29vcmRzLnlcIixcImNvb3Jkcy56XCJdLGNvbXB1dGVTdHJpZGVzKHQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50b1N0cmluZygpfSkuY29uY2F0KFtcIjEuXCJdKSkrXCIpO1xcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBnZXRSZXNoYXBlZElucHV0Q29vcmRzKHQpe3JldHVyblwiXFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xcbiAgICAgIFwiK2dldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoW1wiclwiLFwiY1wiLFwiZFwiXSx0KStcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gZ2V0Q29vcmRzJDEodCl7aWYoMT09PXQpcmV0dXJuXCJzb3VyY2VMb2NcIjtpZigyPT09dClyZXR1cm5cInNvdXJjZUxvYy54LCBzb3VyY2VMb2MueVwiO2lmKDM9PT10KXJldHVyblwic291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2MuelwiO2lmKDQ9PT10KXJldHVyblwic291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2Mueiwgc291cmNlTG9jLndcIjt0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX1mdW5jdGlvbiBnZXRQaHlzaWNhbEZyb21Mb2dpY2FsVGV4dHVyZVR5cGUoYSxlKXtpZihlKXJldHVybiBFTlYuZ2V0KFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT9QaHlzaWNhbFRleHR1cmVUeXBlLlBBQ0tFRF8yWDJfRkxPQVQzMjpQaHlzaWNhbFRleHR1cmVUeXBlLlBBQ0tFRF8yWDJfRkxPQVQxNjtpZihhPT09VGV4dHVyZVVzYWdlLkRPV05MT0FEfHxhPT09VGV4dHVyZVVzYWdlLlBJWEVMUylyZXR1cm4gUGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU7aWYoYT09PVRleHR1cmVVc2FnZS5VUExPQUQpcmV0dXJuIFBoeXNpY2FsVGV4dHVyZVR5cGUuVU5QQUNLRURfRkxPQVQzMjtpZihhPT09VGV4dHVyZVVzYWdlLlJFTkRFUilyZXR1cm4gRU5WLmdldChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/UGh5c2ljYWxUZXh0dXJlVHlwZS5VTlBBQ0tFRF9GTE9BVDMyOlBoeXNpY2FsVGV4dHVyZVR5cGUuVU5QQUNLRURfRkxPQVQxNjt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGxvZ2ljYWwgdGV4dHVyZSB0eXBlIFwiK2EpfWZ1bmN0aW9uIGdldEtleUZyb21UZXh0dXJlU2hhcGUoYSxlLHQpe3JldHVybiBhWzBdK1wiX1wiK2FbMV0rXCJfXCIrZStcIl9cIit0fWZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyQyKGEpe3ZhciBlPWEubGVuZ3RoO2lmKDU8ZSl0aHJvdyBFcnJvcihcIlRpbGUgZm9yIHJhbmsgXCIrZStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09ZSlyZXR1cm5cImltb2QocmVzUkMsIFwiK2FbMF0rXCIpXCI7Zm9yKHZhciB0PVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIl0scj1bXSxuPTA7bjxhLmxlbmd0aDtuKyspci5wdXNoKFwiaW1vZChcIit0W25dK1wiLCBcIithW25dK1wiKVwiKTtyZXR1cm4gci5qb2luKCl9ZnVuY3Rpb24gZ2V0U3dpdGNoZWRDb29yZHMoYSl7dmFyIGU9YS5sZW5ndGg7aWYoNjxlKXRocm93IEVycm9yKFwiVHJhbnNwb3NlIGZvciByYW5rIFwiK2UrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7Zm9yKHZhciB0PVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIixcInJlc1JDLnZcIl0scj1BcnJheShlKSxuPTA7bjxhLmxlbmd0aDtuKyspclthW25dXT10W25dO3JldHVybiByLmpvaW4oKX1mdW5jdGlvbiBTVEVQKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxcImlmIChpc05hTih4KSkgcmV0dXJuIHg7XFxuICAgIHJldHVybiB4ID4gMC4wID8gMS4wIDogZmxvYXQoXCIrdCtcIik7XFxuICBcIn1mdW5jdGlvbiBjb25jYXQxZF8odCl7cmV0dXJuIGNvbmNhdCh0LDApfWZ1bmN0aW9uIGNvbmNhdDJkXyhhLGUpe3JldHVybiBjb25jYXQoYSxlKX1mdW5jdGlvbiBjb25jYXQzZF8oYSxlKXtyZXR1cm4gY29uY2F0KGEsZSl9ZnVuY3Rpb24gY29uY2F0NGRfKGEsZSl7cmV0dXJuIGNvbmNhdChhLGUpfWZ1bmN0aW9uIGNvbmNhdF8ocyxpKXt2b2lkIDA9PT1pJiYoaT0wKSxhc3NlcnQoMTw9cy5sZW5ndGgsXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gY29uY2F0XCIpO3ZhciBwPWNvbnZlcnRUb1RlbnNvckFycmF5KHMsXCJ0ZW5zb3JzXCIsXCJjb25jYXRcIik7aT1wYXJzZUF4aXNQYXJhbShpLHBbMF0uc2hhcGUpWzBdO3ZhciBlPWNvbXB1dGVPdXRTaGFwZShwLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pLGkpO2lmKDA9PT1zaXplRnJvbVNoYXBlKGUpKXJldHVybiB0ZW5zb3IoW10sZSk7aWYoMT09PShwPXAuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiAwPHQuc2l6ZX0pKS5sZW5ndGgpcmV0dXJuIHBbMF07dmFyIG49cC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KTthc3NlcnRQYXJhbXNDb25zaXN0ZW50KG4saSk7dmFyIG89cDtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29uY2F0KHAsaSl9LG8sZnVuY3Rpb24odCl7dmFyIGU9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbaV19KTtyZXR1cm4gc3BsaXQkMSh0LGUsaSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX0pfSl9ZnVuY3Rpb24gc3BsaXRfKGEsZSx0KXt2b2lkIDA9PT10JiYodD0wKTt2YXIgcz1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInNwbGl0XCIpLG87cmV0dXJuIHQ9cGFyc2VBeGlzUGFyYW0odCxzLnNoYXBlKVswXSxcIm51bWJlclwiPT10eXBlb2YgZT8oYXNzZXJ0KDA9PXMuc2hhcGVbdF0lZSxcIk51bWJlciBvZiBzcGxpdHMgbXVzdCBldmVubHkgZGl2aWRlIHRoZSBheGlzLlwiKSxvPUFycmF5KGUpLmZpbGwocy5zaGFwZVt0XS9lKSk6KGFzc2VydChzLnNoYXBlW3RdPT09ZS5yZWR1Y2UoZnVuY3Rpb24oYSxlKXtyZXR1cm4gYStlfSksXCJUaGUgc3VtIG9mIHNpemVzIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGF4aXMgZGltZW5zaW9uLlwiKSxvPWUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLnNwbGl0KHMsbyx0KX0seyR4OnN9LGZ1bmN0aW9uKGEpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBjb25jYXQoYSx0KX19fSl9ZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoYSxlKXtyZXR1cm4gYShlPXtleHBvcnRzOnt9fSxlLmV4cG9ydHMpLGUuZXhwb3J0c31mdW5jdGlvbiBjbG9uZV8oYSl7dmFyIGU9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJjbG9uZVwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oKXtyZXR1cm4gVGVuc29yLm1ha2UoZS5zaGFwZSx7ZGF0YUlkOmUuZGF0YUlkfSxlLmR0eXBlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnRvRmxvYXQoKX19fSl9ZnVuY3Rpb24gZXllXyhwLGUsbCxyKXt2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksbnVsbD09ZSYmKGU9cCk7Zm9yKHZhciBkPWJ1ZmZlcihbcCxlXSxyKSxvPXA8PWU/cDplLGE9MDthPG87KythKWQuc2V0KDEsYSxhKTt2YXIgdT1kLnRvVGVuc29yKCkuYXMyRChwLGUpO2lmKG51bGw9PWwpcmV0dXJuIHU7aWYoMT09PWwubGVuZ3RoKXJldHVybiB0aWxlKGV4cGFuZERpbXModSwwKSxbbFswXSwxLDFdKTtpZigyPT09bC5sZW5ndGgpcmV0dXJuIHRpbGUoZXhwYW5kRGltcyhleHBhbmREaW1zKHUsMCksMCksW2xbMF0sbFsxXSwxLDFdKTtpZigzPT09bC5sZW5ndGgpcmV0dXJuIHRpbGUoZXhwYW5kRGltcyhleHBhbmREaW1zKGV4cGFuZERpbXModSwwKSwwKSwwKSxbbFswXSxsWzFdLGxbMl0sMSwxXSk7dGhyb3cgbmV3IEVycm9yKFwiZXllKCkgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgMUQgYW5kIDJEIGJhdGNoU2hhcGVzLCBidXQgcmVjZWl2ZWQgXCIrbC5sZW5ndGgrXCJELlwiKX1mdW5jdGlvbiByYW5kb21Ob3JtYWxfKHAsZSxsLGQsbil7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09bCYmKGw9MSksbnVsbCE9ZCYmXCJib29sXCI9PT1kKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIitkKTtmb3IodmFyIG89bmV3IE1QUmFuZEdhdXNzKGUsbCxkLCExLG4pLGE9YnVmZmVyKHAsZCksaT0wO2k8YS52YWx1ZXMubGVuZ3RoO2krKylhLnZhbHVlc1tpXT1vLm5leHRWYWx1ZSgpO3JldHVybiBhLnRvVGVuc29yKCl9ZnVuY3Rpb24gdHJ1bmNhdGVkTm9ybWFsXyhwLGUsbCxkLG4pe2lmKHZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PWwmJihsPTEpLG51bGwhPWQmJlwiYm9vbFwiPT09ZCl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXCIrZCk7Zm9yKHZhciBvPW5ldyBNUFJhbmRHYXVzcyhlLGwsZCwhMCxuKSxhPWJ1ZmZlcihwLGQpLGk9MDtpPGEudmFsdWVzLmxlbmd0aDtpKyspYS52YWx1ZXNbaV09by5uZXh0VmFsdWUoKTtyZXR1cm4gYS50b1RlbnNvcigpfWZ1bmN0aW9uIHJhbmRvbVVuaWZvcm1fKHMsZSxpLHApe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PWkmJihpPTEpLHZvaWQgMD09PXAmJihwPVwiZmxvYXQzMlwiKTtmb3IodmFyIGw9YnVmZmVyKHMscCksbz0wO288bC52YWx1ZXMubGVuZ3RoO28rKylsLnZhbHVlc1tvXT1yYW5kVW5pZm9ybShlLGkpO3JldHVybiBsLnRvVGVuc29yKCl9ZnVuY3Rpb24gcmFuZF8ocyxlLHQpe3ZhciByPXNpemVGcm9tU2hhcGUocyksbj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dCluPW5ldyBGbG9hdDMyQXJyYXkocik7ZWxzZSBpZihcImludDMyXCI9PT10KW49bmV3IEludDMyQXJyYXkocik7ZWxzZXtpZihcImJvb2xcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrdCk7bj1uZXcgVWludDhBcnJheShyKX1mb3IodmFyIGk9MDtpPHI7aSsrKW5baV09ZSgpO3JldHVybiBUZW5zb3IubWFrZShzLHt2YWx1ZXM6bn0sdCl9ZnVuY3Rpb24gbXVsdGlub21pYWxfKHAsbCx0LGQpe3ZvaWQgMD09PWQmJihkPSExKTt2YXIgZT1jb252ZXJ0VG9UZW5zb3IocCxcImxvZ2l0c1wiLFwibXVsdGlub21pYWxcIiksbz1lLnNpemUsYT1lLnJhbms7aWYoMj5vKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG11bHRpbm9taWFsOiB5b3UgbmVlZCBhdCBsZWFzdCAyIG91dGNvbWVzLCBidXQgZ290IFwiK28rXCIuXCIpO2lmKDI8YSl0aHJvdyBuZXcgRXJyb3IoXCJSYW5rIG9mIHByb2JhYmlsaXRpZXMgbXVzdCBiZSAxIG9yIDIsIGJ1dCBpcyBcIithKTt0PXR8fE1hdGgucmFuZG9tKCk7dmFyIGk9MT09PWE/ZS5hczJEKDEsLTEpOmUscz1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5tdWx0aW5vbWlhbChpLGQsbCx0KX0se2xvZ2l0czJEOml9KTtyZXR1cm4gMT09PWE/cy5hczFEKCk6c31mdW5jdGlvbiBvbmVIb3RfKGEscyx0LGkpe3ZvaWQgMD09PXQmJih0PTEpLHZvaWQgMD09PWkmJihpPTApO3ZhciBwPWNvbnZlcnRUb1RlbnNvcihhLFwiaW5kaWNlc1wiLFwib25lSG90XCIsXCJpbnQzMlwiKTtpZihhc3NlcnQoXCJpbnQzMlwiPT09cC5kdHlwZSxcIkluZGljZXMgbXVzdCBiZSBvZiBkdHlwZSBgaW50MzJgXCIpLDI+cyl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBvbmVIb3Q6IGRlcHRoIG11c3QgYmUgPj0yLCBidXQgaXQgaXMgXCIrcyk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLm9uZUhvdChwLHMsdCxpKX0seyRpbmRpY2VzOnB9LGZ1bmN0aW9uKCl7cmV0dXJueyRpbmRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHplcm9zTGlrZShwKX19fSl9ZnVuY3Rpb24gZnJvbVBpeGVsc18oYSxlKXtpZih2b2lkIDA9PT1lJiYoZT0zKSw0PGUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBUZW5zb3Igd2l0aCBtb3JlIHRoYW4gNCBjaGFubmVscyBmcm9tIHBpeGVscy5cIik7cmV0dXJuIEVOVi5lbmdpbmUuZnJvbVBpeGVscyhhLGUpfWZ1bmN0aW9uIHRvUGl4ZWxzKGIsZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxOLEksUyxDLGssUixELFAsQSxfLE8sTCx6LE0sRixCLFYsVSxXO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGEpe3N3aXRjaChhLmxhYmVsKXtjYXNlIDA6aWYoMiE9PSh0PWNvbnZlcnRUb1RlbnNvcihiLFwiaW1nXCIsXCJ0b1BpeGVsc1wiLFwiaW50MzJcIikpLnJhbmsmJjMhPT10LnJhbmspdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyByYW5rIDIgb3IgMyB0ZW5zb3JzLCBnb3QgcmFuayBcIit0LnJhbmsrXCIuXCIpO2lmKE49dC5zaGFwZS5zbGljZSgwLDIpLEk9TlswXSxTPU5bMV0sNDwoQz0yPT09dC5yYW5rPzE6dC5zaGFwZVsyXSl8fDI9PT1DKXRocm93IG5ldyBFcnJvcihcInRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgZGVwdGggb2Ygc2l6ZSAxLCAzIG9yIDQgYnV0IGdvdCBcIitDKTtyZXR1cm4gaz10Lm1pbigpLFI9dC5tYXgoKSxbNCxrLmRhdGEoKV07Y2FzZSAxOnJldHVybiBEPWEuc2VudCgpWzBdLFs0LFIuZGF0YSgpXTtjYXNlIDI6aWYoIShQPWEuc2VudCgpWzBdLGsuZGlzcG9zZSgpLFIuZGlzcG9zZSgpLFwiZmxvYXQzMlwiPT09dC5kdHlwZSkpe2lmKFwiaW50MzJcIiE9PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdG9QaXhlbHM6IFwiK3QuZHR5cGUrXCIuIFBsZWFzZSB1c2UgZmxvYXQzMiBvciBpbnQzMiB0ZW5zb3JzLlwiKTtpZigwPkR8fDI1NTxQKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgaW50MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMjU1XSBidXQgZ290IHJhbmdlIFtcIitEK1wiIC0gXCIrUCtcIl0uXCIpfWVsc2UgaWYoMD5EfHwxPFApdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIHZhbHVlcyBmb3IgYSBmbG9hdDMyIFRlbnNvciBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDFdIGJ1dCBnb3QgcmFuZ2UgW1wiK0QrXCIgLSBcIitQK1wiXS5cIik7cmV0dXJuWzQsdC5kYXRhKCldO2Nhc2UgMzpmb3IoQT1hLnNlbnQoKSxfPVwiZmxvYXQzMlwiPT09dC5kdHlwZT8yNTU6MSxPPW5ldyBVaW50OENsYW1wZWRBcnJheSg0KihTKkkpKSxMPTA7TDxJKlM7KytMKXo9dm9pZCAwLE09dm9pZCAwLEY9dm9pZCAwLEI9dm9pZCAwLDE9PT1DPyh6PUFbTF0qXyxNPUFbTF0qXyxGPUFbTF0qXyxCPTI1NSk6Mz09PUM/KHo9QVszKkxdKl8sTT1BWzMqTCsxXSpfLEY9QVszKkwrMl0qXyxCPTI1NSk6ND09PUMmJih6PUFbNCpMXSpfLE09QVs0KkwrMV0qXyxGPUFbNCpMKzJdKl8sQj1BWzQqTCszXSpfKSxPWyhWPTQqTCkrMF09X01hdGhyb3VuZCh6KSxPW1YrMV09X01hdGhyb3VuZChNKSxPW1YrMl09X01hdGhyb3VuZChGKSxPW1YrM109X01hdGhyb3VuZChCKTtyZXR1cm4gbnVsbCE9ZSYmKGUud2lkdGg9UyxlLmhlaWdodD1JLFU9ZS5nZXRDb250ZXh0KFwiMmRcIiksVz1uZXcgSW1hZ2VEYXRhKE8sUyxJKSxVLnB1dEltYWdlRGF0YShXLDAsMCkpLHQhPT1iJiZ0LmRpc3Bvc2UoKSxbMixPXTt9fSl9KX1mdW5jdGlvbiByZXNoYXBlXyhhLG4pe3ZhciBvPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwicmVzaGFwZVwiKTtyZXR1cm4gbj1pbmZlckZyb21JbXBsaWNpdFNoYXBlKG4sby5zaXplKSxhc3NlcnQoby5zaXplPT09c2l6ZUZyb21TaGFwZShuKSxcIm5ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCIpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc2hhcGUobyxuKX0seyR4Om99LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnJlc2hhcGUoby5zaGFwZSl9fX0pfWZ1bmN0aW9uIHNxdWVlemVfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJzcXVlZXplXCIpO3JldHVybiByZXNoYXBlKHQsc3F1ZWV6ZVNoYXBlKHQuc2hhcGUsZSkubmV3U2hhcGUpfWZ1bmN0aW9uIGNhc3RfKGEsbil7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJjYXN0XCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5jYXN0KHQsbil9LHskeDp0fSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9uZSgpfX19KX1mdW5jdGlvbiB0aWxlXyhhLHApe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwidGlsZVwiKTtyZXR1cm4gYXNzZXJ0KHQucmFuaz09PXAubGVuZ3RoLFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiK3QucmFuaytcIiBtdXN0IG1hdGNoIGxlbmd0aCBvZiByZXBzIFwiK3ArXCIuXCIpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLnRpbGUodCxwKX0seyR4OnR9LGZ1bmN0aW9uKHIpe3JldHVybnskeDpmdW5jdGlvbigpe3ZhciBlPXplcm9zTGlrZSh0KTtpZigxPT09dC5yYW5rKWZvcih2YXIgbD0wO2w8cFswXTsrK2wpZT1lLmFkZChyLnNsaWNlKFtsKnQuc2hhcGVbMF1dLFt0LnNoYXBlWzBdXSkpO2Vsc2UgaWYoMj09PXQucmFuaylmb3IobD0wO2w8cFswXTsrK2wpZm9yKHZhciBkPTA7ZDxwWzFdOysrZCllPWUuYWRkKHIuc2xpY2UoW2wqdC5zaGFwZVswXSxkKnQuc2hhcGVbMV1dLFt0LnNoYXBlWzBdLHQuc2hhcGVbMV1dKSk7ZWxzZSBpZigzPT09dC5yYW5rKWZvcihsPTA7bDxwWzBdOysrbClmb3IoZD0wO2Q8cFsxXTsrK2QpZm9yKHZhciB1PTA7dTxwWzJdOysrdSllPWUuYWRkKHIuc2xpY2UoW2wqdC5zaGFwZVswXSxkKnQuc2hhcGVbMV0sdSp0LnNoYXBlWzJdXSxbdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl1dKSk7ZWxzZXtpZig0IT09dC5yYW5rKXRocm93IG5ldyBFcnJvcihcIkdyYWRpZW50IGZvciB0aWxlIG9wZXJhdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHJhbmstXCIrdC5yYW5rK1wiIHRlbnNvcnMgeWV0LlwiKTtmb3IobD0wO2w8cFswXTsrK2wpZm9yKGQ9MDtkPHBbMV07KytkKWZvcih1PTA7dTxwWzJdOysrdSlmb3IodmFyIGM9MDtjPHBbM107KytjKWU9ZS5hZGQoci5zbGljZShbbCp0LnNoYXBlWzBdLGQqdC5zaGFwZVsxXSx1KnQuc2hhcGVbMl0sYyp0LnNoYXBlWzNdXSxbdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0sdC5zaGFwZVszXV0pKX1yZXR1cm4gZX19fSl9ZnVuY3Rpb24gcGFkMWRfKGEsZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksYXNzZXJ0KDI9PT1lLmxlbmd0aCxcIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyLlwiKSxwYWQoYSxbZV0sdCl9ZnVuY3Rpb24gcGFkMmRfKGEsZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksYXNzZXJ0KDI9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgsXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwiKSxwYWQoYSxlLHQpfWZ1bmN0aW9uIHBhZDNkXyhhLGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLGFzc2VydCgzPT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoJiYyPT09ZVsyXS5sZW5ndGgsXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwiKSxwYWQoYSxlLHQpfWZ1bmN0aW9uIHBhZDRkXyhhLGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLGFzc2VydCg0PT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoJiYyPT09ZVsyXS5sZW5ndGgmJjI9PT1lWzNdLmxlbmd0aCxcIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCIpLHBhZChhLGUsdCl9ZnVuY3Rpb24gcGFkXyhhLHMsdCl7dm9pZCAwPT09dCYmKHQ9MCk7dmFyIGk9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJwYWRcIik7aWYoMD09PWkucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJwYWQoc2NhbGFyKSBpcyBub3QgZGVmaW5lZC4gUGFzcyBub24tc2NhbGFyIHRvIHBhZFwiKTt2YXIgbj1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5wYWQoaSxzLHQpfSx7JHg6aX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuc2xpY2UobixpLnNoYXBlKX19fSl9ZnVuY3Rpb24gc3RhY2tfKHMscCl7dm9pZCAwPT09cCYmKHA9MCk7dmFyIGU9Y29udmVydFRvVGVuc29yQXJyYXkocyxcInRlbnNvcnNcIixcInN0YWNrXCIpO2lmKGFzc2VydCgxPD1lLmxlbmd0aCxcIlBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byB0Zi5zdGFja1wiKSwxPT09ZS5sZW5ndGgpcmV0dXJuIGVbMF0uZXhwYW5kRGltcyhwKTt2YXIgcj1lWzBdLnJhbmssbj1lWzBdLnNoYXBlLG89ZVswXS5kdHlwZTthc3NlcnQocDw9cixcIkF4aXMgbXVzdCBiZSA8PSByYW5rIG9mIHRoZSB0ZW5zb3JcIiksZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Fzc2VydFNoYXBlc01hdGNoKG4sdC5zaGFwZSxcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzXCIpfSksZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Fzc2VydChvPT09dC5kdHlwZSxcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgZHR5cGVzXCIpfSk7dmFyIGE9ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXhwYW5kRGltcyhwKX0pO3JldHVybiBjb25jYXQoYSxwKX1mdW5jdGlvbiBiYXRjaFRvU3BhY2VORF8oYSxzLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiYmF0Y2hUb1NwYWNlTkRcIiksZT1zLnJlZHVjZShmdW5jdGlvbihhLGUpe3JldHVybiBhKmV9KTtyZXR1cm4gYXNzZXJ0KHIucmFuaz49MStzLmxlbmd0aCxcImlucHV0IHJhbmsgaXMgXCIrci5yYW5rK1wiIGJ1dCBzaG91bGQgYmUgPiB0aGFuIGJsb2NrU2hhcGUubGVuZ3RoIFwiK3MubGVuZ3RoKSxhc3NlcnQodC5sZW5ndGg9PT1zLmxlbmd0aCxcImNyb3BzLmxlbmd0aCBpcyBcIit0Lmxlbmd0aCtcIiBidXQgc2hvdWxkIGJlIGVxdWFsIHRvIGJsb2NrU2hhcGUubGVuZ3RoICBcIitzLmxlbmd0aCksYXNzZXJ0KDA9PXIuc2hhcGVbMF0lZSxcImlucHV0IHRlbnNvciBiYXRjaCBpcyBcIityLnNoYXBlWzBdK1wiIGJ1dCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBwcm9kdWN0IG9mIHRoZSBlbGVtZW50cyBvZiBibG9ja1NoYXBlIFwiK3Muam9pbihcIiAqIFwiKStcIiA9PT0gXCIrZSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuYmF0Y2hUb1NwYWNlTkQocixzLHQpfSx7JHg6cn0sZnVuY3Rpb24oYSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGEuc3BhY2VUb0JhdGNoTkQocyx0KX19fSl9ZnVuY3Rpb24gc3BhY2VUb0JhdGNoTkRfKGEscyx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInNwYWNlVG9CYXRjaE5EXCIpO3JldHVybiBhc3NlcnQoci5yYW5rPj0xK3MubGVuZ3RoLFwiaW5wdXQgcmFuayBcIityLnJhbmsrXCIgc2hvdWxkIGJlID4gdGhhbiBbYmxvY2tTaGFwZV0gXCIrcy5sZW5ndGgpLGFzc2VydCh0Lmxlbmd0aD09PXMubGVuZ3RoLFwicGFkZGluZ3Muc2hhcGVbMF0gXCIrdC5sZW5ndGgrXCIgbXVzdCBiZSBlcXVhbCB0byBbYmxvY2tTaGFwZV0gXCIrcy5sZW5ndGgpLGFzc2VydChyLnNoYXBlLnJlZHVjZShmdW5jdGlvbihhLGUsbil7cmV0dXJuIDA8biYmbjw9cy5sZW5ndGg/YSYmMD09KGUrdFtuLTFdWzBdK3Rbbi0xXVsxXSklc1tuLTFdOmF9LCEwKSxcImlucHV0IHNwYXRpYWwgZGltZW5zaW9ucyBcIityLnNoYXBlLnNsaWNlKDEpK1wiIHdpdGggcGFkZGluZ3MgXCIrdC50b1N0cmluZygpK1wiIG11c3QgYmUgZGl2aXNpYmxlIGJ5IGJsb2NrU2hhcGVzIFwiK3MudG9TdHJpbmcoKSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3BhY2VUb0JhdGNoTkQocixzLHQpfSx7JHg6cn0sZnVuY3Rpb24oYSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGEuYmF0Y2hUb1NwYWNlTkQocyx0KX19fSl9ZnVuY3Rpb24gdW5zdGFja18ocCxkKXt2b2lkIDA9PT1kJiYoZD0wKTtmb3IodmFyIGM9Y29udmVydFRvVGVuc29yKHAsXCJ4XCIsXCJ1bnN0YWNrXCIpLGU9Yy5zaGFwZVtkXSxuPUFycmF5KGMucmFuay0xKS5maWxsKDApLGE9MCxvPTAsbTtvPGMucmFuaztvKyspbyE9PWQmJihuW2FdPWMuc2hhcGVbb10sYSsrKTttPUFycmF5KGUpLmZpbGwoMSk7dmFyIGg9QXJyYXkoYy5yYW5rKS5maWxsKDApLHU9Yy5zaGFwZS5zbGljZSgpO3JldHVybiBtLm1hcChmdW5jdGlvbih0KXt1W2RdPXQ7dmFyIGU9Yy5zbGljZShoLHUpO3JldHVybiBoW2RdKz10LGUucmVzaGFwZShuKX0pfWZ1bmN0aW9uIGN1bXN1bV8ocCxsLGQsYyl7dm9pZCAwPT09bCYmKGw9MCksdm9pZCAwPT09ZCYmKGQ9ITEpLHZvaWQgMD09PWMmJihjPSExKTt2YXIgZT1jb252ZXJ0VG9UZW5zb3IocCxcInhcIixcImN1bXN1bVwiKSxvPWdldEF4ZXNQZXJtdXRhdGlvbihbbHw9MF0sZS5yYW5rKSxhPWU7bnVsbCE9byYmKGE9ZS50cmFuc3Bvc2UobykpO3ZhciBtPWdldElubmVyTW9zdEF4ZXMoMSxlLnJhbmspWzBdLHM9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY3Vtc3VtKGEsbSxkLGMpfSx7cGVybXV0ZWRYOmF9LGZ1bmN0aW9uKHQpe3JldHVybntwZXJtdXRlZFg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5jdW1zdW0obCxkLCFjKX19fSk7cmV0dXJuIG51bGwhPW8mJihzPXMudHJhbnNwb3NlKG8pKSxzfWZ1bmN0aW9uIGV4cGFuZERpbXNfKGEsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG89Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJleHBhbmREaW1zXCIpO2Fzc2VydChlPD1vLnJhbmssXCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCIpO3ZhciByPW8uc2hhcGUuc2xpY2UoKTtyZXR1cm4gMD5lJiYoYXNzZXJ0KC0oby5yYW5rKzEpPD1lLFwiQXhpcyBtdXN0IGJlIGluIHRoZSBpbnRlcnZhbCBbXCIrLShvLnJhbmsrMSkrXCIsIFwiK28ucmFuaytcIl1cIiksZT1vLnJhbmsrZSsxKSxyLnNwbGljZShlLDAsMSkscmVzaGFwZShvLHIpfWZ1bmN0aW9uIGRlcHRoVG9TcGFjZV8ocyxwLHQpe3ZvaWQgMD09PXQmJih0PVwiTkhXQ1wiKTt2YXIgbD1jb252ZXJ0VG9UZW5zb3IocyxcInhcIixcImRlcHRoVG9TcGFjZVwiKSxlPVwiTkhXQ1wiPT09dD9sLnNoYXBlWzFdOmwuc2hhcGVbMl0sbj1cIk5IV0NcIj09PXQ/bC5zaGFwZVsyXTpsLnNoYXBlWzNdLGE9XCJOSFdDXCI9PT10P2wuc2hhcGVbM106bC5zaGFwZVsxXTtyZXR1cm4gYXNzZXJ0KDA8PWUqcCxcIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXFxuICAgICAgXCIrZStcIiBhbmQgXCIrcCtcIiAgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXFxuICAgICAgXCIrbC5zaGFwZSksYXNzZXJ0KDA8PW4qcCxcIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXFxuICAgICAgXCIrbitcIiBhbmQgXCIrcCtcIiBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGVcXG4gICAgICAgICAgXCIrbC5zaGFwZSksYXNzZXJ0KDA9PWElKHAqcCksXCJEaW1lbnNpb24gc2l6ZSBtdXN0IGJlIGV2ZW5seSBkaXZpc2libGUgYnkgXCIrcCpwK1wiIGJ1dCBpcyBcIithK1wiIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZSBcIitsLnNoYXBlKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5kZXB0aFRvU3BhY2UobCxwLHQpfSx7JHg6bH0pfWZ1bmN0aW9uIHNldGRpZmYxZEFzeW5jXyhtLGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsaCxnLGYseSxiLHgsTixJLGQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD1jb252ZXJ0VG9UZW5zb3IobSxcInhcIixcInNldGRpZmYxZFwiKSxoPWNvbnZlcnRUb1RlbnNvcihlLFwieVwiLFwic2V0ZGlmZjFkXCIpLGFzc2VydCh0LmR0eXBlPT09aC5kdHlwZSxcInggYW5kIHkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZHR5cGUsIGJ1dCBnb3QgeCAoXCIrdC5kdHlwZStcIikgYW5kIHkgKFwiK2guZHR5cGUrXCIpLlwiKSxhc3NlcnQoMT09PXQucmFuayxcInggc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB4IChcIit0LnNoYXBlK1wiKS5cIiksYXNzZXJ0KDE9PT1oLnJhbmssXCJ5IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeSAoXCIraC5zaGFwZStcIikuXCIpLFs0LHQuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIGc9YS5zZW50KCksWzQsaC5kYXRhKCldO2Nhc2UgMjpmb3IoZj1hLnNlbnQoKSx5PW5ldyBTZXQoZiksYj0wLEk9MDtJPGcubGVuZ3RoO0krKyl5LmhhcyhnW0ldKXx8YisrO2Zvcih4PW5ldyBUZW5zb3JCdWZmZXIoW2JdLHQuZHR5cGUpLE49bmV3IFRlbnNvckJ1ZmZlcihbYl0sXCJpbnQzMlwiKSxJPTAsZD0wO0k8Zy5sZW5ndGg7SSsrKXkuaGFzKGdbSV0pfHwoeC52YWx1ZXNbZF09Z1tJXSxOLnZhbHVlc1tkXT1JLGQrKyk7cmV0dXJuWzIsW3gudG9UZW5zb3IoKSxOLnRvVGVuc29yKCldXTt9fSl9KX1mdW5jdGlvbiBidWZmZXIoYSxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksbmV3IFRlbnNvckJ1ZmZlcihhLGUsbil9ZnVuY3Rpb24gcHJpbnQoYSxlKXt2b2lkIDA9PT1lJiYoZT0hMSksY29uc29sZS5sb2coYS50b1N0cmluZyhlKSl9ZnVuY3Rpb24gd2hlcmVJbXBsKHAsZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoO3IrKyllW3JdJiZ0LnB1c2gocik7dmFyIGw9YnVmZmVyKHAsXCJpbnQzMlwiKSxvPWJ1ZmZlcihbdC5sZW5ndGgscC5sZW5ndGhdLFwiaW50MzJcIik7Zm9yKHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGE9bC5pbmRleFRvTG9jKHRbcl0pLGk9cipwLmxlbmd0aDtvLnZhbHVlcy5zZXQoYSxpKX1yZXR1cm4gby50b1RlbnNvcigpfWZ1bmN0aW9uIGZsb2F0MzJUb1R5cGVkQXJyYXkoYSxlKXtpZihcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBhO2lmKFwiaW50MzJcIj09PWV8fFwiYm9vbFwiPT09ZSl7Zm9yKHZhciB0PVwiaW50MzJcIj09PWU/bmV3IEludDMyQXJyYXkoYS5sZW5ndGgpOm5ldyBVaW50OEFycmF5KGEubGVuZ3RoKSxyPTA7cjx0Lmxlbmd0aDsrK3IpdFtyXT1fTWF0aHJvdW5kKGFbcl0pO3JldHVybiB0fXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrZSl9ZnVuY3Rpb24gdHlwZWRBcnJheVRvRmxvYXQzMih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT90Om5ldyBGbG9hdDMyQXJyYXkodCl9ZnVuY3Rpb24gbmVnXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcIm5lZ1wiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubmVnKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubmVnKCl9fX0pfWZ1bmN0aW9uIGNlaWxfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiY2VpbFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2VpbChuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2UodCl9fX0pfWZ1bmN0aW9uIGZsb29yXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcImZsb29yXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5mbG9vcihuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2UodCl9fX0pfWZ1bmN0aW9uIHNpZ25fKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwic2lnblwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2lnbihuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2UodCl9fX0pfWZ1bmN0aW9uIHJvdW5kXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInJvdW5kXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yb3VuZChuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2UodCl9fX0pfWZ1bmN0aW9uIGV4cF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJleHBcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUodC5leHAobikpfSx7JHg6bn0sZnVuY3Rpb24oYSxlKXt2YXIgdD1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBhLm11bFN0cmljdCh0KX19fSl9ZnVuY3Rpb24gZXhwbTFfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiZXhwbTFcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmV4cG0xKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KG4uZXhwKCkpfX19KX1mdW5jdGlvbiBsb2dfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwibG9nXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2cobil9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3Qobi50b0Zsb2F0KCkpfX19KX1mdW5jdGlvbiBsb2cxcF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJsb2cxcFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9nMXAobil9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3Qobi5hZGQoc2NhbGFyKDEpKSl9fX0pfWZ1bmN0aW9uIHNxcnRfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwic3FydFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3FydChuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChuLnRvRmxvYXQoKS5zcXJ0KCkubXVsKHNjYWxhcigyKSkpfX19KX1mdW5jdGlvbiByc3FydF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJyc3FydFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucnNxcnQobil9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3Qobi5wb3coc2NhbGFyKDEuNSkpLm11bChzY2FsYXIoMikpKS5uZWcoKX19fSl9ZnVuY3Rpb24gc3F1YXJlXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInNxdWFyZVwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3F1YXJlKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KG4udG9GbG9hdCgpLm11bChzY2FsYXIoMikpKX19fSl9ZnVuY3Rpb24gcmVjaXByb2NhbF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJyZWNpcHJvY2FsXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWNpcHJvY2FsKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KG4uc3F1YXJlKCkubmVnKCkpfX19KX1mdW5jdGlvbiBhYnNfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiYWJzXCIpO3JldHVyblwiY29tcGxleDY0XCI9PT1uLmR0eXBlP0VOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbXBsZXhBYnMobil9LHskeDpufSk6RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWJzKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KG4udG9GbG9hdCgpLnN0ZXAoLTEpKX19fSl9ZnVuY3Rpb24gY2xpcEJ5VmFsdWVfKGEsbyx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcImNsaXBCeVZhbHVlXCIpO3JldHVybiBhc3NlcnQobzw9dCxcIkVycm9yIGluIGNsaXA6IG1pbiAoXCIrbytcIikgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4IChcIit0K1wiKS5cIiksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2xpcChyLG8sdCl9LHskeDpyfSxmdW5jdGlvbihhKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gYS53aGVyZShyLmdyZWF0ZXJFcXVhbChzY2FsYXIobykpLmxvZ2ljYWxBbmQoci5sZXNzRXF1YWwoc2NhbGFyKHQpKSksemVyb3NMaWtlKGEpKX19fSl9ZnVuY3Rpb24gc2lnbW9pZF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJzaWdtb2lkXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3JldHVybiBlKHQuc2lnbW9pZChuKSl9LHskeDpufSxmdW5jdGlvbihhLGUpe3ZhciB0PWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGEubXVsU3RyaWN0KHQubXVsKHNjYWxhcigxKS5zdWIodCkpKX19fSl9ZnVuY3Rpb24gbG9nU2lnbW9pZF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJsb2dTaWdtb2lkXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zb2Z0cGx1cyhuLm5lZygpKS5uZWcoKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChuLm5lZygpLnNpZ21vaWQoKSl9fX0pfWZ1bmN0aW9uIHNvZnRwbHVzXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInNvZnRwbHVzXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zb2Z0cGx1cyhuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChuLnNpZ21vaWQoKSl9fX0pfWZ1bmN0aW9uIHNpbl8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJzaW5cIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNpbihuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5jb3MoKS5tdWxTdHJpY3QodCl9fX0pfWZ1bmN0aW9uIGNvc18oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJjb3NcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvcyhuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5zaW4oKS5uZWcoKS5tdWxTdHJpY3QodCl9fX0pfWZ1bmN0aW9uIHRhbl8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJ0YW5cIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRhbihuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChuLmNvcygpLnNxdWFyZSgpKX19fSl9ZnVuY3Rpb24gYXNpbl8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJhc2luXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hc2luKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KHNjYWxhcigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pfWZ1bmN0aW9uIGFjb3NfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiYWNvc1wiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWNvcyhuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChzY2FsYXIoMSkuc3ViKG4udG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpLm5lZygpfX19KX1mdW5jdGlvbiBhdGFuXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcImF0YW5cIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF0YW4obil9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3Qoc2NhbGFyKDEpLmFkZChuLnRvRmxvYXQoKS5zcXVhcmUoKSkpfX19KX1mdW5jdGlvbiBzaW5oXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInNpbmhcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNpbmgobil9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuY29zaCgpLm11bFN0cmljdCh0KX19fSl9ZnVuY3Rpb24gY29zaF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJjb3NoXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb3NoKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLnNpbmgoKS5tdWxTdHJpY3QodCl9fX0pfWZ1bmN0aW9uIHRhbmhfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwidGFuaFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZSh0LnRhbmgobikpfSx7JHg6bn0sZnVuY3Rpb24oYSxlKXt2YXIgdD1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBzY2FsYXIoMSkuc3ViKHQuc3F1YXJlKCkpLm11bFN0cmljdChhKX19fSl9ZnVuY3Rpb24gYXNpbmhfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiYXNpbmhcIik7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFzaW5oKG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KHNjYWxhcigxKS5hZGQobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pfWZ1bmN0aW9uIGFjb3NoXyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcImFjb3NoXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hY29zaChuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChuLnRvRmxvYXQoKS5zcXVhcmUoKS5zdWIoc2NhbGFyKDEpKS5zcXJ0KCkpfX19KX1mdW5jdGlvbiBhdGFuaF8oYSl7dmFyIG49Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJhdGFuaFwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXRhbmgobil9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3Qoc2NhbGFyKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkpfX19KX1mdW5jdGlvbiBlcmZfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiZXJmXCIpO3JldHVybiBhc3NlcnQoXCJpbnQzMlwiPT09bi5kdHlwZXx8XCJmbG9hdDMyXCI9PT1uLmR0eXBlLFwiSW5wdXQgZHR5cGUgbXVzdCBiZSBgaW50MzJgIG9yIGBmbG9hdDMyYC5cIiksXCJpbnQzMlwiPT09bi5kdHlwZSYmKG49bi50b0Zsb2F0KCkpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmVyZihuKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChzY2FsYXIoMi9fTWF0aHNxcnQoTWF0aC5QSSkpLm11bChuLnNxdWFyZSgpLm5lZygpLmV4cCgpKSl9fX0pfWZ1bmN0aW9uIHN0ZXBfKGEsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIG89Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJzdGVwXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdGVwKG8sbil9LHskeDpvfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKHQpfX19KX1mdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb24yZF8ocCxlLHQscixkLG8pe3ZvaWQgMD09PXImJihyPS4wMDEpO3ZhciBhPWNvbnZlcnRUb1RlbnNvcihwLFwieFwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpLHU9Y29udmVydFRvVGVuc29yKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIiksbD1jb252ZXJ0VG9UZW5zb3IodCxcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIiksYyxtO3JldHVybiBudWxsIT1kJiYoYz1jb252ZXJ0VG9UZW5zb3IoZCxcInNjYWxlXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLG51bGwhPW8mJihtPWNvbnZlcnRUb1RlbnNvcihvLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLGFzc2VydCgyPT09YS5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK2EucmFuaytcIi5cIiksYXNzZXJ0KDI9PT11LnJhbmt8fDE9PT11LnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogbWVhbiBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIiksYXNzZXJ0KDI9PT1sLnJhbmt8fDE9PT1sLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCIpLG51bGwhPWMmJmFzc2VydCgyPT09Yy5yYW5rfHwxPT09Yy5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IHNjYWxlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwiKSxudWxsIT1tJiZhc3NlcnQoMj09PW0ucmFua3x8MT09PW0ucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIittLnJhbmsrXCIuXCIpLGJhdGNoTm9ybWFsaXphdGlvbihhLHUsbCxyLGMsbSl9ZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uM2RfKHAsZSx0LHIsZCxvKXt2b2lkIDA9PT1yJiYocj0uMDAxKTt2YXIgYT1jb252ZXJ0VG9UZW5zb3IocCxcInhcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSx1PWNvbnZlcnRUb1RlbnNvcihlLFwibWVhblwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpLGw9Y29udmVydFRvVGVuc29yKHQsXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpLGMsbTtyZXR1cm4gbnVsbCE9ZCYmKGM9Y29udmVydFRvVGVuc29yKGQsXCJzY2FsZVwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpKSxudWxsIT1vJiYobT1jb252ZXJ0VG9UZW5zb3IobyxcIm9mZnNldFwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpKSxhc3NlcnQoMz09PWEucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIithLnJhbmsrXCIuXCIpLGFzc2VydCgzPT09dS5yYW5rfHwxPT09dS5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG1lYW4gbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCIpLGFzc2VydCgzPT09bC5yYW5rfHwxPT09bC5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwiKSxudWxsIT1jJiZhc3NlcnQoMz09PWMucmFua3x8MT09PWMucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIiksbnVsbCE9bSYmYXNzZXJ0KDM9PT1tLnJhbmt8fDE9PT1tLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogb2Zmc2V0IG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbS5yYW5rK1wiLlwiKSxiYXRjaE5vcm1hbGl6YXRpb24oYSx1LGwscixjLG0pfWZ1bmN0aW9uIGJhdGNoTm9ybWFsaXphdGlvbjRkXyhwLGUsdCxyLGQsbyl7dm9pZCAwPT09ciYmKHI9LjAwMSk7dmFyIGE9Y29udmVydFRvVGVuc29yKHAsXCJ4XCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIiksdT1jb252ZXJ0VG9UZW5zb3IoZSxcIm1lYW5cIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSxsPWNvbnZlcnRUb1RlbnNvcih0LFwidmFyaWFuY2VcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSxjLG07cmV0dXJuIG51bGwhPWQmJihjPWNvbnZlcnRUb1RlbnNvcihkLFwic2NhbGVcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSksbnVsbCE9byYmKG09Y29udmVydFRvVGVuc29yKG8sXCJvZmZzZXRcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSksYXNzZXJ0KDQ9PT1hLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrYS5yYW5rK1wiLlwiKSxhc3NlcnQoND09PXUucmFua3x8MT09PXUucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBtZWFuIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwiKSxhc3NlcnQoND09PWwucmFua3x8MT09PWwucmFuayxcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIiksbnVsbCE9YyYmYXNzZXJ0KDQ9PT1jLnJhbmt8fDE9PT1jLnJhbmssXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogc2NhbGUgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCIpLG51bGwhPW0mJmFzc2VydCg0PT09bS5yYW5rfHwxPT09bS5yYW5rLFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK20ucmFuaytcIi5cIiksYmF0Y2hOb3JtYWxpemF0aW9uKGEsdSxsLHIsYyxtKX1mdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb25fKGQsZSx0LG0scixvKXt2b2lkIDA9PT1tJiYobT0uMDAxKTt2YXIgZz1jb252ZXJ0VG9UZW5zb3IoZCxcInhcIixcImJhdGNoTm9ybWFsaXphdGlvblwiKSxsPWNvbnZlcnRUb1RlbnNvcihlLFwibWVhblwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpLGM9Y29udmVydFRvVGVuc29yKHQsXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpLHAsYSx5O3JldHVybiBudWxsIT1yJiYocD1jb252ZXJ0VG9UZW5zb3IocixcInNjYWxlXCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLG51bGwhPW8mJihhPWNvbnZlcnRUb1RlbnNvcihvLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1hbGl6YXRpb25cIikpLGFzc2VydChsLnJhbms9PT1jLnJhbmssXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHZhcmlhbmNlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCIpLGFzc2VydChudWxsPT1hfHxsLnJhbms9PT1hLnJhbmssXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIG9mZnNldCB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSxhc3NlcnQobnVsbD09cHx8bC5yYW5rPT09cC5yYW5rLFwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBzY2FsZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSx5PTA9PT1nLnJhbmt8fDE9PT1nLnJhbms/Zy5hczREKDEsMSwxLGcuc2l6ZSk6Mj09PWcucmFuaz9nLmFzNEQoMSwxLGcuc2hhcGVbMF0sZy5zaGFwZVsxXSk6Mz09PWcucmFuaz9nLmFzNEQoMSxnLnNoYXBlWzBdLGcuc2hhcGVbMV0sZy5zaGFwZVsyXSk6ZyxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5iYXRjaE5vcm1hbGl6YXRpb24oeSxiYXRjaG5vcm1SZXNoYXBlNEQobCksYmF0Y2hub3JtUmVzaGFwZTREKGMpLG0sYmF0Y2hub3JtUmVzaGFwZTREKHApLGJhdGNobm9ybVJlc2hhcGU0RChhKSl9LHskeDpnLCRtZWFuOmwsJHZhcmlhbmNlOmMsJHNjYWxlOnAsJG9mZnNldDphfSxmdW5jdGlvbihpKXt2YXIgZT1udWxsPT1wP3NjYWxhcigxKTpwLHU9Z2V0UmVkdWN0aW9uQXhlcyhsLnNoYXBlLHkuc2hhcGUpLHQ9W107aWYoMT09PWwucmFuayl7Zm9yKHZhciBuPTA7bjx5LnNoYXBlLmxlbmd0aC0xOysrbil0LnB1c2goeS5zaGFwZVtuXSk7dC5wdXNoKDEpfXZhciByPWcuc3ViKGwpLG89aS5tdWwoZSkscz1yc3FydChjLmFkZChzY2FsYXIobSkpKSxkPXMubXVsKHMpLm11bChzKS5tdWwoc2NhbGFyKC0uNSkpO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiAxPT09bC5yYW5rP2kubXVsKHRpbGUocy5hczREKDEsMSwxLGwuc2hhcGVbMF0pLHQpKS5tdWwoZSkucmVzaGFwZShnLnNoYXBlKTppLm11bChzKS5tdWwoZSkucmVzaGFwZShnLnNoYXBlKX0sJG1lYW46ZnVuY3Rpb24oKXt2YXIgdD1zLm11bChzY2FsYXIoLTEpKS5tdWwobyk7cmV0dXJuIDE9PT1sLnJhbmsmJih0PXQuc3VtKHUpKSx0LnJlc2hhcGUobC5zaGFwZSl9LCR2YXJpYW5jZTpmdW5jdGlvbigpe3ZhciB0PWQubXVsKHIpLm11bChvKTtyZXR1cm4gMT09PWwucmFuayYmKHQ9dC5zdW0odSkpLHQucmVzaGFwZShsLnNoYXBlKX0sJHNjYWxlOmZ1bmN0aW9uKCl7dmFyIGU9ci5tdWwocyksdD1pLm11bChlKTtyZXR1cm4gMT09PWwucmFuayYmKHQ9dC5zdW0odSkpLHQucmVzaGFwZShsLnNoYXBlKX0sJG9mZnNldDpmdW5jdGlvbigpe3ZhciBlPWk7cmV0dXJuIDE9PT1sLnJhbmsmJihlPWUuc3VtKHUpKSxlLnJlc2hhcGUobC5zaGFwZSl9fX0pLnJlc2hhcGUoZy5zaGFwZSl9ZnVuY3Rpb24gYmF0Y2hub3JtUmVzaGFwZTREKHQpe3JldHVybiBudWxsPT10P251bGw6MD09PXQucmFuaz90LmFzMUQoKToxPT09dC5yYW5rP3Q6Mj09PXQucmFuaz90LmFzNEQoMSwxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk6Mz09PXQucmFuaz90LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSk6dH1mdW5jdGlvbiBjb21wdXRlUG9vbDJESW5mbyhwLGUsdCxyLG4sbyxhKXt2b2lkIDA9PT1hJiYoYT1cImNoYW5uZWxzTGFzdFwiKTt2YXIgZD1wYXJzZVR1cGxlUGFyYW0oZSksdT1kWzBdLGw9ZFsxXSxjO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1hKWM9W3UsbCxwWzNdLHBbM11dO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIithKTtjPVt1LGwscFsxXSxwWzFdXX1yZXR1cm4gY29tcHV0ZUNvbnYyREluZm8ocCxjLHQscixuLG8sITEsYSl9ZnVuY3Rpb24gY29tcHV0ZUNvbnYyREluZm8oSSxlLHQscixuLG8sYSxrKXt2b2lkIDA9PT1hJiYoYT0hMSksdm9pZCAwPT09ayYmKGs9XCJjaGFubmVsc0xhc3RcIik7dmFyIEQ9Wy0xLC0xLC0xLC0xXSx1PURbMF0sUD1EWzFdLE89RFsyXSxMPURbM107aWYoXCJjaGFubmVsc0xhc3RcIj09PWspdT1JWzBdLFA9SVsxXSxPPUlbMl0sTD1JWzNdO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1rKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitrKTt1PUlbMF0sTD1JWzFdLFA9SVsyXSxPPUlbM119dmFyIHo9ZVswXSxmPWVbMV0sbT1lWzNdLGc9cGFyc2VUdXBsZVBhcmFtKHQpLHY9Z1swXSx5PWdbMV0seD1wYXJzZVR1cGxlUGFyYW0ociksVD14WzBdLEU9eFsxXSx3PWdldEVmZmVjdGl2ZUZpbHRlclNpemUoeixUKSxTPWdldEVmZmVjdGl2ZUZpbHRlclNpemUoZixFKSxiPWdldFBhZEFuZE91dEluZm8obixQLE8sdix5LHcsUyxvKSxDPWIucGFkSW5mbyxfPWIub3V0SGVpZ2h0LEE9Yi5vdXRXaWR0aCxOPWE/bSpMOm0sUjtyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PWs/Uj1bdSxOLF8sQV06XCJjaGFubmVsc0xhc3RcIj09ayYmKFI9W3UsXyxBLE5dKSx7YmF0Y2hTaXplOnUsZGF0YUZvcm1hdDprLGluSGVpZ2h0OlAsaW5XaWR0aDpPLGluQ2hhbm5lbHM6TCxvdXRIZWlnaHQ6XyxvdXRXaWR0aDpBLG91dENoYW5uZWxzOk4scGFkSW5mbzpDLHN0cmlkZUhlaWdodDp2LHN0cmlkZVdpZHRoOnksZmlsdGVySGVpZ2h0OnosZmlsdGVyV2lkdGg6ZixlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6dyxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpTLGRpbGF0aW9uSGVpZ2h0OlQsZGlsYXRpb25XaWR0aDpFLGluU2hhcGU6SSxvdXRTaGFwZTpSLGZpbHRlclNoYXBlOmV9fWZ1bmN0aW9uIGNvbXB1dGVPdXRwdXRTaGFwZTNEKHAsZSx0LHIsbixkKXtudWxsPT1uJiYobj1jb21wdXRlRGVmYXVsdFBhZChwLGUscikpO3ZhciBhPXBbMF0saT1wWzFdLHM9Y29uZGl0aW9uYWxSb3VuZCgoYS1lKzIqbikvcisxLGQpO2Fzc2VydChpc0ludChzKSxcIlRoZSBvdXRwdXQgIyBvZiByb3dzIChcIitzK1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO3ZhciB1PWNvbmRpdGlvbmFsUm91bmQoKGktZSsyKm4pL3IrMSxkKTtyZXR1cm4gYXNzZXJ0KGlzSW50KHUpLFwiVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKFwiK3UrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIiksW3MsdSx0XX1mdW5jdGlvbiBjb21wdXRlRGVmYXVsdFBhZChhLGUsdCxyKXt2b2lkIDA9PT1yJiYocj0xKTt2YXIgcz1nZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGUscik7cmV0dXJuIF9NYXRoZmxvb3IoKGFbMF0qKHQtMSktdCtzKS8yKX1mdW5jdGlvbiBwYXJzZVR1cGxlUGFyYW0odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdF06dH1mdW5jdGlvbiBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGEsZSl7cmV0dXJuIDE+PWU/YTphKyhhLTEpKihlLTEpfWZ1bmN0aW9uIGdldFBhZEFuZE91dEluZm8obSxlLHQscixuLG8sYSxpKXt2YXIgcyx5LGI7aWYoXCJudW1iZXJcIj09dHlwZW9mIG0pe3M9e3RvcDptLGJvdHRvbTptLGxlZnQ6bSxyaWdodDptLHR5cGU6MD09PW0/XCJWQUxJRFwiOlwiTlVNQkVSXCJ9O3ZhciB4PWNvbXB1dGVPdXRwdXRTaGFwZTNEKFtlLHQsMV0sbywxLHIsbSxpKTt5PXhbMF0sYj14WzFdfWVsc2UgaWYoXCJzYW1lXCI9PT1tKXt2YXIgcD0oKHk9X01hdGhjZWlsKGUvcikpLTEpKnIrby1lLGQ9KChiPV9NYXRoY2VpbCh0L24pKS0xKSpuK2EtdCxoPV9NYXRoZmxvb3IocC8yKSxmPV9NYXRoZmxvb3IoZC8yKTtzPXt0b3A6aCxib3R0b206cC1oLGxlZnQ6ZixyaWdodDpkLWYsdHlwZTpcIlNBTUVcIn19ZWxzZXtpZihcInZhbGlkXCIhPT1tKXRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIrbSk7cz17dG9wOjAsYm90dG9tOjAsbGVmdDowLHJpZ2h0OjAsdHlwZTpcIlZBTElEXCJ9LHk9X01hdGhjZWlsKChlLW8rMSkvciksYj1fTWF0aGNlaWwoKHQtYSsxKS9uKX1yZXR1cm57cGFkSW5mbzpzLG91dEhlaWdodDp5LG91dFdpZHRoOmJ9fWZ1bmN0aW9uIGNvbmRpdGlvbmFsUm91bmQoYSxlKXtpZighZSlyZXR1cm4gYTtzd2l0Y2goZSl7Y2FzZVwicm91bmRcIjpyZXR1cm4gX01hdGhyb3VuZChhKTtjYXNlXCJjZWlsXCI6cmV0dXJuIF9NYXRoY2VpbChhKTtjYXNlXCJmbG9vclwiOnJldHVybiBfTWF0aGZsb29yKGEpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByb3VuZGluZ01vZGUgXCIrZSk7fX1mdW5jdGlvbiB0dXBsZVZhbHVlc0FyZU9uZShhKXt2YXIgZT1wYXJzZVR1cGxlUGFyYW0oYSksdD1lWzBdLHI9ZVsxXTtyZXR1cm4gMT09PXQmJjE9PT1yfWZ1bmN0aW9uIGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShhLGUpe3JldHVybiB0dXBsZVZhbHVlc0FyZU9uZShhKXx8dHVwbGVWYWx1ZXNBcmVPbmUoZSl9ZnVuY3Rpb24gbWF0TXVsXyh5LGUsdCxiKXt2b2lkIDA9PT10JiYodD0hMSksdm9pZCAwPT09YiYmKGI9ITEpO3ZhciB4PWNvbnZlcnRUb1RlbnNvcih5LFwiYVwiLFwibWF0TXVsXCIpLG89Y29udmVydFRvVGVuc29yKGUsXCJiXCIsXCJtYXRNdWxcIiksYT10P3guc2hhcGVbeC5yYW5rLTJdOnguc2hhcGVbeC5yYW5rLTFdLGk9Yj9vLnNoYXBlW28ucmFuay0xXTpvLnNoYXBlW28ucmFuay0yXSxzPXQ/eC5zaGFwZVt4LnJhbmstMV06eC5zaGFwZVt4LnJhbmstMl0sdT1iP28uc2hhcGVbby5yYW5rLTJdOm8uc2hhcGVbby5yYW5rLTFdLGw9eC5zaGFwZS5zbGljZSgwLC0yKSxjPW8uc2hhcGUuc2xpY2UoMCwtMikscD1zaXplRnJvbVNoYXBlKGwpLGQ9c2l6ZUZyb21TaGFwZShjKTthc3NlcnQoMjw9eC5yYW5rJiYyPD1vLnJhbmsmJngucmFuaz09PW8ucmFuayxcIkVycm9yIGluIG1hdE11bDogaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIG9mIGF0IGxlYXN0IDIsIGdvdCByYW5rcyBcIit4LnJhbmsrXCIgYW5kIFwiK28ucmFuaytcIi5cIiksYXNzZXJ0KGFycmF5c0VxdWFsKGwsYyksXCJFcnJvciBpbiBtYXRNdWw6IG91dGVyIGRpbWVuc2lvbnMgKFwiK2wrXCIpIGFuZCAoXCIrYytcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIit4LnNoYXBlK1wiIGFuZCBcIitvLnNoYXBlK1wiIG11c3QgbWF0Y2guXCIpLGFzc2VydChhPT09aSxcIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIithK1wiKSBhbmQgKFwiK2krXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIreC5zaGFwZStcIiBhbmQgXCIrby5zaGFwZStcIiBhbmQgdHJhbnNwb3NlQT1cIit0K1wiIGFuZCB0cmFuc3Bvc2VCPVwiK2IrXCIgbXVzdCBtYXRjaC5cIik7dmFyIGg9eC5zaGFwZS5zbGljZSgwLC0yKS5jb25jYXQoW3MsdV0pLGY9dD94LmFzM0QocCxhLHMpOnguYXMzRChwLHMsYSksbT1iP28uYXMzRChkLHUsaSk6by5hczNEKGQsaSx1KTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuYmF0Y2hNYXRNdWwoZixtLHQsYil9LHskYTpmLCRiOm19LGZ1bmN0aW9uKGEpe3JldHVybiB0fHxiPyF0JiZiP3skYTpmdW5jdGlvbigpe3JldHVybiBhLm1hdE11bChtLnRvRmxvYXQoKSwhMSwhMSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWF0TXVsKGYudG9GbG9hdCgpLCEwLCExKX19OnQmJiFiP3skYTpmdW5jdGlvbigpe3JldHVybiBtLnRvRmxvYXQoKS5tYXRNdWwoYSwhMSwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGYudG9GbG9hdCgpLm1hdE11bChhLCExLCExKX19OnskYTpmdW5jdGlvbigpe3JldHVybiBtLnRvRmxvYXQoKS5tYXRNdWwoYSwhMCwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWF0TXVsKGYudG9GbG9hdCgpLCEwLCEwKX19OnskYTpmdW5jdGlvbigpe3JldHVybiBhLm1hdE11bChtLnRvRmxvYXQoKSwhMSwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGYudG9GbG9hdCgpLm1hdE11bChhLCEwLCExKX19fSkucmVzaGFwZShoKX1mdW5jdGlvbiBvdXRlclByb2R1Y3RfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJ2MVwiLFwib3V0ZXJQcm9kdWN0XCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJ2MlwiLFwib3V0ZXJQcm9kdWN0XCIpO3JldHVybiBhc3NlcnQoMT09PXQucmFuayYmMT09PXIucmFuayxcIkVycm9yIGluIG91dGVyUHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiK3QucmFuaytcIiBhbmQgXCIrci5yYW5rK1wiLlwiKSx0LmFzMkQoLTEsMSkubWF0TXVsKHIuYXMyRCgxLC0xKSl9ZnVuY3Rpb24gZG90XyhzLGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihzLFwidDFcIixcImRvdFwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwidDJcIixcImRvdFwiKTthc3NlcnQoKDE9PT10LnJhbmt8fDI9PT10LnJhbmspJiYoMT09PXIucmFua3x8Mj09PXIucmFuayksXCJFcnJvciBpbiBkb3Q6IGlucHV0cyBtdXN0IGFsbCBiZSByYW5rIDEgb3IgMiwgYnV0IGdvdCByYW5rcyBcIit0LnJhbmsrXCIgYW5kIFwiK3IucmFuaytcIi5cIik7dmFyIG49MT09PXQucmFuaz90LnNpemU6dC5zaGFwZVsxXSxvPTE9PT1yLnJhbms/ci5zaXplOnIuc2hhcGVbMF07cmV0dXJuIGFzc2VydChuPT09byxcIkVycm9yIGluIGRvdDogaW5uZXIgZGltZW5zaW9ucyBvZiBpbnB1dHMgbXVzdCBtYXRjaCwgYnV0IGdvdCBcIituK1wiIGFuZCBcIitvK1wiLlwiKSwxPT09dC5yYW5rJiYxPT09ci5yYW5rP3QuYXMyRCgxLC0xKS5tYXRNdWwoci5hczJEKC0xLDEpKS5hc1NjYWxhcigpOjE9PT10LnJhbmsmJjI9PT1yLnJhbms/dC5hczJEKDEsLTEpLm1hdE11bChyLmFzMkQoci5zaGFwZVswXSxyLnNoYXBlWzFdKSkuYXMxRCgpOjI9PT10LnJhbmsmJjE9PT1yLnJhbms/dC5tYXRNdWwoci5hczJEKC0xLDEpKS5hczFEKCk6dC5tYXRNdWwoci5hczJEKHIuc2hhcGVbMF0sci5zaGFwZVsxXSkpfWZ1bmN0aW9uIGNvbnYxZF8obSxlLHQscixuLGcsZil7dm9pZCAwPT09biYmKG49XCJOV0NcIiksdm9pZCAwPT09ZyYmKGc9MSk7dmFyIGk9Y29udmVydFRvVGVuc29yKG0sXCJ4XCIsXCJjb252MWRcIikscz1jb252ZXJ0VG9UZW5zb3IoZSxcImZpbHRlclwiLFwiY29udjFkXCIpLHU9aSx5PSExOzI9PT1pLnJhbmsmJih5PSEwLHU9aS5hczNEKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdKSksYXNzZXJ0KDM9PT11LnJhbmssXCJFcnJvciBpbiBjb252MWQ6IGlucHV0IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwiKSxhc3NlcnQoMz09PXMucmFuayxcIkVycm9yIGluIGNvbnYxZDogZmlsdGVyIG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwiKSxudWxsIT1mJiZhc3NlcnQoaXNJbnQociksXCJFcnJvciBpbiBjb252MWQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2YrXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIiksYXNzZXJ0KHUuc2hhcGVbMl09PT1zLnNoYXBlWzFdLFwiRXJyb3IgaW4gY29udjFkOiBkZXB0aCBvZiBpbnB1dCAoXCIrdS5zaGFwZVsyXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Muc2hhcGVbMV0rXCIuXCIpLGFzc2VydChlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUodCxnKSxcIkVycm9yIGluIGNvbnYxRDogRWl0aGVyIHN0cmlkZSBvciBkaWxhdGlvbiBtdXN0IGJlIDEuIEdvdCBzdHJpZGUgXCIrdCtcIiBhbmQgZGlsYXRpb24gJ1wiK2crXCInXCIpLGFzc2VydChcIk5XQ1wiPT09bixcIkVycm9yIGluIGNvbnYxZDogZ290IGRhdGFGb3JtYXQgb2YgXCIrbitcIiBidXQgb25seSBOV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIik7dmFyIGI9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pLHA9dS5hczREKHUuc2hhcGVbMF0sMSx1LnNoYXBlWzFdLHUuc2hhcGVbMl0pLGQ9Y29udjJkKHAsYixbMSx0XSxyLFwiTkhXQ1wiLFsxLGddLGYpO3JldHVybiB5P2QuYXMyRChkLnNoYXBlWzJdLGQuc2hhcGVbM10pOmQuYXMzRChkLnNoYXBlWzBdLGQuc2hhcGVbMl0sZC5zaGFwZVszXSl9ZnVuY3Rpb24gY29udjJkXyhtLGUsdCxyLG4sZyx5KXt2b2lkIDA9PT1uJiYobj1cIk5IV0NcIiksdm9pZCAwPT09ZyYmKGc9WzEsMV0pO3ZhciBpPWNvbnZlcnRUb1RlbnNvcihtLFwieFwiLFwiY29udjJkXCIpLHM9Y29udmVydFRvVGVuc29yKGUsXCJmaWx0ZXJcIixcImNvbnYyZFwiKSx1PWksYj0hMTszPT09aS5yYW5rJiYoYj0hMCx1PWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksYXNzZXJ0KDQ9PT11LnJhbmssXCJFcnJvciBpbiBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwiKSxhc3NlcnQoND09PXMucmFuayxcIkVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwiKSxudWxsIT15JiZhc3NlcnQoaXNJbnQociksXCJFcnJvciBpbiBjb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK3krXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIiksYXNzZXJ0KHUuc2hhcGVbM109PT1zLnNoYXBlWzJdLFwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIrdS5zaGFwZVszXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Muc2hhcGVbMl0rXCIuXCIpLGFzc2VydChlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUodCxnKSxcIkVycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrdCtcIiBhbmQgZGlsYXRpb25zICdcIitnK1wiJ1wiKSxhc3NlcnQoXCJOSFdDXCI9PT1uLFwiRXJyb3IgaW4gY29udjJkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIituK1wiIGJ1dCBvbmx5IE5IV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIik7dmFyIHg9Y29tcHV0ZUNvbnYyREluZm8odS5zaGFwZSxzLnNoYXBlLHQsZyxyLHkpLGQ7aWYoMSE9PXguZmlsdGVySGVpZ2h0fHwxIT09eC5maWx0ZXJXaWR0aHx8MSE9PXguZGlsYXRpb25IZWlnaHR8fDEhPT14LmRpbGF0aW9uV2lkdGh8fDEhPT14LnN0cmlkZUhlaWdodHx8MSE9PXguc3RyaWRlV2lkdGh8fFwiU0FNRVwiIT09eC5wYWRJbmZvLnR5cGUmJlwiVkFMSURcIiE9PXgucGFkSW5mby50eXBlKWQ9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udjJkKHUscyx4KX0se3g6dSwkZmlsdGVyOnN9LGZ1bmN0aW9uKGEpe3JldHVybiBhc3NlcnQodHVwbGVWYWx1ZXNBcmVPbmUoZyksXCJFcnJvciBpbiBncmFkaWVudCBvZiBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3R5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrZytcIidcIikse3g6ZnVuY3Rpb24oKXtyZXR1cm4gY29udjJkRGVySW5wdXRfKHUuc2hhcGUsYSxzLHQscil9LCRmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gY29udjJkRGVyRmlsdGVyXyh1LGEscy5zaGFwZSx0LHIpfX19KTtlbHNle3ZhciBOPXUucmVzaGFwZShbLTEseC5pbkNoYW5uZWxzXSksaD1zLnJlc2hhcGUoW3guaW5DaGFubmVscyx4Lm91dENoYW5uZWxzXSk7ZD1tYXRNdWwoTixoKS5yZXNoYXBlKHgub3V0U2hhcGUpfXJldHVybiBiP2QuYXMzRChkLnNoYXBlWzFdLGQuc2hhcGVbMl0sZC5zaGFwZVszXSk6ZH1mdW5jdGlvbiBjb252MmREZXJJbnB1dF8obSxlLHQscixuLG8pe2Fzc2VydChtLmxlbmd0aD09PWUucmFuayxcIkxlbmd0aCBvZiBpblNoYXBlIChcIittLmxlbmd0aCtcIikgYW5kIHJhbmsgb2YgZHkgKFwiK2UucmFuaytcIikgbXVzdCBtYXRjaFwiKTt2YXIgYT1tLGg9ZSxnPSExOzM9PT1lLnJhbmsmJihnPSEwLGg9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pLGE9WzEsbVswXSxtWzFdLG1bMl1dKTt2YXIgZj1hWzNdLGw9aC5zaGFwZVszXTthc3NlcnQoND09PWEubGVuZ3RoLFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBsZW5ndGggXCIrYS5sZW5ndGgrXCIuXCIpLGFzc2VydCg0PT09aC5yYW5rLFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIraC5yYW5rKSxhc3NlcnQoND09PXQucmFuayxcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit0LnJhbmspLGFzc2VydChmPT09dC5zaGFwZVsyXSxcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoXCIrZitcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Quc2hhcGVbMl0rXCIuXCIpLGFzc2VydChsPT09dC5zaGFwZVszXSxcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiK2wrXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdC5zaGFwZVszXStcIi5cIiksbnVsbCE9byYmYXNzZXJ0KGlzSW50KG4pLFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK28rXCIgYnV0IGdvdCBwYWQgXCIrbitcIi5cIik7dmFyIGM9Y29tcHV0ZUNvbnYyREluZm8oYSx0LnNoYXBlLHIsMSxuLG8pLHA9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuY29udjJkRGVySW5wdXQoaCx0LGMpfSx7ZHk0RDpoLGZpbHRlcjp0fSxmdW5jdGlvbihhKXtyZXR1cm57ZHk0RDpmdW5jdGlvbigpe3JldHVybiBjb252MmQoYSx0LHIsbixcIk5IV0NcIiwxLG8pfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gY29udjJkRGVyRmlsdGVyKGEsaCx0LnNoYXBlLHIsbixvKX19fSk7cmV0dXJuIGc/cC5hczNEKHAuc2hhcGVbMV0scC5zaGFwZVsyXSxwLnNoYXBlWzNdKTpwfWZ1bmN0aW9uIGNvbnYyZERlckZpbHRlcl8ocCxlLHQscixuLG8pe3ZhciBhPXA7Mz09PXAucmFuayYmKGE9cC5hczREKDEscC5zaGFwZVswXSxwLnNoYXBlWzFdLHAuc2hhcGVbMl0pKTt2YXIgbD1lOzM9PT1sLnJhbmsmJihsPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSksYXNzZXJ0KDQ9PT1hLnJhbmssXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiK2Euc2hhcGUrXCIuXCIpLGFzc2VydCg0PT09bC5yYW5rLFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIitsLnNoYXBlK1wiLlwiKSxhc3NlcnQoND09PXQubGVuZ3RoLFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiK3QrXCIuXCIpLGFzc2VydChhLnNoYXBlWzNdPT09dFsyXSxcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgXCIrYS5zaGFwZVszXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiK3RbMl0rXCIuXCIpLGFzc2VydChsLnNoYXBlWzNdPT09dFszXSxcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiK2wuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiK3RbM10rXCIpLlwiKSxudWxsIT1vJiZhc3NlcnQoaXNJbnQobiksXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK28rXCIgYnV0IGdvdCBwYWQgXCIrbitcIi5cIik7dmFyIGQ9Y29tcHV0ZUNvbnYyREluZm8oYS5zaGFwZSx0LHIsMSxuLG8pO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252MmREZXJGaWx0ZXIoYSxsLGQpfSx7eDREOmEsZHk0RDpsfSl9ZnVuY3Rpb24gY29udjJkVHJhbnNwb3NlXyhzLGUsdCxyLG4sbyl7cmV0dXJuIGNvbnYyZERlcklucHV0Xyh0LGNvbnZlcnRUb1RlbnNvcihzLFwieFwiLFwiY29udjJkVHJhbnNwb3NlXCIpLGNvbnZlcnRUb1RlbnNvcihlLFwiZmlsdGVyXCIsXCJjb252MmRUcmFuc3Bvc2VcIikscixuLG8pfWZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZF8obSxlLHQscixuLGgsZyl7dm9pZCAwPT09biYmKG49XCJOSFdDXCIpLHZvaWQgMD09PWgmJihoPVsxLDFdKTt2YXIgaT1jb252ZXJ0VG9UZW5zb3IobSxcInhcIixcImRlcHRod2lzZUNvbnYyZFwiKSxzPWNvbnZlcnRUb1RlbnNvcihlLFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIiksdT1pLGY9ITE7Mz09PWkucmFuayYmKGY9ITAsdT1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLGFzc2VydCg0PT09dS5yYW5rLFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIiksYXNzZXJ0KDQ9PT1zLnJhbmssXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIiksYXNzZXJ0KHUuc2hhcGVbM109PT1zLnNoYXBlWzJdLFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgKFwiK3Uuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGZpbHRlciBcIitzLnNoYXBlWzJdK1wiLlwiKSxudWxsPT1oJiYoaD1bMSwxXSksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZSh0LGgpLFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIit0K1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2grXCInXCIpLG51bGwhPWcmJmFzc2VydChpc0ludChyKSxcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrZytcIiBidXQgZ290IHBhZCBcIityK1wiLlwiKTt2YXIgeT1jb21wdXRlQ29udjJESW5mbyh1LnNoYXBlLHMuc2hhcGUsdCxoLHIsZywhMCkscD1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aHdpc2VDb252MkQodSxzLHkpfSx7eDp1LCRmaWx0ZXI6c30sZnVuY3Rpb24odCl7cmV0dXJuIGFzc2VydCh0dXBsZVZhbHVlc0FyZU9uZShoKSxcIkVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICdcIitoK1wiJ1wiKSx7eDpmdW5jdGlvbigpe3JldHVybiBkZXB0aHdpc2VDb252MmREZXJJbnB1dCh1LnNoYXBlLHQscyx5KX0sJGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBkZXB0aHdpc2VDb252MmREZXJGaWx0ZXIodSx0LHMuc2hhcGUseSl9fX0pO3JldHVybiBmP3AuYXMzRChwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXSk6cH1mdW5jdGlvbiBzZXBhcmFibGVDb252MmRfKGcsZSx0LHIsbixvLHkpe3ZvaWQgMD09PW8mJihvPVsxLDFdKSx2b2lkIDA9PT15JiYoeT1cIk5IV0NcIik7dmFyIGI9Y29udmVydFRvVGVuc29yKGcsXCJ4XCIsXCJzZXBhcmFibGVDb252MmRcIikscz1jb252ZXJ0VG9UZW5zb3IoZSxcImRlcHRod2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLHU9Y29udmVydFRvVGVuc29yKHQsXCJwb2ludHdpc2VGaWx0ZXJcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxsPWIseD0hMTtpZigzPT09Yi5yYW5rJiYoeD0hMCxsPWIuYXM0RCgxLGIuc2hhcGVbMF0sYi5zaGFwZVsxXSxiLnNoYXBlWzJdKSksXCJOQ0hXXCI9PT15KXRocm93IG5ldyBFcnJvcihcInNlcGFyYWJsZUNvbnYyZCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0IE5DSFc7IG9ubHkgTkhXQyBpcyBzdXBwb3J0ZWRcIik7YXNzZXJ0KDQ9PT1sLnJhbmssXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwiKSxhc3NlcnQoND09PXMucmFuayxcIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogZGVwdGh3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIiksYXNzZXJ0KDQ9PT11LnJhbmssXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCIpLGFzc2VydCgxPT09dS5zaGFwZVswXSxcIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrdS5zaGFwZVswXStcIi5cIiksYXNzZXJ0KDE9PT11LnNoYXBlWzFdLFwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgc2Vjb25kIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrdS5zaGFwZVsxXStcIi5cIik7dmFyIE49cy5zaGFwZVsyXSxkPXMuc2hhcGVbM107YXNzZXJ0KHUuc2hhcGVbMl09PT1OKmQsXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSB0aGlyZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIFwiK04qZCtcIiwgYnV0IGdvdCBcIit1LnNoYXBlWzJdK1wiLlwiKTt2YXIgaD1kZXB0aHdpc2VDb252MmQobCxzLHIsbix5LG8pLGY9Y29udjJkKGgsdSwxLFwidmFsaWRcIix5KTtyZXR1cm4geD9mLmFzM0QoZi5zaGFwZVsxXSxmLnNoYXBlWzJdLGYuc2hhcGVbM10pOmZ9ZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkRGVySW5wdXQocyxlLHQscil7dmFyIG49ZSxwPSExOzM9PT1lLnJhbmsmJihwPSEwLG49ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKTt2YXIgbD1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5kZXB0aHdpc2VDb252MkREZXJJbnB1dChuLHQscil9LHtkeTREOm59KTtyZXR1cm4gcD9sLmFzM0QobC5zaGFwZVsxXSxsLnNoYXBlWzJdLGwuc2hhcGVbM10pOmx9ZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkRGVyRmlsdGVyKHMsZSx0LHIpe3ZhciBuPXM7Mz09PXMucmFuayYmKG49cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKTt2YXIgaT1lO3JldHVybiAzPT09aS5yYW5rJiYoaT1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRod2lzZUNvbnYyRERlckZpbHRlcihuLGkscil9LHt4NEQ6bixkeTREOml9KX1mdW5jdGlvbiByZXZlcnNlMWRfKGEpe3ZhciBlPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gYXNzZXJ0KDE9PT1lLnJhbmssXCJFcnJvciBpbiByZXZlcnNlMUQ6IHggbXVzdCBiZSByYW5rIDEgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiK2UucmFuaytcIi5cIikscmV2ZXJzZShlLDApfWZ1bmN0aW9uIHJldmVyc2UyZF8oYSxlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIGFzc2VydCgyPT09dC5yYW5rLFwiRXJyb3IgaW4gcmV2ZXJzZTJEOiB4IG11c3QgYmUgcmFuayAyIGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIit0LnJhbmsrXCIuXCIpLHJldmVyc2UodCxlKX1mdW5jdGlvbiByZXZlcnNlM2RfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBhc3NlcnQoMz09PXQucmFuayxcIkVycm9yIGluIHJldmVyc2UzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290XFxuICAgICAgICAgICAgIHJhbmsgXCIrdC5yYW5rK1wiLlwiKSxyZXZlcnNlKHQsZSl9ZnVuY3Rpb24gcmV2ZXJzZTRkXyhhLGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gYXNzZXJ0KDQ9PT10LnJhbmssXCJFcnJvciBpbiByZXZlcnNlNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiK3QucmFuaytcIi5cIikscmV2ZXJzZSh0LGUpfWZ1bmN0aW9uIHJldmVyc2VfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJyZXZlcnNlXCIpO2lmKDA9PT10LnJhbmspcmV0dXJuIHQuY2xvbmUoKTt2YXIgcj1wYXJzZUF4aXNQYXJhbShlLHQuc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXZlcnNlKHQscil9LHskeDp0fSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5yZXZlcnNlKHIpfX19KS5yZXNoYXBlQXModCl9ZnVuY3Rpb24gbWF4UG9vbEltcGxfKHAsZCx0LHIsbSxlKXt2YXIgYT1jb252ZXJ0VG9UZW5zb3IocCxcInhcIixcIm1heFBvb2xcIiksbz1hLGk9ITE7Mz09PWEucmFuayYmKGk9ITAsbz1hLmFzNEQoMSxhLnNoYXBlWzBdLGEuc2hhcGVbMV0sYS5zaGFwZVsyXSkpLG51bGw9PXImJihyPVsxLDFdKSxhc3NlcnQoND09PW8ucmFuayxcIkVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitvLnJhbmsrXCIuXCIpLGFzc2VydChlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUodCxyKSxcIkVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3QrXCIgYW5kIGRpbGF0aW9ucyAnXCIrcitcIidcIiksbnVsbCE9ZSYmYXNzZXJ0KGlzSW50KG0pLFwiRXJyb3IgaW4gbWF4UG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrZStcIiBidXQgZ290IHBhZCBcIittK1wiLlwiKTt2YXIgaD1jb21wdXRlUG9vbDJESW5mbyhvLnNoYXBlLGQsdCxyLG0sZSksbD1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhLGUpe3JldHVybiBlKGEubWF4UG9vbChvLGgpKX0se3g6b30sZnVuY3Rpb24obixlKXt2YXIgYT1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIG1heFBvb2xCYWNrcHJvcChuLG8sYSxkLHQscixtKX19fSk7cmV0dXJuIGk/bC5hczNEKGwuc2hhcGVbMV0sbC5zaGFwZVsyXSxsLnNoYXBlWzNdKTpsfWZ1bmN0aW9uIG1heFBvb2xfKGEsZSx0LHIsbil7cmV0dXJuIG1heFBvb2xJbXBsXyhhLGUsdCwxLHIsbil9ZnVuY3Rpb24gYXZnUG9vbEltcGxfKHAsZCx0LHIsbSxlKXt2YXIgYT1jb252ZXJ0VG9UZW5zb3IocCxcInhcIixcImF2Z1Bvb2xcIik7YXNzZXJ0KFwiZmxvYXQzMlwiPT09YS5kdHlwZSxcIlRoZSBpbnB1dCBkdHlwZSB0byBhdmdQb29sIG11c3QgYmUgZmxvYXQzMlwiKSxudWxsPT1yJiYocj1bMSwxXSksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZSh0LHIpLFwiRXJyb3IgaW4gYXZnUG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrdCtcIiBhbmQgZGlsYXRpb25zICdcIityK1wiJ1wiKTt2YXIgbz1hLGk9ITE7Mz09PWEucmFuayYmKGk9ITAsbz1hLmFzNEQoMSxhLnNoYXBlWzBdLGEuc2hhcGVbMV0sYS5zaGFwZVsyXSkpLGFzc2VydCg0PT09by5yYW5rLFwiRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrby5yYW5rK1wiLlwiKSxudWxsIT1lJiZhc3NlcnQoaXNJbnQobSksXCJFcnJvciBpbiBhdmdQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitlK1wiIGJ1dCBnb3QgcGFkIFwiK20rXCIuXCIpO3ZhciBoPWNvbXB1dGVQb29sMkRJbmZvKG8uc2hhcGUsZCx0LHIsbSksbD1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sKG8saCl9LHt4Om99LGZ1bmN0aW9uKGEpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGF2Z1Bvb2xCYWNrcHJvcChhLG8sZCx0LHIsbSl9fX0pO3JldHVybiBsPWwuY2FzdChhLmR0eXBlKSxpP2wuYXMzRChsLnNoYXBlWzFdLGwuc2hhcGVbMl0sbC5zaGFwZVszXSk6bH1mdW5jdGlvbiBhdmdQb29sXyhhLGUsdCxyLG4pe3JldHVybiBhdmdQb29sSW1wbF8oYSxlLHQsMSxyLG4pfWZ1bmN0aW9uIHBvb2xfKGIsZSx0LHIsTixJKXtudWxsPT1OJiYoTj1bMSwxXSksbnVsbD09SSYmKEk9MSksMD09PXImJihyPVwidmFsaWRcIik7dmFyIFM9Y29udmVydFRvVGVuc29yKGIsXCJ4XCIsXCJtYXhQb29sXCIpLGk9UyxDPSExOzM9PT1TLnJhbmsmJihDPSEwLGk9Uy5hczREKDEsUy5zaGFwZVswXSxTLnNoYXBlWzFdLFMuc2hhcGVbMl0pKSxhc3NlcnQoZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKEksTiksXCJFcnJvciBpbiBwb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIitJK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK04rXCInXCIpO3ZhciBrPWNvbXB1dGVQb29sMkRJbmZvKGkuc2hhcGUsZSxJLE4sciksYz1bay5kaWxhdGlvbkhlaWdodCxrLmRpbGF0aW9uV2lkdGhdLHA7cD1cInNhbWVcIj09PXI/d2l0aFNwYWNlVG9CYXRjaEJhc2VQYWRkaW5ncyhbay5maWx0ZXJIZWlnaHQsay5maWx0ZXJXaWR0aF0sYyk6W1swLDBdLFswLDBdXTt2YXIgVD0xPT09Y1swXSYmMT09PWNbMV0sZD1yZXF1aXJlZFNwYWNlVG9CYXRjaFBhZGRpbmdzKFtrLmluSGVpZ2h0LGsuaW5XaWR0aF0sYyxwKSxoPWRbMF0sZj1kWzFdLG09VD9yOlwidmFsaWRcIixnPVQ/aTpzcGFjZVRvQmF0Y2hORChpLGMsaCksdj0oXCJhdmdcIj09PXQ/ZnVuY3Rpb24oKXtyZXR1cm4gYXZnUG9vbEltcGxfKGcsZSxJLDEsbSl9OmZ1bmN0aW9uKCl7cmV0dXJuIG1heFBvb2xJbXBsXyhnLGUsSSwxLG0pfSkoKSx5PVQ/djpiYXRjaFRvU3BhY2VORCh2LGMsZik7cmV0dXJuIEM/eS5hczNEKHkuc2hhcGVbMV0seS5zaGFwZVsyXSx5LnNoYXBlWzNdKTp5fWZ1bmN0aW9uIG1heFBvb2xCYWNrcHJvcChkLGUsdCxyLG4sbyxtLGkpe3ZhciBzPWNvbnZlcnRUb1RlbnNvcihkLFwiZHlcIixcIm1heFBvb2xCYWNrcHJvcFwiKSx1PWNvbnZlcnRUb1RlbnNvcihlLFwiaW5wdXRcIixcIm1heFBvb2xCYWNrcHJvcFwiKSxsPWNvbnZlcnRUb1RlbnNvcih0LFwib3V0cHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIik7YXNzZXJ0KHUucmFuaz09PXMucmFuayxcIlJhbmsgb2YgaW5wdXQgKFwiK3UucmFuaytcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIrcy5yYW5rK1wiKVwiKSxudWxsPT1vJiYobz1bMSwxXSksYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShuLG8pLFwiRXJyb3IgaW4gbWF4UG9vbEJhY2tQcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCIpLGFzc2VydCg0PT09cy5yYW5rLFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwiKSxhc3NlcnQoND09PXUucmFuayxcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIiksbnVsbCE9aSYmYXNzZXJ0KGlzSW50KG0pLFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK20rXCIuXCIpO3ZhciBjPWNvbXB1dGVQb29sMkRJbmZvKHUuc2hhcGUscixuLG8sbSxpKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubWF4UG9vbEJhY2twcm9wKHMsdSxsLGMpfSx7JGR5OnMsJGlucHV0OnV9KX1mdW5jdGlvbiBhdmdQb29sQmFja3Byb3AobSxlLHQscixuLGgpe3ZhciBhPWNvbnZlcnRUb1RlbnNvcihtLFwiZHlcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKSxpPWNvbnZlcnRUb1RlbnNvcihlLFwiaW5wdXRcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKTthc3NlcnQoaS5yYW5rPT09YS5yYW5rLFwiUmFuayBvZiBpbnB1dCAoXCIraS5yYW5rK1wiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIithLnJhbmsrXCIpXCIpLG51bGw9PW4mJihuPVsxLDFdKSxhc3NlcnQoZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKHIsbiksXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrbitcIidcIik7dmFyIHM9aSxnPWEsZj0hMTszPT09aS5yYW5rJiYoZj0hMCxzPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSxnPWEuYXM0RCgxLGEuc2hhcGVbMF0sYS5zaGFwZVsxXSxhLnNoYXBlWzJdKSksYXNzZXJ0KDQ9PT1nLnJhbmssXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitnLnJhbmsrXCIuXCIpLGFzc2VydCg0PT09cy5yYW5rLFwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwiKTt2YXIgeT1jb21wdXRlUG9vbDJESW5mbyhzLnNoYXBlLHQscixuLGgpLHA9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbEJhY2twcm9wKGcscyx5KX0se2R5NEQ6ZyxpbnB1dDREOnN9KTtyZXR1cm4gZj9wLmFzM0QocC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM10pOnB9ZnVuY3Rpb24gcmVxdWlyZWRTcGFjZVRvQmF0Y2hQYWRkaW5ncyhwLGUsdCl7dmFyIHI9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSxuPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzFdfSksbz1wLmNvbmNhdChyLG4pLGE9ZS5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm4oYS1vW2VdJWEpJWF9KSxpPW4ubWFwKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4rYVtlXX0pO3JldHVybltlLm1hcChmdW5jdGlvbihhLGUpe3JldHVybltyW2VdLGlbZV1dfSksZS5tYXAoZnVuY3Rpb24obixlKXtyZXR1cm5bMCxhW2VdXX0pXX1mdW5jdGlvbiB3aXRoU3BhY2VUb0JhdGNoQmFzZVBhZGRpbmdzKGEscyl7dmFyIGU9YS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCsodC0xKSooc1tlXS0xKX0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC0xfSkscj1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gX01hdGhmbG9vcih0LzIpfSksbj1lLm1hcChmdW5jdGlvbihhLGUpe3JldHVybiBhLXJbZV19KTtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm5bcltlXSxuW2VdXX0pfWZ1bmN0aW9uIHNsaWNlMWRfKGEsZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInNsaWNlMWRcIik7cmV0dXJuIGFzc2VydCgxPT09ci5yYW5rLFwic2xpY2UxZCBleHBlY3RzIGEgcmFuay0xIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwiKSxzbGljZShyLFtlXSxbdF0pfWZ1bmN0aW9uIHNsaWNlMmRfKGEsZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInNsaWNlMmRcIik7cmV0dXJuIGFzc2VydCgyPT09ci5yYW5rLFwic2xpY2UyZCBleHBlY3RzIGEgcmFuay0yIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwiKSxzbGljZShyLGUsdCl9ZnVuY3Rpb24gc2xpY2UzZF8oYSxlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwic2xpY2UzZFwiKTtyZXR1cm4gYXNzZXJ0KDM9PT1yLnJhbmssXCJzbGljZTNkIGV4cGVjdHMgYSByYW5rLTMgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCIpLHNsaWNlKHIsZSx0KX1mdW5jdGlvbiBzbGljZTRkXyhhLGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJzbGljZTRkXCIpO3JldHVybiBhc3NlcnQoND09PXIucmFuayxcInNsaWNlNGQgZXhwZWN0cyBhIHJhbmstNCB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIiksc2xpY2UocixlLHQpfWZ1bmN0aW9uIHNsaWNlXyhzLGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKHMsXCJ4XCIsXCJzbGljZVwiKSxhLHA7aWYoMD09PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJTbGljaW5nIHNjYWxhciBpcyBub3QgcG9zc2libGVcIik7YT1cIm51bWJlclwiPT10eXBlb2YgZT9bZV0uY29uY2F0KEFycmF5KHIucmFuay0xKS5maWxsKDApKTplLmxlbmd0aDxyLnJhbms/ZS5jb25jYXQoQXJyYXkoci5yYW5rLWUubGVuZ3RoKS5maWxsKDApKTplLnNsaWNlKCkscD0ocD1udWxsPT10P0FycmF5KHIucmFuaykuZmlsbCgtMSk6XCJudW1iZXJcIj09dHlwZW9mIHQ/W3RdLmNvbmNhdChBcnJheShyLnJhbmstMSkuZmlsbCgtMSkpOnQubGVuZ3RoPHIucmFuaz90LmNvbmNhdChBcnJheShyLnJhbmstdC5sZW5ndGgpLmZpbGwoLTEpKTp0KS5tYXAoZnVuY3Rpb24obixlKXtyZXR1cm4gMDw9bj9uOihhc3NlcnQoLTE9PW4sXCJCYWQgdmFsdWUgaW4gc2l6ZVwiKSxyLnNoYXBlW2VdLWFbZV0pfSksYXNzZXJ0UGFyYW1zVmFsaWQocixhLHApO3ZhciBsPXIuc2hhcGU7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNsaWNlKHIsYSxwKX0seyR4OnJ9LGZ1bmN0aW9uKG4pe2Zvcih2YXIgZT1bXSx0PTA7dDxuLnJhbms7dCsrKWUucHVzaChbYVt0XSxsW3RdLWFbdF0tcFt0XV0pO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnBhZChlKX19fSl9ZnVuY3Rpb24gbG9nU3VtRXhwXyhwLGUsbCl7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09bCYmKGw9ITEpO3ZhciBkPWNvbnZlcnRUb1RlbnNvcihwLFwieFwiLFwibG9nU3VtRXhwXCIpLG49cGFyc2VBeGlzUGFyYW0oZSxkLnNoYXBlKSxvPWQubWF4KG4sITApLGE9ZC5zdWIobykuZXhwKCkuc3VtKG4pLmxvZygpLGk9by5yZXNoYXBlKGEuc2hhcGUpLmFkZChhKTtpZihsKXt2YXIgcz1leHBhbmRTaGFwZVRvS2VlcERpbShpLnNoYXBlLG4pO3JldHVybiBpLnJlc2hhcGUocyl9cmV0dXJuIGl9ZnVuY3Rpb24gc3VtXyhhLGUscCl7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09cCYmKHA9ITEpO3ZhciBzPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwic3VtXCIpO1wiYm9vbFwiPT09cy5kdHlwZSYmKHM9cy50b0ludCgpKTt2YXIgbD1wYXJzZUF4aXNQYXJhbShlLHMuc2hhcGUpO3JldHVybiBjdXN0b21HcmFkKGZ1bmN0aW9uKG8pe3ZhciBlPWdldEF4ZXNQZXJtdXRhdGlvbihsLG8ucmFuayksdD1sLHI9bztudWxsIT1lJiYocj1vLnRyYW5zcG9zZShlKSx0PWdldElubmVyTW9zdEF4ZXModC5sZW5ndGgsby5yYW5rKSk7dmFyIGQ9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3VtKHIsdCl9LHtwZXJtdXRlZFg6cn0pO2lmKHApe3ZhciB1PWV4cGFuZFNoYXBlVG9LZWVwRGltKGQuc2hhcGUsbCk7ZD1kLnJlc2hhcGUodSl9cmV0dXJue3ZhbHVlOmQsZ3JhZEZ1bmM6ZnVuY3Rpb24oZSl7dmFyIHQ9by5zaGFwZS5zbGljZSgpO3JldHVybiBsLmZvckVhY2goZnVuY3Rpb24oYSl7dFthXT0xfSksZS5yZXNoYXBlKHQpLm11bChvbmVzJDEoby5zaGFwZSxcImZsb2F0MzJcIikpfX19KShzKX1mdW5jdGlvbiBwcm9kXyhwLGUsZCl7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09ZCYmKGQ9ITEpO3ZhciBjPWNvbnZlcnRUb1RlbnNvcihwLFwieFwiLFwicHJvZFwiKTtcImJvb2xcIj09PWMuZHR5cGUmJihjPWMudG9JbnQoKSk7dmFyIG09cGFyc2VBeGlzUGFyYW0oZSxjLnNoYXBlKSxvPWdldEF4ZXNQZXJtdXRhdGlvbihtLGMucmFuayksYT1tLGg9YztudWxsIT1vJiYoaD1jLnRyYW5zcG9zZShvKSxhPWdldElubmVyTW9zdEF4ZXMoYS5sZW5ndGgsYy5yYW5rKSk7dmFyIGc9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucHJvZChoLGEpfSx7cGVybXV0ZWRYOmh9KTtpZihkKXt2YXIgZj1leHBhbmRTaGFwZVRvS2VlcERpbShnLnNoYXBlLG0pO2c9Zy5yZXNoYXBlKGYpfXJldHVybiBnfWZ1bmN0aW9uIG1lYW5fKHMsaSxwKXt2b2lkIDA9PT1pJiYoaT1udWxsKSx2b2lkIDA9PT1wJiYocD0hMSk7dmFyIGU9Y29udmVydFRvVGVuc29yKHMsXCJ4XCIsXCJtZWFuXCIpLGw9cGFyc2VBeGlzUGFyYW0oaSxlLnNoYXBlKSxvPXNpemVGcm9tU2hhcGUoY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLnNoYXBlLGwpWzFdKTtyZXR1cm4gY3VzdG9tR3JhZChmdW5jdGlvbihhKXt2YXIgZT1zY2FsYXIobyk7cmV0dXJue3ZhbHVlOihlLmR0eXBlPT09YS5kdHlwZT9hOmEuY2FzdChlLmR0eXBlKSkuZGl2KGUpLnN1bShpLHApLGdyYWRGdW5jOmZ1bmN0aW9uKG4pe3ZhciB0PWEuc2hhcGUuc2xpY2UoKTtyZXR1cm4gbC5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RbYV09MX0pLG4ucmVzaGFwZSh0KS5tdWwob25lcyQxKGEuc2hhcGUsXCJmbG9hdDMyXCIpKS5kaXYoZSl9fX0pKGUpfWZ1bmN0aW9uIGdyYWRGb3JNaW5BbmRNYXgocyxpLHAsdCxuKXt2YXIgcj1pWzBdO3JldHVybiByLnJhbms8cC5yYW5rJiYocj1yLnJlc2hhcGUoZXhwYW5kU2hhcGVUb0tlZXBEaW0oci5zaGFwZSx0KSkpLHMucmFuazxwLnJhbmsmJihzPXMucmVzaGFwZShleHBhbmRTaGFwZVRvS2VlcERpbShzLnNoYXBlLHQpKSkseyR4OmZ1bmN0aW9uKCl7dmFyIGU9cy5tdWwocC5lcXVhbChyKS5jYXN0KHMuZHR5cGUpKTtyZXR1cm4gbnVsbD09bj9lOmUudHJhbnNwb3NlKG4pfX19ZnVuY3Rpb24gbWluXyhwLGUsZCl7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09ZCYmKGQ9ITEpO3ZhciBjPWNvbnZlcnRUb1RlbnNvcihwLFwieFwiLFwibWluXCIpLG09YyxvPXBhcnNlQXhpc1BhcmFtKGUsYy5zaGFwZSksYT1vLGg9Z2V0QXhlc1Blcm11dGF0aW9uKGEsYy5yYW5rKTtudWxsIT1oJiYoYz1jLnRyYW5zcG9zZShoKSxhPWdldElubmVyTW9zdEF4ZXMoYS5sZW5ndGgsYy5yYW5rKSk7dmFyIHM9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24obixlKXtyZXR1cm4gZShuLm1pbihjLGEpKX0seyR4OmN9LGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGdyYWRGb3JNaW5BbmRNYXgoYSxlLG0sbyxoKX0pO2lmKGQpe3ZhciBnPWV4cGFuZFNoYXBlVG9LZWVwRGltKHMuc2hhcGUsbyk7cz1zLnJlc2hhcGUoZyl9cmV0dXJuIHN9ZnVuY3Rpb24gbWF4XyhwLGUsZCl7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09ZCYmKGQ9ITEpO3ZhciBjPWNvbnZlcnRUb1RlbnNvcihwLFwieFwiLFwibWF4XCIpLG09YyxvPXBhcnNlQXhpc1BhcmFtKGUsYy5zaGFwZSksYT1vLGg9Z2V0QXhlc1Blcm11dGF0aW9uKGEsYy5yYW5rKTtudWxsIT1oJiYoYz1jLnRyYW5zcG9zZShoKSxhPWdldElubmVyTW9zdEF4ZXMoYS5sZW5ndGgsYy5yYW5rKSk7dmFyIHM9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24obixlKXtyZXR1cm4gZShuLm1heChjLGEpKX0seyR4OmN9LGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGdyYWRGb3JNaW5BbmRNYXgoYSxlLG0sbyxoKX0pO2lmKGQpe3ZhciBnPWV4cGFuZFNoYXBlVG9LZWVwRGltKHMuc2hhcGUsbyk7cz1zLnJlc2hhcGUoZyl9cmV0dXJuIHN9ZnVuY3Rpb24gYXJnTWluXyhhLGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBzPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiYXJnTWluXCIpO251bGw9PWUmJihlPTApO3ZhciBpPXBhcnNlQXhpc1BhcmFtKGUscy5zaGFwZSkscD1nZXRBeGVzUGVybXV0YXRpb24oaSxzLnJhbmspO3JldHVybiBudWxsIT1wJiYocz1zLnRyYW5zcG9zZShwKSxpPWdldElubmVyTW9zdEF4ZXMoaS5sZW5ndGgscy5yYW5rKSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXJnTWluKHMsaVswXSl9LHskeDpzfSxmdW5jdGlvbigpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2Uocyl9fX0pfWZ1bmN0aW9uIGFyZ01heF8oYSxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgcz1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcImFyZ01heFwiKTtudWxsPT1lJiYoZT0wKTt2YXIgaT1wYXJzZUF4aXNQYXJhbShlLHMuc2hhcGUpLHA9Z2V0QXhlc1Blcm11dGF0aW9uKGkscy5yYW5rKTtyZXR1cm4gbnVsbCE9cCYmKHM9cy50cmFuc3Bvc2UocCksaT1nZXRJbm5lck1vc3RBeGVzKGkubGVuZ3RoLHMucmFuaykpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFyZ01heChzLGlbMF0pfSx7JHg6c30sZnVuY3Rpb24oKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKHMpfX19KX1mdW5jdGlvbiBhbGxfKHAsZSxsKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1sJiYobD0hMSk7dmFyIGQ9Y29udmVydFRvVGVuc29yKHAsXCJ4XCIsXCJhbGxcIixcImJvb2xcIik7YXNzZXJ0KFwiYm9vbFwiPT09ZC5kdHlwZSxcIkVycm9yIFRlbnNvciBtdXN0IGJlIG9mIHR5cGUgYm9vbC4gR290OiBcIitkLmR0eXBlKTt2YXIgYz1wYXJzZUF4aXNQYXJhbShlLGQuc2hhcGUpLG89YyxtPWdldEF4ZXNQZXJtdXRhdGlvbihvLGQucmFuayk7bnVsbCE9bSYmKGQ9ZC50cmFuc3Bvc2UobSksbz1nZXRJbm5lck1vc3RBeGVzKG8ubGVuZ3RoLGQucmFuaykpO3ZhciBpPUVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFsbChkLG8pfSx7JHg6ZH0pO2lmKGwpe3ZhciBzPWV4cGFuZFNoYXBlVG9LZWVwRGltKGkuc2hhcGUsYyk7cmV0dXJuIGkucmVzaGFwZShzKX1yZXR1cm4gaX1mdW5jdGlvbiBhbnlfKHAsZSxsKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1sJiYobD0hMSk7dmFyIGQ9Y29udmVydFRvVGVuc29yKHAsXCJ4XCIsXCJhbnlcIixcImJvb2xcIik7YXNzZXJ0KFwiYm9vbFwiPT09ZC5kdHlwZSxcIkVycm9yIFRlbnNvciBtdXN0IGJlIG9mIHR5cGUgYm9vbC4gR290OiBcIitkLmR0eXBlKTt2YXIgYz1wYXJzZUF4aXNQYXJhbShlLGQuc2hhcGUpLG89YyxtPWdldEF4ZXNQZXJtdXRhdGlvbihvLGQucmFuayk7bnVsbCE9bSYmKGQ9ZC50cmFuc3Bvc2UobSksbz1nZXRJbm5lck1vc3RBeGVzKG8ubGVuZ3RoLGQucmFuaykpO3ZhciBpPUVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFueShkLG8pfSx7JHg6ZH0pO2lmKGwpe3ZhciBzPWV4cGFuZFNoYXBlVG9LZWVwRGltKGkuc2hhcGUsYyk7cmV0dXJuIGkucmVzaGFwZShzKX1yZXR1cm4gaX1mdW5jdGlvbiBtb21lbnRzXyhzLGkscCl7dm9pZCAwPT09aSYmKGk9bnVsbCksdm9pZCAwPT09cCYmKHA9ITEpO3ZhciBsPXBhcnNlQXhpc1BhcmFtKGksKHM9Y29udmVydFRvVGVuc29yKHMsXCJ4XCIsXCJtb21lbnRzXCIpKS5zaGFwZSksbj1zLm1lYW4obCxwKSxvPW4uc2hhcGU7cmV0dXJuIHB8fChvPWV4cGFuZFNoYXBlVG9LZWVwRGltKG4uc2hhcGUsbCkpLHttZWFuOm4sdmFyaWFuY2U6cy50b0Zsb2F0KCkuc3ViKG4ucmVzaGFwZShvKSkuc3F1YXJlKCkubWVhbihsLHApfX1mdW5jdGlvbiBub3RFcXVhbF8oYSxlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoYSxcImFcIixcIm5vdEVxdWFsXCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJiXCIsXCJub3RFcXVhbFwiKTtyZXR1cm4gYXNzZXJ0VHlwZXNNYXRjaCh0LHIpLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHQuc2hhcGUsci5zaGFwZSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEubm90RXF1YWwodCxyKX0seyRhOnQsJGI6cn0pfWZ1bmN0aW9uIG5vdEVxdWFsU3RyaWN0XyhhLGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihhLFwiYVwiLFwibm90RXF1YWxTdHJpY3RcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcIm5vdEVxdWFsU3RyaWN0XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaCh0LnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBub3RFcXVhbFN0cmljdDogXCIpLHQubm90RXF1YWwocil9ZnVuY3Rpb24gbGVzc18oYSxlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoYSxcImFcIixcImxlc3NcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImxlc3NcIik7cmV0dXJuIGFzc2VydFR5cGVzTWF0Y2godCxyKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LnNoYXBlLHIuc2hhcGUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLmxlc3ModCxyKX0seyRhOnQsJGI6cn0pfWZ1bmN0aW9uIGxlc3NTdHJpY3RfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJsZXNzU3RyaWN0XCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJiXCIsXCJsZXNzU3RyaWN0XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaCh0LnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBsZXNzU3RyaWN0OiBcIiksdC5sZXNzKHIpfWZ1bmN0aW9uIGVxdWFsXyhhLGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihhLFwiYVwiLFwiZXF1YWxcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImVxdWFsXCIpO3JldHVybiBhc3NlcnRUeXBlc01hdGNoKHQsciksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodC5zaGFwZSxyLnNoYXBlKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5lcXVhbCh0LHIpfSx7JGE6dCwkYjpyfSl9ZnVuY3Rpb24gZXF1YWxTdHJpY3RfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJlcXVhbFN0cmljdFwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwiZXF1YWxTdHJpY3RcIik7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKHQuc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGVxdWFsU3RyaWN0OiBcIiksdC5lcXVhbChyKX1mdW5jdGlvbiBsZXNzRXF1YWxfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJsZXNzRXF1YWxcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImxlc3NFcXVhbFwiKTtyZXR1cm4gYXNzZXJ0VHlwZXNNYXRjaCh0LHIpLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHQuc2hhcGUsci5zaGFwZSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEubGVzc0VxdWFsKHQscil9LHskYTp0LCRiOnJ9KX1mdW5jdGlvbiBsZXNzRXF1YWxTdHJpY3RfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJsZXNzRXF1YWxTdHJpY3RcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImxlc3NFcXVhbFN0cmljdFwiKTtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2godC5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbGVzc0VxdWFsU3RyaWN0OiBcIiksdC5sZXNzRXF1YWwocil9ZnVuY3Rpb24gZ3JlYXRlcl8oYSxlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoYSxcImFcIixcImdyZWF0ZXJcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImdyZWF0ZXJcIik7cmV0dXJuIGFzc2VydFR5cGVzTWF0Y2godCxyKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LnNoYXBlLHIuc2hhcGUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLmdyZWF0ZXIodCxyKX0seyRhOnQsJGI6cn0pfWZ1bmN0aW9uIGdyZWF0ZXJTdHJpY3RfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJncmVhdGVyU3RyaWN0XCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJiXCIsXCJncmVhdGVyU3RyaWN0XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaCh0LnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBncmVhdGVyU3RyaWN0OiBcIiksdC5ncmVhdGVyKHIpfWZ1bmN0aW9uIGdyZWF0ZXJFcXVhbF8oYSxlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoYSxcImFcIixcImdyZWF0ZXJFcXVhbFwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwiZ3JlYXRlckVxdWFsXCIpO3JldHVybiBhc3NlcnRUeXBlc01hdGNoKHQsciksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodC5zaGFwZSxyLnNoYXBlKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5ncmVhdGVyRXF1YWwodCxyKX0seyRhOnQsJGI6cn0sZnVuY3Rpb24oKXtyZXR1cm57JGE6ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKHQpfSwkYjpmdW5jdGlvbigpe3JldHVybiB6ZXJvc0xpa2Uocil9fX0pfWZ1bmN0aW9uIGdyZWF0ZXJFcXVhbFN0cmljdF8oYSxlKXt2YXIgdD1jb252ZXJ0VG9UZW5zb3IoYSxcImFcIixcImdyZWF0ZXJFcXVhbFN0cmljdFwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwiZ3JlYXRlckVxdWFsU3RyaWN0XCIpO3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaCh0LnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBncmVhdGVyRXF1YWxTdHJpY3Q6IFwiKSx0LmdyZWF0ZXJFcXVhbChyKX1mdW5jdGlvbiBhZGRfKGEsZSl7dmFyIHM9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJhZGRcIiksaT1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImFkZFwiKTthc3NlcnRUeXBlc01hdGNoKHMsaSk7dmFyIHA9YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUocy5zaGFwZSxpLnNoYXBlKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWRkKHMsaSl9LHskYTpzLCRiOml9LGZ1bmN0aW9uKGEpe3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPWEscj1nZXRSZWR1Y3Rpb25BeGVzKHMuc2hhcGUscCk7cmV0dXJuIDA8ci5sZW5ndGgmJihlPWUuc3VtKHIpKSxlLnJlc2hhcGUocy5zaGFwZSl9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9YSxuPWdldFJlZHVjdGlvbkF4ZXMoaS5zaGFwZSxwKTtyZXR1cm4gMDxuLmxlbmd0aCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShpLnNoYXBlKX19fSl9ZnVuY3Rpb24gYWRkTl8oYSl7YXNzZXJ0KEFycmF5LmlzQXJyYXkoYSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgYmUgYSBsaXN0IG9mIHRlbnNvcnNcIn0pLGFzc2VydCgxPD1hLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiTXVzdCBwYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuYWRkTigpLCBidXQgZ290IFwiK2EubGVuZ3RofSk7dmFyIG49YS5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm4gY29udmVydFRvVGVuc29yKGEsXCJ0ZW5zb3JzXCIrZSxcImFkZE5cIil9KSx0PW5bMF07bi5mb3JFYWNoKGZ1bmN0aW9uKGEpe2lmKGEuZHR5cGUhPT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIGR0eXBlXCIpfSksbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe2lmKCFhcnJheXNFcXVhbChhLnNoYXBlLHQuc2hhcGUpKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFkZE4obil9LG4sZnVuY3Rpb24odCl7dmFyIGU9e307cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbihhLHIpe2Vbcl09ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9uZSgpfX0pLGV9KX1mdW5jdGlvbiBhZGRTdHJpY3RfKGEsZSl7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsZS5zaGFwZSxcIkVycm9yIGluIGFkZFN0cmljdDogXCIpLGEuYWRkKGUpfWZ1bmN0aW9uIHN1Yl8oYSxlKXt2YXIgcz1jb252ZXJ0VG9UZW5zb3IoYSxcImFcIixcInN1YlwiKSxpPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwic3ViXCIpO2Fzc2VydFR5cGVzTWF0Y2gocyxpKTt2YXIgcD1hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShzLnNoYXBlLGkuc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdWJ0cmFjdChzLGkpfSx7JGE6cywkYjppfSxmdW5jdGlvbihhKXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT1hLHI9Z2V0UmVkdWN0aW9uQXhlcyhzLnNoYXBlLHApO3JldHVybiAwPHIubGVuZ3RoJiYoZT1lLnN1bShyKSksZS5yZXNoYXBlKHMuc2hhcGUpfSwkYjpmdW5jdGlvbigpe3ZhciBlPWEsbj1nZXRSZWR1Y3Rpb25BeGVzKGkuc2hhcGUscCk7cmV0dXJuIDA8bi5sZW5ndGgmJihlPWUuc3VtKG4pKSxlLm5lZygpLnJlc2hhcGUoaS5zaGFwZSl9fX0pfWZ1bmN0aW9uIHN1YlN0cmljdF8oYSxlKXtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSxlLnNoYXBlLFwiRXJyb3IgaW4gc3ViU3RyaWN0OiBcIiksYS5zdWIoZSl9ZnVuY3Rpb24gcG93XyhhLHMpe3ZhciBwPWNvbnZlcnRUb1RlbnNvcihhLFwiYmFzZVwiLFwicG93XCIpLHI9Y29udmVydFRvVGVuc29yKHMsXCJleHBcIixcInBvd1wiKSxuPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHAuc2hhcGUsci5zaGFwZSk7cmV0dXJuIGE9cC5jYXN0KHVwY2FzdFR5cGUocC5kdHlwZSxyLmR0eXBlKSkscz1yLmNhc3QodXBjYXN0VHlwZShwLmR0eXBlLHIuZHR5cGUpKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhLGUpe3JldHVybiBlKGEucG93KHAscikpfSx7JGJhc2U6cCwkZXhwOnJ9LGZ1bmN0aW9uKG8sZSl7dmFyIHM9ZVswXTtyZXR1cm57JGJhc2U6ZnVuY3Rpb24oKXt2YXIgZT1yLnRvRmxvYXQoKSx0PW8ubXVsKGUubXVsKHAucG93KGUuc3ViKHNjYWxhcigxKSkpKSkscz1nZXRSZWR1Y3Rpb25BeGVzKHAuc2hhcGUsbik7cmV0dXJuIDA8cy5sZW5ndGgmJih0PXQuc3VtKHMpKSx0LnJlc2hhcGUocC5zaGFwZSl9LCRleHA6ZnVuY3Rpb24oKXt2YXIgZT1vLm11bChzLm11bChwLmxvZygpKS50b0Zsb2F0KCkpLGE9Z2V0UmVkdWN0aW9uQXhlcyhyLnNoYXBlLG4pO3JldHVybiAwPGEubGVuZ3RoJiYoZT1lLnN1bShhKSksZS5yZXNoYXBlKHIuc2hhcGUpfX19KX1mdW5jdGlvbiBwb3dTdHJpY3RfKGEsZSl7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsZS5zaGFwZSxcIkVycm9yIGluIHBvd1N0cmljdDogXCIpLGEucG93KGUpfWZ1bmN0aW9uIG11bF8oYSxlKXt2YXIgcz1jb252ZXJ0VG9UZW5zb3IoYSxcImFcIixcIm11bFwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwibXVsXCIpO2Fzc2VydFR5cGVzTWF0Y2gocyxyKTt2YXIgbj1hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShzLnNoYXBlLHIuc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5tdWx0aXBseShzLHIpfSx7JGE6cywkYjpyfSxmdW5jdGlvbihvKXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT1vLm11bChyLnRvRmxvYXQoKSksdD1nZXRSZWR1Y3Rpb25BeGVzKHMuc2hhcGUsbik7cmV0dXJuIDA8dC5sZW5ndGg/ZS5zdW0odCkucmVzaGFwZShzLnNoYXBlKTplfSwkYjpmdW5jdGlvbigpe3ZhciBlPW8ubXVsKHMudG9GbG9hdCgpKSx0PWdldFJlZHVjdGlvbkF4ZXMoci5zaGFwZSxuKTtyZXR1cm4gMDx0Lmxlbmd0aD9lLnN1bSh0KS5yZXNoYXBlKHIuc2hhcGUpOmV9fX0pfWZ1bmN0aW9uIG11bFN0cmljdF8oYSxlKXtyZXR1cm4gYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSxlLnNoYXBlLFwiRXJyb3IgaW4gbXVsdGlwbHlTdHJpY3Q6IFwiKSxhLm11bChlKX1mdW5jdGlvbiBkaXZfKHMsZSl7dmFyIHA9Y29udmVydFRvVGVuc29yKHMsXCJhXCIsXCJkaXZcIiksbj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImRpdlwiKSx0O2lmKGFzc2VydFR5cGVzTWF0Y2gocCxuKSxcImludDMyXCI9PT1wLmR0eXBlJiZcImludDMyXCI9PT1uLmR0eXBlKXJldHVybiBmbG9vckRpdihwLG4pO3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhbERpdmlkZShwLG4pfTt2YXIgbz1hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShwLnNoYXBlLG4uc2hhcGUpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbCh0LHskYTpwLCRiOm59LGZ1bmN0aW9uKGEpe3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPWEuZGl2KG4udG9GbG9hdCgpKSx0PWdldFJlZHVjdGlvbkF4ZXMocC5zaGFwZSxvKTtyZXR1cm4gMDx0Lmxlbmd0aD9lLnN1bSh0KS5yZXNoYXBlKHAuc2hhcGUpOmV9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9YS5tdWwocC50b0Zsb2F0KCkpLHM9Z2V0UmVkdWN0aW9uQXhlcyhuLnNoYXBlLG8pOzA8cy5sZW5ndGgmJihlPWUuc3VtKHMpLnJlc2hhcGUobi5zaGFwZSkpO3ZhciByPW4uc3F1YXJlKCk7cmV0dXJuIGUuZGl2KHIudG9GbG9hdCgpKS5uZWcoKX19fSl9ZnVuY3Rpb24gZmxvb3JEaXZfKGEsZSl7dmFyIHM9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJmbG9vckRpdlwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwiZmxvb3JEaXZcIik7YXNzZXJ0VHlwZXNNYXRjaChzLHIpO3ZhciBuPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHMuc2hhcGUsci5zaGFwZSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZsb29yRGl2KHMscil9LHskYTpzLCRiOnJ9LGZ1bmN0aW9uKG8pe3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPW8uZGl2KHIudG9GbG9hdCgpKSx0PWdldFJlZHVjdGlvbkF4ZXMocy5zaGFwZSxuKTtyZXR1cm4gMDx0Lmxlbmd0aD9lLnN1bSh0KS5yZXNoYXBlKHMuc2hhcGUpOmV9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9by5tdWwocy50b0Zsb2F0KCkpLHA9Z2V0UmVkdWN0aW9uQXhlcyhyLnNoYXBlLG4pOzA8cC5sZW5ndGgmJihlPWUuc3VtKHApLnJlc2hhcGUoci5zaGFwZSkpO3ZhciBhPXIuc3F1YXJlKCk7cmV0dXJuIGUuZGl2KGEudG9GbG9hdCgpKS5uZWcoKX19fSl9ZnVuY3Rpb24gZGl2U3RyaWN0XyhhLGUpe3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLGUuc2hhcGUsXCJFcnJvciBpbiBkaXZpZGVTdHJpY3Q6IFwiKSxhLmRpdihlKX1mdW5jdGlvbiBtb2RfKGEsZSl7dmFyIHM9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJtb2RcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcIm1vZFwiKTthc3NlcnRUeXBlc01hdGNoKHMscik7dmFyIG49YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUocy5zaGFwZSxyLnNoYXBlKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubW9kKHMscil9LHskYTpzLCRiOnJ9LGZ1bmN0aW9uKG8pe3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPWdldFJlZHVjdGlvbkF4ZXMocy5zaGFwZSxuKTtyZXR1cm4gMDxlLmxlbmd0aD9vLnN1bShlKS5yZXNoYXBlKHMuc2hhcGUpOm99LCRiOmZ1bmN0aW9uKCl7dmFyIGU9by5tdWwocy5kaXYocikuZmxvb3IoKS5uZWcoKSksdD1nZXRSZWR1Y3Rpb25BeGVzKHIuc2hhcGUsbik7cmV0dXJuIDA8dC5sZW5ndGg/ZS5zdW0odCkucmVzaGFwZShyLnNoYXBlKTplfX19KX1mdW5jdGlvbiBtb2RTdHJpY3RfKGEsZSl7cmV0dXJuIGFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsZS5zaGFwZSxcIkVycm9yIGluIG1vZFN0cmljdDogXCIpLGEubW9kKGUpfWZ1bmN0aW9uIG1pbmltdW1fKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJtaW5pbXVtXCIpLG89Y29udmVydFRvVGVuc29yKGUsXCJiXCIsXCJtaW5pbXVtXCIpO3JldHVybiBhc3NlcnRUeXBlc01hdGNoKHQsbyksXCJib29sXCI9PT10LmR0eXBlJiYodD10LnRvSW50KCkpLFwiYm9vbFwiPT09by5kdHlwZSYmKG89by50b0ludCgpKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LnNoYXBlLG8uc2hhcGUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLm1pbmltdW0odCxvKX0seyRhOnQsJGI6b30sZnVuY3Rpb24oYSl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGEubXVsKHQubGVzc0VxdWFsKG8pLnRvRmxvYXQoKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubXVsKHQuZ3JlYXRlcihvKS50b0Zsb2F0KCkpfX19KX1mdW5jdGlvbiBtaW5pbXVtU3RyaWN0XyhhLGUpe3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLGUuc2hhcGUsXCJFcnJvciBpbiBtaW5pbXVtU3RyaWN0OiBcIiksYS5taW5pbXVtKGUpfWZ1bmN0aW9uIG1heGltdW1fKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJtYXhpbXVtXCIpLG89Y29udmVydFRvVGVuc29yKGUsXCJiXCIsXCJtYXhpbXVtXCIpO3JldHVybiBhc3NlcnRUeXBlc01hdGNoKHQsbyksXCJib29sXCI9PT10LmR0eXBlJiYodD10LnRvSW50KCkpLFwiYm9vbFwiPT09by5kdHlwZSYmKG89by50b0ludCgpKSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LnNoYXBlLG8uc2hhcGUpLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLm1heGltdW0odCxvKX0seyRhOnQsJGI6b30sZnVuY3Rpb24oYSl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGEubXVsKHQuZ3JlYXRlckVxdWFsKG8pLnRvRmxvYXQoKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubXVsKHQubGVzcyhvKS50b0Zsb2F0KCkpfX19KX1mdW5jdGlvbiBtYXhpbXVtU3RyaWN0XyhhLGUpe3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLGUuc2hhcGUsXCJFcnJvciBpbiBtYXhpbXVtU3RyaWN0OiBcIiksYS5tYXhpbXVtKGUpfWZ1bmN0aW9uIHNxdWFyZWREaWZmZXJlbmNlXyhhLGUpe3ZhciBvPWNvbnZlcnRUb1RlbnNvcihhLFwiYVwiLFwic3F1YXJlZERpZmZlcmVuY2VcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpO3JldHVybiBhc3NlcnRUeXBlc01hdGNoKG8sciksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoby5zaGFwZSxyLnNoYXBlKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcXVhcmVkRGlmZmVyZW5jZShvLHIpfSx7JGE6bywkYjpyfSxmdW5jdGlvbihhKXt2YXIgZT1zY2FsYXIoMik7cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGEubXVsKG8uc3ViKHIpLm11bChlKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubXVsKHIuc3ViKG8pLm11bChlKSl9fX0pfWZ1bmN0aW9uIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XyhhLGUpe3JldHVybiBhc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLGUuc2hhcGUsXCJFcnJvciBpbiBzcXVhcmVkRGlmZmVyZW5jZVN0cmljdDogXCIpLGEuc3F1YXJlZERpZmZlcmVuY2UoZSl9ZnVuY3Rpb24gYXRhbjJfKGEsZSl7dmFyIHM9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJhdGFuMlwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwiYXRhbjJcIik7YXNzZXJ0VHlwZXNNYXRjaChzLHIpO3ZhciBuPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHMuc2hhcGUsci5zaGFwZSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF0YW4yKHMscil9LHskYTpzLCRiOnJ9LGZ1bmN0aW9uKG8pe3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPWFkZChzLnNxdWFyZSgpLHIuc3F1YXJlKCkpLHQ9by5tdWwoci5kaXYoZSkpLHA9Z2V0UmVkdWN0aW9uQXhlcyhzLnNoYXBlLG4pO3JldHVybiAwPHAubGVuZ3RoJiYodD10LnN1bShwKSksdC5yZXNoYXBlKHMuc2hhcGUpfSwkYjpmdW5jdGlvbigpe3ZhciBlPWFkZChzLnNxdWFyZSgpLHIuc3F1YXJlKCkpLHQ9bmVnKG8ubXVsKHMuZGl2KGUpKSkscD1nZXRSZWR1Y3Rpb25BeGVzKHIuc2hhcGUsbik7cmV0dXJuIDA8cC5sZW5ndGgmJih0PXQuc3VtKHApKSx0LnJlc2hhcGUoci5zaGFwZSl9fX0pfWZ1bmN0aW9uIGxvZ2ljYWxOb3RfKGEpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwibG9naWNhbE5vdFwiLFwiYm9vbFwiKTtyZXR1cm4gYXNzZXJ0KFwiYm9vbFwiPT09bi5kdHlwZSxcIkVycm9yIEFycmF5IG11c3QgYmUgb2YgdHlwZSBib29sLlwiKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsTm90KG4pfSx7JHg6bn0pfWZ1bmN0aW9uIGxvZ2ljYWxBbmRfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJsb2dpY2FsQW5kXCIsXCJib29sXCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJiXCIsXCJsb2dpY2FsQW5kXCIsXCJib29sXCIpO3JldHVybiBhc3NlcnQoXCJib29sXCI9PT10LmR0eXBlJiZcImJvb2xcIj09PXIuZHR5cGUsXCJFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC5cIiksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodC5zaGFwZSxyLnNoYXBlKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5sb2dpY2FsQW5kKHQscil9LHskYTp0LCRiOnJ9KX1mdW5jdGlvbiBsb2dpY2FsT3JfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJhXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIikscj1jb252ZXJ0VG9UZW5zb3IoZSxcImJcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKTtyZXR1cm4gYXNzZXJ0KFwiYm9vbFwiPT09dC5kdHlwZSYmXCJib29sXCI9PT1yLmR0eXBlLFwiRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuXCIpLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHQuc2hhcGUsci5zaGFwZSksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEubG9naWNhbE9yKHQscil9LHskYTp0LCRiOnJ9KX1mdW5jdGlvbiBsb2dpY2FsWG9yXyhhLGUpe3ZhciB0PWNvbnZlcnRUb1RlbnNvcihhLFwiYVwiLFwibG9naWNhbFhvclwiLFwiYm9vbFwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYlwiLFwibG9naWNhbFhvclwiLFwiYm9vbFwiKTtyZXR1cm4gYXNzZXJ0KFwiYm9vbFwiPT09dC5kdHlwZSYmXCJib29sXCI9PT1yLmR0eXBlLFwiRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuXCIpLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHQuc2hhcGUsci5zaGFwZSksbG9naWNhbE9yKGEsZSkubG9naWNhbEFuZChsb2dpY2FsQW5kKGEsZSkubG9naWNhbE5vdCgpKX1mdW5jdGlvbiB3aGVyZV8ocyxlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihlLFwiYVwiLFwid2hlcmVcIiksbj1jb252ZXJ0VG9UZW5zb3IodCxcImJcIixcIndoZXJlXCIpLG89Y29udmVydFRvVGVuc29yKHMsXCJjb25kaXRpb25cIixcIndoZXJlXCIsXCJib29sXCIpO3JldHVybiBhc3NlcnQoXCJib29sXCI9PT1vLmR0eXBlLFwiRXJyb3IgQ29uZGl0aW9uIG11c3QgYmUgb2YgdHlwZSBib29sLlwiKSxhc3NlcnRTaGFwZXNNYXRjaChyLnNoYXBlLG4uc2hhcGUsXCJFcnJvciBpbiB3aGVyZTogXCIpLDE9PT1vLnJhbms/YXNzZXJ0KG8uc2hhcGVbMF09PT1yLnNoYXBlWzBdLFwiVGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBgYWAgbXVzdCBtYXRjaCB0aGUgc2l6ZSBvZiBgY29uZGl0aW9uYC5cIik6YXNzZXJ0U2hhcGVzTWF0Y2goby5zaGFwZSxuLnNoYXBlLFwiRXJyb3IgaW4gd2hlcmU6IFwiKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zZWxlY3QobyxyLG4pfSx7JGNvbmRpdGlvbjpvLCRhOnIsJGI6bn0sZnVuY3Rpb24odCl7cmV0dXJueyRjb25kaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gemVyb3NMaWtlKG8pfSwkYTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChvLmNhc3Qoci5kdHlwZSkpfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChvLmxvZ2ljYWxOb3QoKS5jYXN0KG4uZHR5cGUpKX19fSl9ZnVuY3Rpb24gd2hlcmVBc3luY18oYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxzLGk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gYXNzZXJ0KFwiYm9vbFwiPT09KGU9Y29udmVydFRvVGVuc29yKGEsXCJjb25kaXRpb25cIixcIndoZXJlXCIsXCJib29sXCIpKS5kdHlwZSxcIkNvbmRpdGlvbiBtdXN0IGJlIG9mIHR5cGUgYm9vbC5cIiksWzQsZS5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gcz10LnNlbnQoKSxpPXdoZXJlSW1wbChlLnNoYXBlLHMpLGEhPT1lJiZlLmRpc3Bvc2UoKSxbMixpXTt9fSl9KX1mdW5jdGlvbiByZWx1XyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInJlbHVcIik7cmV0dXJuXCJib29sXCI9PT1uLmR0eXBlP24udG9JbnQoKTpFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWx1KG4pfSx7JHg6bn0sZnVuY3Rpb24odCl7dmFyIGU9bi5zdGVwKCk7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KGUudG9GbG9hdCgpKX19fSl9ZnVuY3Rpb24gZWx1XyhhKXt2YXIgbj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcImVsdVwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZSh0LmVsdShuKSl9LHskeDpufSxmdW5jdGlvbihhLGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVsdURlcihhLG4pfSx7ZHk6YSx5Om59KX19fSl9ZnVuY3Rpb24gc2VsdV8oYSl7dmFyIHM9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJzZWx1XCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zZWx1KHMpfSx7JHg6c30sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7dmFyIGU9cy5ncmVhdGVyKHNjYWxhcigwKSkscj1zY2FsYXIoU0VMVV9TQ0FMRUFMUEhBKSxuPXNjYWxhcihTRUxVX1NDQUxFKSxvPXQubXVsKG4pLGE9dC5tdWwocikubXVsKHMudG9GbG9hdCgpLmV4cCgpKTtyZXR1cm4gd2hlcmUoZSxvLGEpfX19KX1mdW5jdGlvbiBsZWFreVJlbHVfKGEsZSl7dm9pZCAwPT09ZSYmKGU9LjIpO3ZhciBuPWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwibGVha3lSZWx1XCIpO3JldHVybiBtYXhpbXVtKHNjYWxhcihlKS5tdWwobiksbil9ZnVuY3Rpb24gcHJlbHVfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJwcmVsdVwiKSxyPWNvbnZlcnRUb1RlbnNvcihlLFwiYWxwaGFcIixcInByZWx1XCIpLG49c2NhbGFyKDApO3JldHVybiBtYXhpbXVtKG4sdCkuYWRkKHIubXVsKG1pbmltdW0obix0KSkpfWZ1bmN0aW9uIHRyYW5zcG9zZV8oYSxuKXt2YXIgbz1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcInRyYW5zcG9zZVwiKTtyZXR1cm4obnVsbD09biYmKG49by5zaGFwZS5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm4gZX0pLnJldmVyc2UoKSksYXNzZXJ0KG8ucmFuaz09PW4ubGVuZ3RoLFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiK28ucmFuaytcIiBtdXN0IG1hdGNoIGxlbmd0aCBvZiBwZXJtIFwiK24rXCIuXCIpLG4uZm9yRWFjaChmdW5jdGlvbih0KXthc3NlcnQoMDw9dCYmdDxvLnJhbmssXCJBbGwgZW50cmllcyBpbiAncGVybScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiKyhvLnJhbmstMSkrXCIgYnV0IGdvdCBcIituKX0pLDE+PW8ucmFuayk/by5jbG9uZSgpOkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYW5zcG9zZShvLG4pfSx7JHg6b30sZnVuY3Rpb24odCl7dmFyIGU9Z2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihuKTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC50cmFuc3Bvc2UoZSl9fX0pfWZ1bmN0aW9uIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXyhwLGwsZCxjLG0pe3ZvaWQgMD09PWwmJihsPTUpLHZvaWQgMD09PWQmJihkPTEpLHZvaWQgMD09PWMmJihjPTEpLHZvaWQgMD09PW0mJihtPS41KTt2YXIgZT1jb252ZXJ0VG9UZW5zb3IocCxcInhcIixcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIpO2Fzc2VydCg0PT09ZS5yYW5rfHwzPT09ZS5yYW5rLFwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IHggbXVzdCBiZSByYW5rIDMgb3IgNCBidXQgZ290XFxuICAgICAgICAgICAgICAgcmFuayBcIitlLnJhbmsrXCIuXCIpLGFzc2VydChpc0ludChsKSxcIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiBkZXB0aFJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXJcXG4gICAgICAgICAgICAgICAgICAgICBidXQgZ290IGRlcHRoUmFkaXVzIFwiK2wrXCIuXCIpO3ZhciBoPWUsYT0hMTszPT09ZS5yYW5rJiYoYT0hMCxoPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSk7dmFyIGc9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZSh0LmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQoaCxsLGQsYyxtKSl9LHt4NEQ6aH0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4NEQ6ZnVuY3Rpb24oKXtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuTFJOR3JhZCh0LGgsbixsLGQsYyxtKX0se30pfX19KTtyZXR1cm4gYT9nLmFzM0QoZy5zaGFwZVsxXSxnLnNoYXBlWzJdLGcuc2hhcGVbM10pOmd9ZnVuY3Rpb24gbm9ybV8ocyxwLGwsZCl7dm9pZCAwPT09cCYmKHA9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09bCYmKGw9bnVsbCksdm9pZCAwPT09ZCYmKGQ9ITEpO3ZhciB1PW5vcm1JbXBsKHM9Y29udmVydFRvVGVuc29yKHMsXCJ4XCIsXCJub3JtXCIpLHAsbCksbz11LnNoYXBlO2lmKGQpe3ZhciBjPXBhcnNlQXhpc1BhcmFtKGwscy5zaGFwZSk7bz1leHBhbmRTaGFwZVRvS2VlcERpbSh1LnNoYXBlLGMpfXJldHVybiB1LnJlc2hhcGUobyl9ZnVuY3Rpb24gbm9ybUltcGwoYSxlLHQpe2lmKHZvaWQgMD09PXQmJih0PW51bGwpLDA9PT1hLnJhbmspcmV0dXJuIGEuYWJzKCk7aWYoMSE9PWEucmFuayYmbnVsbD09PXQpcmV0dXJuIG5vcm1JbXBsKGEucmVzaGFwZShbLTFdKSxlLHQpO2lmKDE9PT1hLnJhbmt8fFwibnVtYmVyXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgQXJyYXkmJjE9PT10Lmxlbmd0aCl7aWYoMT09PWUpcmV0dXJuIGEuYWJzKCkuc3VtKHQpO2lmKGU9PT0xLzApcmV0dXJuIGEuYWJzKCkubWF4KHQpO2lmKGU9PT0tMS8wKXJldHVybiBhLmFicygpLm1pbih0KTtpZihcImV1Y2xpZGVhblwiPT09ZXx8Mj09PWUpcmV0dXJuIGEuYWJzKCkucG93KHNjYWxhcigyLFwiaW50MzJcIikpLnN1bSh0KS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK2UpfWlmKHQgaW5zdGFuY2VvZiBBcnJheSYmMj09PXQubGVuZ3RoKXtpZigxPT09ZSlyZXR1cm4gYS5hYnMoKS5zdW0odFswXSkubWF4KHRbMV0tMSk7aWYoZT09PTEvMClyZXR1cm4gYS5hYnMoKS5zdW0odFsxXSkubWF4KHRbMF0pO2lmKGU9PT0tMS8wKXJldHVybiBhLmFicygpLnN1bSh0WzFdKS5taW4odFswXSk7aWYoXCJmcm9cIj09PWV8fFwiZXVjbGlkZWFuXCI9PT1lKXJldHVybiBhLnNxdWFyZSgpLnN1bSh0KS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK2UpfXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgYXhpczogXCIrdCl9ZnVuY3Rpb24gdW5zb3J0ZWRTZWdtZW50U3VtXyhhLGUsdCl7dmFyIHI9Y29udmVydFRvVGVuc29yKGEsXCJ4XCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIiksbj1jb252ZXJ0VG9UZW5zb3IoZSxcInNlZ21lbnRJZHNcIixcInVuc29ydGVkU2VnbWVudFN1bVwiLFwiaW50MzJcIik7cmV0dXJuIGFzc2VydChcImludDMyXCI9PT1uLmR0eXBlLFwic2VnbWVudElkcyBtdXN0IGJlIG9mIGR0eXBlIGBpbnQzMmBcIiksYXNzZXJ0KGlzSW50KHQpLFwibnVtU2VnbWVudHMgbXVzdCBiZSBvZiBkdHlwZSBpbnRcIiksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEudW5zb3J0ZWRTZWdtZW50U3VtKHIsbix0KX0seyR4OnJ9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBnYXRoZXJEcm9wTmVnYXRpdmVzKHQsbil9fX0pfWZ1bmN0aW9uIGdhdGhlcl8oYSxlLGIpe3ZvaWQgMD09PWImJihiPTApO3ZhciB4PWNvbnZlcnRUb1RlbnNvcihhLFwieFwiLFwiZ2F0aGVyXCIpLG49Y29udmVydFRvVGVuc29yKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJcIixcImludDMyXCIpO3JldHVybiBhc3NlcnQoXCJpbnQzMlwiPT09bi5kdHlwZSxcIkluZGljZXMgbXVzdCBiZSBvZiBkdHlwZSBgaW50MzJgXCIpLGI9cGFyc2VBeGlzUGFyYW0oYix4LnNoYXBlKVswXSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5nYXRoZXIoeCxuLGIpfSx7JHg6eH0sZnVuY3Rpb24ocil7cmV0dXJueyR4OmZ1bmN0aW9uKCl7aWYoMD09PWIpcmV0dXJuIHVuc29ydGVkU2VnbWVudFN1bShyLG4seC5zaGFwZVtiXSk7dmFyIGU9eC5zaGFwZSx0PW4uc2l6ZSxhPWUuc2xpY2UoMCxiKSxvPWEubGVuZ3RoLHM9ZS5zbGljZShiLGUubGVuZ3RoKS5zbGljZSgxKSxpPXMubGVuZ3RoLGw9YXJyYXlSYW5nZSgwLG8pLHU9YXJyYXlSYW5nZShvKzEsbysxK2kpLHA9YXJyYXlDb25jYXQoW2EsW3RdLHNdKSxkPXIucmVzaGFwZShwKSxjPW4ucmVzaGFwZShbdF0pLGg9YXJyYXlDb25jYXQoW1tvXSxsLHVdKSxtPWQudHJhbnNwb3NlKGgpLGc9dW5zb3J0ZWRTZWdtZW50U3VtKG0sYyx4LnNoYXBlW2JdKSxmPWdldFVuZG9BeGVzUGVybXV0YXRpb24oaCk7cmV0dXJuIGc9Zy50cmFuc3Bvc2UoZil9fX0pfWZ1bmN0aW9uIGFycmF5UmFuZ2UoYSxlKXtmb3IodmFyIHQ9W10scj1hO3I8ZTsrK3IpdC5wdXNoKHIpO3JldHVybiB0fWZ1bmN0aW9uIGFycmF5Q29uY2F0KGEpe2Zvcih2YXIgZT1bXSx0PTA7dDxhLmxlbmd0aDsrK3QpZm9yKHZhciBvPTA7bzxhW3RdLmxlbmd0aDsrK28pZS5wdXNoKGFbdF1bb10pO3JldHVybiBlfWZ1bmN0aW9uIGdhdGhlckRyb3BOZWdhdGl2ZXMocCxlKXtmb3IodmFyIHQ9bWF4aW11bShlLHplcm9zTGlrZShlKSkscj1nYXRoZXIocCx0KSxuPWdyZWF0ZXJFcXVhbChlLHNjYWxhcigwLFwiaW50MzJcIikpLGw9ci5yYW5rLW4ucmFuayxhPTA7YTxsOysrYSluPWV4cGFuZERpbXMobixhKzEpO249bG9naWNhbEFuZChuLG9uZXMkMShyLnNoYXBlLFwiYm9vbFwiKSk7dmFyIGQ9emVyb3NMaWtlKHIpO3JldHVybiB3aGVyZShuLHIsZCl9ZnVuY3Rpb24gbXVsdGlSTk5DZWxsXyhtLGUsdCxyKXtmb3IodmFyIG49Y29udmVydFRvVGVuc29yKGUsXCJkYXRhXCIsXCJtdWx0aVJOTkNlbGxcIiksbz1jb252ZXJ0VG9UZW5zb3JBcnJheSh0LFwiY1wiLFwibXVsdGlSTk5DZWxsXCIpLGE9Y29udmVydFRvVGVuc29yQXJyYXkocixcImhcIixcIm11bHRpUk5OQ2VsbFwiKSxpPW4saD1bXSx1PTAsZzt1PG0ubGVuZ3RoO3UrKylnPW1bdV0oaSxvW3VdLGFbdV0pLGgucHVzaChnWzBdKSxoLnB1c2goZ1sxXSksaT1nWzFdO3ZhciBmPVtdLHA9W107Zm9yKHU9MDt1PGgubGVuZ3RoO3UrPTIpZi5wdXNoKGhbdV0pLHAucHVzaChoW3UrMV0pO3JldHVybltmLHBdfWZ1bmN0aW9uIGJhc2ljTFNUTUNlbGxfKGIsZSx0LHIsbixvKXt2YXIgYT1jb252ZXJ0VG9UZW5zb3IoYixcImZvcmdldEJpYXNcIixcImJhc2ljTFNUTUNlbGxcIiksaT1jb252ZXJ0VG9UZW5zb3IoZSxcImxzdG1LZXJuZWxcIixcImJhc2ljTFNUTUNlbGxcIikscz1jb252ZXJ0VG9UZW5zb3IodCxcImxzdG1CaWFzXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHU9Y29udmVydFRvVGVuc29yKHIsXCJkYXRhXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGw9Y29udmVydFRvVGVuc29yKG4sXCJjXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGM9Y29udmVydFRvVGVuc29yKG8sXCJoXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHA9dS5jb25jYXQoYywxKS5tYXRNdWwoaSkuYWRkKHMpLGQ9cC5zaGFwZVswXSxoPXAuc2hhcGVbMV0vNCxmPVtkLGhdLG09cC5zbGljZShbMCwwXSxmKSxnPXAuc2xpY2UoWzAsaF0sZiksTj1wLnNsaWNlKFswLDIqaF0sZikseT1wLnNsaWNlKFswLDMqaF0sZikseD1tLnNpZ21vaWQoKS5tdWxTdHJpY3QoZy50YW5oKCkpLmFkZFN0cmljdChsLm11bFN0cmljdChhLmFkZChOKS5zaWdtb2lkKCkpKTtyZXR1cm5beCx4LnRhbmgoKS5tdWxTdHJpY3QoeS5zaWdtb2lkKCkpXX1mdW5jdGlvbiBtb3ZpbmdBdmVyYWdlXyhkLGUsdCxyLG4pe3ZvaWQgMD09PW4mJihuPSEwKTt2YXIgbT1jb252ZXJ0VG9UZW5zb3IoZCxcInZcIixcIm1vdmluZ0F2ZXJhZ2VcIiksYT1jb252ZXJ0VG9UZW5zb3IoZSxcInhcIixcIm1vdmluZ0F2ZXJhZ2VcIiksaT1jb252ZXJ0VG9UZW5zb3IodCxcImRlY2F5XCIsXCJtb3ZpbmdBdmVyYWdlXCIpO2Fzc2VydFR5cGVzTWF0Y2gobSxhKSxhc3NlcnQoYXJyYXlzRXF1YWwobS5zaGFwZSxhLnNoYXBlKSxcIlNoYXBlIG1pc21hdGNoIGluIHYgYW5kIHhcIik7dmFyIHM9c2NhbGFyKDEpLHU9cy5zdWIoaSksbD1hLnN1YihtKS5tdWwodSk7aWYobil7YXNzZXJ0KG51bGwhPXIsXCJXaGVuIHVzaW5nIHplcm9EZWJpYXM6IHRydWUsIHN0ZXAgaXMgcmVxdWlyZWQuXCIpO3ZhciBoPWNvbnZlcnRUb1RlbnNvcihyLFwic3RlcFwiLFwibW92aW5nQXZlcmFnZVwiKTtsPWwuZGl2KHMuc3ViKHBvdyhpLGgpKSl9cmV0dXJuIG0uYWRkKGwpfWZ1bmN0aW9uIHN0cmlkZWRTbGljZV8ocCxkLHQscixuLGMsbSxoLGcpe2lmKHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PWMmJihjPTApLHZvaWQgMD09PW0mJihtPTApLHZvaWQgMD09PWgmJihoPTApLHZvaWQgMD09PWcmJihnPTApLDAhPT1tKXRocm93IG5ldyBFcnJvcihcImVsbGlwc2lzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMCE9PWgpdGhyb3cgbmV3IEVycm9yKFwibmV3IGF4aXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt2YXIgZj1jb252ZXJ0VG9UZW5zb3IocCxcInhcIixcInN0cmlkZWRTbGljZVwiKTtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3RyaWRlZFNsaWNlKGYsZCx0LHIsbixjLG0saCxnKX0seyR4OmZ9KX1mdW5jdGlvbiB0b3BrXyhzLGkscCl7dm9pZCAwPT09aSYmKGk9MSksdm9pZCAwPT09cCYmKHA9ITApO3ZhciBsPWNvbnZlcnRUb1RlbnNvcihzLFwieFwiLFwidG9wa1wiKTtpZigwPT09bC5yYW5rKXRocm93IG5ldyBFcnJvcihcInRvcGsoKSBleHBlY3RzIHRoZSBpbnB1dCB0byBiZSBvZiByYW5rIDEgb3IgaGlnaGVyXCIpO3ZhciBlPWwuc2hhcGVbbC5zaGFwZS5sZW5ndGgtMV07aWYoaT5lKXRocm93IG5ldyBFcnJvcihcIidrJyBwYXNzZWQgdG8gdG9waygpIG11c3QgYmUgPD0gdGhlIGxhc3QgZGltZW5zaW9uIChcIitlK1wiKSBidXQgZ290IFwiK2kpO3ZhciBuPUVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvcGsobCxpLHApfSx7JHg6bH0pO3JldHVybnt2YWx1ZXM6blswXSxpbmRpY2VzOm5bMV19fWZ1bmN0aW9uIHNjYXR0ZXJORF8oYSxlLHQpe3ZhciByPWNvbnZlcnRUb1RlbnNvcihhLFwiaW5kaWNlc1wiLFwic2NhdHRlck5EXCIsXCJpbnQzMlwiKSxuPWNvbnZlcnRUb1RlbnNvcihlLFwidXBkYXRlc1wiLFwic2NhdHRlck5EXCIpO3JldHVybiB2YWxpZGF0ZUlucHV0KG4scix0KSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5zY2F0dGVyTkQocixuLHQpfSx7JGluZGljZXM6ciwkdXBkYXRlczpufSl9ZnVuY3Rpb24gZmZ0XyhhKXthc3NlcnQoXCJjb21wbGV4NjRcIj09PWEuZHR5cGUsXCJUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmZmdCgpIG11c3QgYmUgY29tcGxleDY0IGJ1dCBnb3QgXCIrYS5kdHlwZStcIi5cIik7dmFyIGU9YS5zaGFwZVthLnNoYXBlLmxlbmd0aC0xXSx0PWEuc2l6ZS9lLHI9YS5hczJEKHQsZSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZmdChyKX0se2lucHV0OmF9KS5yZXNoYXBlKGEuc2hhcGUpfWZ1bmN0aW9uIGlmZnRfKGEpe2Fzc2VydChcImNvbXBsZXg2NFwiPT09YS5kdHlwZSxcIlRoZSBkdHlwZSBmb3IgdGYuc3BlY3RyYWwuaWZmdCgpIG11c3QgYmUgY29tcGxleDY0IGJ1dCBnb3QgXCIrYS5kdHlwZStcIi5cIik7dmFyIGU9YS5zaGFwZVthLnNoYXBlLmxlbmd0aC0xXSx0PWEuc2l6ZS9lLHI9YS5hczJEKHQsZSk7cmV0dXJuIEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlmZnQocil9LHtpbnB1dDphfSkucmVzaGFwZShhLnNoYXBlKX1mdW5jdGlvbiByZmZ0XyhkKXthc3NlcnQoXCJmbG9hdDMyXCI9PT1kLmR0eXBlLFwiVGhlIGR0eXBlIGZvciByZmZ0KCkgbXVzdCBiZSByZWFsIHZhbHVlIGJ1dFxcbiAgICBnb3QgXCIrZC5kdHlwZSk7dmFyIGU9ZC5zaGFwZVtkLnNoYXBlLmxlbmd0aC0xXSx0PWQuc2l6ZS9lLHI9ZC56ZXJvc0xpa2UoKSxuPWNvbXBsZXgoZCxyKS5hczJEKHQsZSksbz1FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5mZnQobil9LHtjb21wbGV4SW5wdXQ6bn0pLGE9X01hdGhmbG9vcihlLzIpKzEsaT1yZWFsKG8pLHM9aW1hZyhvKSx1PWkuc3BsaXQoW2EsZS1hXSxpLnNoYXBlLmxlbmd0aC0xKSxsPXMuc3BsaXQoW2EsZS1hXSxzLnNoYXBlLmxlbmd0aC0xKSxjPWQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gY1tkLnNoYXBlLmxlbmd0aC0xXT1hLGNvbXBsZXgodVswXSxsWzBdKS5yZXNoYXBlKGMpfWZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQkMShzLGUsdCxyKXtpZihcImludDMyXCIhPT1zLmR0eXBlKXRocm93IG5ldyBFcnJvcihcInRmLnNwYXJzZVRvRGVuc2UoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzIFwiK3MuZHR5cGUrXCIuXCIpO2lmKDI8cy5yYW5rKXRocm93IG5ldyBFcnJvcihcInNwYXJzZUluZGljZXMgc2hvdWxkIGJlIGEgc2NhbGFyLCB2ZWN0b3IsIG9yIG1hdHJpeCwgYnV0IGdvdCBzaGFwZSBcIitzLnNoYXBlK1wiLlwiKTt2YXIgbj0wPHMucmFuaz9zLnNoYXBlWzBdOjEsbz0xPHMucmFuaz9zLnNoYXBlWzFdOjE7aWYodC5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcIm91dHB1dFNoYXBlIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGVsZW1lbnRzOiwgXCIrdC5sZW5ndGgrXCIsIHNob3VsZCBiZTogXCIrbytcIi5cIik7dmFyIGE9ZS5zaXplO2lmKDAhPT1lLnJhbmsmJigxIT09ZS5yYW5rfHxhIT09bikpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzIGhhcyBpbmNvcnJlY3Qgc2hhcGUgXCIrZS5zaGFwZStcIiwgc2hvdWxkIGJlIFtdIG9yIFtcIituK1wiXVwiKTtpZihlLmR0eXBlIT09ci5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VWYWx1ZXMuZHR5cGUgbXVzdCBtYXRjaCBkZWZhdWx0VmFsdWVzLmR0eXBlXCIpfWZ1bmN0aW9uIHNwYXJzZVRvRGVuc2VfKHMsZSx0LHIpe3ZhciBuPWNvbnZlcnRUb1RlbnNvcihzLFwic3BhcnNlSW5kaWNlc1wiLFwic3BhcnNlVG9EZW5zZVwiLFwiaW50MzJcIiksbz1jb252ZXJ0VG9UZW5zb3IoZSxcInNwYXJzZVZhbHVlc1wiLFwic3BhcnNlVG9EZW5zZVwiKSxhPWNvbnZlcnRUb1RlbnNvcihyLFwiZGVmYXVsdFZhbHVlXCIsXCJzcGFyc2VUb0RlbnNlXCIsby5kdHlwZSk7cmV0dXJuIHZhbGlkYXRlSW5wdXQkMShuLG8sdCxhKSxFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihyKXtyZXR1cm4gci5zcGFyc2VUb0RlbnNlKG4sbyx0LGEpfSx7JHNwYXJzZUluZGljZXM6biwkc3BhcnNlVmFsdWVzOm8sJGRlZmF1bHRWYWx1ZTphfSl9ZnVuY3Rpb24gZ2F0aGVyTkRfKGEsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJORFwiLFwiaW50MzJcIikscj1jb252ZXJ0VG9UZW5zb3IoYSxcInhcIixcImdhdGhlck5EXCIpO3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5nYXRoZXJORChyLHQpfSx7JHg6ciwkaW5kaWNlczp0fSl9ZnVuY3Rpb24gY29tcHV0ZVdlaWdodGVkTG9zc18ocCxlLHQpe3ZvaWQgMD09PXQmJih0PVJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbD1jb252ZXJ0VG9UZW5zb3IocCxcImxvc3Nlc1wiLFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiKSxuPW51bGw7bnVsbCE9ZSYmKG49Y29udmVydFRvVGVuc29yKGUsXCJ3ZWlnaHRzXCIsXCJjb21wdXRlV2VpZ2h0ZWRMb3NzXCIpKTt2YXIgZD1udWxsPT1uP2w6bC5tdWwobik7aWYodD09PVJlZHVjdGlvbi5OT05FKXJldHVybiBkO2lmKHQ9PT1SZWR1Y3Rpb24uU1VNKXJldHVybiBkLnN1bSgpO2lmKHQ9PT1SZWR1Y3Rpb24uTUVBTil7aWYobnVsbD09bilyZXR1cm4gZC5tZWFuKCk7dmFyIGE9c2l6ZUZyb21TaGFwZShsLnNoYXBlKS9zaXplRnJvbVNoYXBlKG4uc2hhcGUpLGk9ZC5zdW0oKS5kaXYobi5zdW0oKSk7cmV0dXJuIDE8YT9pLmRpdihzY2FsYXIoYSkpOml9aWYodD09PVJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtpZihudWxsPT1uKXJldHVybiBkLnN1bSgpLmRpdihzY2FsYXIobC5zaXplKSk7dmFyIHM9bi5tdWwob25lcyQxKGwuc2hhcGUpKS5ub3RFcXVhbChzY2FsYXIoMCkpLnN1bSgpLnRvRmxvYXQoKTtyZXR1cm4gZC5zdW0oKS5kaXYocyl9dGhyb3cgRXJyb3IoXCJVbmtub3duIHJlZHVjdGlvbjogXCIrdCl9ZnVuY3Rpb24gYWJzb2x1dGVEaWZmZXJlbmNlXyhwLGUsdCxyKXt2b2lkIDA9PT1yJiYocj1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGw9Y29udmVydFRvVGVuc29yKHAsXCJsYWJlbHNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxvPWNvbnZlcnRUb1RlbnNvcihlLFwicHJlZGljdGlvbnNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxhPW51bGw7bnVsbCE9dCYmKGE9Y29udmVydFRvVGVuc29yKHQsXCJ3ZWlnaHRzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIikpLGFzc2VydFNoYXBlc01hdGNoKGwuc2hhcGUsby5zaGFwZSxcIkVycm9yIGluIGFic29sdXRlRGlmZmVyZW5jZTogXCIpO3ZhciBkPWwuc3ViKG8pLmFicygpO3JldHVybiBjb21wdXRlV2VpZ2h0ZWRMb3NzKGQsYSxyKX1mdW5jdGlvbiBtZWFuU3F1YXJlZEVycm9yXyhwLGUsdCxyKXt2b2lkIDA9PT1yJiYocj1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGw9Y29udmVydFRvVGVuc29yKHAsXCJsYWJlbHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksbz1jb252ZXJ0VG9UZW5zb3IoZSxcInByZWRpY3Rpb25zXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLGE9bnVsbDtudWxsIT10JiYoYT1jb252ZXJ0VG9UZW5zb3IodCxcIndlaWdodHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIikpLGFzc2VydFNoYXBlc01hdGNoKGwuc2hhcGUsby5zaGFwZSxcIkVycm9yIGluIG1lYW5TcXVhcmVkRXJyb3I6IFwiKTt2YXIgZD1sLnNxdWFyZWREaWZmZXJlbmNlKG8pO3JldHVybiBjb21wdXRlV2VpZ2h0ZWRMb3NzKGQsYSxyKX1mdW5jdGlvbiBjb3NpbmVEaXN0YW5jZV8ocCxlLHQscixuKXt2b2lkIDA9PT1uJiYobj1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGw9Y29udmVydFRvVGVuc29yKHAsXCJsYWJlbHNcIixcImNvc2luZURpc3RhbmNlXCIpLGE9Y29udmVydFRvVGVuc29yKGUsXCJwcmVkaWN0aW9uc1wiLFwiY29zaW5lRGlzdGFuY2VcIiksaT1udWxsO251bGwhPXImJihpPWNvbnZlcnRUb1RlbnNvcihyLFwid2VpZ2h0c1wiLFwiY29zaW5lRGlzdGFuY2VcIikpLGFzc2VydFNoYXBlc01hdGNoKGwuc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIGNvc2luZURpc3RhbmNlOiBcIik7dmFyIGQ9c2NhbGFyKDEpLnN1YihsLm11bChhKS5zdW0odCwhMCkpO3JldHVybiBjb21wdXRlV2VpZ2h0ZWRMb3NzKGQsaSxuKX1mdW5jdGlvbiBoaW5nZUxvc3NfKHAsZSx0LHIpe3ZvaWQgMD09PXImJihyPVJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbD1jb252ZXJ0VG9UZW5zb3IocCxcImxhYmVsc1wiLFwiaGluZ2VMb3NzXCIpLGQ9Y29udmVydFRvVGVuc29yKGUsXCJwcmVkaWN0aW9uc1wiLFwiaGluZ2VMb3NzXCIpLGE9bnVsbDtudWxsIT10JiYoYT1jb252ZXJ0VG9UZW5zb3IodCxcIndlaWdodHNcIixcImhpbmdlTG9zc1wiKSksYXNzZXJ0U2hhcGVzTWF0Y2gobC5zaGFwZSxkLnNoYXBlLFwiRXJyb3IgaW4gaGluZ2VMb3NzOiBcIik7dmFyIGM9c2NhbGFyKDEpO2w9c2NhbGFyKDIpLm11bChsKS5zdWIoYyk7dmFyIHM9Yy5zdWIobC5tdWwoZCkpLnJlbHUoKTtyZXR1cm4gY29tcHV0ZVdlaWdodGVkTG9zcyhzLGEscil9ZnVuY3Rpb24gbG9nTG9zc18ocCxlLHQscixkKXt2b2lkIDA9PT1yJiYocj0xZS03KSx2b2lkIDA9PT1kJiYoZD1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG09Y29udmVydFRvVGVuc29yKHAsXCJsYWJlbHNcIixcImxvZ0xvc3NcIiksYT1jb252ZXJ0VG9UZW5zb3IoZSxcInByZWRpY3Rpb25zXCIsXCJsb2dMb3NzXCIpLGk9bnVsbDtudWxsIT10JiYoaT1jb252ZXJ0VG9UZW5zb3IodCxcIndlaWdodHNcIixcImxvZ0xvc3NcIikpLGFzc2VydFNoYXBlc01hdGNoKG0uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIGxvZ0xvc3M6IFwiKTt2YXIgaD1zY2FsYXIoMSksdT1zY2FsYXIociksbD1tLm11bChhLmFkZCh1KS5sb2coKSkubmVnKCkuc3ViKGguc3ViKG0pLm11bChoLnN1YihhKS5hZGQodSkubG9nKCkpKTtyZXR1cm4gY29tcHV0ZVdlaWdodGVkTG9zcyhsLGksZCl9ZnVuY3Rpb24gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHNfKHMsZSl7dmFyIHQ9Y29udmVydFRvVGVuc29yKHMsXCJsYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJsb2dpdHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpO2Fzc2VydFNoYXBlc01hdGNoKHQuc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzOiBcIik7dmFyIG49ci5yZWx1KCksbz1yLm11bCh0KSxhPXIuYWJzKCkubmVnKCkuZXhwKCkubG9nMXAoKTtyZXR1cm4gbi5zdWIobykuYWRkKGEpfWZ1bmN0aW9uIHNpZ21vaWRDcm9zc0VudHJvcHlfKGQsZSx0LHIsbSl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09bSYmKG09UmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBoPWNvbnZlcnRUb1RlbnNvcihkLFwibXVsdGlDbGFzc0xhYmVsc1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxnPWNvbnZlcnRUb1RlbnNvcihlLFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLGk9bnVsbDtpZihudWxsIT10JiYoaT1jb252ZXJ0VG9UZW5zb3IodCxcIndlaWdodHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIikpLGFzc2VydFNoYXBlc01hdGNoKGguc2hhcGUsZy5zaGFwZSxcIkVycm9yIGluIHNpZ21vaWRDcm9zc0VudHJvcHk6IFwiKSwwPHIpe3ZhciBmPXNjYWxhcihyKSx1PXNjYWxhcigxKSxsPXNjYWxhciguNSk7aD1oLm11bCh1LnN1YihmKSkuYWRkKGwubXVsKGYpKX12YXIgYz1zaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c18oaCxnKTtyZXR1cm4gY29tcHV0ZVdlaWdodGVkTG9zcyhjLGksbSl9ZnVuY3Rpb24gaHViZXJMb3NzXyhtLGUsdCxyLGgpe3ZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PWgmJihoPVJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgZz1jb252ZXJ0VG9UZW5zb3IobSxcImxhYmVsc1wiLFwiaHViZXJMb3NzXCIpLGE9Y29udmVydFRvVGVuc29yKGUsXCJwcmVkaWN0aW9uc1wiLFwiaHViZXJMb3NzXCIpLGk9bnVsbDtudWxsIT10JiYoaT1jb252ZXJ0VG9UZW5zb3IodCxcIndlaWdodHNcIixcImh1YmVyTG9zc1wiKSksYXNzZXJ0U2hhcGVzTWF0Y2goZy5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gaHViZXJMb3NzOiBcIik7dmFyIGY9c2NhbGFyKHIpLHU9YS5zdWIoZykuYWJzKCksbD1taW5pbXVtKHUsZiksYz11LnN1YihsKSxwPXNjYWxhciguNSkubXVsKGwuc3F1YXJlKCkpLmFkZChmLm11bChjKSk7cmV0dXJuIGNvbXB1dGVXZWlnaHRlZExvc3MocCxpLGgpfWZ1bmN0aW9uIHNvZnRtYXhDcm9zc0VudHJvcHlXaXRoTG9naXRzXyhhLGUscyl7aWYodm9pZCAwPT09cyYmKHM9LTEpLC0xPT09cyYmKHM9ZS5yYW5rLTEpLHMhPT1lLnJhbmstMSl0aHJvdyBFcnJvcihcIlNvZnRtYXggY3Jvc3MgZW50cm9weSBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTGFiZWxzIC8gbG9naXRzIHdhcyByYW5rIFwiK2UucmFuaytcIiBhbmQgZGltIHdhcyBcIitzKTtyZXR1cm4gY3VzdG9tR3JhZChmdW5jdGlvbihhLGUpe3ZhciB0PWUubG9nU3VtRXhwKFtzXSwhMCkscj1lLnRvRmxvYXQoKS5zdWIodCk7cmV0dXJue3ZhbHVlOnIubXVsKGEpLm5lZygpLnN1bShbc10pLGdyYWRGdW5jOmZ1bmN0aW9uKGUpe3ZhciB0PWV4cGFuZFNoYXBlVG9LZWVwRGltKGUuc2hhcGUsW3NdKTtyZXR1cm5bZS5yZXNoYXBlKHQpLm11bChhLnRvRmxvYXQoKS5zdWIoci5leHAoKSkpLGUucmVzaGFwZSh0KS5tdWwoci5leHAoKS5zdWIoYS50b0Zsb2F0KCkpKV19fX0pKGEsZSl9ZnVuY3Rpb24gc29mdG1heENyb3NzRW50cm9weV8oZCxlLHQscixtKXt2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1tJiYobT1SZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGg9Y29udmVydFRvVGVuc29yKGQsXCJvbmVob3RMYWJlbHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIiksZz1jb252ZXJ0VG9UZW5zb3IoZSxcImxvZ2l0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxpPW51bGw7aWYobnVsbCE9dCYmKGk9Y29udmVydFRvVGVuc29yKHQsXCJ3ZWlnaHRzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpKSxhc3NlcnRTaGFwZXNNYXRjaChoLnNoYXBlLGcuc2hhcGUsXCJFcnJvciBpbiBzb2Z0bWF4Q3Jvc3NFbnRyb3B5OiBcIiksMDxyKXt2YXIgZj1zY2FsYXIociksdT1zY2FsYXIoMSksbD1zY2FsYXIoaC5zaGFwZVsxXSk7aD1oLm11bCh1LnN1YihmKSkuYWRkKGYuZGl2KGwpKX12YXIgYz1zb2Z0bWF4Q3Jvc3NFbnRyb3B5V2l0aExvZ2l0c18oaCxnKTtyZXR1cm4gY29tcHV0ZVdlaWdodGVkTG9zcyhjLGksbSl9ZnVuY3Rpb24gZ3JhbVNjaG1pZHRfKHMpe3ZhciBwO2lmKEFycmF5LmlzQXJyYXkocykpe3A9ITEsYXNzZXJ0KG51bGwhPXMmJjA8cy5sZW5ndGgsXCJHcmFtLVNjaG1pZHQgcHJvY2VzczogaW5wdXQgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eVwiKTtmb3IodmFyIGw9c1swXS5zaGFwZVswXSxyPTE7cjxzLmxlbmd0aDsrK3IpYXNzZXJ0KHNbcl0uc2hhcGVbMF09PT1sLFwiR3JhbS1TY2htaWR0OiBOb24tdW5pcXVlIGxlbmd0aHMgZm91bmQgaW4gdGhlIGlucHV0IHZlY3RvcnM6IChcIitzW3JdLnNoYXBlWzBdK1wiIHZzLiBcIitsK1wiKVwiKX1lbHNlIHA9ITAscz1zcGxpdCQxKHMscy5zaGFwZVswXSwwKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHNxdWVlemUodCxbMF0pfSk7YXNzZXJ0KHMubGVuZ3RoPD1zWzBdLnNoYXBlWzBdLFwiR3JhbS1TY2htaWR0OiBOdW1iZXIgb2YgdmVjdG9ycyAoXCIrcy5sZW5ndGgrXCIpIGV4Y2VlZHMgbnVtYmVyIG9mIGRpbWVuc2lvbnMgKFwiK3NbMF0uc2hhcGVbMF0rXCIpLlwiKTt2YXIgZD1bXSxvPXMsYT1mdW5jdGlvbihhKXtkLnB1c2goRU5WLmVuZ2luZS50aWR5KGZ1bmN0aW9uKCl7dmFyIGU9b1thXTtpZigwPGEpZm9yKHZhciBzPTAsaTtzPGE7KytzKWk9c3VtJDEoZFtzXS5tdWxTdHJpY3QoZSkpLm11bChkW3NdKSxlPWUuc3ViKGkpO3JldHVybiBlLmRpdihub3JtKGUsXCJldWNsaWRlYW5cIikpfSkpfTtmb3Iocj0wO3I8cy5sZW5ndGg7KytyKWEocik7cmV0dXJuIHA/c3RhY2soZCwwKTpkfWZ1bmN0aW9uIHFyXyhhLHMpe2lmKHZvaWQgMD09PXMmJihzPSExKSwyPmEucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJxcigpIHJlcXVpcmVzIGlucHV0IHRlbnNvciB0byBoYXZlIGEgcmFuayA+PSAyLCBidXQgZ290IHJhbmsgXCIrYS5yYW5rKTtpZigyPT09YS5yYW5rKXJldHVybiBxcjJkKGEscyk7dmFyIGU9YS5zaGFwZS5zbGljZSgwLGEuc2hhcGUubGVuZ3RoLTIpLnJlZHVjZShmdW5jdGlvbihhLGUpe3JldHVybiBhKmV9KSxwPVtdLG49W107cmV0dXJuIHVuc3RhY2soYS5yZXNoYXBlKFtlLGEuc2hhcGVbYS5zaGFwZS5sZW5ndGgtMl0sYS5zaGFwZVthLnNoYXBlLmxlbmd0aC0xXV0pLDApLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9cXIyZCh0LHMpLHI9ZVswXSxhPWVbMV07cC5wdXNoKHIpLG4ucHVzaChhKX0pLFtzdGFjayhwLDApLnJlc2hhcGUoYS5zaGFwZSksc3RhY2sobiwwKS5yZXNoYXBlKGEuc2hhcGUpXX1mdW5jdGlvbiBxcjJkKHAsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSxFTlYuZW5naW5lLnRpZHkoZnVuY3Rpb24oKXtpZigyIT09cC5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwicXIyZCgpIHJlcXVpcmVzIGEgMkQgVGVuc29yLCBidXQgZ290IGEgXCIrcC5zaGFwZS5sZW5ndGgrXCJEIFRlbnNvci5cIik7Zm9yKHZhciB5PXAuc2hhcGVbMF0scj1wLnNoYXBlWzFdLG49ZXllKHkpLGI9cC5jbG9uZSgpLHg9dGVuc29yMmQoW1sxXV0sWzEsMV0pLGk9eC5jbG9uZSgpLHQ9eT49cj9yOnksZD1mdW5jdGlvbihhKXt2YXIgZT1iLG89aSxzPW4scDtwPUVOVi5lbmdpbmUudGlkeShmdW5jdGlvbigpe3ZhciBlPWIuc2xpY2UoW2EsYV0sW3ktYSwxXSksdD1lLm5vcm0oKSxvPWIuc2xpY2UoW2EsYV0sWzEsMV0pLHM9by5zaWduKCkubmVnKCksbD1vLnN1YihzLm11bCh0KSkscD1lLmRpdihsKTtpPTE9PT1wLnNoYXBlWzBdP3guY2xvbmUoKTp4LmNvbmNhdChwLnNsaWNlKFsxLDBdLFtwLnNoYXBlWzBdLTEscC5zaGFwZVsxXV0pLDApO3ZhciBkPXMubWF0TXVsKGwpLmRpdih0KS5uZWcoKSx1PWIuc2xpY2UoW2EsMF0sW3ktYSxyXSksYz1kLm11bChpKTtiPTA9PT1hP3Uuc3ViKGMubWF0TXVsKGkudHJhbnNwb3NlKCkubWF0TXVsKHUpKSk6Yi5zbGljZShbMCwwXSxbYSxyXSkuY29uY2F0KHUuc3ViKGMubWF0TXVsKGkudHJhbnNwb3NlKCkubWF0TXVsKHUpKSksMCk7dmFyIG09bi5zbGljZShbMCxhXSxbeSxuLnNoYXBlWzFdLWFdKTtyZXR1cm4gbj0wPT09YT9tLnN1YihtLm1hdE11bChpKS5tYXRNdWwoYy50cmFuc3Bvc2UoKSkpOm4uc2xpY2UoWzAsMF0sW3ksYV0pLmNvbmNhdChtLnN1YihtLm1hdE11bChpKS5tYXRNdWwoYy50cmFuc3Bvc2UoKSkpLDEpLFtpLGIsbl19KSxpPXBbMF0sYj1wWzFdLG49cFsyXSxkaXNwb3NlKFtlLG8sc10pfSxsPTA7bDx0OysrbClkKGwpO3JldHVybiFlJiZ5PnImJihuPW4uc2xpY2UoWzAsMF0sW3kscl0pLGI9Yi5zbGljZShbMCwwXSxbcixyXSkpLFtuLGJdfSl9ZnVuY3Rpb24gcmVzaXplQmlsaW5lYXJfKHAsZSxsKXt2b2lkIDA9PT1sJiYobD0hMSk7dmFyIHQ9Y29udmVydFRvVGVuc29yKHAsXCJpbWFnZXNcIixcInJlc2l6ZUJpbGluZWFyXCIpO2Fzc2VydCgzPT09dC5yYW5rfHw0PT09dC5yYW5rLFwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rIFwiK3QucmFuaytcIi5cIiksYXNzZXJ0KDI9PT1lLmxlbmd0aCxcIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIitlK1wiLlwiKTt2YXIgbj10LGQ9ITE7Mz09PXQucmFuayYmKGQ9ITAsbj10LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSkpO3ZhciBjPWVbMF0saT1lWzFdLHM9RU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzaXplQmlsaW5lYXIobixjLGksbCl9LHtiYXRjaEltYWdlczpufSxmdW5jdGlvbihhKXtyZXR1cm57YmF0Y2hJbWFnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcChhLG4sbCl9LHt9KX19fSk7cmV0dXJuIGQ/cy5hczNEKHMuc2hhcGVbMV0scy5zaGFwZVsyXSxzLnNoYXBlWzNdKTpzfWZ1bmN0aW9uIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcl8ocCxlLGwpe3ZvaWQgMD09PWwmJihsPSExKTt2YXIgdD1jb252ZXJ0VG9UZW5zb3IocCxcImltYWdlc1wiLFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpO2Fzc2VydCgzPT09dC5yYW5rfHw0PT09dC5yYW5rLFwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayBcIit0LnJhbmsrXCIuXCIpLGFzc2VydCgyPT09ZS5sZW5ndGgsXCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiK2UrXCIuXCIpLGFzc2VydChcImZsb2F0MzJcIj09PXQuZHR5cGV8fFwiaW50MzJcIj09PXQuZHR5cGUsXCJgaW1hZ2VzYCBtdXN0IGhhdmUgYGludDMyYCBvciBgZmxvYXQzMmAgYXMgZHR5cGVcIik7dmFyIG49dCxkPSExOzM9PT10LnJhbmsmJihkPSEwLG49dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgYz1lWzBdLGk9ZVsxXSxzPUVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihuLGMsaSxsKX0se2JhdGNoSW1hZ2VzOm59LGZ1bmN0aW9uKGEpe3JldHVybntiYXRjaEltYWdlczpmdW5jdGlvbigpe3JldHVybiBFTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcChhLG4sbCl9LHt9KX19fSk7cmV0dXJuIGQ/cy5hczNEKHMuc2hhcGVbMV0scy5zaGFwZVsyXSxzLnNoYXBlWzNdKTpzfWZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uXyhwLGUsdCxsLGQpe3ZvaWQgMD09PWwmJihsPS41KSx2b2lkIDA9PT1kJiYoZD1fTnVtYmVyTkVHQVRJVkVfSU5GSU5JVFkpO3ZhciB1PWNvbnZlcnRUb1RlbnNvcihwLFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLGE9Y29udmVydFRvVGVuc29yKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLGk9bm9uTWF4U3VwcFNhbml0eUNoZWNrKHUsYSx0LGwsZCk7cmV0dXJuIHQ9aS5tYXhPdXRwdXRTaXplLGw9aS5pb3VUaHJlc2hvbGQsZD1pLnNjb3JlVGhyZXNob2xkLEVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uKG4pe3JldHVybiBuLm5vbk1heFN1cHByZXNzaW9uKHUsYSx0LGwsZCl9LHskYm94ZXM6dX0pfWZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uQXN5bmNfKGQsZSx0LG0saCl7cmV0dXJuIHZvaWQgMD09PW0mJihtPS41KSx2b2lkIDA9PT1oJiYoaD1fTnVtYmVyTkVHQVRJVkVfSU5GSU5JVFkpLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLG8sZyxmLHk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1jb252ZXJ0VG9UZW5zb3IoZCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLHI9Y29udmVydFRvVGVuc29yKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksbz1ub25NYXhTdXBwU2FuaXR5Q2hlY2sobixyLHQsbSxoKSx0PW8ubWF4T3V0cHV0U2l6ZSxtPW8uaW91VGhyZXNob2xkLGg9by5zY29yZVRocmVzaG9sZCxbNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiBnPWEuc2VudCgpLFs0LHIuZGF0YSgpXTtjYXNlIDI6cmV0dXJuIGY9YS5zZW50KCkseT1ub25NYXhTdXBwcmVzc2lvbkltcGwoZyxmLHQsbSxoKSxuIT09ZCYmbi5kaXNwb3NlKCksciE9PWUmJnIuZGlzcG9zZSgpLFsyLHldO319KX0pfWZ1bmN0aW9uIG5vbk1heFN1cHBTYW5pdHlDaGVjayhzLGUsdCxpLHApe251bGw9PWkmJihpPS41KSxudWxsPT1wJiYocD1fTnVtYmVyTkVHQVRJVkVfSU5GSU5JVFkpO3ZhciBsPXMuc2hhcGVbMF07cmV0dXJuIHQ9X01hdGhtaW4odCxsKSxhc3NlcnQoMDw9aSYmMT49aSxcImlvdVRocmVzaG9sZCBtdXN0IGJlIGluIFswLCAxXSwgYnV0IHdhcyAnXCIraStcIidcIiksYXNzZXJ0KDI9PT1zLnJhbmssXCJib3hlcyBtdXN0IGJlIGEgMkQgdGVuc29yLCBidXQgd2FzIG9mIHJhbmsgJ1wiK3MucmFuaytcIidcIiksYXNzZXJ0KDQ9PT1zLnNoYXBlWzFdLFwiYm94ZXMgbXVzdCBoYXZlIDQgY29sdW1ucywgYnV0IDJuZCBkaW1lbnNpb24gd2FzIFwiK3Muc2hhcGVbMV0pLGFzc2VydCgxPT09ZS5yYW5rLFwic2NvcmVzIG11c3QgYmUgYSAxRCB0ZW5zb3JcIiksYXNzZXJ0KGUuc2hhcGVbMF09PT1sLFwic2NvcmVzIGhhcyBpbmNvbXBhdGlibGUgc2hhcGUgd2l0aCBib3hlcy4gRXhwZWN0ZWQgXCIrbCtcIiwgYnV0IHdhcyBcIitlLnNoYXBlWzBdKSx7bWF4T3V0cHV0U2l6ZTp0LGlvdVRocmVzaG9sZDppLHNjb3JlVGhyZXNob2xkOnB9fWZ1bmN0aW9uIGNyb3BBbmRSZXNpemVfKHAsZSx0LHIsbixkKXt2YXIgYz1jb252ZXJ0VG9UZW5zb3IocCxcImltYWdlXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJmbG9hdDMyXCIpLGk9Y29udmVydFRvVGVuc29yKGUsXCJib3hlc1wiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiZmxvYXQzMlwiKSxzPWNvbnZlcnRUb1RlbnNvcih0LFwiYm94SW5kXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJpbnQzMlwiKTtuPW58fFwiYmlsaW5lYXJcIixkPWR8fDA7dmFyIHU9aS5zaGFwZVswXTtyZXR1cm4gYXNzZXJ0KDQ9PT1jLnJhbmssXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBpbWFnZSBtdXN0IGJlIHJhbmsgNCxidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwiKSxhc3NlcnQoMj09PWkucmFuayYmND09PWkuc2hhcGVbMV0sXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hlcyBtdXN0IGJlIGhhdmUgc2l6ZSBbXCIrdStcIiw0XSBidXQgaGFkIHNoYXBlIFwiK2kuc2hhcGUrXCIuXCIpLGFzc2VydCgxPT09cy5yYW5rJiZzLnNoYXBlWzBdPT09dSxcIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveEluZCBtdXN0IGJlIGhhdmUgc2l6ZSBbXCIrdStcIl0gYnV0IGhhZCBzaGFwZSBcIitpLnNoYXBlK1wiLlwiKSxhc3NlcnQoXCJpbnQzMlwiPT09cy5kdHlwZSxcIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveEluZCBtdXN0IGJlIG9mIGR0eXBlIGludDMyLCBidXQgZ290IGR0eXBlIFwiK3MuZHR5cGUrXCIuXCIpLGFzc2VydCgyPT09ci5sZW5ndGgsXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBjcm9wU2l6ZSBtdXN0IGJlIG9mIGxlbmd0aCAyLCBidXQgZ290IGxlbmd0aCBcIityLmxlbmd0aCtcIi5cIiksYXNzZXJ0KDE8PXJbMF0mJjE8PXJbMV0sXCJjcm9wU2l6ZSBtdXN0IGJlIGF0bGVhc3QgWzEsMV0sIGJ1dCB3YXMgXCIrciksYXNzZXJ0KFwiYmlsaW5lYXJcIj09PW58fFwibmVhcmVzdFwiPT09bixcIm1ldGhvZCBtdXN0IGJlIGJpbGluZWFyIG9yIG5lYXJlc3QsIGJ1dCB3YXMgXCIrbiksRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY3JvcEFuZFJlc2l6ZShjLGkscyxyLG4sZCl9LHskaW1hZ2U6YywkYm94ZXM6aX0pfWZ1bmN0aW9uIG5leHRGcmFtZSgpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0KXtyZXR1cm4gZGVsYXlDYWxsYmFjayhmdW5jdGlvbigpe3JldHVybiB0KCl9KX0pfWZ1bmN0aW9uIGVuY29kZVdlaWdodHMoYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxzLGkscDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmZvcihpIGluIGU9W10scz1bXSxhKXtpZihcImZsb2F0MzJcIiE9PShwPWFbaV0pLmR0eXBlJiZcImludDMyXCIhPT1wLmR0eXBlJiZcImJvb2xcIiE9PXAuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIitpK1wiJzogXCIrcC5kdHlwZSk7ZS5wdXNoKHtuYW1lOmksc2hhcGU6cC5zaGFwZSxkdHlwZTpwLmR0eXBlfSkscy5wdXNoKHAuZGF0YSgpKX1yZXR1cm5bNCxQcm9taXNlLmFsbChzKV07Y2FzZSAxOnJldHVyblsyLHtkYXRhOmNvbmNhdGVuYXRlVHlwZWRBcnJheXModC5zZW50KCkpLHNwZWNzOmV9XTt9fSl9KX1mdW5jdGlvbiBkZWNvZGVXZWlnaHRzKHUsZSl7Zm9yKHZhciBtPXt9LHI9MCx0PWZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUuZHR5cGUsYT1lLnNoYXBlLG89c2l6ZUZyb21TaGFwZShhKSxzO2lmKChcInF1YW50aXphdGlvblwiaW4gZSkpe3ZhciBpPWUucXVhbnRpemF0aW9uO2lmKFwidWludDhcIiE9PWkuZHR5cGUmJlwidWludDE2XCIhPT1pLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIldlaWdodCBcIitlLm5hbWUrXCIgaGFzIHVua25vd24gcXVhbnRpemF0aW9uIGR0eXBlIFwiK2kuZHR5cGUrXCIuIFN1cHBvcnRlZCBxdWFudGl6YXRpb24gZHR5cGVzIGFyZTogJ3VpbnQ4JyBhbmQgJ3VpbnQxNicuXCIpO3ZhciBsPURUWVBFX1ZBTFVFX1NJWkVfTUFQW2kuZHR5cGVdLGM9dS5zbGljZShyLHIrbypsKSxnPVwidWludDhcIj09PWkuZHR5cGU/bmV3IFVpbnQ4QXJyYXkoYyk6bmV3IFVpbnQxNkFycmF5KGMpO2lmKFwiZmxvYXQzMlwiPT09bilzPUZsb2F0MzJBcnJheS5mcm9tKGcsZnVuY3Rpb24odCl7cmV0dXJuIHQqaS5zY2FsZStpLm1pbn0pO2Vsc2V7aWYoXCJpbnQzMlwiIT09bil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK3QrXCInOiBcIituKTtzPUludDMyQXJyYXkuZnJvbShnLGZ1bmN0aW9uKHQpe3JldHVybiBfTWF0aHJvdW5kKHQqaS5zY2FsZStpLm1pbil9KX1yKz1vKmx9ZWxzZXt2YXIgZD1EVFlQRV9WQUxVRV9TSVpFX01BUFtuXTtpZihjPXUuc2xpY2UocixyK28qZCksXCJmbG9hdDMyXCI9PT1uKXM9bmV3IEZsb2F0MzJBcnJheShjKTtlbHNlIGlmKFwiaW50MzJcIj09PW4pcz1uZXcgSW50MzJBcnJheShjKTtlbHNle2lmKFwiYm9vbFwiIT09bil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK3QrXCInOiBcIituKTtzPW5ldyBVaW50OEFycmF5KGMpfXIrPW8qZH12YXIgaDtpZihcImZsb2F0MzJcIj09PW4paD10ZW5zb3IocyxhLFwiZmxvYXQzMlwiKTtlbHNlIGlmKFwiaW50MzJcIj09PW4paD10ZW5zb3IocyxhLFwiaW50MzJcIik7ZWxzZXtpZihcImJvb2xcIiE9PW4pdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIit0K1wiJzogXCIrbik7aD10ZW5zb3IocyxhLFwiYm9vbFwiKX1tW3RdPWh9LG89MCxzPWU7bzxzLmxlbmd0aDtvKyspdChzW29dKTtyZXR1cm4gbX1mdW5jdGlvbiBjb25jYXRlbmF0ZVR5cGVkQXJyYXlzKGEpe2lmKG51bGw9PT1hKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdmFsdWU6IFwiK0pTT04uc3RyaW5naWZ5KGEpKTt2YXIgcz0wLGk9W107YS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKHMrPXQuYnl0ZUxlbmd0aCxpLnB1c2godC5ieXRlTGVuZ3RoPT09dC5idWZmZXIuYnl0ZUxlbmd0aD90Om5ldyB0LmNvbnN0cnVjdG9yKHQpKSwhKHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgVHlwZWRBcnJheSBzdWJ0eXBlOiBcIit0LmNvbnN0cnVjdG9yLm5hbWUpfSk7dmFyIHI9bmV3IFVpbnQ4QXJyYXkocyksbj0wO3JldHVybiBpLmZvckVhY2goZnVuY3Rpb24odCl7ci5zZXQobmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLG4pLG4rPXQuYnl0ZUxlbmd0aH0pLHIuYnVmZmVyfWZ1bmN0aW9uIHN0cmluZ0J5dGVMZW5ndGgodCl7cmV0dXJuIHVzZU5vZGVCdWZmZXI/QnVmZmVyLmJ5dGVMZW5ndGgodCk6bmV3IEJsb2IoW3RdKS5zaXplfWZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcodCl7cmV0dXJuIHVzZU5vZGVCdWZmZXI/QnVmZmVyLmZyb20odCkudG9TdHJpbmcoXCJiYXNlNjRcIik6YnRvYShfU3RyaW5nZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkodCkpKX1mdW5jdGlvbiBiYXNlNjRTdHJpbmdUb0FycmF5QnVmZmVyKGEpe2lmKHVzZU5vZGVCdWZmZXIpe3ZhciBlPUJ1ZmZlci5mcm9tKGEsXCJiYXNlNjRcIik7cmV0dXJuIGUuYnVmZmVyLnNsaWNlKGUuYnl0ZU9mZnNldCxlLmJ5dGVPZmZzZXQrZS5ieXRlTGVuZ3RoKX1mb3IodmFyIHQ9YXRvYihhKSxyPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxuPTA7bjx0Lmxlbmd0aDsrK24pci5zZXQoW3QuY2hhckNvZGVBdChuKV0sbik7cmV0dXJuIHIuYnVmZmVyfWZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKGEpe3ZhciBvPTA7YS5mb3JFYWNoKGZ1bmN0aW9uKHQpe28rPXQuYnl0ZUxlbmd0aH0pO3ZhciBzPW5ldyBVaW50OEFycmF5KG8pLHI9MDtyZXR1cm4gYS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Muc2V0KG5ldyBVaW50OEFycmF5KHQpLHIpLHIrPXQuYnl0ZUxlbmd0aH0pLHMuYnVmZmVyfWZ1bmN0aW9uIGJhc2VuYW1lKGEpe2ZvcihhPWEudHJpbSgpO2EuZW5kc1dpdGgoXCIvXCIpOylhPWEuc2xpY2UoMCxhLmxlbmd0aC0xKTt2YXIgbj1hLnNwbGl0KFwiL1wiKTtyZXR1cm4gbltuLmxlbmd0aC0xXX1mdW5jdGlvbiBnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKHQpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEpTT04gbW9kZWwgdG9wb2xvZ3ksIHJlY2VpdmVkIEFycmF5QnVmZmVyLlwiKTtyZXR1cm57ZGF0ZVNhdmVkOm5ldyBEYXRlLG1vZGVsVG9wb2xvZ3lUeXBlOlwiSlNPTlwiLG1vZGVsVG9wb2xvZ3lCeXRlczpudWxsPT10Lm1vZGVsVG9wb2xvZ3k/MDpzdHJpbmdCeXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KHQubW9kZWxUb3BvbG9neSkpLHdlaWdodFNwZWNzQnl0ZXM6bnVsbD09dC53ZWlnaHRTcGVjcz8wOnN0cmluZ0J5dGVMZW5ndGgoSlNPTi5zdHJpbmdpZnkodC53ZWlnaHRTcGVjcykpLHdlaWdodERhdGFCeXRlczpudWxsPT10LndlaWdodERhdGE/MDp0LndlaWdodERhdGEuYnl0ZUxlbmd0aH19ZnVuY3Rpb24gcGFyc2VVUkwodCl7aWYoLTE9PT10LmluZGV4T2YoXCI6Ly9cIikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHVybCBzdHJpbmcgcHJvdmlkZWQgZG9lcyBub3QgY29udGFpbiBhIHNjaGVtZS4gU3VwcG9ydGVkIHNjaGVtZXMgYXJlOiBcIitNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldFNjaGVtZXMoKS5qb2luKFwiLFwiKSk7cmV0dXJue3NjaGVtZTp0LnNwbGl0KFwiOi8vXCIpWzBdLHBhdGg6dC5zcGxpdChcIjovL1wiKVsxXX19ZnVuY3Rpb24gY2xvbmVNb2RlbEludGVybmFsKG0sZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixoLGcsZix5LGIseCxOLEk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDpyZXR1cm4gYXNzZXJ0KG0hPT1lLFwiT2xkIHBhdGggYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZTogJ1wiK20rXCInXCIpLGFzc2VydCgwPChyPUlPUm91dGVyUmVnaXN0cnkuZ2V0TG9hZEhhbmRsZXJzKG0pKS5sZW5ndGgsXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIGxvYWQgaGFuZGxlciBpcyBmb3VuZCBmb3Igc291cmNlIFVSTCBcIittK1wiLlwiKSxhc3NlcnQoMj5yLmxlbmd0aCxcIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoXCIrci5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIHNvdXJjZSBVUkwgXCIrbStcIi5cIiksaD1yWzBdLGFzc2VydCgwPChnPUlPUm91dGVyUmVnaXN0cnkuZ2V0U2F2ZUhhbmRsZXJzKGUpKS5sZW5ndGgsXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIHNhdmUgaGFuZGxlciBpcyBmb3VuZCBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCIpLGFzc2VydCgyPmcubGVuZ3RoLFwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIityLmxlbmd0aCtcIikgc2F2ZSBoYW5kbGVycyBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCIpLGY9Z1swXSx5PXBhcnNlVVJMKG0pLnNjaGVtZSxiPXBhcnNlVVJMKG0pLnBhdGgseD15PT09cGFyc2VVUkwobSkuc2NoZW1lLFs0LGgubG9hZCgpXTtjYXNlIDE6cmV0dXJuIE49YS5zZW50KCksdCYmeD9bNCxNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldE1hbmFnZXIoeSkucmVtb3ZlTW9kZWwoYildOlszLDNdO2Nhc2UgMjphLnNlbnQoKSxhLmxhYmVsPTM7Y2FzZSAzOnJldHVybls0LGYuc2F2ZShOKV07Y2FzZSA0OnJldHVybiBJPWEuc2VudCgpLCF0fHx4P1szLDZdOls0LE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0TWFuYWdlcih5KS5yZW1vdmVNb2RlbChiKV07Y2FzZSA1OmEuc2VudCgpLGEubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzIsSS5tb2RlbEFydGlmYWN0c0luZm9dO319KX0pfWZ1bmN0aW9uIGxpc3RNb2RlbHMoKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBwLGwsZCx1LGMsbSxoO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cD1Nb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldFNjaGVtZXMoKSxsPXt9LGQ9MCx1PXAsZS5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gZDx1Lmxlbmd0aD8oYz11W2RdLFs0LE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0TWFuYWdlcihjKS5saXN0TW9kZWxzKCldKTpbMyw0XTtjYXNlIDI6Zm9yKGggaW4gbT1lLnNlbnQoKSlsW2MrXCI6Ly9cIitoXT1tW2hdO2UubGFiZWw9MztjYXNlIDM6cmV0dXJuIGQrKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzIsbF07fX0pfSl9ZnVuY3Rpb24gcmVtb3ZlTW9kZWwoYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPXBhcnNlVVJMKGEpLFs0LE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0TWFuYWdlcihlLnNjaGVtZSkucmVtb3ZlTW9kZWwoZS5wYXRoKV07Y2FzZSAxOnJldHVyblsyLHQuc2VudCgpXTt9fSl9KX1mdW5jdGlvbiBjb3B5TW9kZWwoYSxlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsY2xvbmVNb2RlbEludGVybmFsKGEsZSwhMSldO2Nhc2UgMTpyZXR1cm5bMix0LnNlbnQoKV07fX0pfSl9ZnVuY3Rpb24gbW92ZU1vZGVsKGEsZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGNsb25lTW9kZWxJbnRlcm5hbChhLGUsITApXTtjYXNlIDE6cmV0dXJuWzIsdC5zZW50KCldO319KX0pfWZ1bmN0aW9uIGdldEluZGV4ZWREQkZhY3RvcnkoKXtpZighRU5WLmdldChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIG9idGFpbiBJbmRleGVkREIgZmFjdG9yeSBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50aXMgbm90IGEgd2ViIGJyb3dzZXIuXCIpO3ZhciBhPXdpbmRvdyxlPWEuaW5kZXhlZERCfHxhLm1vekluZGV4ZWREQnx8YS53ZWJraXRJbmRleGVkREJ8fGEubXNJbmRleGVkREJ8fGEuc2hpbUluZGV4ZWREQjtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgSW5kZXhlZERCLlwiKTtyZXR1cm4gZX1mdW5jdGlvbiBzZXRVcERhdGFiYXNlKGEpe3ZhciBlPWEucmVzdWx0O2UuY3JlYXRlT2JqZWN0U3RvcmUoXCJtb2RlbHNfc3RvcmVcIix7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSksZS5jcmVhdGVPYmplY3RTdG9yZShcIm1vZGVsX2luZm9fc3RvcmVcIix7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSl9ZnVuY3Rpb24gYnJvd3NlckluZGV4ZWREQih0KXtyZXR1cm4gbmV3IEJyb3dzZXJJbmRleGVkREIodCl9ZnVuY3Rpb24gbWF5YmVTdHJpcFNjaGVtZSh0KXtyZXR1cm4gdC5zdGFydHNXaXRoKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRSk/dC5zbGljZShCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUubGVuZ3RoKTp0fWZ1bmN0aW9uIGdldE1vZGVsS2V5cyh0KXtyZXR1cm57aW5mbzpbXCJ0ZW5zb3JmbG93anNfbW9kZWxzXCIsdCxcImluZm9cIl0uam9pbihcIi9cIiksdG9wb2xvZ3k6W1widGVuc29yZmxvd2pzX21vZGVsc1wiLHQsXCJtb2RlbF90b3BvbG9neVwiXS5qb2luKFwiL1wiKSx3ZWlnaHRTcGVjczpbXCJ0ZW5zb3JmbG93anNfbW9kZWxzXCIsdCxcIndlaWdodF9zcGVjc1wiXS5qb2luKFwiL1wiKSx3ZWlnaHREYXRhOltcInRlbnNvcmZsb3dqc19tb2RlbHNcIix0LFwid2VpZ2h0X2RhdGFcIl0uam9pbihcIi9cIil9fWZ1bmN0aW9uIGdldE1vZGVsUGF0aEZyb21LZXkoYSl7dmFyIGU9YS5zcGxpdChcIi9cIik7aWYoMz5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSBmb3JtYXQ6IFwiK2EpO3JldHVybiBlLnNsaWNlKDEsZS5sZW5ndGgtMSkuam9pbihcIi9cIil9ZnVuY3Rpb24gbWF5YmVTdHJpcFNjaGVtZSQxKHQpe3JldHVybiB0LnN0YXJ0c1dpdGgoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FKT90LnNsaWNlKEJyb3dzZXJMb2NhbFN0b3JhZ2UuVVJMX1NDSEVNRS5sZW5ndGgpOnR9ZnVuY3Rpb24gYnJvd3NlckxvY2FsU3RvcmFnZSh0KXtyZXR1cm4gbmV3IEJyb3dzZXJMb2NhbFN0b3JhZ2UodCl9ZnVuY3Rpb24gYnJvd3NlckRvd25sb2Fkcyh0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJtb2RlbFwiKSxuZXcgQnJvd3NlckRvd25sb2Fkcyh0KX1mdW5jdGlvbiBicm93c2VyRmlsZXModCl7cmV0dXJuIG5ldyBCcm93c2VyRmlsZXModCl9ZnVuY3Rpb24gbG9hZFdlaWdodHNBc0FycmF5QnVmZmVyKGEsbil7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSx0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9YS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGZldGNoKHQsbil9KSxbNCxQcm9taXNlLmFsbChlKV07Y2FzZSAxOnJldHVybiB0PW4uc2VudCgpLFs0LFByb21pc2UuYWxsKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSldO2Nhc2UgMjpyZXR1cm5bMixuLnNlbnQoKV07fX0pfSl9ZnVuY3Rpb24gbG9hZFdlaWdodHMobSxhLGcsZSl7cmV0dXJuIHZvaWQgMD09PWEmJihhPVwiXCIpLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcix5LG4sYix0LHgsTixJLHYsUztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmlmKHI9bS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4hMX0pLHk9e30sbj1udWxsPT1nP1tdOmcubWFwKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSxiPVtdLG0uZm9yRWFjaChmdW5jdGlvbihhLG8pe3ZhciB0PTA7YS53ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGU9XCJxdWFudGl6YXRpb25cImluIGE/YS5xdWFudGl6YXRpb24uZHR5cGU6YS5kdHlwZSxuPURUWVBFX1ZBTFVFX1NJWkVfTUFQW2VdKnNpemVGcm9tU2hhcGUoYS5zaGFwZSkscz1mdW5jdGlvbigpe3Jbb109ITAsbnVsbD09eVtvXSYmKHlbb109W10pLHlbb10ucHVzaCh7bWFuaWZlc3RFbnRyeTphLGdyb3VwT2Zmc2V0OnQsc2l6ZUJ5dGVzOm59KX07bnVsbD09Zz9zKCk6Zy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7ZT09PWEubmFtZSYmKHMoKSxuW3RdPSEwKX0pLGIucHVzaChhLm5hbWUpLHQrPW59KX0pLCFuLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpdGhyb3cgdD1nLmZpbHRlcihmdW5jdGlvbihhLGUpe3JldHVybiFuW2VdfSksbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2VpZ2h0cyBpbiBtYW5pZmVzdCB3aXRoIG5hbWVzOiBcIit0LmpvaW4oXCIsIFwiKStcIi4gXFxuTWFuaWZlc3QgSlNPTiBoYXMgd2VpZ2h0cyB3aXRoIG5hbWVzOiBcIitiLmpvaW4oXCIsIFwiKStcIi5cIik7cmV0dXJuIHg9ci5yZWR1Y2UoZnVuY3Rpb24oYSxlLHQpe3JldHVybiBlJiZhLnB1c2godCksYX0sW10pLE49W10seC5mb3JFYWNoKGZ1bmN0aW9uKGUpe21bZV0ucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT1hKyhhLmVuZHNXaXRoKFwiL1wiKT9cIlwiOlwiL1wiKSt0O04ucHVzaChlKX0pfSksWzQsbG9hZFdlaWdodHNBc0FycmF5QnVmZmVyKE4sZSldO2Nhc2UgMTpyZXR1cm4gST1vLnNlbnQoKSx2PXt9LFM9MCx4LmZvckVhY2goZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW1bZV0ucGF0aHMubGVuZ3RoLGE9MCxyPTA7cjx0O3IrKylhKz1JW1Mrcl0uYnl0ZUxlbmd0aDtmb3IodmFyIHA9bmV3IEFycmF5QnVmZmVyKGEpLGk9bmV3IFVpbnQ4QXJyYXkocCkscz0wLGQ9MCxoO2Q8dDtkKyspaD1uZXcgVWludDhBcnJheShJW1MrZF0pLGkuc2V0KGgscykscys9aC5ieXRlTGVuZ3RoO3lbZV0uZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgZT1kZWNvZGVXZWlnaHRzKHAuc2xpY2UoYS5ncm91cE9mZnNldCxhLmdyb3VwT2Zmc2V0K2Euc2l6ZUJ5dGVzKSxbYS5tYW5pZmVzdEVudHJ5XSk7Zm9yKHZhciB0IGluIGUpdlt0XT1lW3RdfSksUys9dH0pLFsyLHZdO319KX0pfWZ1bmN0aW9uIHBhcnNlVXJsKGEpe3ZhciBlPWEubGFzdEluZGV4T2YoXCIvXCIpLHQ9YS5sYXN0SW5kZXhPZihcIj9cIik7cmV0dXJuW2Euc3Vic3RyaW5nKDAsZSkrXCIvXCIsdD5lP2Euc3Vic3RyaW5nKHQpOlwiXCJdfWZ1bmN0aW9uIGlzSFRUUFNjaGVtZSh0KXtyZXR1cm4gbnVsbCE9dC5tYXRjaChCcm93c2VySFRUUFJlcXVlc3QuVVJMX1NDSEVNRV9SRUdFWCl9ZnVuY3Rpb24gYnJvd3NlckhUVFBSZXF1ZXN0KGEsZSx0KXtyZXR1cm4gbmV3IEJyb3dzZXJIVFRQUmVxdWVzdChhLGUsdCl9ZnVuY3Rpb24gZnJvbU1lbW9yeShhLGUsdCl7cmV0dXJuIG5ldyBQYXNzdGhyb3VnaExvYWRlcihhLGUsdCl9ZnVuY3Rpb24gd2l0aFNhdmVIYW5kbGVyKHQpe3JldHVybiBuZXcgUGFzc3Rocm91Z2hTYXZlcih0KX1mdW5jdGlvbiBjb25mdXNpb25NYXRyaXhfKHMsZSx0KXt2YXIgcj1jb252ZXJ0VG9UZW5zb3IocyxcImxhYmVsXCIsXCJjb25mdXNpb25NYXRyaXhcIixcImludDMyXCIpLG49Y29udmVydFRvVGVuc29yKGUsXCJsYWJlbFwiLFwiY29uZnVzaW9uTWF0cml4XCIsXCJpbnQzMlwiKTthc3NlcnQobnVsbD09dHx8MDx0JiZfTnVtYmVyaXNJbnRlZ2VyKHQpLFwiSWYgcHJvdmlkZWQsIG51bUNsYXNzZXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrdCksYXNzZXJ0KDE9PT1yLnJhbmssXCJFeHBlY3RlZCB0aGUgcmFuayBvZiBsYWJlbHMgdG8gYmUgMSwgYnV0IGdvdCBcIityLnJhbmspLGFzc2VydCgxPT09bi5yYW5rLFwiRXhwZWN0ZWQgdGhlIHJhbmsgb2YgcHJlZGljdGlvbnMgdG8gYmUgMSwgYnV0IGdvdCBcIituLnJhbmspLGFzc2VydChyLnNoYXBlWzBdPT09bi5zaGFwZVswXSxcIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZXhhbXBsZXM6IFwiK3Iuc2hhcGVbMF0rXCIgdnMuIFwiK24uc2hhcGVbMF0rXCIuIExhYmVscyBhbmQgcHJlZGljdGlvbnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLlwiKSxhc3NlcnQoMDx0JiZfTnVtYmVyaXNJbnRlZ2VyKHQpLFwibnVtQ2xhc3NlcyBpcyByZXF1aXJlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrdCk7dmFyIG89b25lSG90KHIuYXNUeXBlKFwiaW50MzJcIiksdCksYT1vbmVIb3Qobi5hc1R5cGUoXCJpbnQzMlwiKSx0KTtyZXR1cm4gby50cmFuc3Bvc2UoKS5tYXRNdWwoYSkuYXNUeXBlKFwiaW50MzJcIil9ZnVuY3Rpb24gcmVnaXN0ZXJDbGFzcyh0KXthc3NlcnQobnVsbCE9dC5jbGFzc05hbWUsXCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGRvZXMgbm90IGhhdmUgdGhlIHN0YXRpYyBjbGFzc05hbWUgcHJvcGVydHkgZGVmaW5lZC5cIiksYXNzZXJ0KFwic3RyaW5nXCI9PXR5cGVvZiB0LmNsYXNzTmFtZSxcImNsYXNzTmFtZSBpcyByZXF1aXJlZCB0byBiZSBhIHN0cmluZywgYnV0IGdvdCB0eXBlIFwiK3R5cGVvZiB0LmNsYXNzTmFtZSksYXNzZXJ0KDA8dC5jbGFzc05hbWUubGVuZ3RoLFwiQ2xhc3MgYmVpbmcgcmVnaXN0ZXJlZCBoYXMgYW4gZW1wdHktc3RyaW5nIGFzIGl0cyBjbGFzc05hbWUsIHdoaWNoIGlzIGRpc2FsbG93ZWQuXCIpLFNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIodCl9ZnVuY3Rpb24gZXhwZWN0QXJyYXlzQ2xvc2UocCxlLHQpe2lmKCEobnVsbD09dCYmKHQ9RU5WLmdldChcIlRFU1RfRVBTSUxPTlwiKSkscCBpbnN0YW5jZW9mIFRlbnNvcnx8ZSBpbnN0YW5jZW9mIFRlbnNvcikpe3ZhciBkPXAuY29uc3RydWN0b3IubmFtZSxuPWUuY29uc3RydWN0b3IubmFtZTtpZihkIT09bil0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlIGFjdHVhbDogXCIrZCtcIiB2cyBleHBlY3RlZDogXCIrbil9ZWxzZSBpZihwIGluc3RhbmNlb2YgVGVuc29yJiZlIGluc3RhbmNlb2YgVGVuc29yKXtpZihwLmR0eXBlIT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlIGFjdHVhbDogXCIrcC5kdHlwZStcIiB2cyBleHBlY3RlZDogXCIrZS5kdHlwZStcIi5cIik7aWYoIWFycmF5c0VxdWFsKHAuc2hhcGUsZS5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgc2hhcGUgYWN0dWFsOiBcIitwLnNoYXBlK1wiIHZzIGV4cGVjdGVkOiBcIitlLnNoYXBlK1wiLlwiKX12YXIgbyxjO2lmKG89cCBpbnN0YW5jZW9mIFRlbnNvcj9wLmRhdGFTeW5jKCk6cCxjPWUgaW5zdGFuY2VvZiBUZW5zb3I/ZS5kYXRhU3luYygpOmUsby5sZW5ndGghPT1jLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyBhY3R1YWw6IFwiK28ubGVuZ3RoK1wiIHZzIGV4cGVjdGVkOiBcIitjLmxlbmd0aCtcIi5cXG5BY3R1YWw6ICAgXCIrbytcIi5cXG5FeHBlY3RlZDogXCIrYytcIi5cIik7Zm9yKHZhciBtPTA7bTxjLmxlbmd0aDsrK20pe3ZhciBoPW9bbV0sdT1jW21dO2lmKCFhcmVDbG9zZShoLCt1LHQpKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBkaWZmZXI6IGFjdHVhbFtcIittK1wiXSA9IFwiK2grXCIsIGV4cGVjdGVkW1wiK20rXCJdID0gXCIrdStcIi5cXG5BY3R1YWw6ICAgXCIrbytcIi5cXG5FeHBlY3RlZDogXCIrYytcIi5cIil9fWZ1bmN0aW9uIGV4cGVjdFByb21pc2VUb0ZhaWwoYSxlKXthKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBlLmZhaWwoKX0sZnVuY3Rpb24oKXtyZXR1cm4gZSgpfSl9ZnVuY3Rpb24gZXhwZWN0QXJyYXlzRXF1YWwoYSxlKXtyZXR1cm4gZXhwZWN0QXJyYXlzQ2xvc2UoYSxlLDApfWZ1bmN0aW9uIGV4cGVjdE51bWJlcnNDbG9zZShhLGUsdCl7aWYobnVsbD09dCYmKHQ9RU5WLmdldChcIlRFU1RfRVBTSUxPTlwiKSksIWFyZUNsb3NlKGEsZSx0KSl0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXJzIGRpZmZlcjogYWN0dWFsID09PSBcIithK1wiLCBleHBlY3RlZCA9PT0gXCIrZSl9ZnVuY3Rpb24gYXJlQ2xvc2UoYSxlLHQpe3JldHVybiBpc05hTihhKSYmaXNOYU4oZSl8fCEoaXNOYU4oYSl8fGlzTmFOKGUpfHxfTWF0aGFicyhhLWUpPnQpfWZ1bmN0aW9uIGV4cGVjdFZhbHVlc0luUmFuZ2UoYSxlLHQpe3ZhciByPWEgaW5zdGFuY2VvZiBUZW5zb3I/YS5kYXRhU3luYygpOmE7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aDtuKyspaWYocltuXTxlfHxyW25dPnQpdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlOlwiK3Jbbl0rXCIgbG93OiBcIitlK1wiLCBoaWdoOiBcIit0KX1mdW5jdGlvbiBleHBlY3RBcnJheUJ1ZmZlcnNFcXVhbChhLGUpe2V4cGVjdChuZXcgRmxvYXQzMkFycmF5KGEpKS50b0VxdWFsKG5ldyBGbG9hdDMyQXJyYXkoZSkpfWZ1bmN0aW9uIF9fZXh0ZW5kcyQxKGEsZSl7ZnVuY3Rpb24gdCgpe3RoaXMuY29uc3RydWN0b3I9YX1leHRlbmRTdGF0aWNzJDEoYSxlKSxhLnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOih0LnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gX19hd2FpdGVyJDEocCxlLHQsZCl7cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoZnVuY3Rpb24obixyKXtmdW5jdGlvbiBhKHQpe3RyeXtzKGQubmV4dCh0KSl9Y2F0Y2godCl7cih0KX19ZnVuY3Rpb24gbyh0KXt0cnl7cyhkLnRocm93KHQpKX1jYXRjaCh0KXtyKHQpfX1mdW5jdGlvbiBzKHIpe3IuZG9uZT9uKHIudmFsdWUpOm5ldyB0KGZ1bmN0aW9uKGUpe2Uoci52YWx1ZSl9KS50aGVuKGEsbyl9cygoZD1kLmFwcGx5KHAsZXx8W10pKS5uZXh0KCkpfSl9ZnVuY3Rpb24gX19nZW5lcmF0b3IkMShwLGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbih0KXtpZihsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKGw9MSxkJiYodT0yJnRbMF0/ZC5yZXR1cm46dFswXT9kLnRocm93fHwoKHU9ZC5yZXR1cm4pJiZ1LmNhbGwoZCksMCk6ZC5uZXh0KSYmISh1PXUuY2FsbChkLHRbMV0pKS5kb25lKXJldHVybiB1O3N3aXRjaChkPTAsdSYmKHQ9WzImdFswXSx1LnZhbHVlXSksdFswXSl7Y2FzZSAwOmNhc2UgMTp1PXQ7YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOnRbMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxkPXRbMV0sdD1bMF07Y29udGludWU7Y2FzZSA3OnQ9cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoISh1PTA8KHU9cy50cnlzKS5sZW5ndGgmJnVbdS5sZW5ndGgtMV0pJiYoNj09PXRbMF18fDI9PT10WzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT10WzBdJiYoIXV8fHRbMV0+dVswXSYmdFsxXTx1WzNdKSl7cy5sYWJlbD10WzFdO2JyZWFrfWlmKDY9PT10WzBdJiZzLmxhYmVsPHVbMV0pe3MubGFiZWw9dVsxXSx1PXQ7YnJlYWt9aWYodSYmcy5sYWJlbDx1WzJdKXtzLmxhYmVsPXVbMl0scy5vcHMucHVzaCh0KTticmVha311WzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWU7fXQ9ZS5jYWxsKHAscyl9Y2F0Y2goYSl7dD1bNixhXSxkPTB9ZmluYWxseXtsPXU9MH1pZig1JnRbMF0pdGhyb3cgdFsxXTtyZXR1cm57dmFsdWU6dFswXT90WzFdOnZvaWQgMCxkb25lOiEwfX0oW3QsYV0pfX12YXIgcz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZ1WzBdKXRocm93IHVbMV07cmV0dXJuIHVbMV19LHRyeXM6W10sb3BzOltdfSxsLGQsdSxjO3JldHVybiBjPXtuZXh0OnQoMCksdGhyb3c6dCgxKSxyZXR1cm46dCgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoY1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxjfWZ1bmN0aW9uIGVwc2lsb24oKXtyZXR1cm4gX2Vwc2lsb259ZnVuY3Rpb24gaW1hZ2VEYXRhRm9ybWF0KCl7cmV0dXJuXCJjaGFubmVsc0xhc3RcIn1mdW5jdGlvbiBnZXROZXh0VW5pcXVlVGVuc29ySWQoKXtyZXR1cm4gX25leHRVbmlxdWVUZW5zb3JJZCsrfWZ1bmN0aW9uIGdldFVpZCh0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJcIiksdCBpbiBfdWlkUHJlZml4ZXN8fChfdWlkUHJlZml4ZXNbdF09MCksX3VpZFByZWZpeGVzW3RdKz0xLHQrX3VpZFByZWZpeGVzW3RdLnRvU3RyaW5nKCl9ZnVuY3Rpb24gZ2V0U2NhbGFyKGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxudWxsPT1zY2FsYXJDYWNoZVtlXVthXSYmKHNjYWxhckNhY2hlW2VdW2FdPXNjYWxhcihhLGUpLGtlZXAoc2NhbGFyQ2FjaGVbZV1bYV0pKSxzY2FsYXJDYWNoZVtlXVthXX1mdW5jdGlvbiBweUxpc3RSZXBlYXQoYSxlKXtpZihBcnJheS5pc0FycmF5KGEpKXtmb3IodmFyIHQ9W10sbz0wO288ZTtvKyspdD10LmNvbmNhdChhKTtyZXR1cm4gdH1yZXR1cm4odD1BcnJheShlKSkuZmlsbChhKSx0fWZ1bmN0aW9uIGFzc2VydCQxKGEsZSl7aWYoIWEpdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGUpfWZ1bmN0aW9uIGNvdW50KGEsZSl7Zm9yKHZhciB0PTAsbz0wLHM9YTtvPHMubGVuZ3RoO28rKylzW29dPT09ZSYmdCsrO3JldHVybiB0fWZ1bmN0aW9uIHNpbmdsZXRvbk9yQXJyYXkodCl7cmV0dXJuIDE9PT10Lmxlbmd0aD90WzBdOnR9ZnVuY3Rpb24gdG9MaXN0KHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP3Q6W3RdfWZ1bmN0aW9uIHRvU25ha2VDYXNlKGEpe3ZhciBlPWEucmVwbGFjZSgvKC4pKFtBLVpdW2EtejAtOV0rKS9nLFwiJDFfJDJcIikucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJfXCI9PT1lWzBdP1wicHJpdmF0ZVwiK2U6ZX1mdW5jdGlvbiB0b0NhbWVsQ2FzZSh0KXtyZXR1cm4gMT49dC5sZW5ndGg/dDotMT09PXQuaW5kZXhPZihcIl9cIik/dDp0LnJlcGxhY2UoL1tfXSsoXFx3fCQpL2csZnVuY3Rpb24oYSxlKXtyZXR1cm4gZS50b1VwcGVyQ2FzZSgpfSl9ZnVuY3Rpb24gc2VyaWFsaXplS2VyYXNPYmplY3QodCl7cmV0dXJuIG51bGw9PT10fHx2b2lkIDA9PT10P251bGw6e2NsYXNzTmFtZTp0LmdldENsYXNzTmFtZSgpLGNvbmZpZzp0LmdldENvbmZpZygpfX1mdW5jdGlvbiBkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KHgsZSxDLGspe2lmKHZvaWQgMD09PWUmJihlPXt9KSx2b2lkIDA9PT1DJiYoQz17fSksdm9pZCAwPT09ayYmKGs9XCJvYmplY3RcIiksXCJzdHJpbmdcIj09dHlwZW9mIHgpe3ZhciBUPXgsaTtpZihUIGluIEMpaT1DW1RdO2Vsc2UgaWYoVCBpbiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKWk9X0dMT0JBTF9DVVNUT01fT0JKRUNUU1tUXTtlbHNlIGlmKG51bGw9PShpPWVbVF0pKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5rbm93biBcIitrK1wiOiBcIit4K1wiLiBUaGlzIG1heSBiZSBkdWUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBUaGUgXCIraytcIiBpcyBkZWZpbmVkIGluIFB5dGhvbiwgaW4gd2hpY2ggY2FzZSBpdCBuZWVkcyB0byBiZSBwb3J0ZWQgdG8gVGVuc29yRmxvdy5qcyBvciB5b3VyIEphdmFTY3JpcHQgY29kZS5cXG4yLiBUaGUgY3VzdG9tIFwiK2srXCIgaXMgZGVmaW5lZCBpbiBKYXZhU2NyaXB0LCBidXQgaXMgbm90IHJlZ2lzdGVyZWQgcHJvcGVybHkgd2l0aCB0Zi5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoKS5cIik7cmV0dXJuIGl9dmFyIEU9eDtpZihudWxsPT1FLmNsYXNzTmFtZXx8bnVsbD09RS5jb25maWcpdGhyb3cgbmV3IFZhbHVlRXJyb3IoaytcIjogSW1wcm9wZXIgY29uZmlnIGZvcm1hdDogXCIrSlNPTi5zdHJpbmdpZnkoRSkrXCIuXFxuJ2NsYXNzTmFtZScgYW5kICdjb25maWcnIG11c3Qgc2V0LlwiKTt2YXIgbz1FLmNsYXNzTmFtZSxzLFI7aWYobyBpbiBDPyhzPSh6PUMuZ2V0KG8pKVswXSxSPXpbMV0pOm8gaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUz8ocz0oQj1fR0xPQkFMX0NVU1RPTV9PQkpFQ1RTLmNsYXNzTmFtZSlbMF0sUj1CWzFdKTpvIGluIGUmJihzPShWPWVbb10pWzBdLFI9VlsxXSksbnVsbD09cyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gXCIraytcIjogXCIrbytcIi4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gVGhlIFwiK2srXCIgaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGNhc2UgaXQgbmVlZHMgdG8gYmUgcG9ydGVkIHRvIFRlbnNvckZsb3cuanMgb3IgeW91ciBKYXZhU2NyaXB0IGNvZGUuXFxuMi4gVGhlIGN1c3RvbSBcIitrK1wiIGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYnV0IGlzIG5vdCByZWdpc3RlcmVkIHByb3Blcmx5IHdpdGggdGYuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKCkuXCIpO2lmKG51bGwhPVIpe2Zvcih2YXIgRD17fSxjPTAsUD1PYmplY3Qua2V5cyhfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKTtjPFAubGVuZ3RoO2MrKylEW3k9UFtjXV09X0dMT0JBTF9DVVNUT01fT0JKRUNUU1t5XTtmb3IodmFyIGg9MCxBPU9iamVjdC5rZXlzKEMpO2g8QS5sZW5ndGg7aCsrKURbeT1BW2hdXT1DW3ldO0UuY29uZmlnLmN1c3RvbU9iamVjdHM9RDtmb3IodmFyIGY9X19hc3NpZ24kMSh7fSxfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKSxfPTAsTz1PYmplY3Qua2V5cyhDKSx5O188Ty5sZW5ndGg7XysrKXk9T1tfXSxfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW3ldPUNbeV07dmFyIEw9UihzLEUuY29uZmlnKTtyZXR1cm4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUz1fX2Fzc2lnbiQxKHt9LGYpLEx9Zj1fX2Fzc2lnbiQxKHt9LF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpO2Zvcih2YXIgTT0wLEY9T2JqZWN0LmtleXMoQyk7TTxGLmxlbmd0aDtNKyspeT1GW01dLF9HTE9CQUxfQ1VTVE9NX09CSkVDVFNbeV09Q1t5XTt2YXIgeixCLFY7cmV0dXJuIEw9bmV3IHMoRS5jb25maWcpLF9HTE9CQUxfQ1VTVE9NX09CSkVDVFM9X19hc3NpZ24kMSh7fSxmKSxMfWZ1bmN0aW9uIG51bWJlckNvbXBhcmUoYSxlKXtyZXR1cm4gYTxlPy0xOmE+ZT8xOjB9ZnVuY3Rpb24gcmV2ZXJzZU51bWJlckNvbXBhcmUoYSxlKXtyZXR1cm4tMSpudW1iZXJDb21wYXJlKGEsZSl9ZnVuY3Rpb24gc3RyaW5nVG9EVHlwZSh0KXtzd2l0Y2godCl7Y2FzZVwiZmxvYXQzMlwiOnJldHVyblwiZmxvYXQzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnZhbGlkIGR0eXBlOiBcIit0KTt9fWZ1bmN0aW9uIHVuaXF1ZShhKXtpZihudWxsPT1hKXJldHVybiBhO2Zvcih2YXIgZT1bXSx0PTAsbz1hLHI7dDxvLmxlbmd0aDt0Kyspcj1vW3RdLC0xPT09ZS5pbmRleE9mKHIpJiZlLnB1c2gocik7cmV0dXJuIGV9ZnVuY3Rpb24gaXNPYmplY3RFbXB0eShhKXtpZihudWxsPT1hKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW52YWxpZCB2YWx1ZSBpbiBvYmo6IFwiK0pTT04uc3RyaW5naWZ5KGEpKTtmb3IodmFyIGUgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGUpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoYSxlLHQpe2lmKG51bGwhPXQmJjA+YS5pbmRleE9mKHQpKXRocm93IG5ldyBWYWx1ZUVycm9yKHQrXCIgaXMgbm90IGEgdmFsaWQgXCIrZStcIi4gIFZhbGlkIHZhbHVlcyBhcmUgXCIrYStcIiBvciBudWxsL3VuZGVmaW5lZC5cIil9ZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoYSxvLGUsdCl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PXQmJih0PTEvMCksYXNzZXJ0JDEoMDw9ZSksYXNzZXJ0JDEodD49ZSksQXJyYXkuaXNBcnJheShhKSYmYS5sZW5ndGg+PWUmJmEubGVuZ3RoPD10JiZhLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09PW99KX1mdW5jdGlvbiBjYWxjTDJOb3JtcyhhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHNxcnQoc3VtJDEobXVsU3RyaWN0KGEsYSksZSwhMCkpfSl9ZnVuY3Rpb24gc2VyaWFsaXplQ29uc3RyYWludCh0KXtyZXR1cm4gc2VyaWFsaXplS2VyYXNPYmplY3QodCl9ZnVuY3Rpb24gZGVzZXJpYWxpemVDb25zdHJhaW50KGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGEsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCxlLFwiY29uc3RyYWludFwiKX1mdW5jdGlvbiBnZXRDb25zdHJhaW50KHQpe3JldHVybiBudWxsPT10P251bGw6XCJzdHJpbmdcIj09dHlwZW9mIHQ/ZGVzZXJpYWxpemVDb25zdHJhaW50KHtjbGFzc05hbWU6dCBpbiBDT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD9DT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFt0XTp0LGNvbmZpZzp7fX0pOnQgaW5zdGFuY2VvZiBDb25zdHJhaW50P3Q6ZGVzZXJpYWxpemVDb25zdHJhaW50KHQpfWZ1bmN0aW9uIG1heE5vcm0odCl7cmV0dXJuIG5ldyBNYXhOb3JtKHQpfWZ1bmN0aW9uIHVuaXROb3JtKHQpe3JldHVybiBuZXcgVW5pdE5vcm0odCl9ZnVuY3Rpb24gbm9uTmVnKCl7cmV0dXJuIG5ldyBOb25OZWd9ZnVuY3Rpb24gbWluTWF4Tm9ybSh0KXtyZXR1cm4gbmV3IE1pbk1heE5vcm0odCl9ZnVuY3Rpb24gY2hlY2tEYXRhRm9ybWF0KHQpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfREFUQV9GT1JNQVRfVkFMVUVTLFwiRGF0YUZvcm1hdFwiLHQpfWZ1bmN0aW9uIGNoZWNrUGFkZGluZ01vZGUodCl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9QQURESU5HX01PREVfVkFMVUVTLFwiUGFkZGluZ01vZGVcIix0KX1mdW5jdGlvbiBjaGVja1Bvb2xNb2RlKHQpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfUE9PTF9NT0RFX1ZBTFVFUyxcIlBvb2xNb2RlXCIsdCl9ZnVuY3Rpb24gbmFtZVNjb3BlKGEsZSl7X25hbWVTY29wZVN0YWNrLnB1c2goYSk7dHJ5e3ZhciB0PWUoKTtyZXR1cm4gX25hbWVTY29wZVN0YWNrLnBvcCgpLHR9Y2F0Y2godCl7dGhyb3cgX25hbWVTY29wZVN0YWNrLnBvcCgpLHR9fWZ1bmN0aW9uIGN1cnJlbnROYW1lU2NvcGVQcmVmaXgoKXtyZXR1cm4gMD09PV9uYW1lU2NvcGVTdGFjay5sZW5ndGg/XCJcIjpfbmFtZVNjb3BlU3RhY2suam9pbihcIi9cIikrXCIvXCJ9ZnVuY3Rpb24gZ2V0U2NvcGVkVGVuc29yTmFtZSh0KXtpZighaXNWYWxpZFRlbnNvck5hbWUodCkpdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6ICdcIit0K1wiJ1wiKTtyZXR1cm4gY3VycmVudE5hbWVTY29wZVByZWZpeCgpK3R9ZnVuY3Rpb24gZ2V0VW5pcXVlVGVuc29yTmFtZShhKXtpZighaXNWYWxpZFRlbnNvck5hbWUoYSkpdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6ICdcIithK1wiJ1wiKTtuYW1lTWFwLmhhcyhhKXx8bmFtZU1hcC5zZXQoYSwwKTt2YXIgZT1uYW1lTWFwLmdldChhKTtpZihuYW1lTWFwLnNldChhLG5hbWVNYXAuZ2V0KGEpKzEpLDA8ZSl7dmFyIHQ9YStcIl9cIitlO3JldHVybiBuYW1lTWFwLnNldCh0LDEpLHR9cmV0dXJuIGF9ZnVuY3Rpb24gaXNWYWxpZFRlbnNvck5hbWUodCl7cmV0dXJuISF0Lm1hdGNoKHRlbnNvck5hbWVSZWdleCl9ZnVuY3Rpb24gaXNJbnRlZ2VyKHQpe3JldHVybiB0PT09cGFyc2VJbnQodC50b1N0cmluZygpLDEwKX1mdW5jdGlvbiBhcnJheVByb2QoYSxlLG8pe251bGw9PWUmJihlPTApLG51bGw9PW8mJihvPWEubGVuZ3RoKTtmb3IodmFyIHM9MSxwPWU7cDxvOysrcClzKj1hW3BdO3JldHVybiBzfWZ1bmN0aW9uIHRvQXJyYXkxRCh0KXtyZXR1cm4gdD1BcnJheS5pc0FycmF5KHQpP25ldyBGbG9hdDMyQXJyYXkodCk6dCx0ZW5zb3IxZCh0KX1mdW5jdGlvbiBtaW4kMSh0KXtyZXR1cm4gbWluKHRvQXJyYXkxRCh0KSkuZGF0YVN5bmMoKVswXX1mdW5jdGlvbiBtYXgkMSh0KXtyZXR1cm4gbWF4KHRvQXJyYXkxRCh0KSkuZGF0YVN5bmMoKVswXX1mdW5jdGlvbiByYW5nZSQxKGEsZSl7aWYoZTxhKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZW5kIChcIitlK1wiKSA8IGJlZ2luIChcIithK1wiKSBpcyBmb3JiaWRkZW4uXCIpO2Zvcih2YXIgdD1bXSxuPWE7bjxlOysrbil0LnB1c2gobik7cmV0dXJuIHR9ZnVuY3Rpb24gY2FzdCQxKGEsZSl7cmV0dXJuIGEuYXNUeXBlKGUpfWZ1bmN0aW9uIGV4cGFuZERpbXMkMShhLGUpe3ZvaWQgMD09PWUmJihlPS0xKTt2YXIgcj1hLnNoYXBlLnNsaWNlKCk7cmV0dXJuIDA+ZSYmKGU9ci5sZW5ndGgrZSsxKSxyLnNwbGljZShlLDAsMSksYS5yZXNoYXBlKHIpfWZ1bmN0aW9uIHJlcGVhdChhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PWEuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwicmVwZWF0KCkgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCByZWNlaXZlZCBhIHJhbmstXCIrYS5zaGFwZS5sZW5ndGgrXCIgdGVuc29yLlwiKTtyZXR1cm4gdGlsZSQxKGV4cGFuZERpbXMkMShhLDEpLFsxLGUsMV0pfSl9ZnVuY3Rpb24gZmxhdHRlbiQxKGEpe3ZhciBlPVthcnJheVByb2QoYS5zaGFwZSldO3JldHVybiBhLnJlc2hhcGUoZSl9ZnVuY3Rpb24gYmF0Y2hGbGF0dGVuKGEpe2lmKDE+PWEucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImJhdGNoRmxhdHRlbiByZXF1aXJlcyBhIG1pbmltdW0gcmFuayBvZiAyLiBHb3QgcmFuazogXCIrYS5yYW5rK1wiLlwiKTt2YXIgZT1bYS5zaGFwZVswXSxhcnJheVByb2QoYS5zaGFwZSwxKV07cmV0dXJuIGEucmVzaGFwZShlKX1mdW5jdGlvbiBzbGljZUFsb25nRmlyc3RBeGlzKGEsZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3N3aXRjaChhLnJhbmspe2Nhc2UgMTpyZXR1cm4gc2xpY2UxZChhLGUsdCk7Y2FzZSAyOnJldHVybiBzbGljZTJkKGEsW2UsMF0sW3QsYS5zaGFwZVsxXV0pO2Nhc2UgMzpyZXR1cm4gc2xpY2UzZChhLFtlLDAsMF0sW3QsYS5zaGFwZVsxXSxhLnNoYXBlWzJdXSk7Y2FzZSA0OnJldHVybiBzbGljZTRkKGEsW2UsMCwwLDBdLFt0LGEuc2hhcGVbMV0sYS5zaGFwZVsyXSxhLnNoYXBlWzNdXSk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNsaWNlQWxvbmdGaXJzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIrYS5yYW5rKTt9fSl9ZnVuY3Rpb24gc2xpY2VBbG9uZ0xhc3RBeGlzKGEsZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3N3aXRjaChhLnJhbmspe2Nhc2UgMTpyZXR1cm4gc2xpY2UxZChhLGUsdCk7Y2FzZSAyOnJldHVybiBzbGljZTJkKGEsWzAsZV0sW2Euc2hhcGVbMF0sdF0pO2Nhc2UgMzpyZXR1cm4gc2xpY2UzZChhLFswLDAsZV0sW2Euc2hhcGVbMF0sYS5zaGFwZVsxXSx0XSk7Y2FzZSA0OnJldHVybiBzbGljZTRkKGEsWzAsMCwwLGVdLFthLnNoYXBlWzBdLGEuc2hhcGVbMV0sYS5zaGFwZVsyXSx0XSk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIithLnJhbmspO319KX1mdW5jdGlvbiBzbGljZUFsb25nQXhpcyhhLGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3N3aXRjaChhLnJhbmspe2Nhc2UgMTpyZXR1cm4gc2xpY2UxZChhLGUsdCk7Y2FzZSAyOnN3aXRjaChuKXtjYXNlIDE6cmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoYSxlLHQpO2Nhc2UgMjpyZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGEsZSx0KTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yIFwiK24pO31jYXNlIDM6c3dpdGNoKG4pe2Nhc2UgMTpyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhLGUsdCk7Y2FzZSAyOnJldHVybiBzbGljZTNkKGEsWzAsZSwwXSxbYS5zaGFwZVswXSx0LGEuc2hhcGVbMl1dKTtjYXNlIDM6cmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhhLGUsdCk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIituKTt9Y2FzZSA0OnN3aXRjaChuKXtjYXNlIDE6cmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoYSxlLHQpO2Nhc2UgMjpyZXR1cm4gc2xpY2U0ZChhLFswLGUsMCwwXSxbYS5zaGFwZVswXSx0LGEuc2hhcGVbMl0sYS5zaGFwZVszXV0pO2Nhc2UgMzpyZXR1cm4gc2xpY2U0ZChhLFswLDAsZSwwXSxbYS5zaGFwZVswXSxhLnNoYXBlWzFdLHQsYS5zaGFwZVszXV0pO2Nhc2UgNDpyZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGEsZSx0KTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yIFwiK24pO31kZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwic2xpY2VBbG9uZ0xhc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2EucmFuayk7fX0pfWZ1bmN0aW9uIGNvbmNhdGVuYXRlKGEsZSl7dmFyIHI7cmV0dXJuIHZvaWQgMD09PWUmJihlPS0xKSwwPmUmJihlPTA9PT0ocj1hWzBdLnJhbmspPzA6ciksZT09PWFbMF0ucmFuayYmKGU9LTEpLGNvbmNhdChhLGUpfWZ1bmN0aW9uIGNvbmNhdEFsb25nRmlyc3RBeGlzKGEsZSl7c3dpdGNoKGEucmFuayl7Y2FzZSAxOnJldHVybiBjb25jYXQxZChbYSxlXSk7Y2FzZSAyOnJldHVybiBjb25jYXQyZChbYSxlXSwwKTtjYXNlIDM6cmV0dXJuIGNvbmNhdDNkKFthLGVdLDApO2Nhc2UgNDpyZXR1cm4gY29uY2F0NGQoW2EsZV0sMCk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbmNhdEFsb25nRmlyc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2EucmFuayk7fX1mdW5jdGlvbiB0aWxlJDEoYSxlKXtpZihBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLGEucmFuayE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGxlbmd0aCBvZiBpbnB1dCBuIChcIitlLmxlbmd0aCtcIikgZG9lcyBub3QgbWF0Y2ggdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIGlucHV0IHggKFwiK2EucmFuaytcIilcIik7cmV0dXJuIHRpbGUoYSxlKX1mdW5jdGlvbiByYW5kb21Ob3JtYWwkMShhLGUsbyxzLHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1vJiYobz0xKSxyYW5kb21Ob3JtYWwoYSxlLG8scyxyKX1mdW5jdGlvbiBkb3QkMShwLGQpe2lmKDI+cC5yYW5rfHwyPmQucmFuayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImRvdCByZXF1aXJlcyBib3RoIGlucHV0cyB0byBiZSByYW5rID49IDIgYnV0IGdvdCB4IHNoYXBlID0gXCIrcC5zaGFwZStcIiBhbmQgeSBzaGFwZSA9IFwiK2Quc2hhcGUpO2lmKDM8PWQucmFuayYmKG49cC5zaGFwZS5zbGljZSgtMSlbMF0pIT09KGE9ZC5zaGFwZS5zbGljZSgtMilbMF0pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiSWYgcmFuayB5ID49IDMsIHRoZW4gdGhlIHNlY29uZCBsYXN0IGRpbSBvZiB5IG11c3QgZXF1YWwgdGhlIGxhc3QgZGltIG9mIHggYnV0IGdvdCB4IHNoYXBlID0gXCIrcC5zaGFwZStcIiBhbmQgIHkgc2hhcGUgPSBcIitkLnNoYXBlKTtpZigyPT09cC5yYW5rJiYyPT09ZC5yYW5rKXJldHVybiBtYXRNdWwocCxkKTt2YXIgYz1wLnNoYXBlLnNsaWNlKCksbj1jLnBvcCgpO3A9cC5yZXNoYXBlKFstMSxuXSk7dmFyIG09ZC5zaGFwZS5zbGljZSgpLGk9bS5wb3AoKSxhPW0ucG9wKCksaD1tLmNvbmNhdChbaV0pLHM9QXJyYXkuZnJvbSh7bGVuZ3RoOmQucmFua30sZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09PWU/ZC5yYW5rLTI6ZTw9ZC5yYW5rLTI/ZS0xOmV9KTtkPWQudHJhbnNwb3NlKHMpLnJlc2hhcGUoW2EsLTFdKTt2YXIgbD1jLmNvbmNhdChoKTtyZXR1cm4gbWF0TXVsKHAsZCkucmVzaGFwZShsKX1mdW5jdGlvbiBnYXRoZXIkMShhLGUscil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZT1BcnJheS5pc0FycmF5KGUpP3RlbnNvcjFkKGUsXCJpbnQzMlwiKTplLnRvSW50KCksZ2F0aGVyKGEsZSxyKX0pfWZ1bmN0aW9uIHNxdWFyZSQxKHQpe3JldHVybiBtdWxTdHJpY3QodCx0KX1mdW5jdGlvbiBiaWFzQWRkKGEsZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKG51bGw9PXQmJih0PWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQodCksMSE9PWUucmFuayYmZS5yYW5rIT09YS5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5leHBlY3RlZCBiaWFzIGRpbWVuc2lvbnM6IFwiK2UucmFuaytcIjsgZXhwZWN0ZWQgaXQgdG8gYmUgMSBvciBcIithLnJhbmspO3ZhciBuPWUuc2hhcGUsbztpZig1PT09YS5yYW5rKVwiY2hhbm5lbHNGaXJzdFwiPT09dD9vPTE9PT1uLmxlbmd0aD9hLmFkZChlLnJlc2hhcGUoWzEsblswXSwxLDEsMV0pKTphLmFkZChlLnJlc2hhcGUoWzEsblszXSxuWzBdLG5bMV0sblsyXV0pKTpcImNoYW5uZWxzTGFzdFwiPT09dCYmKG89MT09PW4ubGVuZ3RoP2EuYWRkKGUucmVzaGFwZShbMSwxLDEsMSxuWzBdXSkpOmEuYWRkKGUucmVzaGFwZShbMV0uY29uY2F0KG4pKSkpO2Vsc2UgaWYoND09PWEucmFuaylcImNoYW5uZWxzRmlyc3RcIj09PXQ/bz0xPT09bi5sZW5ndGg/YS5hZGQoZS5yZXNoYXBlKFsxLG5bMF0sMSwxXSkpOmEuYWRkKGUucmVzaGFwZShbMSxuWzJdLG5bMF0sblsxXV0pKTpcImNoYW5uZWxzTGFzdFwiPT09dCYmKG89MT09PW4ubGVuZ3RoP2EuYWRkKGUucmVzaGFwZShbMSwxLDEsblswXV0pKTphLmFkZChlLnJlc2hhcGUoWzFdLmNvbmNhdChuKSkpKTtlbHNlIGlmKDM9PT1hLnJhbmspXCJjaGFubmVsc0ZpcnN0XCI9PT10P289MT09PW4ubGVuZ3RoP2EuYWRkKGUucmVzaGFwZShbMSxuWzBdLDFdKSk6YS5hZGQoZS5yZXNoYXBlKFsxLG5bMV0sblswXV0pKTpcImNoYW5uZWxzTGFzdFwiPT09dCYmKG89MT09PW4ubGVuZ3RoP2EuYWRkKGUucmVzaGFwZShbMSwxLG5bMF1dKSk6YS5hZGQoZS5yZXNoYXBlKFsxXS5jb25jYXQobikpKSk7ZWxzZXtpZighKDM+YS5yYW5rKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVuc3VwcG9ydGVkIGlucHV0IHJhbmsgYnkgYmlhc0FkZDogXCIrYS5yYW5rKTtvPWEuYWRkKGUpfXJldHVybiBvfSl9ZnVuY3Rpb24gZWx1JDEoYSxlKXtpZih2b2lkIDA9PT1lJiYoZT0xKSwxIT09ZSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlN1cHBvcnQgZm9yIGFscGhhIHZhbHVlcyBvdGhlciB0aGFuIDEgKFwiK2UrXCIpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiBlbHUoYSl9ZnVuY3Rpb24gc29mdHNpZ24odCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZGl2KHQsYWRkKGdldFNjYWxhcigxKSxhYnModCkpKX0pfWZ1bmN0aW9uIGRyb3BvdXQoYSxlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihudWxsIT10JiYhdXRpbC5hcnJheXNFcXVhbChhLnNoYXBlLHQpKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgbm9pc2Ugc2hhcGUgaXMgbm90IGltcGxlbWVudGVkIHlldDogXCIrSlNPTi5zdHJpbmdpZnkodCkpO2lmKG51bGwhPW4pdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJzZWVkIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgZHJvcG91dCB5ZXQuXCIpO3ZhciByPXN0ZXAoYWRkKG5lZyhlKSxyYW5kb21Vbmlmb3JtKGEuc2hhcGUsMCwxLFwiZmxvYXQzMlwiKSkpO3JldHVybiByPW11bChkaXYoZ2V0U2NhbGFyKDEpLHN1YihnZXRTY2FsYXIoMSksZSkpLHIpLG11bChhLHIpfSl9ZnVuY3Rpb24gaGFyZFNpZ21vaWQoYSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgZT1hZGQoZ2V0U2NhbGFyKC41KSxtdWwoZ2V0U2NhbGFyKC4yKSxhKSk7cmV0dXJuIGNsaXBCeVZhbHVlKGUsMCwxKX0pfWZ1bmN0aW9uIGluVHJhaW5QaGFzZShhLGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0P2EoKTplKCl9ZnVuY3Rpb24gY2hlY2tGYW5Nb2RlKHQpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfRkFOX01PREVfVkFMVUVTLFwiRmFuTW9kZVwiLHQpfWZ1bmN0aW9uIGNoZWNrRGlzdHJpYnV0aW9uKHQpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfRElTVFJJQlVUSU9OX1ZBTFVFUyxcIkRpc3RyaWJ1dGlvblwiLHQpfWZ1bmN0aW9uIGNvbXB1dGVGYW5zKG8sZSl7dmFyIHMscDtpZih2b2lkIDA9PT1lJiYoZT1cImNoYW5uZWxzTGFzdFwiKSxjaGVja0RhdGFGb3JtYXQoZSksMj09PW8ubGVuZ3RoKXM9b1swXSxwPW9bMV07ZWxzZSBpZighKC0xIT09WzMsNCw1XS5pbmRleE9mKG8ubGVuZ3RoKSkpe3ZhciBsPWFycmF5UHJvZChvKTtzPV9NYXRoc3FydChsKSxwPV9NYXRoc3FydChsKX1lbHNlIGlmKFwiY2hhbm5lbHNGaXJzdFwiPT09ZSl7dmFyIGE9YXJyYXlQcm9kKG8sMik7cz1vWzFdKmEscD1vWzBdKmF9ZWxzZVwiY2hhbm5lbHNMYXN0XCI9PT1lJiYoYT1hcnJheVByb2QobywwLG8ubGVuZ3RoLTIpLHM9b1tvLmxlbmd0aC0yXSphLHA9b1tvLmxlbmd0aC0xXSphKTtyZXR1cm5bcyxwXX1mdW5jdGlvbiBkZXNlcmlhbGl6ZUluaXRpYWxpemVyKGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGEsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCxlLFwiaW5pdGlhbGl6ZXJcIil9ZnVuY3Rpb24gc2VyaWFsaXplSW5pdGlhbGl6ZXIodCl7cmV0dXJuIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KHQpfWZ1bmN0aW9uIGdldEluaXRpYWxpemVyKGEpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXt2YXIgZT1hIGluIElOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD9JTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbYV06YTtyZXR1cm5cIkdsb3JvdFVuaWZvcm1cIj09PWU/bmV3IEdsb3JvdFVuaWZvcm06XCJHbG9yb3ROb3JtYWxcIj09PWU/bmV3IEdsb3JvdE5vcm1hbDpcIkhlTm9ybWFsXCI9PT1lP25ldyBIZU5vcm1hbDpcIkxlQ3VuTm9ybWFsXCI9PT1lP25ldyBMZUN1bk5vcm1hbDpkZXNlcmlhbGl6ZUluaXRpYWxpemVyKHtjbGFzc05hbWU6ZSxjb25maWc6e319KX1yZXR1cm4gYSBpbnN0YW5jZW9mIEluaXRpYWxpemVyP2E6ZGVzZXJpYWxpemVJbml0aWFsaXplcihhKX1mdW5jdGlvbiB6ZXJvcyQxKCl7cmV0dXJuIG5ldyBaZXJvc31mdW5jdGlvbiBvbmVzJDEkMSgpe3JldHVybiBuZXcgT25lc31mdW5jdGlvbiBjb25zdGFudCh0KXtyZXR1cm4gbmV3IENvbnN0YW50KHQpfWZ1bmN0aW9uIHJhbmRvbVVuaWZvcm0kMSh0KXtyZXR1cm4gbmV3IFJhbmRvbVVuaWZvcm0odCl9ZnVuY3Rpb24gcmFuZG9tTm9ybWFsJDIodCl7cmV0dXJuIG5ldyBSYW5kb21Ob3JtYWwodCl9ZnVuY3Rpb24gdHJ1bmNhdGVkTm9ybWFsJDEodCl7cmV0dXJuIG5ldyBUcnVuY2F0ZWROb3JtYWwodCl9ZnVuY3Rpb24gaWRlbnRpdHkodCl7cmV0dXJuIG5ldyBJZGVudGl0eSh0KX1mdW5jdGlvbiB2YXJpYW5jZVNjYWxpbmcodCl7cmV0dXJuIG5ldyBWYXJpYW5jZVNjYWxpbmcodCl9ZnVuY3Rpb24gZ2xvcm90VW5pZm9ybSh0KXtyZXR1cm4gbmV3IEdsb3JvdFVuaWZvcm0odCl9ZnVuY3Rpb24gZ2xvcm90Tm9ybWFsKHQpe3JldHVybiBuZXcgR2xvcm90Tm9ybWFsKHQpfWZ1bmN0aW9uIGhlTm9ybWFsKHQpe3JldHVybiBuZXcgSGVOb3JtYWwodCl9ZnVuY3Rpb24gbGVDdW5Ob3JtYWwodCl7cmV0dXJuIG5ldyBMZUN1bk5vcm1hbCh0KX1mdW5jdGlvbiBvcnRob2dvbmFsKHQpe3JldHVybiBuZXcgT3J0aG9nb25hbCh0KX1mdW5jdGlvbiBpc0FycmF5T2ZTaGFwZXModCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCkmJkFycmF5LmlzQXJyYXkodFswXSl9ZnVuY3Rpb24gbm9ybWFsaXplU2hhcGVMaXN0KHQpe3JldHVybiAwPT09dC5sZW5ndGg/W106QXJyYXkuaXNBcnJheSh0WzBdKT90Olt0XX1mdW5jdGlvbiBnZXRFeGFjdGx5T25lVGVuc29yKGEpe3ZhciBlO2lmKEFycmF5LmlzQXJyYXkoYSkpe2lmKDEhPT1hLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkV4cGVjdGVkIFRlbnNvciBsZW5ndGggdG8gYmUgMTsgZ290IFwiK2EubGVuZ3RoKTtlPWFbMF19ZWxzZSBlPWE7cmV0dXJuIGV9ZnVuY3Rpb24gZ2V0RXhhY3RseU9uZVNoYXBlKHQpe2lmKEFycmF5LmlzQXJyYXkodCkmJkFycmF5LmlzQXJyYXkodFswXSkpe2lmKDE9PT10Lmxlbmd0aClyZXR1cm4odD10KVswXTt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkV4cGVjdGVkIGV4YWN0bHkgMSBTaGFwZTsgZ290IFwiK3QubGVuZ3RoKX1yZXR1cm4gdH1mdW5jdGlvbiBjb3VudFBhcmFtc0luV2VpZ2h0cyhhKXtmb3IodmFyIGU9MCxvPTAscz1hLHI7bzxzLmxlbmd0aDtvKyspcj1zW29dLGUrPTA9PT1yLnNoYXBlLmxlbmd0aD8xOnIuc2hhcGUucmVkdWNlKGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGEqZX0pO3JldHVybiBlfWZ1bmN0aW9uIGNoZWNrU2hhcGVzTWF0Y2goYSxlKXtpZihhLnNoYXBlLnRvU3RyaW5nKCkhPT1lLnNoYXBlLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgbWlzbWF0Y2g6IFwiK0pTT04uc3RyaW5naWZ5KGEuc2hhcGUpK1wiIHZzLiBcIitKU09OLnN0cmluZ2lmeShlLnNoYXBlKSl9ZnVuY3Rpb24gYmF0Y2hHZXRWYWx1ZSh0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhZCgpfSl9ZnVuY3Rpb24gYmF0Y2hTZXRWYWx1ZSh0KXt0Lm1hcChmdW5jdGlvbih0KXt0WzBdLndyaXRlKHRbMV0pfSl9ZnVuY3Rpb24gY29sbGVjdElucHV0U2hhcGUoYSl7Zm9yKHZhciBvPVtdLHQ9MCxzPWE9dG9MaXN0KGEpLHI7dDxzLmxlbmd0aDt0Kyspcj1zW3RdLG8ucHVzaChyLnNoYXBlKTtyZXR1cm4gc2luZ2xldG9uT3JBcnJheShvKX1mdW5jdGlvbiBndWVzc091dHB1dERUeXBlKCl7cmV0dXJuXCJmbG9hdDMyXCJ9ZnVuY3Rpb24gZ2V0U291cmNlSW5wdXRzKHAsZSxkKXtpZigobnVsbD09ZXx8bnVsbCE9ZCYmMDxkKSYmKGU9cC5zb3VyY2VMYXllcixkPXAubm9kZUluZGV4KSwwPT09ZS5pbmJvdW5kTm9kZXMubGVuZ3RoKXJldHVybltwXTt2YXIgdT1lLmluYm91bmROb2Rlc1tkXTtpZigwPT09dS5pbmJvdW5kTGF5ZXJzLmxlbmd0aClyZXR1cm4gdS5pbnB1dFRlbnNvcnM7Zm9yKHZhciByPVtdLGk9MDtpPHUuaW5ib3VuZExheWVycy5sZW5ndGg7aSsrKWZvcih2YXIgYz0wLG09Z2V0U291cmNlSW5wdXRzKHUuaW5wdXRUZW5zb3JzW2ldLHUuaW5ib3VuZExheWVyc1tpXSx1Lm5vZGVJbmRpY2VzW2ldKSxzO2M8bS5sZW5ndGg7YysrKXM9bVtjXSwtMT09PXIuaW5kZXhPZihzKSYmci5wdXNoKHMpO3JldHVybiByfWZ1bmN0aW9uIElucHV0KGEpe2lmKG51bGw9PWEuYmF0Y2hTaGFwZSYmbnVsbD09YS5zaGFwZSl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSB0byBJbnB1dCBlaXRoZXIgYSBgc2hhcGVgIG9yIGEgYGJhdGNoU2hhcGVgIGFyZ3VtZW50LiBOb3RlIHRoYXQgYHNoYXBlYCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBiYXRjaCBkaW1lbnNpb24uXCIpO2lmKG51bGwhPWEuYmF0Y2hTaGFwZSYmbnVsbCE9YS5zaGFwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBzaGFwZWAgb3IgYGJhdGNoU2hhcGVgIGFyZ3VtZW50IHRvIElucHV0LCBidXQgbm90IGJvdGguXCIpO3ZhciBlPWEuYmF0Y2hTaGFwZTtudWxsIT1hLnNoYXBlJiZudWxsPT1lJiYoZT1bbnVsbF0uY29uY2F0KGEuc2hhcGUpKTt2YXIgcj1hLmR0eXBlO3JldHVybiBudWxsPT1yJiYocj1cImZsb2F0MzJcIiksbmV3IElucHV0TGF5ZXIoe2JhdGNoSW5wdXRTaGFwZTplLG5hbWU6YS5uYW1lLGR0eXBlOnIsc3BhcnNlOmEuc3BhcnNlfSkuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF19ZnVuY3Rpb24gcmVzb2x2ZVNjYWxhcnNJbkxvZ3MocCl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLGQsYyx1LG0saCxnLGY7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PXApcmV0dXJuWzJdO2Zvcih1IGluIGU9W10sZD1bXSxjPVtdLHApXCJudW1iZXJcIiE9dHlwZW9mKG09cFt1XSkmJihoPW0sZS5wdXNoKGguZGF0YSgpKSxkLnB1c2godSksYy5wdXNoKGgpKTtyZXR1cm5bNCxQcm9taXNlLmFsbChlKV07Y2FzZSAxOmZvcihnPXQuc2VudCgpLGY9MDtmPGcubGVuZ3RoOysrZilwW2RbZl1dPWdbZl1bMF07cmV0dXJuIGRpc3Bvc2UoYyksWzJdO319KX0pfWZ1bmN0aW9uIGRpc3Bvc2VUZW5zb3JzSW5Mb2dzKGEpe2lmKG51bGwhPWEpZm9yKHZhciBlIGluIGEpe3ZhciB0PWFbZV07XCJudW1iZXJcIiE9dHlwZW9mIHQmJnQuZGlzcG9zZSgpfX1mdW5jdGlvbiBzdGFuZGFyZGl6ZUNhbGxiYWNrcyh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQgaW5zdGFuY2VvZiBCYXNlQ2FsbGJhY2s/W3RdOkFycmF5LmlzQXJyYXkodCkmJnRbMF1pbnN0YW5jZW9mIEJhc2VDYWxsYmFjaz90OnRvTGlzdCh0KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBDdXN0b21DYWxsYmFjayh0KX0pfWZ1bmN0aW9uIGNvbmZpZ3VyZUNhbGxiYWNrcyhkLGUsdCxuLHIsaSxhLG8scyxsKXt2YXIgdT1uZXcgSGlzdG9yeSxjPVtuZXcgQmFzZUxvZ2dlcihlKV0uY29uY2F0KENhbGxiYWNrQ29uc3RydWN0b3JSZWdpc3RyeS5jcmVhdGVDYWxsYmFja3ModCkpO251bGwhPWQmJmMucHVzaC5hcHBseShjLGQpLGMucHVzaCh1KTt2YXIgcD1uZXcgQ2FsbGJhY2tMaXN0KGMpO3JldHVybiBwLnNldFBhcmFtcyh7ZXBvY2hzOm4saW5pdGlhbEVwb2NoOnIsc2FtcGxlczppLHN0ZXBzOmEsYmF0Y2hTaXplOm8sdmVyYm9zZTp0LGRvVmFsaWRhdGlvbjpzLG1ldHJpY3M6bH0pLHtjYWxsYmFja0xpc3Q6cCxoaXN0b3J5OnV9fWZ1bmN0aW9uIGwyTm9ybWFsaXplKGEsZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1zdW0kMShzcXVhcmUkMShhKSxlLCEwKSxuPW11bChzY2FsYXIoZXBzaWxvbigpKSxvbmVzTGlrZShhKSkscj1zcXJ0KG1heGltdW0odCxuKSk7cmV0dXJuIGRpdihhLHIpfSl9ZnVuY3Rpb24gbWVhblNxdWFyZWRFcnJvciQxKGEsZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbWVhbihzcXVhcmUkMShzdWIoZSxhKSksLTEpfSl9ZnVuY3Rpb24gbWVhbkFic29sdXRlRXJyb3IoYSxlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBtZWFuKGFicyhzdWIoZSxhKSksLTEpfSl9ZnVuY3Rpb24gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKGEsZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1zdWIoYSxlKSxuPWNsaXBCeVZhbHVlKGFicyhhKSxlcHNpbG9uKCksTnVtYmVyLk1BWF9WQUxVRSkscj1hYnMoZGl2KHQsbikpO3JldHVybiBtdWwoZ2V0U2NhbGFyKDEwMCksbWVhbihyLC0xKSl9KX1mdW5jdGlvbiBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3IocyxlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldFNjYWxhcigxKSxuPWNsaXBCeVZhbHVlKGUsZXBzaWxvbigpLE51bWJlci5NQVhfVkFMVUUpLHI9bG9nJDEoYWRkKHQsbikpLGk9Y2xpcEJ5VmFsdWUocyxlcHNpbG9uKCksTnVtYmVyLk1BWF9WQUxVRSksYT1sb2ckMShhZGQodCxpKSk7cmV0dXJuIG1lYW4oc3F1YXJlJDEoc3ViKHIsYSkpLC0xKX0pfWZ1bmN0aW9uIHNxdWFyZWRIaW5nZShhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0U2NhbGFyKDApLG49Z2V0U2NhbGFyKDEpLHI9bWF4aW11bSh0LHN1YihuLG11bChhLGUpKSk7cmV0dXJuIG1lYW4oc3F1YXJlJDEociksLTEpfSl9ZnVuY3Rpb24gaGluZ2UoYSxlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldFNjYWxhcigwKSxuPWdldFNjYWxhcigxKSxyPW1heGltdW0odCxzdWIobixtdWwoYSxlKSkpO3JldHVybiBtZWFuKHIsLTEpfSl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxIaW5nZShvLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0U2NhbGFyKDApLG49Z2V0U2NhbGFyKDEpLHI9c3VtJDEobXVsKG8sZSksLTEpLHM9bWF4KG11bChzdWIobixvKSxlKSwtMSk7cmV0dXJuIG1heGltdW0odCxhZGQobixzdWIocyxyKSkpfSl9ZnVuY3Rpb24gbG9nY29zaChhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0U2NhbGFyKF9NYXRobG9nKDIpKSxuPXN1YihlLGEpLHI9c3ViKGFkZChuLHNvZnRwbHVzKG11bChnZXRTY2FsYXIoLTIpLG4pKSksdCk7cmV0dXJuIG1lYW4ociwtMSl9KX1mdW5jdGlvbiBjYXRlZ29yaWNhbENyb3NzZW50cm9weShhLGUsbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPSExKSx0aWR5KGZ1bmN0aW9uKCl7aWYobyllPXNvZnRtYXgoZSk7ZWxzZXt2YXIgdD1zdW0kMShlLGUuc2hhcGUubGVuZ3RoLTEsITApO2U9ZGl2KGUsdCl9cmV0dXJuIGU9Y2xpcEJ5VmFsdWUoZSxlcHNpbG9uKCksMS1lcHNpbG9uKCkpLG5lZyhzdW0kMShtdWwoYS50b0Zsb2F0KCksbG9nJDEoZSkpLGUuc2hhcGUubGVuZ3RoLTEpKX0pfWZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KGEsZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1mbG9vcihmbGF0dGVuJDEoYSkpLnRvSW50KCkscj1lLnNoYXBlO3JldHVybiBjYXRlZ29yaWNhbENyb3NzZW50cm9weShvbmVIb3QobixyW3IubGVuZ3RoLTFdKS5yZXNoYXBlKHIpLGUsdCl9KX1mdW5jdGlvbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0cyhhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9bWF4aW11bShlLHplcm9zTGlrZShlKSksbj1tdWwoZSxhKSxyPWxvZyQxKGFkZChnZXRTY2FsYXIoMSksZXhwKG5lZyhhYnMoZSkpKSkpO3JldHVybiBhZGQoc3ViKHQsbikscil9KX1mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoYSxlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0O3JldHVybiB0PWNsaXBCeVZhbHVlKGUsZXBzaWxvbigpLDEtZXBzaWxvbigpKSx0PWxvZyQxKGRpdih0LHN1YihvbmVzTGlrZSh0KSx0KSkpLG1lYW4oc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHMoYSx0KSwtMSl9KX1mdW5jdGlvbiBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlKGEsZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1jbGlwQnlWYWx1ZShhLGVwc2lsb24oKSwxKSxuPWNsaXBCeVZhbHVlKGUsZXBzaWxvbigpLDEpO3JldHVybiBzdW0kMShtdWwoYSxsb2ckMShkaXYodCxuKSkpLC0xKX0pfWZ1bmN0aW9uIHBvaXNzb24oYSxlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWxvZyQxKGFkZChnZXRTY2FsYXIoZXBzaWxvbigpKSxlKSk7cmV0dXJuIG1lYW4oc3ViKGUsbXVsKGEsdCkpLC0xKX0pfWZ1bmN0aW9uIGNvc2luZVByb3hpbWl0eShhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9bDJOb3JtYWxpemUoYSwtMSksbj1sMk5vcm1hbGl6ZShlLC0xKSxyPW11bCh0LG4pO3JldHVybiBuZWcoc3VtJDEociwtMSkpfSl9ZnVuY3Rpb24gZ2V0KGEpe3ZhciBlPXttZWFuU3F1YXJlZEVycm9yOm1lYW5TcXVhcmVkRXJyb3IkMSxtZWFuQWJzb2x1dGVFcnJvcjptZWFuQWJzb2x1dGVFcnJvcixtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I6bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcjptZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3Isc3F1YXJlZEhpbmdlOnNxdWFyZWRIaW5nZSxoaW5nZTpoaW5nZSxjYXRlZ29yaWNhbEhpbmdlOmNhdGVnb3JpY2FsSGluZ2UsbG9nY29zaDpsb2djb3NoLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LGJpbmFyeUNyb3NzZW50cm9weTpiaW5hcnlDcm9zc2VudHJvcHksa3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZTprdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlLHBvaXNzb246cG9pc3Nvbixjb3NpbmVQcm94aW1pdHk6Y29zaW5lUHJveGltaXR5fTtpZihcInN0cmluZ1wiPT10eXBlb2YgYSl7aWYoYSBpbiBlKXJldHVybiBlW2FdO3ZhciB0PVwiVW5rbm93biBsb3NzIFwiK2E7dGhyb3cgYS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic29mdG1heGNyb3NzZW50cm9weVwiKSYmKHQ9XCJVbmtub3duIGxvc3MgXCIrYStcIi4gVXNlIFxcXCJjYXRlZ29yaWNhbENyb3NzZW50cm9weVxcXCIgYXMgdGhlIHN0cmluZyBuYW1lIGZvciB0Zi5sb3NzZXMuc29mdG1heENyb3NzRW50cm9weVwiKSxuZXcgVmFsdWVFcnJvcih0KX1yZXR1cm4gYX1mdW5jdGlvbiBiaW5hcnlBY2N1cmFjeShhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9bXVsKGdldFNjYWxhciguNSksb25lc0xpa2UoZSkpLG49Y2FzdCQxKGdyZWF0ZXIoZSx0KSxhLmR0eXBlKTtyZXR1cm4gbWVhbihlcXVhbChhLG4pLC0xKX0pfWZ1bmN0aW9uIGNhdGVnb3JpY2FsQWNjdXJhY3koYSxlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBjYXN0JDEoZXF1YWwoYXJnTWF4KGEsLTEpLGFyZ01heChlLC0xKSksXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gdHJ1ZVBvc2l0aXZlcyhhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0U2NhbGFyKDEpO3JldHVybiBsb2dpY2FsQW5kKGEuZXF1YWwodCksZS5lcXVhbCh0KSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBmYWxzZU5lZ2F0aXZlcyhhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0U2NhbGFyKDEpLG49Z2V0U2NhbGFyKDApO3JldHVybiBsb2dpY2FsQW5kKGEuZXF1YWwodCksZS5lcXVhbChuKSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBmYWxzZVBvc2l0aXZlcyhhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0U2NhbGFyKDEpLG49Z2V0U2NhbGFyKDApO3JldHVybiBsb2dpY2FsQW5kKGEuZXF1YWwobiksZS5lcXVhbCh0KSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBwcmVjaXNpb24obyxlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldFNjYWxhcigwKSxuPXRydWVQb3NpdGl2ZXMobyxlKSxyPWZhbHNlUG9zaXRpdmVzKG8sZSkscz1uLmFkZChyKTtyZXR1cm4gd2hlcmUoZ3JlYXRlcihzLHQpLG4uZGl2KHMpLHQpLmNhc3QoXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gcmVjYWxsKG8sZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRTY2FsYXIoMCksbj10cnVlUG9zaXRpdmVzKG8sZSkscj1mYWxzZU5lZ2F0aXZlcyhvLGUpLHM9bi5hZGQocik7cmV0dXJuIHdoZXJlKGdyZWF0ZXIocyx0KSxuLmRpdihzKSx0KS5jYXN0KFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weSQxKGEsZSl7cmV0dXJuIGJpbmFyeUNyb3NzZW50cm9weShhLGUpfWZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3koKXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn1mdW5jdGlvbiBnZXQkMShhKXt2YXIgZT17YmluYXJ5QWNjdXJhY3k6YmluYXJ5QWNjdXJhY3ksY2F0ZWdvcmljYWxBY2N1cmFjeTpjYXRlZ29yaWNhbEFjY3VyYWN5LHByZWNpc2lvbjpwcmVjaXNpb24sY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMSxzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTpzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSQxLG1zZTptc2UkMSxNU0U6TVNFJDEsbWFlOm1hZSQxLE1BRTpNQUUkMSxtYXBlOm1hcGUkMSxNQVBFOk1BUEUkMSxjb3NpbmU6Y29zaW5lJDF9O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhJiZhIGluIGUpcmV0dXJuIGVbYV07aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGEmJm51bGwhPWEpcmV0dXJuIGE7dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIG1ldHJpYyBcIithKX1mdW5jdGlvbiBnZXRPcHRpbWl6ZXIoYSl7dmFyIGU9e0FkYWdyYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uYWRhZ3JhZCguMDEpfSxBZGFkZWx0YTpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5hZGFkZWx0YSgxLC45NSxlcHNpbG9uKCkpfSxBZGFtOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLmFkYW0oLjAwMSwuOSwuOTk5LGVwc2lsb24oKSl9LEFkYW1heDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5hZGFtYXgoLjAwMiwuOSwuOTk5LGVwc2lsb24oKSwwKX0sUk1TUHJvcDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5ybXNwcm9wKC4wMDEsLjksMCxlcHNpbG9uKCkpfSxTR0Q6ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uc2dkKC4wMSl9fTtpZihlLmFkYWdyYWQ9ZS5BZGFncmFkLGUuYWRhZGVsdGE9ZS5BZGFkZWx0YSxlLmFkYW09ZS5BZGFtLGUuYWRhbWF4PWUuQWRhbWF4LGUucm1zcHJvcD1lLlJNU1Byb3AsZS5zZ2Q9ZS5TR0QsYSBpbiBlKXJldHVybiBlW2FdKCk7dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIE9wdGltaXplciBcIithKX1mdW5jdGlvbiBwcmludFN1bW1hcnkoZCxtLGUsaCl7dm9pZCAwPT09aCYmKGg9Y29uc29sZS5sb2cpO3ZhciBnPWlzTW9kZWxTZXF1ZW50aWFsTGlrZShkKSxhPVtcIkxheWVyICh0eXBlKVwiLFwiT3V0cHV0IHNoYXBlXCIsXCJQYXJhbSAjXCJdLG87aWYoZz8obT1tfHw2NSxlPWV8fFsuNDUsLjg1LDFdKToobT1tfHw5OCxlPWV8fFsuMzMsLjU1LC42NywxXSksMT49ZVtlLmxlbmd0aC0xXSYmKGU9ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIF9NYXRoZmxvb3IobSp0KX0pKSwhZylmb3IodmFyIGYgaW4gYS5wdXNoKFwiUmVjZWl2ZXMgaW5wdXRzXCIpLG89W10sZC5ub2Rlc0J5RGVwdGgpby5wdXNoLmFwcGx5KG8sZC5ub2Rlc0J5RGVwdGhbZl0pO2goXCJfXCIucmVwZWF0KG0pKSxwcmludFJvdyhhLGUsaCksaChcIj1cIi5yZXBlYXQobSkpO2Zvcih2YXIgcz1kLmxheWVycyxsPTA7bDxzLmxlbmd0aDsrK2wpZz9wcmludExheWVyU3VtbWFyeShzW2xdLGUsaCk6cHJpbnRMYXllclN1bW1hcnlXaXRoQ29ubmVjdGlvbnMoc1tsXSxlLG8saCksaCgobD09cy5sZW5ndGgtMT9cIj1cIjpcIl9cIikucmVwZWF0KG0pKTtkLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCk7dmFyIHk9Y291bnRUcmFpbmFibGVQYXJhbXMoZCksYz1jb3VudFBhcmFtc0luV2VpZ2h0cyhkLm5vblRyYWluYWJsZVdlaWdodHMpO2goXCJUb3RhbCBwYXJhbXM6IFwiKyh5K2MpKSxoKFwiVHJhaW5hYmxlIHBhcmFtczogXCIreSksaChcIk5vbi10cmFpbmFibGUgcGFyYW1zOiBcIitjKSxoKFwiX1wiLnJlcGVhdChtKSl9ZnVuY3Rpb24gY291bnRUcmFpbmFibGVQYXJhbXModCl7cmV0dXJuIG51bGw9PXQuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cz9jb3VudFBhcmFtc0luV2VpZ2h0cyh0LnRyYWluYWJsZVdlaWdodHMpOmNvdW50UGFyYW1zSW5XZWlnaHRzKHQuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyl9ZnVuY3Rpb24gaXNNb2RlbFNlcXVlbnRpYWxMaWtlKG0pe3ZhciBlPSEwLGc9W10sbj1bXTtmb3IodmFyIHIgaW4gbS5ub2Rlc0J5RGVwdGgpZy5wdXNoKG0ubm9kZXNCeURlcHRoW3JdKTtmb3IodmFyIGk9MCxmPWcsbztpPGYubGVuZ3RoO2krKyl7aWYobz1mW2ldLDE8by5sZW5ndGh8fDE9PT1vLmxlbmd0aCYmMTxvWzBdLmluYm91bmRMYXllcnMubGVuZ3RoKXtlPSExO2JyZWFrfW4ucHVzaC5hcHBseShuLG8pfWlmKGUpZm9yKHZhciB5PTAsYj1tLmxheWVyczt5PGIubGVuZ3RoO3krKyl7Zm9yKHZhciB1PSExLHg9MCxOPWJbeV0uaW5ib3VuZE5vZGVzLGg7eDxOLmxlbmd0aDt4KyspaWYoaD1OW3hdLC0xIT09bi5pbmRleE9mKGgpKXtpZih1KXtlPSExO2JyZWFrfXU9ITB9aWYoIWUpYnJlYWt9cmV0dXJuIGV9ZnVuY3Rpb24gcHJpbnRSb3coYSxlLHQpe3ZvaWQgMD09PXQmJih0PWNvbnNvbGUubG9nKTtmb3IodmFyIG89XCJcIixzPTA7czxhLmxlbmd0aDsrK3MpMDxzJiYobz1vLnNsaWNlKDAsby5sZW5ndGgtMSkrXCIgXCIpLG89KG8rPWFbc10pLnNsaWNlKDAsZVtzXSksbys9XCIgXCIucmVwZWF0KGVbc10tby5sZW5ndGgpO3Qobyl9ZnVuY3Rpb24gcHJpbnRMYXllclN1bW1hcnkoYSxlLHQpe3ZhciBuO3RyeXtuPUpTT04uc3RyaW5naWZ5KGEub3V0cHV0U2hhcGUpfWNhdGNoKHQpe249XCJtdWx0aXBsZVwifXByaW50Um93KFthLm5hbWUrXCIgKFwiK2EuZ2V0Q2xhc3NOYW1lKCkrXCIpXCIsbixhLmNvdW50UGFyYW1zKCkudG9TdHJpbmcoKV0sZSx0KX1mdW5jdGlvbiBwcmludExheWVyU3VtbWFyeVdpdGhDb25uZWN0aW9ucyhtLGUsdCxuKXt2YXIgcjt0cnl7cj1KU09OLnN0cmluZ2lmeShtLm91dHB1dFNoYXBlKX1jYXRjaCh0KXtyPVwibXVsdGlwbGVcIn1mb3IodmFyIHk9W10sYT0wLGI9bS5pbmJvdW5kTm9kZXMsczthPGIubGVuZ3RoO2ErKylpZihzPWJbYV0sIShudWxsIT10JiYwPHQubGVuZ3RoJiYtMT09PXQuaW5kZXhPZihzKSkpZm9yKHZhciB4PTA7eDxzLmluYm91bmRMYXllcnMubGVuZ3RoOysreCl7dmFyIE49cy5pbmJvdW5kTGF5ZXJzW3hdLm5hbWUsYz1zLm5vZGVJbmRpY2VzW3hdLHA9cy50ZW5zb3JJbmRpY2VzW3hdO3kucHVzaChOK1wiW1wiK2MrXCJdW1wiK3ArXCJdXCIpfXZhciBoPW0ubmFtZSxkPW0uZ2V0Q2xhc3NOYW1lKCksZj0wPT09eS5sZW5ndGg/XCJcIjp5WzBdO2ZvcihwcmludFJvdyhbaCtcIiAoXCIrZCtcIilcIixyLG0uY291bnRQYXJhbXMoKS50b1N0cmluZygpLGZdLGUsbikseD0xO3g8eS5sZW5ndGg7Kyt4KXByaW50Um93KFtcIlwiLFwiXCIsXCJcIix5W3hdXSxlLG4pfWZ1bmN0aW9uIGRlc2VyaWFsaXplKGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGEsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCxlLFwibGF5ZXJcIil9ZnVuY3Rpb24gaXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZShhLGUsdCl7cmV0dXJuKFwiaW5ib3VuZE5vZGVzXCI9PT1hfHxcIm91dHB1dExheWVyc1wiPT09YXx8XCJpbnB1dExheWVyc1wiPT09YSkmJjA9PT1lJiZcInN0cmluZ1wiPT10eXBlb2YgdH1mdW5jdGlvbiBjb252ZXJ0UHl0aG9uaWNUb1RzKGQsZSl7aWYobnVsbD09PWQpcmV0dXJuIG51bGw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGQpcmV0dXJuIHRvQ2FtZWxDYXNlKGQpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBkfHxcImJvb2xlYW5cIj09dHlwZW9mIGQpcmV0dXJuIGQ7aWYoZCBpbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIHQ9W10sbj1kLmxlbmd0aCxyPTAsbTtyPG47KytyKW09ZFtyXSxpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lKGUscixtKT90LnB1c2gobSk6dC5wdXNoKGNvbnZlcnRQeXRob25pY1RvVHMobSxlKSk7cmV0dXJuIHR9Zm9yKHZhciBoPXt9LG89MCxnPU9iamVjdC5rZXlzKGQpO288Zy5sZW5ndGg7bysrKXt2YXIgbD1nW29dLHU9ZFtsXTtpZihcIm5hbWVcIj09PWwmJlwic3RyaW5nXCI9PXR5cGVvZiB1KWhbbF09dTtlbHNle3ZhciBjPXRvQ2FtZWxDYXNlKGwpO2hbY109Y29udmVydFB5dGhvbmljVG9Ucyh1LGMpfX1yZXR1cm4gaH1mdW5jdGlvbiBjb252ZXJ0VHNUb1B5dGhvbmljKGQsZSl7aWYobnVsbD09PWR8fHZvaWQgMD09PWQpcmV0dXJuIG51bGw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGQpcmV0dXJuIHRvU25ha2VDYXNlKGQpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBkfHxcImJvb2xlYW5cIj09dHlwZW9mIGQpcmV0dXJuIGQ7aWYoZCBpbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIHQ9W10sbj1kLmxlbmd0aCxyPTAsbTtyPG47KytyKW09ZFtyXSxpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lKGUscixtKT90LnB1c2gobSk6dC5wdXNoKGNvbnZlcnRUc1RvUHl0aG9uaWMobSxlKSk7cmV0dXJuIHR9Zm9yKHZhciBoPXt9LG89MCxnPU9iamVjdC5rZXlzKGQpO288Zy5sZW5ndGg7bysrKXt2YXIgbD1nW29dLHU9ZFtsXSxjPXRvU25ha2VDYXNlKGwpO2hbY109XCJuYW1lXCIhPT1sJiZcImNsYXNzTmFtZVwiIT09bHx8XCJzdHJpbmdcIiE9dHlwZW9mIHU/Y29udmVydFRzVG9QeXRob25pYyh1LGwpOnV9cmV0dXJuIGh9ZnVuY3Rpb24gcHJlcHJvY2Vzc1dlaWdodHNGb3JMb2FkaW5nKGEsZSx0KXtpZighdC5zdGFydHNXaXRoKFwiMi5cIikpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbnN1cHBvcnRlZCBLZXJhcyB2ZXJzaW9uIGluIHdlaWdodHMgYmVpbmcgbG9hZGVkOiBcIit0KTtyZXR1cm4gZX1mdW5jdGlvbiBsb2FkVGVuc29yKGEsZSx0KXt2YXIgbj1zdHJpbmdUb0RUeXBlKGEpO3JldHVybiBUZW5zb3IubWFrZShlLHt2YWx1ZXM6MD09PWUubGVuZ3RoP3Q6dXRpbC5mbGF0dGVuKHQpfSxuKX1mdW5jdGlvbiBsb2FkV2VpZ2h0c0Zyb21Kc29uKHgsZSx0KXt2b2lkIDA9PT10JiYodD0hMSk7Zm9yKHZhciBOPXgua2VyYXNfdmVyc2lvbixyPXguYmFja2VuZCxpPWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSxhPXt9LG89MCxJPWU7bzxJLmxlbmd0aDtvKyspbnVsbCE9KEQ9SVtvXSkubmFtZSYmKG51bGw9PWFbRC5uYW1lXSYmKGFbRC5uYW1lXT1bXSksYVtELm5hbWVdLnB1c2goRCkpO2Zvcih2YXIgbD14LndlaWdodHMsdT1bXSxjPTA7YzxpLmxlbmd0aDsrK2Mpe3ZhciBTPWlbY10saD1sW1NdO251bGw9PWgmJihoPVtdKTtmb3IodmFyIEM9W10saz0wLFQ7azxoLmxlbmd0aDsrK2spVD1oW2tdLEMucHVzaChuZXcgTGF5ZXJWYXJpYWJsZShsb2FkVGVuc29yKFQuZHR5cGUsVC5zaGFwZSxULnZhbHVlKSkpO2Zvcih2YXIgRT0wLFI9YVtTXTtFPFIubGVuZ3RoO0UrKyl7dmFyIHY9KEQ9UltFXSkud2VpZ2h0cyxEO2lmKChDPXByZXByb2Nlc3NXZWlnaHRzRm9yTG9hZGluZyhELEMsTixyKSkubGVuZ3RoIT09di5sZW5ndGgpe2lmKCF0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGF5ZXIgI1wiK2MrXCIgKG5hbWVkIFxcXCJcIitELm5hbWUrXCJcXFwiKSBleHBlY3RzIFwiK3YubGVuZ3RoK1wiIHdlaWdodChzKSwgYnV0IHRoZSBzYXZlZCB3ZWlnaHRzIGhhdmUgXCIrQy5sZW5ndGgrXCIgZWxlbWVudChzKS5cIik7Y29uc29sZS53YXJuKFwiU2tpcHBpbmcgbG9hZGluZyBvZiB3ZWlnaHRzIG9mIGxheWVyIFwiK0QubmFtZStcIiBkdWUgdG8gbWlzbWF0Y2ggaW4gbnVtYmVyIG9mIHdlaWdodHM6IChcIitDLmxlbmd0aCtcIiB2cyBcIit2Lmxlbmd0aCtcIikuXCIpfWZvcih2YXIgdz0wO3c8Qy5sZW5ndGg7Kyt3KSF0fHx1dGlsLmFycmF5c0VxdWFsKHZbd10uc2hhcGUsQ1t3XS5zaGFwZSk/dS5wdXNoKFt2W3ddLENbd10ucmVhZCgpXSk6Y29uc29sZS53YXJuKFwiU2tpcHBpbmcgbG9hZGluZyBvZiB3ZWlnaHRzIGZvciBsYXllciBcIitELm5hbWUrXCIgZHVlIHRvIG1pc21hdGNoIGluIHNoYXBlIChcIit2W3ddLnNoYXBlK1wiIHZzIFwiK0Nbd10uc2hhcGUrXCIpXCIpfX1iYXRjaFNldFZhbHVlKHUpfWZ1bmN0aW9uIGxvYWRXZWlnaHRzRnJvbU5hbWVkVGVuc29yTWFwKG0sZSx0KXt2b2lkIDA9PT10JiYodD0hMCk7Zm9yKHZhciBnPXt9LHI9MCxmPTAseT1lO2Y8eS5sZW5ndGg7ZisrKWZvcih2YXIgbz0wLGI9eVtmXS53ZWlnaHRzLGw7bzxiLmxlbmd0aDtvKyspe2lmKGw9YltvXSxudWxsIT1nW2wub3JpZ2luYWxOYW1lXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgbmFtZTogXCIrbC5vcmlnaW5hbE5hbWUpO2dbbC5vcmlnaW5hbE5hbWVdPWwscisrfXZhciB4PVtdO2Zvcih2YXIgYyBpbiBtKXtpZihudWxsIT1nW2NdKXgucHVzaChbZ1tjXSxtW2NdXSk7ZWxzZSBpZih0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiUHJvdmlkZWQgd2VpZ2h0IGRhdGEgaGFzIG5vIHRhcmdldCB2YXJpYWJsZTogXCIrYyk7ZGVsZXRlIGdbY119aWYodCl7dmFyIHA9W107Zm9yKHZhciBoIGluIGcpcC5wdXNoKGgpO2lmKDA8cC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IocC5sZW5ndGgrXCIgb2YgXCIrcitcIiB3ZWlnaHRzIGFyZSBub3Qgc2V0OiBcIitwKX1iYXRjaFNldFZhbHVlKHgpfWZ1bmN0aW9uIGFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGEsZSl7aWYobnVsbCE9YS5zaGFwZSl7aWYoYS5zaGFwZS5sZW5ndGghPT1lLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSByYW5rIG9mIGZlZWQgKFwiK2Uuc2hhcGUubGVuZ3RoK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUga2V5IChcIithLnNoYXBlLmxlbmd0aCtcIikuXCIpO2Zvcih2YXIgdD0wO3Q8YS5zaGFwZS5sZW5ndGg7Kyt0KWlmKG51bGwhPWEuc2hhcGVbdF0mJmEuc2hhcGVbdF0hPT1lLnNoYXBlW3RdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIFwiK3QrXCItdGggZGltZW5zaW9uIG9mIHRoZSBmZWVkIChcIitlLnNoYXBlW3RdK1wiKSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGF0IG9mIHRoZSBrZXkgKFwiK2Euc2hhcGVbdF0rXCIpLlwiKX1pZihudWxsPT1hLmR0eXBlfHxhLmR0eXBlPT09ZS5kdHlwZSlyZXR1cm4gZTt0cnl7cmV0dXJuIGNhc3QoZSxhLmR0eXBlKX1jYXRjaCh0KXt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBkdHlwZSBvZiB0aGUgZmVlZCAoXCIrZS5kdHlwZStcIikgY2FuIG5vdCBiZSBjYXN0IHRvIHRoZSBkdHlwZSBvZiB0aGUga2V5ICdcIithLm5hbWUrXCInIChcIithLmR0eXBlK1wiKS5cIil9fWZ1bmN0aW9uIGV4ZWN1dGUocCxlLHQpe2Zvcih2YXIgbj1BcnJheS5pc0FycmF5KHApLHI9bj9wOltwXSxpPVtdLGE9bmV3IEZlZWREaWN0KGUpLG89MCxkPXIsbDtvPGQubGVuZ3RoO28rKylsPWRbb10saS5wdXNoKGV4ZWN1dGVJbnRlcm5hbChsLGEsdCkpO3JldHVybiBuP2k6aVswXX1mdW5jdGlvbiBleGVjdXRlSW50ZXJuYWwocCxlLHQpe2lmKGUuaGFzS2V5KHApKXJldHVybiBlLmdldFZhbHVlKHApO2lmKHAuc291cmNlTGF5ZXIgaW5zdGFuY2VvZiBJbnB1dExheWVyKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTWlzc2luZyBhIGZlZWQgdmFsdWUgZm9yIFN5bWJvbGljVGVuc29yIGZyb20gSW5wdXRMYXllciAnXCIrSW5wdXRMYXllci5uYW1lK1wiJ1wiKTtmb3IodmFyIG49W10scj0wLGQ9cC5pbnB1dHMsYTtyPGQubGVuZ3RoO3IrKylhPWV4ZWN1dGVJbnRlcm5hbChkW3JdLGUsdCksbi5wdXNoKGEpO3ZhciBtPXAuc291cmNlTGF5ZXIuYXBwbHkobix0KTtBcnJheS5pc0FycmF5KG0pfHwobT1bbV0pO2Zvcih2YXIgaD1nZXROb2RlT3V0cHV0cyhwKSxsPUFycmF5LmlzQXJyYXkoaCk/aDpbaF0sdT0wO3U8bC5sZW5ndGg7Kyt1KWUuYWRkKGxbdV0sbVt1XSk7cmV0dXJuIDE9PT1tLmxlbmd0aD9tWzBdOm1bcC5vdXRwdXRUZW5zb3JJbmRleF19ZnVuY3Rpb24gZ2V0Tm9kZU91dHB1dHMobyl7dmFyIGU7aWYoMT09PW8uc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCllPW8uc291cmNlTGF5ZXIub3V0cHV0O2Vsc2V7Zm9yKHZhciBzPW51bGwscD0wO3A8by5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOysrcClmb3IodmFyIGw9MCxkPW8uc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzW3BdLm91dHB1dFRlbnNvcnM7bDxkLmxlbmd0aDtsKyspaWYoZFtsXS5pZD09PW8uaWQpe3M9cDticmVha31lPW8uc291cmNlTGF5ZXIuZ2V0T3V0cHV0QXQocyl9cmV0dXJuIGV9ZnVuY3Rpb24gc3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQocCxlKXtpZigxPHAub3V0cHV0cy5sZW5ndGgpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJTdXBwb3J0IGZvciB0cmFpbmluZyBhIG1vZGVsIHdpdGggbXVsdGlwbGUgb3V0cHV0IHRlbnNvcnMgd2l0aCBhIGRhdGFzZXQgb2JqZWN0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3V0aWwuYXNzZXJ0KEFycmF5LmlzQXJyYXkoZSkmJjI9PT1lLmxlbmd0aCxcIkRhdGFzZXQgaXRlcmF0b3IgZm9yIGZpdERhdGFzZXQoKSBpcyBleHBlY3RlZCB0byBnZW5lcmF0ZSBhbiBBcnJheSBvZiBsZW5ndGggMjogYFt4cywgeXNdYCwgYnV0IGluc3RlYWQgZ2VuZXJhdGVzIFwiK2UpO3ZhciBkPShlPWUpWzFdLG49ZVswXTtpZihuIGluc3RhbmNlb2YgVGVuc29yKXJldHVybiB1dGlsLmFzc2VydCgxPT09cC5pbnB1dHMubGVuZ3RoLFwiTW9kZWwgaGFzIG11bHRpcGxlIFwiK3AuaW5wdXRzLmxlbmd0aCtcIiBpbnB1dHMsIGhlbmNlIGl0IGV4cGVjdHMgdGhlIGlucHV0IGRhdGFzZXQgdG8gZ2VuZXJhdGUgYSBkaWN0aW9uYXJ5IG9mIHRlbnNvcnMgICh3aXRoIGtleXMgXCIrSlNPTi5zdHJpbmdpZnkocC5pbnB1dE5hbWVzKStcIiwgYnV0IHJlY2VpdmVkIGEgc2luZ2xlIHRlbnNvci5cIiksdXRpbC5hc3NlcnQobi5zaGFwZVswXT09PWQuc2hhcGVbMF0sXCJNaXNtYXRjaCBpbiBiYXRjaCBzaXplIGJldHdlZW4geCBhbmQgeSB0ZW5zb3JzIChcIituLnNoYXBlWzBdK1wiIHZzLiBcIitkLnNoYXBlWzBdK1wiKVwiKSxbbixkXTt2YXIgdTtuPW47Zm9yKHZhciBjPVtdLGE9MCxtPXAuaW5wdXROYW1lcyxzO2E8bS5sZW5ndGg7YSsrKXtpZihzPW1bYV0sbnVsbD09bltzXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBmZWF0dXJlIGRhdGEgZ2VuZXJhdGVkIGJ5IHRoZSBkYXRhc2V0IGxhY2tzIHRoZSByZXF1aXJlZCBpbnB1dCBrZXkgJ1wiK3MrXCInLlwiKTtjLnB1c2gobltzXSksbnVsbD09dT91PW5bc10uc2hhcGVbMF06dXRpbC5hc3NlcnQobltzXS5zaGFwZVswXT09PXUsXCJNaXNtYXRjaCBpbiBiYXRjaCBzaXplIGJldHdlZW4geCBhbmQgeSB0ZW5zb3JzIChcIituW3NdLnNoYXBlWzBdK1wiIHZzLiBcIitkLnNoYXBlWzBdK1wiKVwiKX1yZXR1cm4gYy5jb25jYXQoZCl9ZnVuY3Rpb24gc3RhbmRhcmRpemVUZW5zb3JWYWxpZGF0aW9uRGF0YSh0KXtpZigzPT09dC5sZW5ndGgpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWYWxpZGF0aW9uIHdpdGggc2FtcGxlIHdlaWdodHMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJue3hzOnRbMF0seXM6dFsxXX19ZnVuY3Rpb24gZml0RGF0YXNldCh4LGUsdCl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLFQsUixELFAsTyxMLE0sRixCLFYsVSxXLEcscSxILGosJCxrLEssWCxZLFosUSxKLGVlO3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDppZihuPW51bGwhPXQuYmF0Y2hlc1BlckVwb2NoLHV0aWwuYXNzZXJ0KG51bGwhPXgub3B0aW1pemVyLFwiWW91IG11c3QgY29tcGlsZSBhIG1vZGVsIGJlZm9yZSB0cmFpbmluZy90ZXN0aW5nLiBVc2UgTW9kZWwuY29tcGlsZShtb2RlbENvbXBpbGVDb25maWcpLlwiKSx1dGlsLmFzc2VydChudWxsIT10LFwiRm9yIGZpdERhdGFzZXQoKSwgdGhlIDJuZCBhcmd1bWVudCAoY29uZmlnKSBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGlzIGNhbGwuXCIpLHV0aWwuYXNzZXJ0KG51bGwhPXQuZXBvY2hzJiYwPHQuZXBvY2hzJiZfTnVtYmVyaXNJbnRlZ2VyKHQuZXBvY2hzKSxcIkZvciBmaXREYXRhc2V0KCksIGNvbmZpZy5lcG9jaHMgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK3QuZXBvY2hzKSx1dGlsLmFzc2VydCghbnx8MDx0LmJhdGNoZXNQZXJFcG9jaCYmX051bWJlcmlzSW50ZWdlcih0LmJhdGNoZXNQZXJFcG9jaCksXCJGb3IgZml0RGF0YXNldCgpLCBjb25maWcuYmF0Y2hlc1BlckVwb2NoIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQsIGJ1dCBnb3QgXCIrdC5iYXRjaGVzUGVyRXBvY2gpLHV0aWwuYXNzZXJ0KG51bGw9PXQudmFsaWRhdGlvblNwbGl0LFwiYHZhbGlkYXRpb25TcGxpdGAgaXMgbm90IHN1cHBvcnRlZCBieSBgZml0RGF0YXNldCgpYC4gVXNlIHZhbGlkYXRpb25EYXRhIGluc3RlYWQuXCIpLHguaXNUcmFpbmluZyl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RhcnQgdHJhaW5pbmcgYmVjYXVzZSBhbm90aGVyIGZpdCgpIGNhbGwgaXMgb25nb2luZy5cIik7eC5pc1RyYWluaW5nPSEwLGEubGFiZWw9MTtjYXNlIDE6cmV0dXJuIGEudHJ5cy5wdXNoKFsxLCwyMSwyMl0pLFQ9bnVsbCE9dC52YWxpZGF0aW9uRGF0YSxSPXZvaWQgMCxEPXZvaWQgMCxUJiYoaXNEYXRhc2V0T2JqZWN0KHQudmFsaWRhdGlvbkRhdGEpP3V0aWwuYXNzZXJ0KG51bGw9PXQudmFsaWRhdGlvbkJhdGNoZXN8fDA8dC52YWxpZGF0aW9uQmF0Y2hlcyYmX051bWJlcmlzSW50ZWdlcih0LnZhbGlkYXRpb25CYXRjaGVzKSxcIkZvciBmaXREYXRhc2V0KCkgd2l0aCBkYXRhc2V0LWJhc2VkIHZhbGlkYXRpb24sIGNvbmZpZy52YWxpZGF0aW9uQmF0Y2hlcyBpcyBleHBlY3RlZCBub3QgdG8gYmUgcHJvdmlkZWQsIG9yIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIit0LnZhbGlkYXRpb25CYXRjaGVzKTooUD1zdGFuZGFyZGl6ZVRlbnNvclZhbGlkYXRpb25EYXRhKHQudmFsaWRhdGlvbkRhdGEpLFI9UC54cyxEPVAueXMpKSxPPXgubWFrZVRyYWluRnVuY3Rpb24oKSxMPXguZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpLE09dm9pZCAwLE09VD9MLnNsaWNlKCkuY29uY2F0KEwubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwidmFsX1wiK3R9KSk6TC5zbGljZSgpLEY9c3RhbmRhcmRpemVDYWxsYmFja3ModC5jYWxsYmFja3MpLEI9Y29uZmlndXJlQ2FsbGJhY2tzKEYsdC55aWVsZEV2ZXJ5LHQudmVyYm9zZSx0LmVwb2NocyxudWxsLG51bGwsdC5iYXRjaGVzUGVyRXBvY2gsbnVsbCxULE0pLFY9Qi5jYWxsYmFja0xpc3QsVT1CLmhpc3RvcnkseC5oaXN0b3J5PVUsWzQsVi5vblRyYWluQmVnaW4oKV07Y2FzZSAyOnJldHVybiBhLnNlbnQoKSxXPW51bGw9PXQuaW5pdGlhbEVwb2NoPzA6dC5pbml0aWFsRXBvY2gsRz17fSxbNCxlLml0ZXJhdG9yKCldO2Nhc2UgMzpxPWEuc2VudCgpLGEubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIFc8dC5lcG9jaHM/WzQsVi5vbkVwb2NoQmVnaW4oVyldOlszLDE4XTtjYXNlIDU6cmV0dXJuIGEuc2VudCgpLEg9MCxqPTAsbj9bMyw3XTpbNCxlLml0ZXJhdG9yKCldO2Nhc2UgNjpxPWEuc2VudCgpLGEubGFiZWw9NztjYXNlIDc6cmV0dXJuIW58fEg8dC5iYXRjaGVzUGVyRXBvY2g/WzQscS5uZXh0KCldOlszLDE2XTtjYXNlIDg6aWYoJD1hLnNlbnQoKSxuJiYkLmRvbmUpcmV0dXJuIGNvbnNvbGUud2FybihcIllvdSBwcm92aWRlZCBgYmF0Y2hlc1BlckVwb2NoYCBhcyBcIit0LmJhdGNoZXNQZXJFcG9jaCtcIiwgYnV0IHlvdXIgZGF0YXNldCBpdGVyYXRvciByYW4gb3V0IG9mIGRhdGEgYWZ0ZXIgXCIrSCtcIiBiYXRjaGVzOyBpbnRlcnJ1cHRpbmcgdHJhaW5pbmcuIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgYGJhdGNoZXNQZXJFcG9jaCAqIGVwb2Noc2AgYmF0Y2hlcyAoaW4gdGhpcyBjYXNlLCBcIit0LmJhdGNoZXNQZXJFcG9jaCp0LmVwb2NocytcIiBiYXRjaGVzKS4gWW91IG1heSBuZWVkIHRvIHVzZSB0aGUgcmVwZWF0KCkgZnVuY3Rpb24gd2hlbiBidWlsZGluZyB5b3VyIGRhdGFzZXQuXCIpLFszLDE2XTtpZihudWxsPT0kLnZhbHVlKXJldHVyblszLDEwXTtmb3Ioaz1zdGFuZGFyZGl6ZURhdGFJdGVyYXRvck91dHB1dCh4LCQudmFsdWUpLChLPXt9KS5iYXRjaD1qLEsuc2l6ZT1rWzBdLnNoYXBlWzBdLFYub25CYXRjaEJlZ2luKGosSyksWD1PKGspLGRpc3Bvc2UoayksZWU9MDtlZTxMLmxlbmd0aDsrK2VlKVk9TFtlZV0sWj1YW2VlXSxLW1ldPVosa2VlcChaKTtyZXR1cm5bNCxWLm9uQmF0Y2hFbmQoaixLKV07Y2FzZSA5OmEuc2VudCgpLGRpc3Bvc2VUZW5zb3JzSW5Mb2dzKEspLGorKyxIKyssYS5sYWJlbD0xMDtjYXNlIDEwOnJldHVybihuP0g+PXQuYmF0Y2hlc1BlckVwb2NoOiQuZG9uZSk/VD8oUT12b2lkIDAsaXNEYXRhc2V0T2JqZWN0KHQudmFsaWRhdGlvbkRhdGEpPyhKPXRvTGlzdCxbNCx4LmV2YWx1YXRlRGF0YXNldCh0LnZhbGlkYXRpb25EYXRhLHtiYXRjaGVzOnQudmFsaWRhdGlvbkJhdGNoZXN9KV0pOlszLDEyXSk6WzMsMTRdOlszLDE1XTtjYXNlIDExOnJldHVybiBRPUouYXBwbHkodm9pZCAwLFthLnNlbnQoKV0pLFszLDEzXTtjYXNlIDEyOlE9dG9MaXN0KHguZXZhbHVhdGUoUixELHtiYXRjaFNpemU6bnVsbD09dC52YWxpZGF0aW9uQmF0Y2hTaXplPzMyOnQudmFsaWRhdGlvbkJhdGNoU2l6ZSx2ZXJib3NlOjB9KSksYS5sYWJlbD0xMztjYXNlIDEzOmZvcihlZT0wO2VlPHgubWV0cmljc05hbWVzLmxlbmd0aDsrK2VlKUdbXCJ2YWxfXCIreC5tZXRyaWNzTmFtZXNbZWVdXT1RW2VlXTthLmxhYmVsPTE0O2Nhc2UgMTQ6cmV0dXJuWzMsMTZdO2Nhc2UgMTU6cmV0dXJuIHguc3RvcFRyYWluaW5nXz9bMywxNl06WzMsN107Y2FzZSAxNjpyZXR1cm5bNCxWLm9uRXBvY2hFbmQoVyxHKV07Y2FzZSAxNzpyZXR1cm4gYS5zZW50KCksVysrLHguc3RvcFRyYWluaW5nXz9bMywxOF06WzMsNF07Y2FzZSAxODpyZXR1cm5bNCxWLm9uVHJhaW5FbmQoKV07Y2FzZSAxOTpyZXR1cm4gYS5zZW50KCksWzQseC5oaXN0b3J5LnN5bmNEYXRhKCldO2Nhc2UgMjA6cmV0dXJuIGEuc2VudCgpLFsyLHguaGlzdG9yeV07Y2FzZSAyMTpyZXR1cm4geC5pc1RyYWluaW5nPSExLFs3XTtjYXNlIDIyOnJldHVyblsyXTt9fSl9KX1mdW5jdGlvbiBpc0RhdGFzZXRPYmplY3QodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdC5pdGVyYXRvcn1mdW5jdGlvbiBpc0xhenlJdGVyYXRvck9iamVjdCh0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lm5leHR9ZnVuY3Rpb24gZXZhbHVhdGVEYXRhc2V0KG0sZSxnKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4sdCxmLHksYix4LE4sSSxkLHY7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbihhKXtzd2l0Y2goYS5sYWJlbCl7Y2FzZSAwOmlmKG49bnVsbCE9Zy5iYXRjaGVzLHQ9bS50ZXN0RnVuY3Rpb24sZj1bXSwwPGcudmVyYm9zZSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlZlcmJvc2UgbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gdXRpbC5hc3NlcnQoIW58fDA8Zy5iYXRjaGVzJiZfTnVtYmVyaXNJbnRlZ2VyKGcuYmF0Y2hlcyksXCJUZXN0IGxvb3AgZXhwZWN0cyBgYmF0Y2hlc2AgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZy5iYXRjaGVzKSksaXNMYXp5SXRlcmF0b3JPYmplY3QoZSk/KGI9ZSxbMywzXSk6WzMsMV07Y2FzZSAxOnJldHVybls0LGUuaXRlcmF0b3IoKV07Y2FzZSAyOmI9YS5zZW50KCksYS5sYWJlbD0zO2Nhc2UgMzp5PWIseD0wLE49MCxJPWZ1bmN0aW9uKCl7dmFyIGUsYSxyLG8saSxsO3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx5Lm5leHQoKV07Y2FzZSAxOmlmKChlPXQuc2VudCgpKS52YWx1ZSl7aWYoYT1zdGFuZGFyZGl6ZURhdGFJdGVyYXRvck91dHB1dChtLGUudmFsdWUpLHI9dGlkeShmdW5jdGlvbigpe3JldHVybiB0KGEpfSksZGlzcG9zZShhKSwwPT09Tilmb3IobD0wO2w8ci5sZW5ndGg7KytsKWYucHVzaChnZXRTY2FsYXIoMCkpO2ZvcihvPWFbMF0uc2hhcGVbMF0saT1mdW5jdGlvbihhKXt2YXIgZT1yW2FdLHQ9ZlthXTtmW2FdPXRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gYWRkKGZbYV0sbXVsKGdldFNjYWxhcihvKSxlKSl9KSwwPE4mJmRpc3Bvc2UodCl9LGw9MDtsPHIubGVuZ3RoOysrbClpKGwpO2Rpc3Bvc2UocikseCs9bywrK059cmV0dXJuIGUuZG9uZT8obiYmY29uc29sZS53YXJuKFwiWW91ciBkYXRhc2V0IGl0ZXJhdG9yIHJhbiBvdXQgb2YgZGF0YSBkdXJpbmcgZXZhbHVhdGVEYXRhc2V0KCkuIEludGVycnVwdGluZyBldmFsdXRpb24uIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgYGJhdGNoZXNgIGJhdGNoZXMgKGluIHRoaXMgY2FzZSwgXCIrZy5iYXRjaGVzK1wiIGJhdGNoZXMpLiBZb3UgbWF5IG5lZWQgdG8gdXNlIHRoZSByZXBlYXQoKSBmdW5jdGlvbiB3aGVuIGJ1aWxkaW5nIHlvdXIgZGF0YXNldC5cIiksWzIsXCJicmVha1wiXSk6WzJdO319KX0sYS5sYWJlbD00O2Nhc2UgNDpyZXR1cm4hbnx8TjxnLmJhdGNoZXM/WzUsSSgpXTpbMyw2XTtjYXNlIDU6cmV0dXJuXCJicmVha1wiPT09YS5zZW50KCk/WzMsNl06WzMsNF07Y2FzZSA2OmZvcihkPWZ1bmN0aW9uKGEpe3ZhciBlPWZbYV07ZlthXT10aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGRpdihmW2FdLGdldFNjYWxhcih4KSl9KSxkaXNwb3NlKGUpfSx2PTA7djxmLmxlbmd0aDsrK3YpZCh2KTtyZXR1cm5bMixzaW5nbGV0b25PckFycmF5KGYpXTt9fSl9KX1mdW5jdGlvbiBjaGVja0JhdGNoU2l6ZSh0KXt1dGlsLmFzc2VydCgwPHQmJl9OdW1iZXJpc0ludGVnZXIodCksXCJiYXRjaFNpemUgaXMgcmVxdWlyZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK3QpfWZ1bmN0aW9uIHNsaWNlQXJyYXlzKGEscix0KXtyZXR1cm4gbnVsbD09YT9bbnVsbF06QXJyYXkuaXNBcnJheShhKT9hLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhLHIsdC1yKX0pOnNsaWNlQWxvbmdGaXJzdEF4aXMoYSxyLHQtcil9ZnVuY3Rpb24gc2xpY2VBcnJheXNCeUluZGljZXMoYSxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBudWxsPT1hP251bGw6QXJyYXkuaXNBcnJheShhKT9hLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gc2xpY2VBcnJheXNCeUluZGljZXModCxuKX0pOmdhdGhlciQxKGEsXCJpbnQzMlwiPT09bi5kdHlwZT9uOm4udG9JbnQoKSl9KX1mdW5jdGlvbiBtYWtlQmF0Y2hlcyhhLGUpe2Zvcih2YXIgdD1bXSxuPTAsbz1udWxsO248YTspKG89bitlKT49YSYmKG89YSksdC5wdXNoKFtuLG9dKSxuPW87cmV0dXJuIHR9ZnVuY3Rpb24gZml0TG9vcCh4LGUsdCxuLHIsQyxrLFQscyxsLHUsRSxwLFIsZCxmKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGksYyxELGEsUCxvLGgsZztyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKG0pe3N3aXRjaChtLmxhYmVsKXtjYXNlIDA6aWYobnVsbD09ciYmKHI9MzIpLG51bGw9PUMmJihDPTEpLG51bGw9PXUmJih1PSEwKSxudWxsPT1wJiYocD0wKSxpPSExLG51bGwhPXMmJm51bGwhPWwmJihpPSEwKSxudWxsIT1kJiYoaT0hMCxudWxsPT1SKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbiBvbmx5IHVzZSBgdmFsaWRhdGlvblN0ZXBzYCB3aGVuIGRvaW5nIHN0ZXAtd2lzZSB0cmFpbmluZywgaS5lLiwgYHN0ZXBzUGVyRXBvY2hgIG11c3QgYmUgc2V0LlwiKTtyZXR1cm4gbnVsbCE9KGM9eC5jaGVja051bVNhbXBsZXModCxyLFIsXCJzdGVwc19wZXJfZXBvY2hcIikpJiYoRD1yYW5nZSQxKDAsYykpLG51bGw9PWsmJihrPTEpLGE9Y29uZmlndXJlQ2FsbGJhY2tzKFQsZixrLEMscCxjLFIscixpLEUpLFA9YS5jYWxsYmFja0xpc3Qsbz1hLmhpc3RvcnksUC5zZXRNb2RlbCh4KSx4Lmhpc3Rvcnk9byxbNCxQLm9uVHJhaW5CZWdpbigpXTtjYXNlIDE6bS5zZW50KCkseC5zdG9wVHJhaW5pbmdfPSExLGg9ZnVuY3Rpb24oZCl7dmFyIGEsbSxOLHksYjtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsUC5vbkVwb2NoQmVnaW4oZCldO2Nhc2UgMTppZihvLnNlbnQoKSxhPXt9LG51bGw9PVIpcmV0dXJuWzMsMl07dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJzdGVwc1BlckVwb2NoIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7Y2FzZSAyOmlmKFwiYmF0Y2hcIj09PXUpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaCBzaHVmZmxpbmcgaXMgbm90IGltcGxlbW5ldGVkIHlldFwiKTt1JiZ1dGlsLnNodWZmbGUoRCksbT10ZW5zb3IxZChEKSxOPW1ha2VCYXRjaGVzKGMscikseT1mdW5jdGlvbihvKXt2YXIgcDtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKGQpe3N3aXRjaChkLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHA9e30sWzQsUC5vbkJhdGNoQmVnaW4obyxwKV07Y2FzZSAxOnJldHVybiBkLnNlbnQoKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIHU9TltvXVswXSxjPU5bb11bMV0sZD1zbGljZUFsb25nRmlyc3RBeGlzKG0sdSxjLXUpO3AuYmF0Y2g9byxwLnNpemU9Yy11O2Zvcih2YXIgaD1zbGljZUFycmF5c0J5SW5kaWNlcyh0LGQpLGc9ZShoKSxmPTA7ZjxuLmxlbmd0aDsrK2Ype3ZhciB5PW5bZl0sST1nW2ZdO3BbeV09SSxrZWVwKEkpfWlmKG89PT1OLmxlbmd0aC0xJiZpKXt2YXIgUz14LnRlc3RMb29wKHMsbCxyKTtmb3IoZj0wO2Y8bi5sZW5ndGg7KytmKXk9bltmXSxJPVNbZl0sa2VlcChJKSxhW1widmFsX1wiK3ldPUl9fSksWzQsUC5vbkJhdGNoRW5kKG8scCldO2Nhc2UgMjpyZXR1cm4gZC5zZW50KCksZGlzcG9zZVRlbnNvcnNJbkxvZ3MocCkseC5zdG9wVHJhaW5pbmdfP1syLFwiYnJlYWtcIl06WzJdO319KX0sYj0wLG8ubGFiZWw9MztjYXNlIDM6cmV0dXJuIGI8Ti5sZW5ndGg/WzUseShiKV06WzMsNl07Y2FzZSA0OmlmKFwiYnJlYWtcIj09PW8uc2VudCgpKXJldHVyblszLDZdO28ubGFiZWw9NTtjYXNlIDU6cmV0dXJuKytiLFszLDNdO2Nhc2UgNjptLmRpc3Bvc2UoKSxvLmxhYmVsPTc7Y2FzZSA3OnJldHVybls0LFAub25FcG9jaEVuZChkLGEpXTtjYXNlIDg6cmV0dXJuIG8uc2VudCgpLHguc3RvcFRyYWluaW5nXz9bMixcImJyZWFrXCJdOlsyXTt9fSl9LGc9cCxtLmxhYmVsPTI7Y2FzZSAyOnJldHVybiBnPEM/WzUsaChnKV06WzMsNV07Y2FzZSAzOmlmKFwiYnJlYWtcIj09PW0uc2VudCgpKXJldHVyblszLDVdO20ubGFiZWw9NDtjYXNlIDQ6cmV0dXJuKytnLFszLDJdO2Nhc2UgNTpyZXR1cm5bNCxQLm9uVHJhaW5FbmQoKV07Y2FzZSA2OnJldHVybiBtLnNlbnQoKSxbNCx4Lmhpc3Rvcnkuc3luY0RhdGEoKV07Y2FzZSA3OnJldHVybiBtLnNlbnQoKSxbMix4Lmhpc3RvcnldO319KX0pfWZ1bmN0aW9uIGZpdFRlbnNvcnMoeCxlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSxfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixDLGssVCxFLFIsRCxQLEEsXyxOLE8sTCxNLEYsQixWLFUsVyxHO3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDppZih4LmlzVHJhaW5pbmcpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0YXJ0IHRyYWluaW5nIGJlY2F1c2UgYW5vdGhlciBmaXQoKSBjYWxsIGlzIG9uZ29pbmcuXCIpO3guaXNUcmFpbmluZz0hMCxhLmxhYmVsPTE7Y2FzZSAxOmlmKGEudHJ5cy5wdXNoKFsxLCwzLDRdKSxjaGVja0JhdGNoU2l6ZShEPW51bGw9PW4uYmF0Y2hTaXplPzMyOm4uYmF0Y2hTaXplKSxQPXguc3RhbmRhcmRpemVVc2VyRGF0YShlLHQsITEsRCkscj1QWzBdLEM9UFsxXSxBPSExLF89dm9pZCAwLG51bGwhPW4udmFsaWRhdGlvbkRhdGEmJjA8bi52YWxpZGF0aW9uRGF0YS5sZW5ndGgpe2lmKEE9ITAsMiE9PW4udmFsaWRhdGlvbkRhdGEubGVuZ3RoKXRocm93IDM9PT1uLnZhbGlkYXRpb25EYXRhLmxlbmd0aD9uZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInZhbGlkYXRpb25EYXRhIGluY2x1ZGluZyBzYW1wbGUgd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik6bmV3IFZhbHVlRXJyb3IoXCJXaGVuIHBhc3NpbmcgdmFsaWRhdGlvbiBkYXRhLCBpdCBtdXN0IGNvbnRhaW4gMiAodmFsWCwgdmFsWSkgb3IgMyAodmFsWCwgdmFsWSwgdmFsU2FtcGxlV2VpZ2h0KSBpdGVtczsgXCIrbi52YWxpZGF0aW9uRGF0YStcIiBpcyBpbnZhbGlkLlwiKTtrPW4udmFsaWRhdGlvbkRhdGFbMF0sVD1uLnZhbGlkYXRpb25EYXRhWzFdLE49eC5zdGFuZGFyZGl6ZVVzZXJEYXRhKGssVCwhMCxEKSxFPU5bMF0sUj1OWzFdLF89RS5jb25jYXQoUil9ZWxzZSBudWxsIT1uLnZhbGlkYXRpb25TcGxpdCYmMDxuLnZhbGlkYXRpb25TcGxpdCYmMT5uLnZhbGlkYXRpb25TcGxpdD8oQT0hMCxPPV9NYXRoZmxvb3IoclswXS5zaGFwZVswXSooMS1uLnZhbGlkYXRpb25TcGxpdCkpLEw9clswXS5zaGFwZVswXSxFPXNsaWNlQXJyYXlzKHIsTyxMKSxyPXNsaWNlQXJyYXlzKHIsMCxPKSxSPXNsaWNlQXJyYXlzKEMsTyxMKSxDPXNsaWNlQXJyYXlzKEMsMCxPKSxfPUUuY29uY2F0KFIpKTpudWxsIT1uLnZhbGlkYXRpb25TdGVwcyYmKEE9ITApO3JldHVybiBNPXIuY29uY2F0KEMpLHguY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKSxGPXgubWFrZVRyYWluRnVuY3Rpb24oKSxCPXguZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpLFY9dm9pZCAwLFU9dm9pZCAwLEE/KHgubWFrZVRlc3RGdW5jdGlvbigpLFY9eC50ZXN0RnVuY3Rpb24sVT1CLnNsaWNlKCkuY29uY2F0KEIubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwidmFsX1wiK3R9KSkpOihWPW51bGwsXz1bXSxVPUIuc2xpY2UoKSksVz1zdGFuZGFyZGl6ZUNhbGxiYWNrcyhuLmNhbGxiYWNrcyksWzQsZml0TG9vcCh4LEYsTSxCLEQsbi5lcG9jaHMsbi52ZXJib3NlLFcsVixfLG4uc2h1ZmZsZSxVLG4uaW5pdGlhbEVwb2NoLG51bGwsbnVsbCxuLnlpZWxkRXZlcnkpXTtjYXNlIDI6cmV0dXJuIEc9YS5zZW50KCkseC5pc1RyYWluaW5nPSExLFsyLEddO2Nhc2UgMzpyZXR1cm4geC5pc1RyYWluaW5nPSExLGRpc3Bvc2VOZXdUZW5zb3JzKHIsZSksZGlzcG9zZU5ld1RlbnNvcnMoQyx0KSxkaXNwb3NlTmV3VGVuc29ycyhFLGspLGRpc3Bvc2VOZXdUZW5zb3JzKFIsVCksWzddO2Nhc2UgNDpyZXR1cm5bMl07fX0pfSl9ZnVuY3Rpb24gZW5zdXJlVGVuc29yc1JhbmsyT3JIaWdoZXIoYSl7dmFyIG89W107YSBpbnN0YW5jZW9mIFRlbnNvciYmKGE9W2FdKTtmb3IodmFyIHQ9MCxzO3Q8YS5sZW5ndGg7Kyt0KWlmKHM9YVt0XSwxPT09cy5yYW5rKW8ucHVzaChleHBhbmREaW1zJDEocywxKSk7ZWxzZXtpZigwPT09cy5yYW5rKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHRlbnNvciB0byBiZSBhdCBsZWFzdCAxRCwgYnV0IHJlY2VpdmVkIGEgMEQgdGVuc29yIChzY2FsYXIpLlwiKTtvLnB1c2gocyl9cmV0dXJuIG99ZnVuY3Rpb24gZGlzcG9zZU5ld1RlbnNvcnMocCxlKXtpZihudWxsIT1wKXt2YXIgdD1bXTtpZihlIGluc3RhbmNlb2YgVGVuc29yKXQucHVzaChlLmlkKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpZS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiB0LnB1c2goYS5pZCl9KTtlbHNlIGlmKG51bGwhPWUpZm9yKHZhciBuIGluIGUpe3ZhciByPWVbbl07dC5wdXNoKHIuaWQpfXZhciBpPVtdO2lmKHAgaW5zdGFuY2VvZiBUZW5zb3IpLTE9PT10LmluZGV4T2YocC5pZCkmJmkucHVzaChwKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkocCkpcC5mb3JFYWNoKGZ1bmN0aW9uKGEpey0xPT09dC5pbmRleE9mKGEuaWQpJiZpLnB1c2goYSl9KTtlbHNlIGlmKG51bGwhPXApZm9yKHZhciBhIGluIHApe3ZhciBvPXBbYV07LTE9PT10LmluZGV4T2Yoby5pZCkmJmkucHVzaChvKX1pLmZvckVhY2goZnVuY3Rpb24odCl7dC5pc0Rpc3Bvc2VkfHx0LmRpc3Bvc2UoKX0pfX1mdW5jdGlvbiBpc0RhdGFUZW5zb3IodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBUZW5zb3J9ZnVuY3Rpb24gaXNEYXRhQXJyYXkodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCl9ZnVuY3Rpb24gaXNEYXRhRGljdCh0KXtyZXR1cm4haXNEYXRhVGVuc29yKHQpJiYhaXNEYXRhQXJyYXkodCl9ZnVuY3Rpb24gc3RhbmRhcmRpemVJbnB1dERhdGEobSx5LHQsbixiKXtpZih2b2lkIDA9PT1uJiYobj0hMCksdm9pZCAwPT09YiYmKGI9XCJcIiksbnVsbD09eXx8MD09PXkubGVuZ3RoKXtpZihudWxsIT1tKXt2YXIgeD0hMTtpZihpc0RhdGFBcnJheShtKSYmMDxtLmxlbmd0aCl4PSEwO2Vsc2UgaWYoaXNEYXRhRGljdChtKSl7Zm9yKHZhciBOIGluIG0paWYobS5oYXNPd25Qcm9wZXJ0eShOKSl7eD0hMDticmVha319ZWxzZSB4PSEwO2lmKHgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsIFwiK2IrXCIgZXhwZWN0ZWQgbm8gZGF0YSwgYnV0IGdvdCBcIittKX1yZXR1cm5bXX1pZihudWxsPT1tKXJldHVybiB5Lm1hcChmdW5jdGlvbigpe3JldHVybiBudWxsfSk7dmFyIG87aWYoaXNEYXRhRGljdChtKSl7bT1tLG89W107Zm9yKHZhciBJPTAsdj15LHU7STx2Lmxlbmd0aDtJKyspe2lmKHU9dltJXSxudWxsPT1tW3VdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTm8gZGF0YSBwcm92aWRlZCBmb3IgXFxcIlwiK3UrXCJcXFwiLiBOZWVkIGRhdGEgZm9yIGVhY2gga2V5IGluOiBcIit5KTtvLnB1c2gobVt1XSl9fWVsc2UgaWYoaXNEYXRhQXJyYXkobSkpe2lmKChtPW0pLmxlbmd0aCE9PXkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIitiK1wiOiB0aGUgQXJyYXkgb2YgVGVuc29ycyB0aGF0IHlvdSBhcmUgcGFzc2luZyB0byB5b3VyIG1vZGVsIGlzIG5vdCB0aGUgc2l6ZSB0aGUgbW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSBcIit5Lmxlbmd0aCtcIiBUZW5zb3IocyksIGJ1dCBpbnN0ZWFkIGdvdCB0aGUgZm9sbG93aW5nIGxpc3Qgb2YgVGVuc29yKHMpOiBcIittKTtvPW19ZWxzZXtpZihtPW0sMTx5Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBtb2RlbCBcIitiK1wiIGV4cGVjdHMgXCIreS5sZW5ndGgrXCIgVGVuc29yKHMpLCBidXQgb25seSByZWNlaXZlZCBvbmUgVGVuc29yLiBGb3VuZDogVGVuc29yIHdpdGggc2hhcGUgXCIrbS5zaGFwZSk7bz1bbV19aWYobz1lbnN1cmVUZW5zb3JzUmFuazJPckhpZ2hlcihvKSxudWxsIT10KWZvcih2YXIgUz0wO1M8eS5sZW5ndGg7KytTKWlmKG51bGwhPXRbU10pe3ZhciBDPW9bU107aWYoQy5zaGFwZS5sZW5ndGghPT10W1NdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIrYitcIjogZXhwZWN0ZWQgXCIreVtTXStcIiB0byBoYXZlIFwiK3RbU10ubGVuZ3RoK1wiIGRpbWVuc2lvbihzKS4gYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFwiK0Muc2hhcGUpO2Zvcih2YXIgaD0wO2g8dFtTXS5sZW5ndGg7KytoKWlmKDAhPWh8fG4pe3ZhciBrPUMuc2hhcGVbaF0sZj10W1NdW2hdO2lmKG51bGwhPWYmJjA8PWYmJmshPT1mKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIitiK1wiOiBleHBlY3RlZCBcIit5W1NdK1wiIHRvIGhhdmUgc2hhcGUgW1wiK3RbU10rXCJdLCBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgW1wiK0Muc2hhcGUrXCJdLlwiKX19cmV0dXJuIG99ZnVuY3Rpb24gY2hlY2tBcnJheUxlbmd0aHMoYSxlKXt2YXIgdD11bmlxdWUoYS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGVbMF19KSk7dC5zb3J0KCk7dmFyIG49dW5pcXVlKGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlWzBdfSkpO2lmKG4uc29ydCgpLDE8dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgaW5wdXQgVGVuc29ycyAoeCkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMuIEdvdCBhcnJheSBzaGFwZXM6IFwiK0pTT04uc3RyaW5naWZ5KGEubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpKTtpZigxPG4ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIHRhcmdldCBUZW5zb3JzICh5KSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcy4gR290IGFycmF5IHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkoZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSkpO2lmKDA8dC5sZW5ndGgmJjA8bi5sZW5ndGgmJiF1dGlsLmFycmF5c0VxdWFsKHQsbikpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBUZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzIGFzIHRhcmdldCBUZW5zb3JzLiBGb3VuZCBcIit0WzBdK1wiIGlucHV0IHNhbXBsZShzKSBhbmQgXCIrblswXStcIiB0YXJnZXQgc2FtcGxlKHMpLlwiKX1mdW5jdGlvbiBjaGVja0xvc3NBbmRUYXJnZXRDb21wYXRpYmlsaXR5KGQsZSx0KXtmb3IodmFyIG49W21lYW5TcXVhcmVkRXJyb3IkMSxiaW5hcnlDcm9zc2VudHJvcHksY2F0ZWdvcmljYWxDcm9zc2VudHJvcHldLHI9MDtyPGQubGVuZ3RoOysrcil7dmFyIG09ZFtyXSxhPWVbcl0sbz10W3JdO2lmKG51bGwhPWEpe2lmKGE9PT1jYXRlZ29yaWNhbENyb3NzZW50cm9weSYmMT09PW0uc2hhcGVbbS5zaGFwZS5sZW5ndGgtMV0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJZb3UgYXJlIHBhc3NpbmcgYSB0YXJnZXQgYXJyYXkgb2Ygc2hhcGUgXCIrbS5zaGFwZStcIiB3aGlsZSB1c2luZyBhIGxvc3MgJ2NhdGVnb3JpY2FsX2Nyb3NzZW50cm9weScuICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknZXhwZWN0cyB0YXJnZXRzIHRvIGJlIGJpbmFyeSBtYXRyaWNlcyAoMXMgYW5kIDBzKSBvZiBzaGFwZSBbc2FtcGxlcywgY2xhc3Nlc10uXCIpO2lmKC0xIT09bi5pbmRleE9mKGEpKWZvcih2YXIgcz1tLnNoYXBlLnNsaWNlKDEpLGw9by5zbGljZSgxKSx1PTA7dTxzLmxlbmd0aDsrK3Upe3ZhciBnPXNbdV0scD1sW3VdO2lmKG51bGwhPXAmJmchPT1wKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSB0YXJnZXQgVGVuc29yIHdpdGggc2hhcGUgXCIrbS5zaGFwZStcIiB3YXMgcGFzc2VkIGZvciBhbiBvdXRwdXQgb2Ygc2hhcGUgXCIrbytcIiwgd2hpbGUgdXNpbmcgYSBsb3NzIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0YXJnZXRzIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGUgYXMgdGhlIG91dHB1dC5cIil9fX19ZnVuY3Rpb24gY2hlY2tJbnB1dERhdGEocCxlLHQsbixkKXt2YXIgbTtpZih2b2lkIDA9PT1uJiYobj0hMCksdm9pZCAwPT09ZCYmKGQ9XCJcIiksQXJyYXkuaXNBcnJheShwKSl7aWYocC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgXCIrZCtcIjogdGhlIEFycmF5IG9mIFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIHRoZSBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlIFwiK2UubGVuZ3RoK1wiIFRlbnNvcihzKSwgYnV0IGluc3RlYWQgZ290IFwiK3AubGVuZ3RoK1wiIFRlbnNvcnMocykuXCIpO209cH1lbHNle2lmKDE8ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbW9kZWwgZXhwZWN0cyBcIitlLmxlbmd0aCtcIiBcIitkK1wiIFRlbnNvcnMsIGJ1dCBvbmx5IHJlY2VpdmVkIG9uZSBUZW5zb3IuIEZvdW5kOiBhcnJheSB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KHAuc2hhcGUpK1wiLlwiKTttPVtwXX1pZihudWxsIT10KWZvcih2YXIgaD0wO2g8ZS5sZW5ndGg7KytoKWlmKG51bGwhPXRbaF0pe3ZhciBnPW1baF07aWYoZy5zaGFwZS5sZW5ndGghPT10W2hdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIrZCtcIjogZXhwZWN0ZWQgXCIrZVtoXStcIiB0byBoYXZlIFwiK3RbaF0ubGVuZ3RoK1wiIGRpbWVuc2lvbihzKSwgYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KGcuc2hhcGUpKTtmb3IodmFyIHM9MDtzPHRbaF0ubGVuZ3RoOysrcylpZigwIT1zfHxuKXt2YXIgZj1nLnNoYXBlW3NdLHU9dFtoXVtzXTtpZihudWxsIT11JiZ1IT09Zil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIrZCtcIjogZXhwZWN0ZWQgXCIrZVtoXStcIiB0byBoYXZlIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KHRbaF0pK1wiIGJ1dCBnb3QgYXJyYXkgd2l0aCBzaGFwZSBcIitKU09OLnN0cmluZ2lmeShnLnNoYXBlKStcIi5cIil9fX1mdW5jdGlvbiBjb2xsZWN0TWV0cmljcyhzLGUpe2lmKG51bGw9PXN8fEFycmF5LmlzQXJyYXkocykmJjA9PT1zLmxlbmd0aClyZXR1cm4gZS5tYXAoZnVuY3Rpb24oKXtyZXR1cm5bXX0pO2lmKEFycmF5LmlzQXJyYXkocykpcmV0dXJuIGUubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHN9KTtpZihudWxsIT1zKXtmb3IodmFyIHQ9W10sbj0wLHA9ZTtuPHAubGVuZ3RoO24rKyl7dmFyIGk9cFtuXSxhPXMuaGFzT3duUHJvcGVydHkoaSk/c1tpXTpbXTtBcnJheS5pc0FycmF5KGEpfHwoYT1bYV0pLHQucHVzaChhKX1yZXR1cm4gdH10aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZSBvZiBtZXRyaWNzIGFyZ3VtZW50IG5vdCB1bmRlcnN0b29kLiBFeHBlY3RlZCBhbiBBcnJheSBvciBPYmplY3QsIGZvdW5kOiBcIitzKX1mdW5jdGlvbiBtb2RlbEZyb21KU09OKGQsbSl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQsZyxmLHksYix4LE4sSSx2O3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDpyZXR1cm5cIm1vZGVsVG9wb2xvZ3lcImluIGR8fChkPXttb2RlbFRvcG9sb2d5OmR9KSxudWxsIT0oZT0oZD1kKS5tb2RlbFRvcG9sb2d5KS5tb2RlbF9jb25maWcmJihlPWUubW9kZWxfY29uZmlnKSx0PWNvbnZlcnRQeXRob25pY1RvVHMoZSksZz1kZXNlcmlhbGl6ZSh0LG0pLG51bGw9PWQud2VpZ2h0c01hbmlmZXN0P1szLDJdOls0LGlvLmxvYWRXZWlnaHRzKGQud2VpZ2h0c01hbmlmZXN0LGQucGF0aFByZWZpeCxnLndlaWdodHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9yaWdpbmFsTmFtZX0pKV07Y2FzZSAxOmZvcihmPWEuc2VudCgpLHk9e30sYj0wLHg9Zy53ZWlnaHRzO2I8eC5sZW5ndGg7YisrKU49eFtiXSx5W04ub3JpZ2luYWxOYW1lXT1mW04ub3JpZ2luYWxOYW1lXTtJPW51bGwsdj0hMCxnLmxvYWRXZWlnaHRzKHksSSx2KSxhLmxhYmVsPTI7Y2FzZSAyOnJldHVyblsyLGddO319KX0pfWZ1bmN0aW9uIGlucHV0KHQpe3JldHVybiBJbnB1dCh0KX1mdW5jdGlvbiBzZXJpYWxpemVBY3RpdmF0aW9uKHQpe3JldHVybiB0LmdldENsYXNzTmFtZSgpfWZ1bmN0aW9uIGRlc2VyaWFsaXplQWN0aXZhdGlvbihhLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksZGVzZXJpYWxpemVLZXJhc09iamVjdChhLHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsZSxcImFjdGl2YXRpb25cIil9ZnVuY3Rpb24gZ2V0QWN0aXZhdGlvbih0KXtyZXR1cm4gbnVsbD09dD9kZXNlcmlhbGl6ZUFjdGl2YXRpb24oe2NsYXNzTmFtZTpcImxpbmVhclwiLGNvbmZpZzp7fX0pOlwic3RyaW5nXCI9PXR5cGVvZiB0P2Rlc2VyaWFsaXplQWN0aXZhdGlvbih7Y2xhc3NOYW1lOnQsY29uZmlnOnt9fSk6dCBpbnN0YW5jZW9mIEFjdGl2YXRpb24/dDpkZXNlcmlhbGl6ZUFjdGl2YXRpb24odCl9ZnVuY3Rpb24gbDEodCl7cmV0dXJuIG5ldyBMMUwyKHtsMTpudWxsPT10P251bGw6dC5sMSxsMjowfSl9ZnVuY3Rpb24gbDIodCl7cmV0dXJuIG5ldyBMMUwyKHtsMjpudWxsPT10P251bGw6dC5sMixsMTowfSl9ZnVuY3Rpb24gc2VyaWFsaXplUmVndWxhcml6ZXIodCl7cmV0dXJuIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KHQpfWZ1bmN0aW9uIGRlc2VyaWFsaXplUmVndWxhcml6ZXIoYSxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLGRlc2VyaWFsaXplS2VyYXNPYmplY3QoYSxzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLGUsXCJyZWd1bGFyaXplclwiKX1mdW5jdGlvbiBnZXRSZWd1bGFyaXplcih0KXtyZXR1cm4gbnVsbD09dD9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiB0P2Rlc2VyaWFsaXplUmVndWxhcml6ZXIoe2NsYXNzTmFtZTp0IGluIFJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD9SRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbdF06dCxjb25maWc6e319KTp0IGluc3RhbmNlb2YgUmVndWxhcml6ZXI/dDpkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHQpfWZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KGEsZSx0KXtpZihcIm51bWJlclwiPT10eXBlb2YgYSlyZXR1cm4gcHlMaXN0UmVwZWF0KGEsZSk7aWYoYS5sZW5ndGghPT1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIFwiK3QrXCIgYXJndW1lbnQgbXVzdCBiZSBhIHR1cGxlIG9mIFwiK2UrXCIgaW50ZWdlcnMuIFJlY2VpdmVkOiBcIithLmxlbmd0aCtcIiBlbGVtZW50cy5cIik7Zm9yKHZhciBuPTAsbztuPGU7KytuKWlmKG89YVtuXSwhaXNJbnRlZ2VyKG8pKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIFwiK3QrXCIgYXJndW1lbnQgbXVzdCBiZSBhIHR1cGxlIG9mIFwiK2UrXCIgaW50ZWdlcnMuIFJlY2VpdmVkOiBcIitKU09OLnN0cmluZ2lmeShhKStcIiBpbmNsdWRpbmcgYSBub24taW50ZWdlciBudW1iZXIgXCIrbyk7cmV0dXJuIGF9ZnVuY3Rpb24gY29udk91dHB1dExlbmd0aChvLGUsdCxuLHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0xKSxudWxsPT1vP286KHM9XCJzYW1lXCI9PT10P286by0oZSsoZS0xKSooci0xKSkrMSxfTWF0aGZsb29yKChzK24tMSkvbikpO3ZhciBzfWZ1bmN0aW9uIGRlY29udkxlbmd0aChhLG8sdCxuKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKFwidmFsaWRcIj09PW4pYT1hKm8rbWF4JDEoW3QtbywwXSk7ZWxzZXtpZihcInNhbWVcIiE9PW4pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbnN1cHBvcnQgcGFkZGluZyBtb2RlOiBcIituK1wiLlwiKTthKj1vfXJldHVybiBhfWZ1bmN0aW9uIHByZXByb2Nlc3NDb252MkRJbnB1dChhLGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdChlKSxcImNoYW5uZWxzRmlyc3RcIj09PWU/dHJhbnNwb3NlKGEsWzAsMiwzLDFdKTphfSl9ZnVuY3Rpb24gY29udjFkV2l0aEJpYXMocCxsLHQsbixkLHUsYyl7cmV0dXJuIHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PWQmJihkPVwidmFsaWRcIiksdm9pZCAwPT09YyYmKGM9MSksdGlkeShmdW5jdGlvbigpe2lmKG51bGw9PXUmJih1PWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQodSksMyE9PXAuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGlucHV0IG9mIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAzLCBidXQgaXMgXCIrcC5zaGFwZS5sZW5ndGgrXCIgaW5zdGVhZC5cIik7aWYoMyE9PWwuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGtlcm5lbCBmb3IgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDMsIGJ1dCBpcyBcIitsLnNoYXBlLmxlbmd0aCtcIiBpbnN0ZWFkXCIpO2lmKG51bGwhPXQmJjEhPT10LnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBiaWFzIGZvciBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMSwgYnV0IGlzIFwiK2wuc2hhcGUubGVuZ3RoK1wiIGluc3RlYWRcIik7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT11JiYocD10cmFuc3Bvc2UocCxbMCwyLDFdKSksXCJjYXVzYWxcIj09PWQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTt2YXIgZT1jb252MWQocCxsLG4sXCJzYW1lXCI9PT1kP1wic2FtZVwiOlwidmFsaWRcIixcIk5XQ1wiLGMpO3JldHVybiBudWxsIT10JiYoZT1iaWFzQWRkKGUsdCkpLGV9KX1mdW5jdGlvbiBjb252MmRXaXRoQmlhcyhwLGUsdCxuLGwsZCx1KXtyZXR1cm4gdm9pZCAwPT09biYmKG49WzEsMV0pLHZvaWQgMD09PWwmJihsPVwidmFsaWRcIiksdGlkeShmdW5jdGlvbigpe2lmKG51bGw9PWQmJihkPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQoZCksMyE9PXAucmFuayYmNCE9PXAucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbnYyZFdpdGhCaWFzIGV4cGVjdHMgaW5wdXQgdG8gYmUgb2YgcmFuayAzIG9yIDQsIGJ1dCByZWNlaXZlZCBcIitwLnJhbmsrXCIuXCIpO2lmKDMhPT1lLnJhbmsmJjQhPT1lLnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb252MmRXaXRoQmlhcyBleHBlY3RzIGtlcm5lbCB0byBiZSBvZiByYW5rIDMgb3IgNCwgYnV0IHJlY2VpdmVkIFwiK3AucmFuaytcIi5cIik7dmFyIGE9cHJlcHJvY2Vzc0NvbnYyRElucHV0KHAsZCk7aWYoXCJjYXVzYWxcIj09PWwpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gYT1jb252MmQoYSxlLG4sXCJzYW1lXCI9PT1sP1wic2FtZVwiOlwidmFsaWRcIixcIk5IV0NcIix1KSxudWxsIT10JiYoYT1iaWFzQWRkKGEsdCkpLFwiY2hhbm5lbHNGaXJzdFwiPT09ZCYmKGE9dHJhbnNwb3NlKGEsWzAsMywxLDJdKSksYX0pfWZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZCQxKHMsZSx0LHAsbCxkKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9WzEsMV0pLHZvaWQgMD09PXAmJihwPVwidmFsaWRcIiksdGlkeShmdW5jdGlvbigpe251bGw9PWwmJihsPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQobCk7dmFyIGE9cHJlcHJvY2Vzc0NvbnYyRElucHV0KHMsbCk7aWYoNCE9PXMucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IGZvciBkZXB0aHdpc2VDb252MmQgaXMgcmVxdWlyZWQgdG8gYmUgNC1ELCBidXQgaXMgaW5zdGVhZCBcIitzLnJhbmsrXCItRFwiKTtpZig0IT09ZS5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGVwdGh3aXNlS2VybmVsIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgXCIrZS5yYW5rK1wiLURcIik7cmV0dXJuIGE9ZGVwdGh3aXNlQ29udjJkKGEsZSx0LFwic2FtZVwiPT09cD9cInNhbWVcIjpcInZhbGlkXCIsXCJOSFdDXCIsZCksXCJjaGFubmVsc0ZpcnN0XCI9PT1sJiYoYT10cmFuc3Bvc2UoYSxbMCwzLDEsMl0pKSxhfSl9ZnVuY3Rpb24gaW50ZXJwcmV0QXhpcyhhLG4pe2Zvcig7MD5hOylhKz1uO3JldHVybiBhfWZ1bmN0aW9uIGJhdGNoRG90KGQsbSxvKXtpZigzPGQuc2hhcGUubGVuZ3RofHwzPG0uc2hhcGUubGVuZ3RoKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldFwiKTtpZih1dGlsLmFzc2VydCgyPD1kLnNoYXBlLmxlbmd0aCxcImJhdGNoRG90IHJlcXVpcmVzIHRoZSByYW5rIG9mIHggdG8gYmUgPj0gMiwgYnV0IGdvdCBcIitkLnNoYXBlLmxlbmd0aCksdXRpbC5hc3NlcnQoMjw9ZC5zaGFwZS5sZW5ndGgsXCJiYXRjaERvdCByZXF1aXJlcyB0aGUgcmFuayBvZiB5IHRvIGJlID49IDIsIGJ1dCBnb3QgXCIrbS5zaGFwZS5sZW5ndGgpLFwibnVtYmVyXCI9PXR5cGVvZiBvJiYobz1bbyxvXSksXCJjb21wbGV4NjRcIj09PWQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1tLmR0eXBlKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciBjb21wbGV4NjQtdHlwZSBUZW5zb3JzIHlldC5cIik7dmFyIGc9ZC5zaGFwZS5sZW5ndGgscj1tLnNoYXBlLmxlbmd0aDtudWxsPT1vJiYobz1bZy0xLHItMl0pO3ZhciBpPW87cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgZSx0O2lmKGc+cil7ZT1nLXI7Zm9yKHZhciBhPVtdLGY9MDtmPGU7KytmKWEucHVzaCgxKTttPW0ucmVzaGFwZShtLnNoYXBlLmNvbmNhdChhKSl9ZWxzZSBpZihyPmcpe2ZvcihlPXItZyxhPVtdLGY9MDtmPGU7KytmKWEucHVzaCgxKTtkPWQucmVzaGFwZShkLnNoYXBlLmNvbmNhdChhKSl9ZWxzZSBlPTA7aWYoMj09PWQuc2hhcGUubGVuZ3RoJiYyPT09bS5zaGFwZS5sZW5ndGgpdD1pWzBdPT09aVsxXT9kLm11bFN0cmljdChtKS5zdW0oaVswXSk6ZC50cmFuc3Bvc2UoWzEsMF0pLm11bFN0cmljdChtKS5zdW0oaVsxXSk7ZWxzZXt2YXIgeT1pWzBdIT09ZC5zaGFwZS5sZW5ndGgtMXx8bnVsbCx1PWlbMV09PT1tLnNoYXBlLmxlbmd0aC0xfHxudWxsO3Q9ZC5tYXRNdWwobSx5LHUpfWlmKDA8ZSl7dmFyIGM9W10saDtmb3IoZj1oPWc+cj9nK3ItMzpnLTE7ZjxoK2U7KytmKWMucHVzaChmKTt0PXQuc3F1ZWV6ZShjKX1yZXR1cm4gMT09PXQuc2hhcGUubGVuZ3RoJiYodD10LmV4cGFuZERpbXMoMSkpLHR9KX1mdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb24kMShzLGUsdCxuLHIsaSl7dmFyIHA7aWYodm9pZCAwPT09aSYmKGk9LjAwMSksMj09PXMucmFuaylwPWJhdGNoTm9ybWFsaXphdGlvbjJkKHMsZSx0LGkscixuKTtlbHNlIGlmKDM9PT1zLnJhbmspcD1iYXRjaE5vcm1hbGl6YXRpb24zZChzLGUsdCxpLHIsbik7ZWxzZXtpZig0IT09cy5yYW5rKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2hOb3JtYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgYXJyYXkgb2YgcmFuayBcIitzLnJhbmsrXCIgeWV0XCIpO3A9YmF0Y2hOb3JtYWxpemF0aW9uNGQocyxlLHQsaSxyLG4pfXJldHVybiBwfWZ1bmN0aW9uIHJlZ3VsYXJOb3JtYWxpemVCYXRjaEluVHJhaW5pbmcocCxlLHQsbixyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksdGlkeShmdW5jdGlvbigpe3ZhciBpPW1vbWVudHMocCxuKSxhPWkubWVhbixvPWkudmFyaWFuY2U7cmV0dXJuW2JhdGNoTm9ybWFsaXphdGlvbiQxKHAsYSxvLHQsZSxyKSxhLG9dfSl9ZnVuY3Rpb24gYnJvYWRjYXN0Tm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKG0sZSx0LG4scil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIGk9bW9tZW50cyhtLG4pLGE9aS5tZWFuLG89aS52YXJpYW5jZSxzPVtdLGw9MCx5PXJhbmdlJDEoMCxtLnJhbmspLGM7bDx5Lmxlbmd0aDtsKyspYz15W2xdLC0xPT09bi5pbmRleE9mKGMpP3MucHVzaChtLnNoYXBlW2NdKTpzLnB1c2goMSk7dmFyIGI9YS5yZXNoYXBlKHMpLGg9by5yZXNoYXBlKHMpLGQ9bnVsbD09ZT9udWxsOmUucmVzaGFwZShzKSxmPW51bGw9PXQ/bnVsbDp0LnJlc2hhcGUocyk7cmV0dXJuW2JhdGNoTm9ybWFsaXphdGlvbiQxKG0sYixoLGYsZCxyKSxhLG9dfSl9ZnVuY3Rpb24gbm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGEsZSx0LG4scil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLHV0aWwuYXJyYXlzRXF1YWwobi5zbGljZSgpLnNvcnQoKSxyYW5nZSQxKDAsYS5yYW5rLTEpKT9yZWd1bGFyTm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGEsZSx0LG4scik6YnJvYWRjYXN0Tm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGEsZSx0LG4scil9ZnVuY3Rpb24gc3BhdGlhbDJkUGFkZGluZyhhLGUsbyl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZig0IT09YS5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwidGVtcG9yYWxQYWRkaW5nIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIDQtRCwgYnV0IHJlY2VpdmVkIGEgXCIrYS5yYW5rK1wiLUQgdGVuc29yLlwiKTtpZihudWxsPT1lJiYoZT1bWzEsMV0sWzEsMV1dKSwyIT09ZS5sZW5ndGh8fDIhPT1lWzBdLmxlbmd0aHx8MiE9PWVbMV0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwic3BhdGlhbDJkUGFkZGluZyBleHBlY3RzIGBwYWRkaW5nYCB0byBiZSBhbiBBcnJheSBvZiB0d28gQXJyYXlzLCBlYWNoIG9mIHdoaWNoIGlzIGFuIEFycmF5IG9mIHR3byBpbnRlZ2Vycy5cIik7aWYobnVsbD09byYmKG89aW1hZ2VEYXRhRm9ybWF0KCkpLFwiY2hhbm5lbHNMYXN0XCIhPT1vJiZcImNoYW5uZWxzRmlyc3RcIiE9PW8pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIGRhdGEgZm9ybWF0OiBcIitvK1wiLiBTdXBwb3J0ZWQgZGF0YSBmb3JtYXRzIGFyZSAnY2hhbm5lbHNMYXN0JyBhbmQgJ2NoYW5uZWxzRmlyc3QuXCIpO3ZhciB0O3JldHVybiB0PVwiY2hhbm5lbHNGaXJzdFwiPT09bz9bWzAsMF0sWzAsMF0sZVswXSxlWzFdXTpbWzAsMF0sZVswXSxlWzFdLFswLDBdXSxwYWQoYSx0KX0pfWZ1bmN0aW9uIHBvb2wyZChwLGwsdCxkLHUsYyl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgZTtjaGVja0RhdGFGb3JtYXQodSksY2hlY2tQb29sTW9kZShjKSxjaGVja1BhZGRpbmdNb2RlKGQpLG51bGw9PXQmJih0PVsxLDFdKSxudWxsPT1kJiYoZD1cInZhbGlkXCIpLG51bGw9PXUmJih1PWltYWdlRGF0YUZvcm1hdCgpKSxudWxsPT1jJiYoYz1cIm1heFwiKSxwPXByZXByb2Nlc3NDb252MkRJbnB1dChwLHUpO3ZhciBhPVwic2FtZVwiPT09ZD9cInNhbWVcIjpcInZhbGlkXCI7cmV0dXJuIGU9XCJtYXhcIj09PWM/bWF4UG9vbChwLGwsdCxhKTphdmdQb29sKHAsbCx0LGEpLFwiY2hhbm5lbHNGaXJzdFwiPT09dSYmKGU9dHJhbnNwb3NlKGUsWzAsMywxLDJdKSksZX0pfWZ1bmN0aW9uIHN0YW5kYXJkaXplQXJncyhhLG8scyxwKXtmdW5jdGlvbiByKHQpe3JldHVybiBudWxsPT10fHxBcnJheS5pc0FycmF5KHQpP3Q6W3RdfWlmKEFycmF5LmlzQXJyYXkoYSkpe2lmKG51bGwhPW98fG51bGwhPXMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXaGVuIGlucHV0cyBpcyBhbiBhcnJheSwgbmVpdGhlciBpbml0aWFsU3RhdGUgb3IgY29uc3RhbnRzIHNob3VsZCBiZSBwcm92aWRlZFwiKTtudWxsIT1wJiYocz1hLnNsaWNlKGEubGVuZ3RoLXAsYS5sZW5ndGgpLGE9YS5zbGljZSgwLGEubGVuZ3RoLXApKSwxPGEubGVuZ3RoJiYobz1hLnNsaWNlKDEsYS5sZW5ndGgpKSxhPWFbMF19cmV0dXJue2lucHV0czphLGluaXRpYWxTdGF0ZTpvPXIobyksY29uc3RhbnRzOnM9cihzKX19ZnVuY3Rpb24gcm5uKG0sZSx5LG4sYixpLGEseCl7dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PWEmJihhPSExKSx2b2lkIDA9PT14JiYoeD0hMSk7dmFyIE49ZS5zaGFwZS5sZW5ndGg7aWYoMz5OKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgc2hvdWxkIGJlIGF0IGxlYXN0IDNELCBidXQgaXMgXCIrTitcIkQuXCIpO3ZhciBsPVsxLDBdLmNvbmNhdChyYW5nZSQxKDIsTikpLHAsSTtpZihlPXRyYW5zcG9zZShlLGwpLG51bGwhPWIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgcm5uKCkgZnVuY3Rpb24gb2YgdGhlIGRlZXBsZWFybi5qcyBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgbWFza2luZyB5ZXQuXCIpO2lmKG51bGwhPWkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgcm5uKCkgZnVuY3RvaW4gb2YgdGhlIGRlZXBsZWFybi5qcyBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgY29uc3RhbnRzIHlldC5cIik7YSYmY29uc29sZS53YXJuKFwiQmFja2VuZCBybm4oKTogdGhlIHVucm9sbCA9IHRydWUgb3B0aW9uIGlzIG5vdCBhcHBsaWNhYmxlIHRvIHRoZSBpbXBlcmF0aXZlIGRlZXBsZWFybi5qcyBiYWNrZW5kLlwiKSxuJiYoZT1yZXZlcnNlKGUsMCkpO2Zvcih2YXIgdj15LFM9ZS5zaGFwZVswXSxkPWZ1bmN0aW9uKHQpe3ZhciBuPXNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LDEpO249bi5yZXNoYXBlKG4uc2hhcGUuc2xpY2UoMSkpO3ZhciBvPXRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbShuLHYpfSk7aWYoST1vWzBdLHgpaWYoMD09PXQpcD1JLmV4cGFuZERpbXMoMSk7ZWxzZXt2YXIgcz1jb25jYXQoW3AsSS5leHBhbmREaW1zKDEpXSwxKTtwLmRpc3Bvc2UoKSxwPXN9dj1vWzFdfSxmPTA7ZjxTOysrZilkKGYpO3JldHVybltJLHAsdl19ZnVuY3Rpb24gZ2VuZXJhdGVEcm9wb3V0TWFzayhzLGUsdCxwKXtmdW5jdGlvbiBsKCl7cmV0dXJuIGRyb3BvdXQocygpLGdldFNjYWxhcihlKSl9aWYodm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09cCYmKHA9MSksMTxwKXtmb3IodmFyIGk9W10sYT0wO2E8cDthKyspaS5wdXNoKGluVHJhaW5QaGFzZShsLHMsdCkpO3JldHVybiBpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGtlZXAodCl9KSxpfXJldHVybiBrZWVwKGluVHJhaW5QaGFzZShsLHMsdCkpfWZ1bmN0aW9uIGNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZSh0KXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERVMsXCJCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlXCIsdCl9ZnVuY3Rpb24gaW5wdXRMYXllcih0KXtyZXR1cm4gbmV3IElucHV0TGF5ZXIodCl9ZnVuY3Rpb24gZWx1JDIodCl7cmV0dXJuIG5ldyBFTFUkMSh0KX1mdW5jdGlvbiByZUxVKHQpe3JldHVybiBuZXcgUmVMVSh0KX1mdW5jdGlvbiBsZWFreVJlTFUodCl7cmV0dXJuIG5ldyBMZWFreVJlTFUodCl9ZnVuY3Rpb24gc29mdG1heCQxKHQpe3JldHVybiBuZXcgU29mdG1heCQxKHQpfWZ1bmN0aW9uIHRocmVzaG9sZGVkUmVMVSh0KXtyZXR1cm4gbmV3IFRocmVzaG9sZGVkUmVMVSh0KX1mdW5jdGlvbiBjb252MWQkMih0KXtyZXR1cm4gbmV3IENvbnYxRCh0KX1mdW5jdGlvbiBjb252MmQkMih0KXtyZXR1cm4gbmV3IENvbnYyRCh0KX1mdW5jdGlvbiBjb252MmRUcmFuc3Bvc2UkMSh0KXtyZXR1cm4gbmV3IENvbnYyRFRyYW5zcG9zZSh0KX1mdW5jdGlvbiBzZXBhcmFibGVDb252MmQkMSh0KXtyZXR1cm4gbmV3IFNlcGFyYWJsZUNvbnYyRCh0KX1mdW5jdGlvbiBjcm9wcGluZzJEKHQpe3JldHVybiBuZXcgQ3JvcHBpbmcyRCh0KX1mdW5jdGlvbiB1cFNhbXBsaW5nMmQodCl7cmV0dXJuIG5ldyBVcFNhbXBsaW5nMkQodCl9ZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkJDIodCl7cmV0dXJuIG5ldyBEZXB0aHdpc2VDb252MkQodCl9ZnVuY3Rpb24gYWN0aXZhdGlvbih0KXtyZXR1cm4gbmV3IEFjdGl2YXRpb24kMSh0KX1mdW5jdGlvbiBkZW5zZSh0KXtyZXR1cm4gbmV3IERlbnNlKHQpfWZ1bmN0aW9uIGRyb3BvdXQkMSh0KXtyZXR1cm4gbmV3IERyb3BvdXQodCl9ZnVuY3Rpb24gZmxhdHRlbiQxJDEodCl7cmV0dXJuIG5ldyBGbGF0dGVuKHQpfWZ1bmN0aW9uIHJlcGVhdFZlY3Rvcih0KXtyZXR1cm4gbmV3IFJlcGVhdFZlY3Rvcih0KX1mdW5jdGlvbiByZXNoYXBlJDEodCl7cmV0dXJuIG5ldyBSZXNoYXBlKHQpfWZ1bmN0aW9uIHBlcm11dGUodCl7cmV0dXJuIG5ldyBQZXJtdXRlKHQpfWZ1bmN0aW9uIGVtYmVkZGluZyh0KXtyZXR1cm4gbmV3IEVtYmVkZGluZyh0KX1mdW5jdGlvbiBhZGQkMih0KXtyZXR1cm4gbmV3IEFkZCh0KX1mdW5jdGlvbiBhdmVyYWdlJDEodCl7cmV0dXJuIG5ldyBBdmVyYWdlKHQpfWZ1bmN0aW9uIGNvbmNhdGVuYXRlJDIodCl7cmV0dXJuIG5ldyBDb25jYXRlbmF0ZSh0KX1mdW5jdGlvbiBtYXhpbXVtJDIodCl7cmV0dXJuIG5ldyBNYXhpbXVtKHQpfWZ1bmN0aW9uIG1pbmltdW0kMih0KXtyZXR1cm4gbmV3IE1pbmltdW0odCl9ZnVuY3Rpb24gbXVsdGlwbHkkMSh0KXtyZXR1cm4gbmV3IE11bHRpcGx5KHQpfWZ1bmN0aW9uIGRvdCQxJDEodCl7cmV0dXJuIG5ldyBEb3QodCl9ZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uJDEkMSh0KXtyZXR1cm4gbmV3IEJhdGNoTm9ybWFsaXphdGlvbih0KX1mdW5jdGlvbiB6ZXJvUGFkZGluZzJkKHQpe3JldHVybiBuZXcgWmVyb1BhZGRpbmcyRCh0KX1mdW5jdGlvbiBhdmVyYWdlUG9vbGluZzFkKHQpe3JldHVybiBuZXcgQXZlcmFnZVBvb2xpbmcxRCh0KX1mdW5jdGlvbiBhdmdQb29sMWQodCl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMWQodCl9ZnVuY3Rpb24gYXZnUG9vbGluZzFkKHQpe3JldHVybiBhdmVyYWdlUG9vbGluZzFkKHQpfWZ1bmN0aW9uIGF2ZXJhZ2VQb29saW5nMmQodCl7cmV0dXJuIG5ldyBBdmVyYWdlUG9vbGluZzJEKHQpfWZ1bmN0aW9uIGF2Z1Bvb2wyZCh0KXtyZXR1cm4gYXZlcmFnZVBvb2xpbmcyZCh0KX1mdW5jdGlvbiBhdmdQb29saW5nMmQodCl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMmQodCl9ZnVuY3Rpb24gZ2xvYmFsQXZlcmFnZVBvb2xpbmcxZCh0KXtyZXR1cm4gbmV3IEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQodCl9ZnVuY3Rpb24gZ2xvYmFsQXZlcmFnZVBvb2xpbmcyZCh0KXtyZXR1cm4gbmV3IEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQodCl9ZnVuY3Rpb24gZ2xvYmFsTWF4UG9vbGluZzFkKHQpe3JldHVybiBuZXcgR2xvYmFsTWF4UG9vbGluZzFEKHQpfWZ1bmN0aW9uIGdsb2JhbE1heFBvb2xpbmcyZCh0KXtyZXR1cm4gbmV3IEdsb2JhbE1heFBvb2xpbmcyRCh0KX1mdW5jdGlvbiBtYXhQb29saW5nMWQodCl7cmV0dXJuIG5ldyBNYXhQb29saW5nMUQodCl9ZnVuY3Rpb24gbWF4UG9vbGluZzJkKHQpe3JldHVybiBuZXcgTWF4UG9vbGluZzJEKHQpfWZ1bmN0aW9uIGdydSh0KXtyZXR1cm4gbmV3IEdSVSh0KX1mdW5jdGlvbiBncnVDZWxsKHQpe3JldHVybiBuZXcgR1JVQ2VsbCh0KX1mdW5jdGlvbiBsc3RtKHQpe3JldHVybiBuZXcgTFNUTSh0KX1mdW5jdGlvbiBsc3RtQ2VsbCh0KXtyZXR1cm4gbmV3IExTVE1DZWxsKHQpfWZ1bmN0aW9uIHNpbXBsZVJOTih0KXtyZXR1cm4gbmV3IFNpbXBsZVJOTih0KX1mdW5jdGlvbiBzaW1wbGVSTk5DZWxsKHQpe3JldHVybiBuZXcgU2ltcGxlUk5OQ2VsbCh0KX1mdW5jdGlvbiBybm4kMSh0KXtyZXR1cm4gbmV3IFJOTih0KX1mdW5jdGlvbiBzdGFja2VkUk5OQ2VsbHModCl7cmV0dXJuIG5ldyBTdGFja2VkUk5OQ2VsbHModCl9ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbCh0KXtyZXR1cm4gbmV3IEJpZGlyZWN0aW9uYWwodCl9ZnVuY3Rpb24gdGltZURpc3RyaWJ1dGVkKHQpe3JldHVybiBuZXcgVGltZURpc3RyaWJ1dGVkKHQpfWZ1bmN0aW9uIGJpbmFyeUFjY3VyYWN5JDEoYSxlKXtyZXR1cm4gYmluYXJ5QWNjdXJhY3koYSxlKX1mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkkMihhLGUpe3JldHVybiBiaW5hcnlDcm9zc2VudHJvcHkkMShhLGUpfWZ1bmN0aW9uIGNhdGVnb3JpY2FsQWNjdXJhY3kkMShhLGUpe3JldHVybiBjYXRlZ29yaWNhbEFjY3VyYWN5KGEsZSl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMihhLGUpe3JldHVybiBjYXRlZ29yaWNhbENyb3NzZW50cm9weSQxKGEsZSl9ZnVuY3Rpb24gcHJlY2lzaW9uJDEoYSxlKXtyZXR1cm4gcHJlY2lzaW9uKGEsZSl9ZnVuY3Rpb24gcmVjYWxsJDEoYSxlKXtyZXR1cm4gcmVjYWxsKGEsZSl9ZnVuY3Rpb24gY29zaW5lUHJveGltaXR5JDEoYSxlKXtyZXR1cm4gY29zaW5lUHJveGltaXR5KGEsZSl9ZnVuY3Rpb24gbWVhbkFic29sdXRlRXJyb3IkMShhLGUpe3JldHVybiBtZWFuQWJzb2x1dGVFcnJvcihhLGUpfWZ1bmN0aW9uIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvciQxKGEsZSl7cmV0dXJuIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcihhLGUpfWZ1bmN0aW9uIE1BUEUkMihhLGUpe3JldHVybiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoYSxlKX1mdW5jdGlvbiBtYXBlJDIoYSxlKXtyZXR1cm4gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKGEsZSl9ZnVuY3Rpb24gbWVhblNxdWFyZWRFcnJvciQxJDEoYSxlKXtyZXR1cm4gbWVhblNxdWFyZWRFcnJvciQxKGEsZSl9ZnVuY3Rpb24gTVNFJDIoYSxlKXtyZXR1cm4gbWVhblNxdWFyZWRFcnJvciQxKGEsZSl9ZnVuY3Rpb24gbXNlJDIoYSxlKXtyZXR1cm4gbWVhblNxdWFyZWRFcnJvciQxKGEsZSl9ZnVuY3Rpb24gbDFsMih0KXtyZXR1cm4gbmV3IEwxTDIodCl9ZnVuY3Rpb24gbDEkMSh0KXtyZXR1cm4gbDEodCl9ZnVuY3Rpb24gbDIkMSh0KXtyZXR1cm4gbDIodCl9ZnVuY3Rpb24gX19hd2FpdGVyJDIobCxlLHQsZCl7cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoZnVuY3Rpb24oYSxuKXtmdW5jdGlvbiByKHQpe3RyeXtzKGQubmV4dCh0KSl9Y2F0Y2godCl7bih0KX19ZnVuY3Rpb24gbyh0KXt0cnl7cyhkLnRocm93KHQpKX1jYXRjaCh0KXtuKHQpfX1mdW5jdGlvbiBzKG4pe24uZG9uZT9hKG4udmFsdWUpOm5ldyB0KGZ1bmN0aW9uKGUpe2Uobi52YWx1ZSl9KS50aGVuKHIsbyl9cygoZD1kLmFwcGx5KGwsZXx8W10pKS5uZXh0KCkpfSl9ZnVuY3Rpb24gX19nZW5lcmF0b3IkMihwLGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbih0KXtpZihsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7aTspdHJ5e2lmKGw9MSxkJiYodT1kWzImdFswXT9cInJldHVyblwiOnRbMF0/XCJ0aHJvd1wiOlwibmV4dFwiXSkmJiEodT11LmNhbGwoZCx0WzFdKSkuZG9uZSlyZXR1cm4gdTtzd2l0Y2goZD0wLHUmJih0PVswLHUudmFsdWVdKSx0WzBdKXtjYXNlIDA6Y2FzZSAxOnU9dDticmVhaztjYXNlIDQ6cmV0dXJuIGkubGFiZWwrKyx7dmFsdWU6dFsxXSxkb25lOiExfTtjYXNlIDU6aS5sYWJlbCsrLGQ9dFsxXSx0PVswXTtjb250aW51ZTtjYXNlIDc6dD1pLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKHU9MDwodT1pLnRyeXMpLmxlbmd0aCYmdVt1Lmxlbmd0aC0xXSkmJig2PT09dFswXXx8Mj09PXRbMF0pKXtpPTA7Y29udGludWV9aWYoMz09PXRbMF0mJighdXx8dFsxXT51WzBdJiZ0WzFdPHVbM10pKXtpLmxhYmVsPXRbMV07YnJlYWt9aWYoNj09PXRbMF0mJmkubGFiZWw8dVsxXSl7aS5sYWJlbD11WzFdLHU9dDticmVha31pZih1JiZpLmxhYmVsPHVbMl0pe2kubGFiZWw9dVsyXSxpLm9wcy5wdXNoKHQpO2JyZWFrfXVbMl0mJmkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZTt9dD1lLmNhbGwocCxpKX1jYXRjaChhKXt0PVs2LGFdLGQ9MH1maW5hbGx5e2w9dT0wfWlmKDUmdFswXSl0aHJvdyB0WzFdO3JldHVybnt2YWx1ZTp0WzBdP3RbMV06dm9pZCAwLGRvbmU6ITB9fShbdCxhXSl9fXZhciBpPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJnVbMF0pdGhyb3cgdVsxXTtyZXR1cm4gdVsxXX0sdHJ5czpbXSxvcHM6W119LGwsZCx1LGM7cmV0dXJuIGM9e25leHQ6dCgwKSx0aHJvdzp0KDEpLHJldHVybjp0KDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihjW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGN9ZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUkMShhLGUpe3JldHVybiBhKGU9e2V4cG9ydHM6e319LGUuZXhwb3J0cyksZS5leHBvcnRzfWZ1bmN0aW9uIGFzUHJvbWlzZShzLGUpe2Zvcih2YXIgdD1BcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLGE9MCxpPTIscD0hMDtpPGFyZ3VtZW50cy5sZW5ndGg7KXRbYSsrXT1hcmd1bWVudHNbaSsrXTtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocixuKXt0W2FdPWZ1bmN0aW9uKG8pe2lmKHApaWYocD0hMSxvKW4obyk7ZWxzZXtmb3IodmFyIGU9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSx0PTA7dDxlLmxlbmd0aDspZVt0KytdPWFyZ3VtZW50c1t0XTtyLmFwcGx5KG51bGwsZSl9fTt0cnl7cy5hcHBseShlfHxudWxsLHQpfWNhdGNoKHQpe3AmJihwPSExLG4odCkpfX0pfWZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpe3RoaXMuX2xpc3RlbmVycz17fX1mdW5jdGlvbiBmYWN0b3J5KHApe3ZhciBsPU1hdGguTE4yO3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBGbG9hdDMyQXJyYXk/ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHMsZSxpLGEpe3ZhciByPTA+ZT8xOjA7aWYociYmKGU9LWUpLDA9PT1lKXMoMDwxL2U/MDoyMTQ3NDgzNjQ4LGksYSk7ZWxzZSBpZihpc05hTihlKSlzKDIxNDMyODkzNDQsaSxhKTtlbHNlIGlmKDM0MDI4MjM0NjYzODUyODg2ZTIyPGUpcygoMjEzOTA5NTA0MHxyPDwzMSk+Pj4wLGksYSk7ZWxzZSBpZigxMTc1NDk0MzUwODIyMjg3NWUtNTQ+ZSlzKChyPDwzMXxfTWF0aHJvdW5kKGUvMTQwMTI5ODQ2NDMyNDgxN2UtNjApKT4+PjAsaSxhKTtlbHNle3ZhciBuPV9NYXRoZmxvb3IoX01hdGhsb2coZSkvbCk7cygocjw8MzF8bisxMjc8PDIzfDgzODg2MDcmX01hdGhyb3VuZCg4Mzg4NjA4KihlKl9NYXRocG93KDIsLW4pKSkpPj4+MCxpLGEpfX1mdW5jdGlvbiB0KGksZSx0KXt2YXIgYT1pKGUsdCkscj0yKihhPj4zMSkrMSxuPTI1NSZhPj4+MjMsbz04Mzg4NjA3JmE7cmV0dXJuIDI1NT09bj9vP05hTjpyKigxLzApOjA9PW4/MTQwMTI5ODQ2NDMyNDgxN2UtNjAqcipvOnIqX01hdGhwb3coMixuLTE1MCkqKG8rODM4ODYwOCl9cC53cml0ZUZsb2F0TEU9ZS5iaW5kKG51bGwsd3JpdGVVaW50TEUpLHAud3JpdGVGbG9hdEJFPWUuYmluZChudWxsLHdyaXRlVWludEJFKSxwLnJlYWRGbG9hdExFPXQuYmluZChudWxsLHJlYWRVaW50TEUpLHAucmVhZEZsb2F0QkU9dC5iaW5kKG51bGwscmVhZFVpbnRCRSl9KCk6ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGEsZSxyKXtpWzBdPWEsZVtyXT10WzBdLGVbcisxXT10WzFdLGVbcisyXT10WzJdLGVbciszXT10WzNdfWZ1bmN0aW9uIG4oYSxlLHIpe2lbMF09YSxlW3JdPXRbM10sZVtyKzFdPXRbMl0sZVtyKzJdPXRbMV0sZVtyKzNdPXRbMF19ZnVuY3Rpb24gbyhhLGUpe3JldHVybiB0WzBdPWFbZV0sdFsxXT1hW2UrMV0sdFsyXT1hW2UrMl0sdFszXT1hW2UrM10saVswXX1mdW5jdGlvbiBzKGEsZSl7cmV0dXJuIHRbM109YVtlXSx0WzJdPWFbZSsxXSx0WzFdPWFbZSsyXSx0WzBdPWFbZSszXSxpWzBdfXZhciBpPW5ldyBGbG9hdDMyQXJyYXkoWy0wXSksdD1uZXcgVWludDhBcnJheShpLmJ1ZmZlciksYT0xMjg9PT10WzNdO3Aud3JpdGVGbG9hdExFPWE/ZTpuLHAud3JpdGVGbG9hdEJFPWE/bjplLHAucmVhZEZsb2F0TEU9YT9vOnMscC5yZWFkRmxvYXRCRT1hP3M6b30oKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgRmxvYXQ2NEFycmF5P2Z1bmN0aW9uKCl7ZnVuY3Rpb24gZShkLGUsdCxhLHUsbil7dmFyIG89MD5hPzE6MDtpZihvJiYoYT0tYSksMD09PWEpZCgwLHUsbitlKSxkKDA8MS9hPzA6MjE0NzQ4MzY0OCx1LG4rdCk7ZWxzZSBpZihpc05hTihhKSlkKDAsdSxuK2UpLGQoMjE0Njk1OTM2MCx1LG4rdCk7ZWxzZSBpZigxNzk3NjkzMTM0ODYyMzE1N2UyOTI8YSlkKDAsdSxuK2UpLGQoKDIxNDY0MzUwNzJ8bzw8MzEpPj4+MCx1LG4rdCk7ZWxzZXt2YXIgcztpZigyMjI1MDczODU4NTA3MjAxNGUtMzI0PmEpZCgocz1hLzVlLTMyNCk+Pj4wLHUsbitlKSxkKChvPDwzMXxzLzQyOTQ5NjcyOTYpPj4+MCx1LG4rdCk7ZWxzZXt2YXIgYz1fTWF0aGZsb29yKF9NYXRobG9nKGEpL2wpOzEwMjQ9PT1jJiYoYz0xMDIzKSxkKDQ1MDM1OTk2MjczNzA0OTYqKHM9YSpfTWF0aHBvdygyLC1jKSk+Pj4wLHUsbitlKSxkKChvPDwzMXxjKzEwMjM8PDIwfDEwNDg1NzUmMTA0ODU3NipzKT4+PjAsdSxuK3QpfX19ZnVuY3Rpb24gdChsLGUsdCxhLHIpe3ZhciBuPWwoYSxyK2UpLG89bChhLHIrdCkscz0yKihvPj4zMSkrMSxpPTIwNDcmbz4+PjIwLHA9NDI5NDk2NzI5NiooMTA0ODU3NSZvKStuO3JldHVybiAyMDQ3PT1pP3A/TmFOOnMqKDEvMCk6MD09aT81ZS0zMjQqcypwOnMqX01hdGhwb3coMixpLTEwNzUpKihwKzQ1MDM1OTk2MjczNzA0OTYpfXAud3JpdGVEb3VibGVMRT1lLmJpbmQobnVsbCx3cml0ZVVpbnRMRSwwLDQpLHAud3JpdGVEb3VibGVCRT1lLmJpbmQobnVsbCx3cml0ZVVpbnRCRSw0LDApLHAucmVhZERvdWJsZUxFPXQuYmluZChudWxsLHJlYWRVaW50TEUsMCw0KSxwLnJlYWREb3VibGVCRT10LmJpbmQobnVsbCxyZWFkVWludEJFLDQsMCl9KCk6ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGEsZSxyKXtpWzBdPWEsZVtyXT10WzBdLGVbcisxXT10WzFdLGVbcisyXT10WzJdLGVbciszXT10WzNdLGVbcis0XT10WzRdLGVbcis1XT10WzVdLGVbcis2XT10WzZdLGVbcis3XT10WzddfWZ1bmN0aW9uIG4oYSxlLHIpe2lbMF09YSxlW3JdPXRbN10sZVtyKzFdPXRbNl0sZVtyKzJdPXRbNV0sZVtyKzNdPXRbNF0sZVtyKzRdPXRbM10sZVtyKzVdPXRbMl0sZVtyKzZdPXRbMV0sZVtyKzddPXRbMF19ZnVuY3Rpb24gbyhhLGUpe3JldHVybiB0WzBdPWFbZV0sdFsxXT1hW2UrMV0sdFsyXT1hW2UrMl0sdFszXT1hW2UrM10sdFs0XT1hW2UrNF0sdFs1XT1hW2UrNV0sdFs2XT1hW2UrNl0sdFs3XT1hW2UrN10saVswXX1mdW5jdGlvbiBzKGEsZSl7cmV0dXJuIHRbN109YVtlXSx0WzZdPWFbZSsxXSx0WzVdPWFbZSsyXSx0WzRdPWFbZSszXSx0WzNdPWFbZSs0XSx0WzJdPWFbZSs1XSx0WzFdPWFbZSs2XSx0WzBdPWFbZSs3XSxpWzBdfXZhciBpPW5ldyBGbG9hdDY0QXJyYXkoWy0wXSksdD1uZXcgVWludDhBcnJheShpLmJ1ZmZlciksYT0xMjg9PT10WzddO3Aud3JpdGVEb3VibGVMRT1hP2U6bixwLndyaXRlRG91YmxlQkU9YT9uOmUscC5yZWFkRG91YmxlTEU9YT9vOnMscC5yZWFkRG91YmxlQkU9YT9zOm99KCkscH1mdW5jdGlvbiB3cml0ZVVpbnRMRShuLGUsdCl7ZVt0XT0yNTUmbixlW3QrMV09MjU1Jm4+Pj44LGVbdCsyXT0yNTUmbj4+PjE2LGVbdCszXT1uPj4+MjR9ZnVuY3Rpb24gd3JpdGVVaW50QkUobixlLHQpe2VbdF09bj4+PjI0LGVbdCsxXT0yNTUmbj4+PjE2LGVbdCsyXT0yNTUmbj4+PjgsZVt0KzNdPTI1NSZufWZ1bmN0aW9uIHJlYWRVaW50TEUoYSxlKXtyZXR1cm4oYVtlXXxhW2UrMV08PDh8YVtlKzJdPDwxNnxhW2UrM108PDI0KT4+PjB9ZnVuY3Rpb24gcmVhZFVpbnRCRShhLGUpe3JldHVybihhW2VdPDwyNHxhW2UrMV08PDE2fGFbZSsyXTw8OHxhW2UrM10pPj4+MH1mdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpe3RyeXt2YXIgbW9kJCQxPWV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpO2lmKG1vZCQkMSYmKG1vZCQkMS5sZW5ndGh8fE9iamVjdC5rZXlzKG1vZCQkMSkubGVuZ3RoKSlyZXR1cm4gbW9kJCQxfWNhdGNoKHQpe31yZXR1cm4gbnVsbH1mdW5jdGlvbiBwb29sJDEobixlLHQpe3ZhciBwPXR8fDgxOTIscj1udWxsLGw9cDtyZXR1cm4gZnVuY3Rpb24odCl7aWYoMT50fHx0PnA+Pj4xKXJldHVybiBuKHQpO2wrdD5wJiYocj1uKHApLGw9MCk7dmFyIGE9ZS5jYWxsKHIsbCxsKz10KTtyZXR1cm4gNyZsJiYobD0xKyg3fGwpKSxhfX1mdW5jdGlvbiBMb25nQml0cyhhLGUpe3RoaXMubG89YT4+PjAsdGhpcy5oaT1lPj4+MH1mdW5jdGlvbiBPcChuLGUsdCl7dGhpcy5mbj1uLHRoaXMubGVuPWUsdGhpcy5uZXh0PXZvaWQgMCx0aGlzLnZhbD10fWZ1bmN0aW9uIG5vb3AoKXt9ZnVuY3Rpb24gU3RhdGUodCl7dGhpcy5oZWFkPXQuaGVhZCx0aGlzLnRhaWw9dC50YWlsLHRoaXMubGVuPXQubGVuLHRoaXMubmV4dD10LnN0YXRlc31mdW5jdGlvbiBXcml0ZXIoKXt0aGlzLmxlbj0wLHRoaXMuaGVhZD1uZXcgT3Aobm9vcCwwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH1mdW5jdGlvbiB3cml0ZUJ5dGUobixlLHQpe2VbdF09MjU1Jm59ZnVuY3Rpb24gd3JpdGVWYXJpbnQzMihuLHIsdCl7Zm9yKDsxMjc8bjspclt0KytdPTEyOHwxMjcmbixuPj4+PTc7clt0XT1ufWZ1bmN0aW9uIFZhcmludE9wKGEsZSl7dGhpcy5sZW49YSx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPWV9ZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NChuLGUsdCl7Zm9yKDtuLmhpOyllW3QrK109MTI4fDEyNyZuLmxvLG4ubG89KG4ubG8+Pj43fG4uaGk8PDI1KT4+PjAsbi5oaT4+Pj03O2Zvcig7MTI3PG4ubG87KWVbdCsrXT0xMjh8MTI3Jm4ubG8sbi5sbz4+Pj03O2VbdCsrXT1uLmxvfWZ1bmN0aW9uIHdyaXRlRml4ZWQzMihuLGUsdCl7ZVt0XT0yNTUmbixlW3QrMV09MjU1Jm4+Pj44LGVbdCsyXT0yNTUmbj4+PjE2LGVbdCszXT1uPj4+MjR9ZnVuY3Rpb24gQnVmZmVyV3JpdGVyJDEoKXt3cml0ZXIuY2FsbCh0aGlzKX1mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcihuLGUsdCl7NDA+bi5sZW5ndGg/bWluaW1hbC51dGY4LndyaXRlKG4sZSx0KTplLnV0ZjhXcml0ZShuLHQpfWZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShhLGUpe3JldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIithLnBvcytcIiArIFwiKyhlfHwxKStcIiA+IFwiK2EubGVuKX1mdW5jdGlvbiBSZWFkZXIodCl7dGhpcy5idWY9dCx0aGlzLnBvcz0wLHRoaXMubGVuPXQubGVuZ3RofWZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCl7dmFyIGE9bmV3IExvbmdCaXRzJDIoMCwwKSxlPTA7aWYoISg0PHRoaXMubGVuLXRoaXMucG9zKSl7Zm9yKDszPmU7KytlKXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO2lmKGEubG89KGEubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCwxMjg+dGhpcy5idWZbdGhpcy5wb3MrK10pcmV0dXJuIGF9cmV0dXJuIGEubG89KGEubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk8PDcqZSk+Pj4wLGF9Zm9yKDs0PmU7KytlKWlmKGEubG89KGEubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCwxMjg+dGhpcy5idWZbdGhpcy5wb3MrK10pcmV0dXJuIGE7aWYoYS5sbz0oYS5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDI4KT4+PjAsYS5oaT0oYS5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk+PjQpPj4+MCwxMjg+dGhpcy5idWZbdGhpcy5wb3MrK10pcmV0dXJuIGE7aWYoZT0wLDQ8dGhpcy5sZW4tdGhpcy5wb3Mpe2Zvcig7NT5lOysrZSlpZihhLmhpPShhLmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8NyplKzMpPj4+MCwxMjg+dGhpcy5idWZbdGhpcy5wb3MrK10pcmV0dXJuIGE7fWVsc2UgZm9yKDs1PmU7KytlKXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO2lmKGEuaGk9KGEuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUrMyk+Pj4wLDEyOD50aGlzLmJ1Zlt0aGlzLnBvcysrXSlyZXR1cm4gYX10aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpfWZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChhLGUpe3JldHVybihhW2UtNF18YVtlLTNdPDw4fGFbZS0yXTw8MTZ8YVtlLTFdPDwyNCk+Pj4wfWZ1bmN0aW9uIHJlYWRGaXhlZDY0KCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyw4KTtyZXR1cm4gbmV3IExvbmdCaXRzJDIocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLHRoaXMucG9zKz00KSxyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsdGhpcy5wb3MrPTQpKX1mdW5jdGlvbiBCdWZmZXJSZWFkZXIkMSh0KXtyZWFkZXIuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIFNlcnZpY2UobixlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7bWluaW1hbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSx0aGlzLnJwY0ltcGw9bix0aGlzLnJlcXVlc3REZWxpbWl0ZWQ9ISFlLHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQ9ISF0fWZ1bmN0aW9uIGdldFBhcmFtVmFsdWUocyxlLHQsYSl7dmFyIHI9ZS5wYXJhbXNbc107aWYociYmdm9pZCAwIT09ci5pbnB1dEluZGV4KXtpZihcInRlbnNvclwiPT09ci50eXBlKXJldHVybiBnZXRUZW5zb3IoZS5pbnB1dE5hbWVzW3IuaW5wdXRJbmRleF0sdCxhKTtpZihcInRlbnNvcnNcIj09PXIudHlwZSlyZXR1cm4oMD09PXIuaW5wdXRJbmRleD8wPT09ci5pbnB1dFBhcmFtTGVuZ3RoP2UuaW5wdXROYW1lczplLmlucHV0TmFtZXMuc2xpY2Uoci5pbnB1dEluZGV4LC1yLmlucHV0UGFyYW1MZW5ndGgpOmUuaW5wdXROYW1lcy5zcGxpY2Uoci5pbnB1dEluZGV4KSkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBnZXRUZW5zb3Iobix0LGEpfSk7dmFyIG49QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0VGVuc29yKGUuaW5wdXROYW1lcy5zbGljZShyLmlucHV0SW5kZXgpWzBdLHQsYSkuZGF0YVN5bmMoKSk7cmV0dXJuXCJudW1iZXJcIj09PXIudHlwZT9uWzBdOm59cmV0dXJuIHImJnIudmFsdWV9ZnVuY3Rpb24gZ2V0VGVuc29yKGkscCxlKXt2YXIgdD1wYXJzZU5vZGVOYW1lKGkpLGE9dFswXSxuPXRbMV0scj1lLmN1cnJlbnRDb250ZXh0SWRzLmZpbmQoZnVuY3Rpb24odCl7cmV0dXJuISFwW2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChhLHQpXX0pO3JldHVybiB2b2lkIDA9PT1yP3ZvaWQgMDpwW2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChhLHIpXVtuXX1mdW5jdGlvbiBnZXRUZW5zb3JzRm9yQ3VycmVudENvbnRlbnh0KG4sZSx0KXtyZXR1cm4gZVtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobix0LmN1cnJlbnRDb250ZXh0SWQpXX1mdW5jdGlvbiBnZXROb2RlTmFtZUFuZEluZGV4KG8sZSl7dmFyIHQ9cGFyc2VOb2RlTmFtZShvKSxhPXRbMF0scj10WzFdO3JldHVybltnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQoYSxlJiZlLmN1cnJlbnRDb250ZXh0SWQpLHJdfWZ1bmN0aW9uIGdldE5vZGVOYW1lV2l0aENvbnRleHRJZChhLGUpe3JldHVybiBlP2ErXCItXCIrZTphfWZ1bmN0aW9uIHBhcnNlTm9kZU5hbWUoYSl7dmFyIGU9YS5sYXN0SW5kZXhPZihcIjpcIik7cmV0dXJuLTE9PT1lP1thLDBdOlthLnN1YnN0cmluZygwLGUpLCthLnN1YnN0cmluZyhlKzEpXX1mdW5jdGlvbiBzcGxpdCQxJDEobixlKXtmb3IodmFyIHQ9W10sYT0wO2E8bi5sZW5ndGg7YSs9ZSl0LnB1c2gobi5zbGljZShhLGErZSkpO3JldHVybiB0fWZ1bmN0aW9uIGV4ZWN1dGVPcCQyKHosTSx0KXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsYSxGLEIsVSxXLEcscSxILEssWCxZLFosUSxKLGVlLHRlLGFlLG5lLHJlLG9lLHNlLGllLHBlLGxlLGRlLHVlLGNlLG1lLGhlLGdlLGZlLHllLGJlLHhlO3JldHVybiBfX2dlbmVyYXRvciQyKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpzd2l0Y2goei5vcCl7Y2FzZVwibG9vcENvbmRcIjpyZXR1cm5bMywxXTtjYXNlXCJzd2l0Y2hcIjpyZXR1cm5bMywyXTtjYXNlXCJtZXJnZVwiOnJldHVyblszLDRdO2Nhc2VcImVudGVyXCI6cmV0dXJuWzMsNV07Y2FzZVwiZXhpdFwiOnJldHVyblszLDZdO2Nhc2VcIm5leHRJdGVyYXRpb25cIjpyZXR1cm5bMyw3XTtjYXNlXCJ0ZW5zb3JBcnJheVwiOnJldHVyblszLDhdO2Nhc2VcInRlbnNvckFycmF5V3JpdGVcIjpyZXR1cm5bMyw5XTtjYXNlXCJ0ZW5zb3JBcnJheVJlYWRcIjpyZXR1cm5bMywxMF07Y2FzZVwidGVuc29yQXJyYXlHYXRoZXJcIjpyZXR1cm5bMywxMV07Y2FzZVwidGVuc29yQXJyYXlTY2F0dGVyXCI6cmV0dXJuWzMsMTJdO2Nhc2VcInRlbnNvckFycmF5Q29uY2F0XCI6cmV0dXJuWzMsMTNdO2Nhc2VcInRlbnNvckFycmF5U3BsaXRcIjpyZXR1cm5bMywxNF07Y2FzZVwidGVuc29yQXJyYXlTaXplXCI6cmV0dXJuWzMsMTVdO2Nhc2VcInRlbnNvckFycmF5Q2xvc2VcIjpyZXR1cm5bMywxNl07fXJldHVyblszLDE3XTtjYXNlIDE6cmV0dXJuWzIsW2dldFBhcmFtVmFsdWUoXCJwcmVkXCIseixNLHQpLmNsb25lKCldXTtjYXNlIDI6cmV0dXJuIGU9Z2V0UGFyYW1WYWx1ZShcInByZWRcIix6LE0sdCksYT1nZXRQYXJhbVZhbHVlKFwiZGF0YVwiLHosTSx0KSxbNCxlLmRhdGEoKV07Y2FzZSAzOnJldHVyblsyLG4uc2VudCgpWzBdP1t2b2lkIDAsYS5jbG9uZSgpXTpbYS5jbG9uZSgpLHZvaWQgMF1dO2Nhc2UgNDpyZXR1cm5bMiwoRj16LmlucHV0TmFtZXMuZmluZChmdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwIT09Z2V0VGVuc29yKGEsTSx0KX0pKT9bZ2V0VGVuc29yKEYsTSx0KS5jbG9uZSgpXTp2b2lkIDBdO2Nhc2UgNTpyZXR1cm4gQj1nZXRQYXJhbVZhbHVlKFwiZnJhbWVOYW1lXCIseixNLHQpLFU9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLHosTSx0KSx0LmVudGVyRnJhbWUoQiksWzIsW1UuY2xvbmUoKV1dO2Nhc2UgNjpyZXR1cm4gVz1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIseixNLHQpLHQuZXhpdEZyYW1lKCksWzIsW1cuY2xvbmUoKV1dO2Nhc2UgNzpyZXR1cm4gRz1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIseixNLHQpLHQubmV4dEl0ZXJhdGlvbigpLFsyLFtHLmNsb25lKCldXTtjYXNlIDg6cmV0dXJuIHE9Z2V0UGFyYW1WYWx1ZShcInNpemVcIix6LE0sdCksSD1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIix6LE0sdCksSz1nZXRQYXJhbVZhbHVlKFwiZWxlbWVudFNoYXBlXCIseixNLHQpLFg9Z2V0UGFyYW1WYWx1ZShcImR5bmFtaWNTaXplXCIseixNLHQpLFk9Z2V0UGFyYW1WYWx1ZShcImNsZWFyQWZ0ZXJSZWFkXCIseixNLHQpLFo9Z2V0UGFyYW1WYWx1ZShcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIix6LE0sdCksUT1nZXRQYXJhbVZhbHVlKFwibmFtZVwiLHosTSx0KSxKPW5ldyBUZW5zb3JBcnJheShRLEgscSxLLFosWCxZKSx0LmFkZFRlbnNvckFycmF5KEopLFsyLFtzY2FsYXIoSi5pZCksc2NhbGFyKDEpXV07Y2FzZSA5OnJldHVybiBlZT1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLHosTSx0KSx0ZT1nZXRQYXJhbVZhbHVlKFwiaW5kZXhcIix6LE0sdCksYWU9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLHosTSx0KSx0LmdldFRlbnNvckFycmF5KGVlKS53cml0ZSh0ZSxhZSksWzIsW3NjYWxhcigxKV1dO2Nhc2UgMTA6cmV0dXJuIG5lPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIseixNLHQpLHJlPWdldFBhcmFtVmFsdWUoXCJpbmRleFwiLHosTSx0KSxbMixbdC5nZXRUZW5zb3JBcnJheShuZSkucmVhZChyZSldXTtjYXNlIDExOnJldHVybiBvZT1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLHosTSx0KSxzZT1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLHosTSx0KSxpZT1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIix6LE0sdCksWzIsW3QuZ2V0VGVuc29yQXJyYXkob2UpLmdhdGhlcihzZSxpZSldXTtjYXNlIDEyOnJldHVybiBwZT1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLHosTSx0KSxsZT1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLHosTSx0KSxkZT1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIseixNLHQpLHQuZ2V0VGVuc29yQXJyYXkocGUpLnNjYXR0ZXIobGUsZGUpLFsyLFtzY2FsYXIoMSldXTtjYXNlIDEzOnJldHVybiB1ZT1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLHosTSx0KSxjZT10LmdldFRlbnNvckFycmF5KHVlKSxtZT1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIix6LE0sdCksWzIsW2NlLmNvbmNhdChtZSldXTtjYXNlIDE0OnJldHVybiBoZT1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLHosTSx0KSxnZT1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIseixNLHQpLGZlPWdldFBhcmFtVmFsdWUoXCJsZW5ndGhzXCIseixNLHQpLHQuZ2V0VGVuc29yQXJyYXkoaGUpLnNwbGl0KGZlLGdlKSxbMixbc2NhbGFyKDEpXV07Y2FzZSAxNTpyZXR1cm4geWU9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIix6LE0sdCksYmU9dC5nZXRUZW5zb3JBcnJheSh5ZSksWzIsW3NjYWxhcihiZS5zaXplKCksXCJpbnQzMlwiKV1dO2Nhc2UgMTY6cmV0dXJuIHhlPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIseixNLHQpLHQuZ2V0VGVuc29yQXJyYXkoeGUpLmNsZWFyQW5kQ2xvc2UoKSxbMixbXV07Y2FzZSAxNzp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrei5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7fX0pfSl9ZnVuY3Rpb24gZXhlY3V0ZU9wJDUobCxlLHQpe3JldHVybiBfX2F3YWl0ZXIkMih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYSxkLHUsYyxtO3JldHVybiBfX2dlbmVyYXRvciQyKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpzd2l0Y2gobC5vcCl7Y2FzZVwibm9uTWF4U3VwcHJlc3Npb25cIjpyZXR1cm5bMywxXTtjYXNlXCJ3aGVyZUFzeW5jXCI6cmV0dXJuWzMsM107Y2FzZVwic2V0ZGlmZjFkQXN5bmNcIjpyZXR1cm5bMyw1XTt9cmV0dXJuWzMsN107Y2FzZSAxOnJldHVybiBhPWdldFBhcmFtVmFsdWUoXCJib3hlc1wiLGwsZSx0KSxkPWdldFBhcmFtVmFsdWUoXCJzY29yZXNcIixsLGUsdCksdT1nZXRQYXJhbVZhbHVlKFwibWF4T3V0cHV0U2l6ZVwiLGwsZSx0KSxjPWdldFBhcmFtVmFsdWUoXCJpb3VUaHJlc2hvbGRcIixsLGUsdCksbT1nZXRQYXJhbVZhbHVlKFwic2NvcmVUaHJlc2hvbGRcIixsLGUsdCksWzQsaW1hZ2Vfb3BzLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoYSxkLHUsYyxtKV07Y2FzZSAyOnJldHVyblsyLFtuLnNlbnQoKV1dO2Nhc2UgMzpyZXR1cm5bNCx3aGVyZUFzeW5jKGdldFBhcmFtVmFsdWUoXCJjb25kaXRpb25cIixsLGUsdCkpXTtjYXNlIDQ6cmV0dXJuWzIsW24uc2VudCgpXV07Y2FzZSA1OnJldHVybls0LHNldGRpZmYxZEFzeW5jKGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLGdldFBhcmFtVmFsdWUoXCJ5XCIsbCxlLHQpKV07Y2FzZSA2OnJldHVyblsyLG4uc2VudCgpXTtjYXNlIDc6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2wub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO319KX0pfWZ1bmN0aW9uIGV4ZWN1dGVPcCQxNShuLGUsdCl7c3dpdGNoKG4uY2F0ZWdvcnkpe2Nhc2VcImFyaXRobWV0aWNcIjpyZXR1cm4gZXhlY3V0ZU9wKG4sZSx0KTtjYXNlXCJiYXNpY19tYXRoXCI6cmV0dXJuIGV4ZWN1dGVPcCQxKG4sZSx0KTtjYXNlXCJjb250cm9sXCI6cmV0dXJuIGV4ZWN1dGVPcCQyKG4sZSx0KTtjYXNlXCJjb252b2x1dGlvblwiOnJldHVybiBleGVjdXRlT3AkMyhuLGUsdCk7Y2FzZVwiY3JlYXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDQobixlLHQpO2Nhc2VcImR5bmFtaWNcIjpyZXR1cm4gZXhlY3V0ZU9wJDUobixlLHQpO2Nhc2VcImV2YWx1YXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDYobixlLHQpO2Nhc2VcImltYWdlXCI6cmV0dXJuIGV4ZWN1dGVPcCQ4KG4sZSx0KTtjYXNlXCJncmFwaFwiOnJldHVybiBleGVjdXRlT3AkNyhuLGUsdCk7Y2FzZVwibG9naWNhbFwiOnJldHVybiBleGVjdXRlT3AkOShuLGUsdCk7Y2FzZVwibWF0cmljZXNcIjpyZXR1cm4gZXhlY3V0ZU9wJDEwKG4sZSx0KTtjYXNlXCJub3JtYWxpemF0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQxMShuLGUsdCk7Y2FzZVwicmVkdWN0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQxMihuLGUsdCk7Y2FzZVwic2xpY2Vfam9pblwiOnJldHVybiBleGVjdXRlT3AkMTMobixlLHQpO2Nhc2VcInRyYW5zZm9ybWF0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQxNChuLGUsdCk7ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrbi5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7fX1mdW5jdGlvbiBsb2FkRnJvemVuTW9kZWwobyxlLHQpe3JldHVybiBfX2F3YWl0ZXIkMih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gX19nZW5lcmF0b3IkMih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsKGE9bmV3IEZyb3plbk1vZGVsKG8sZSx0KSkubG9hZCgpXTtjYXNlIDE6cmV0dXJuIHIuc2VudCgpLFsyLGFdO319KX0pfS8vIEB0ZW5zb3JmbG93L3RmanMgQ29weXJpZ2h0IDIwMTggR29vZ2xlXG4vKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IDIwMTkgVmljdG9yIERpYmlhLlxuICAgKiBIYW5kdHJhY2suanMgLSBBIGxpYnJhcnkgZm9yIHByb3RvdHlwaW5nIHJlYWx0aW1lIGhhbmQgdHJhY2tpbmcgdXNpbmcgbmV1cmFsIG5ldHdvcmtzLlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKHRoZSBcIkxpY2Vuc2VcIik7IFxuICAgKiBDb2RlIHNuaXBwZXRzIGZyb20gdGhlIHRlbnNvcmZsb3cgY29jby1zc2QgZXhhbXBsZSBhcmUgcmV1c2VkIGhlcmUgLSBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLW1vZGVscy90cmVlL21hc3Rlci9jb2NvLXNzZFxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgKi9hc3luYyBmdW5jdGlvbiBsb2FkKGUpe2xldCB0PU9iamVjdC5hc3NpZ24oe30sZGVmYXVsdFBhcmFtcyxlKTsvLyBjb25zb2xlLmxvZyhtb2RlbFBhcmFtcykgXG5jb25zdCBhPW5ldyBPYmplY3REZXRlY3Rpb24odCk7cmV0dXJuIGF3YWl0IGEubG9hZCgpLGF9ZnVuY3Rpb24gc3RhcnRWaWRlbyhlKXtyZXR1cm4gZS53aWR0aD1lLndpZHRofHw2NDAsZS5oZWlnaHQ9ZS5oZWlnaHR8fGUud2lkdGgqKDMvNCksbmV3IFByb21pc2UoZnVuY3Rpb24odCl7bmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe2F1ZGlvOiExLHZpZGVvOntmYWNpbmdNb2RlOlwidXNlclwifX0pLnRoZW4oYT0+e3dpbmRvdy5sb2NhbFN0cmVhbT1hLGUuc3JjT2JqZWN0PWEsZS5vbmxvYWRlZG1ldGFkYXRhPSgpPT57ZS5wbGF5KCksdCghMCl9fSkuY2F0Y2goZnVuY3Rpb24oKXt0KCExKX0pfSl9YXN5bmMgZnVuY3Rpb24gc3RvcFZpZGVvKCl7cmV0dXJuISF3aW5kb3cubG9jYWxTdHJlYW0mJnZvaWQgd2luZG93LmxvY2FsU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZT0+KGUuc3RvcCgpLCEwKSl9ZnVuY3Rpb24gZ2V0VmFsaWRSZXNvbHV0aW9uKGUsdCxhKXtjb25zdCBuPXQqZS0xO3JldHVybiBuLW4lYSsxfWZ1bmN0aW9uIGdldElucHV0VGVuc29yRGltZW5zaW9ucyhlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFRlbnNvcj9bZS5zaGFwZVswXSxlLnNoYXBlWzFdXTpbZS5oZWlnaHQsZS53aWR0aF19ZnVuY3Rpb24gY2FsY3VsYXRlTWF4U2NvcmVzKGUsdCxhKXtjb25zdCBuPVtdLHI9W107Zm9yKGxldCBvPTA7bzx0O28rKyl7bGV0IHQ9TnVtYmVyLk1JTl9WQUxVRSxzPS0xO2ZvcihsZXQgbj0wO248YTtuKyspZVtvKmErbl0+dCYmKHQ9ZVtvKmErbl0scz1uKTtuW29dPXQscltvXT1zfS8vIGNvbnNvbGUubG9nKFttYXhlcywgY2xhc3Nlc10pXG5yZXR1cm5bbixyXX12YXIgZXh0ZW5kU3RhdGljcz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oYSxlKXthLl9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24oYSxlKXtmb3IodmFyIHQgaW4gZSllLmhhc093blByb3BlcnR5KHQpJiYoYVt0XT1lW3RdKX0sX19hc3NpZ249T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oYSl7Zm9yKHZhciBlPTEscz1hcmd1bWVudHMubGVuZ3RoLG47ZTxzO2UrKylmb3IodmFyIGkgaW4gbj1hcmd1bWVudHNbZV0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4saSkmJihhW2ldPW5baV0pO3JldHVybiBhfSxjb250ZXh0cz17fSxXRUJHTF9BVFRSSUJVVEVTPXthbHBoYTohMSxhbnRpYWxpYXM6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMSxkZXB0aDohMSxzdGVuY2lsOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITB9LHV0aWw9T2JqZWN0LmZyZWV6ZSh7c2h1ZmZsZTpzaHVmZmxlLGNsYW1wOmNsYW1wLG5lYXJlc3RMYXJnZXJFdmVuOm5lYXJlc3RMYXJnZXJFdmVuLHN1bTpzdW0scmFuZFVuaWZvcm06cmFuZFVuaWZvcm0sZGlzdFNxdWFyZWQ6ZGlzdFNxdWFyZWQsYXNzZXJ0OmFzc2VydCxhc3NlcnRTaGFwZXNNYXRjaDphc3NlcnRTaGFwZXNNYXRjaCxhc3NlcnROb25OdWxsOmFzc2VydE5vbk51bGwsZmxhdHRlbjpmbGF0dGVuLHNpemVGcm9tU2hhcGU6c2l6ZUZyb21TaGFwZSxpc1NjYWxhclNoYXBlOmlzU2NhbGFyU2hhcGUsYXJyYXlzRXF1YWw6YXJyYXlzRXF1YWwsaXNJbnQ6aXNJbnQsdGFuaDp0YW5oLHNpemVUb1NxdWFyaXNoU2hhcGU6c2l6ZVRvU3F1YXJpc2hTaGFwZSxjcmVhdGVTaHVmZmxlZEluZGljZXM6Y3JlYXRlU2h1ZmZsZWRJbmRpY2VzLHJpZ2h0UGFkOnJpZ2h0UGFkLHJlcGVhdGVkVHJ5OnJlcGVhdGVkVHJ5LGluZmVyRnJvbUltcGxpY2l0U2hhcGU6aW5mZXJGcm9tSW1wbGljaXRTaGFwZSxzcXVlZXplU2hhcGU6c3F1ZWV6ZVNoYXBlLGdldFR5cGVkQXJyYXlGcm9tRFR5cGU6Z2V0VHlwZWRBcnJheUZyb21EVHlwZSxjaGVja0NvbXB1dGF0aW9uRm9yTmFOOmNoZWNrQ29tcHV0YXRpb25Gb3JOYU4sY2hlY2tDb252ZXJzaW9uRm9yTmFOOmNoZWNrQ29udmVyc2lvbkZvck5hTixoYXNFbmNvZGluZ0xvc3M6aGFzRW5jb2RpbmdMb3NzLGlzVHlwZWRBcnJheTppc1R5cGVkQXJyYXksYnl0ZXNQZXJFbGVtZW50OmJ5dGVzUGVyRWxlbWVudCxpc0Z1bmN0aW9uOmlzRnVuY3Rpb24sbmVhcmVzdERpdmlzb3I6bmVhcmVzdERpdmlzb3IsY29tcHV0ZVN0cmlkZXM6Y29tcHV0ZVN0cmlkZXMsdG9UeXBlZEFycmF5OnRvVHlwZWRBcnJheSxtYWtlT25lc1R5cGVkQXJyYXk6bWFrZU9uZXNUeXBlZEFycmF5LG1ha2VaZXJvc1R5cGVkQXJyYXk6bWFrZVplcm9zVHlwZWRBcnJheSxub3c6bm93fSksUHJvZmlsZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEsZSl7dGhpcy5iYWNrZW5kVGltZXI9YSx0aGlzLmxvZ2dlcj1lLG51bGw9PWUmJih0aGlzLmxvZ2dlcj1uZXcgTG9nZ2VyKX1yZXR1cm4gdC5wcm90b3R5cGUucHJvZmlsZUtlcm5lbD1mdW5jdGlvbihzLGUpe3ZhciBpPXRoaXMsYT10aGlzLmJhY2tlbmRUaW1lci50aW1lKGZ1bmN0aW9uKCl7dD1lKCl9KSx0O3JldHVybihBcnJheS5pc0FycmF5KHQpP3Q6W3RdKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUuZGF0YVN5bmMoKTtjaGVja0NvbXB1dGF0aW9uRm9yTmFOKHQsZS5kdHlwZSxzKSxhLnRoZW4oZnVuY3Rpb24obil7dmFyIHI9XCJcIjtudWxsIT1uLmdldEV4dHJhUHJvZmlsZUluZm8mJihyPW4uZ2V0RXh0cmFQcm9maWxlSW5mbygpKSxpLmxvZ2dlci5sb2dLZXJuZWxQcm9maWxlKHMsZSx0LG4ua2VybmVsTXMscil9KX0pLHR9LHR9KCksTG9nZ2VyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUubG9nS2VybmVsUHJvZmlsZT1mdW5jdGlvbihwLGUsdCxyLG4pe3ZhciBvPXJpZ2h0UGFkKHIrXCJtc1wiLDkpLGE9cmlnaHRQYWQocCwyNSksaT1lLnJhbmsscz1lLnNpemUsZD1yaWdodFBhZChlLnNoYXBlLnRvU3RyaW5nKCksMTQpO2NvbnNvbGUubG9nKFwiJWNcIithK1wiXFx0JWNcIitvK1wiXFx0JWNcIitpK1wiRCBcIitkK1wiXFx0JWNcIitzK1wiXFx0JWNcIituLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6cmVkXCIsXCJjb2xvcjpibHVlXCIsXCJjb2xvcjogb3JhbmdlXCIsXCJjb2xvcjogZ3JlZW5cIil9LHR9KCksRk9STUFUX0xJTUlUX05VTV9WQUxTPTIwLEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTPTMsRk9STUFUX05VTV9TSUdfRElHSVRTPTcsVGVuc29yQnVmZmVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChhLGUsdCl7aWYodGhpcy5kdHlwZT1lLHRoaXMuc2hhcGU9YS5zbGljZSgpLHRoaXMuc2l6ZT1zaXplRnJvbVNoYXBlKGEpLG51bGwhPXQpe3ZhciByPXQubGVuZ3RoO2Fzc2VydChyPT09dGhpcy5zaXplLFwiTGVuZ3RoIG9mIHZhbHVlcyAnXCIrcitcIicgZG9lcyBub3QgbWF0Y2ggdGhlIHNpemUgaW5mZXJyZWQgYnkgdGhlIHNoYXBlICdcIit0aGlzLnNpemUrXCInLlwiKX1pZihcImNvbXBsZXg2NFwiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJjb21wbGV4NjQgZHR5cGUgVGVuc29yQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGNyZWF0ZSBhIFRlbnNvckJ1ZmZlciBmb3IgdGhlIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cyBzZXBhcmF0ZWx5IGFuZCBjYWxsIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMudmFsdWVzPXR8fGdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZSxzaXplRnJvbVNoYXBlKHRoaXMuc2hhcGUpKSx0aGlzLnN0cmlkZXM9Y29tcHV0ZVN0cmlkZXMoYSl9cmV0dXJuIHQucHJvdG90eXBlLnNldD1mdW5jdGlvbihhKXtmb3IodmFyIGU9W10sbz0xO288YXJndW1lbnRzLmxlbmd0aDtvKyspZVtvLTFdPWFyZ3VtZW50c1tvXTswPT09ZS5sZW5ndGgmJihlPVswXSksYXNzZXJ0KGUubGVuZ3RoPT09dGhpcy5yYW5rLFwiVGhlIG51bWJlciBvZiBwcm92aWRlZCBjb29yZGluYXRlcyAoXCIrZS5sZW5ndGgrXCIpIG11c3QgbWF0Y2ggdGhlIHJhbmsgKFwiK3RoaXMucmFuaytcIilcIik7dmFyIHM9dGhpcy5sb2NUb0luZGV4KGUpO3RoaXMudmFsdWVzW3NdPWF9LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxvPTA7bzxhcmd1bWVudHMubGVuZ3RoO28rKylhW29dPWFyZ3VtZW50c1tvXTswPT09YS5sZW5ndGgmJihhPVswXSk7Zm9yKHZhciBzPWFbYS5sZW5ndGgtMV0saT0wO2k8YS5sZW5ndGgtMTsrK2kpcys9dGhpcy5zdHJpZGVzW2ldKmFbaV07cmV0dXJuIHRoaXMudmFsdWVzW3NdfSx0LnByb3RvdHlwZS5sb2NUb0luZGV4PWZ1bmN0aW9uKGEpe2lmKDA9PT10aGlzLnJhbmspcmV0dXJuIDA7aWYoMT09PXRoaXMucmFuaylyZXR1cm4gYVswXTtmb3IodmFyIGU9YVthLmxlbmd0aC0xXSxuPTA7bjxhLmxlbmd0aC0xOysrbillKz10aGlzLnN0cmlkZXNbbl0qYVtuXTtyZXR1cm4gZX0sdC5wcm90b3R5cGUuaW5kZXhUb0xvYz1mdW5jdGlvbihhKXtpZigwPT09dGhpcy5yYW5rKXJldHVybltdO2lmKDE9PT10aGlzLnJhbmspcmV0dXJuW2FdO2Zvcih2YXIgbj1BcnJheSh0aGlzLnNoYXBlLmxlbmd0aCksdD0wO3Q8bi5sZW5ndGgtMTsrK3Qpblt0XT1fTWF0aGZsb29yKGEvdGhpcy5zdHJpZGVzW3RdKSxhLT1uW3RdKnRoaXMuc3RyaWRlc1t0XTtyZXR1cm4gbltuLmxlbmd0aC0xXT1hLG59LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJhbmtcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnRvVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuIFRlbnNvci5tYWtlKHRoaXMuc2hhcGUse3ZhbHVlczp0aGlzLnZhbHVlc30sdGhpcy5kdHlwZSl9LHR9KCksdHJhY2tlckZuPW51bGwsb3BIYW5kbGVyPW51bGwsVGVuc29yPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGUsdCxyKXt0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMSx0aGlzLnNoYXBlPWEuc2xpY2UoKSx0aGlzLmR0eXBlPWV8fFwiZmxvYXQzMlwiLHRoaXMuc2l6ZT1zaXplRnJvbVNoYXBlKGEpLG51bGwhPXQmJmFzc2VydCh0aGlzLnNpemU9PT10Lmxlbmd0aCxcIkJhc2VkIG9uIHRoZSBwcm92aWRlZCBzaGFwZSwgW1wiK2ErXCJdLCBhbmQgZHR5cGUgXCIrdGhpcy5kdHlwZStcIiwgdGhlIHRlbnNvciBzaG91bGQgaGF2ZSBcIit0aGlzLnNpemUrXCIgdmFsdWVzIGJ1dCBoYXMgXCIrdC5sZW5ndGgpLHRoaXMuc3RyaWRlcz1jb21wdXRlU3RyaWRlcyhhKSx0aGlzLmRhdGFJZD1udWxsPT1yP3t9OnIsdGhpcy5pZD10cmFja2VyRm4oKS5uZXh0VGVuc29ySWQoKSx0aGlzLnJhbmtUeXBlPTU+dGhpcy5yYW5rP3RoaXMucmFuay50b1N0cmluZygpOlwiaGlnaGVyXCIsdHJhY2tlckZuKCkucmVnaXN0ZXJUZW5zb3IodGhpcyksbnVsbCE9dCYmdHJhY2tlckZuKCkud3JpdGUodGhpcy5kYXRhSWQsdCl9cmV0dXJuIGEubWFrZT1mdW5jdGlvbihlLHQscil7cmV0dXJuIG5ldyBhKGUscix0LnZhbHVlcyx0LmRhdGFJZCl9LGEucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmFzMUQoKX0sYS5wcm90b3R5cGUuYXNTY2FsYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxhc3NlcnQoMT09PXRoaXMuc2l6ZSxcIlRoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuXCIpLHRoaXMucmVzaGFwZShbXSl9LGEucHJvdG90eXBlLmFzMUQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pfSxhLnByb3RvdHlwZS5hczJEPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFthLGVdKX0sYS5wcm90b3R5cGUuYXMzRD1mdW5jdGlvbihhLGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFthLGUsdF0pfSxhLnByb3RvdHlwZS5hczREPWZ1bmN0aW9uKGEsZSx0LHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbYSxlLHQscl0pfSxhLnByb3RvdHlwZS5hc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmNhc3QodGhpcyx0KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLG89MDtvPGFyZ3VtZW50cy5sZW5ndGg7bysrKWFbb109YXJndW1lbnRzW29dO2Fzc2VydChhLmxlbmd0aD09PXRoaXMucmFuayxcIk51bWJlciBvZiBjb29yZGluYXRlcyBpbiBnZXQoKSBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3JcIiksYXNzZXJ0KFwiY29tcGxleDY0XCIhPT10aGlzLmR0eXBlLFwiVGVuc29yLmdldCgpIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGNvbXBsZXg2NCB0ZW5zb3JzIHlldC5cIiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSwwPT09YS5sZW5ndGgmJihhPVswXSk7Zm9yKHZhciBzPWFbYS5sZW5ndGgtMV0saT0wO2k8YS5sZW5ndGgtMTsrK2kpcys9dGhpcy5zdHJpZGVzW2ldKmFbaV07cmV0dXJuIHRoaXMuZGF0YVN5bmMoKVtzXX0sYS5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIG9wSGFuZGxlci5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHRoaXMuZGF0YVN5bmMoKSl9LGEucHJvdG90eXBlLmRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksWzIsdHJhY2tlckZuKCkucmVhZCh0aGlzLmRhdGFJZCldfSl9KX0sYS5wcm90b3R5cGUuZGF0YVN5bmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0cmFja2VyRm4oKS5yZWFkU3luYyh0aGlzLmRhdGFJZCl9LGEucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmlzRGlzcG9zZWR8fCh0cmFja2VyRm4oKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSEwKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwiaXNEaXNwb3NlZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYS5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0Rpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBpcyBkaXNwb3NlZC5cIil9LGEucHJvdG90eXBlLnRvRmxvYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJmbG9hdDMyXCIpfSxhLnByb3RvdHlwZS50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzVHlwZShcImludDMyXCIpfSxhLnByb3RvdHlwZS50b0Jvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJib29sXCIpfSxhLnByb3RvdHlwZS5wcmludD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLG9wSGFuZGxlci5wcmludCh0aGlzLHQpfSxhLnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5yZXNoYXBlKHRoaXMsdCl9LGEucHJvdG90eXBlLnJlc2hhcGVBcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUodC5zaGFwZSl9LGEucHJvdG90eXBlLmV4cGFuZERpbXM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLG9wSGFuZGxlci5leHBhbmREaW1zKHRoaXMsdCl9LGEucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbihhLG4sbyl7cmV0dXJuIHZvaWQgMD09PWEmJihhPTApLHZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1vJiYobz0hMSksb3BIYW5kbGVyLmN1bXN1bSh0aGlzLGEsbixvKX0sYS5wcm90b3R5cGUuc3F1ZWV6ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3F1ZWV6ZSh0aGlzLHQpfSxhLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5jbG9uZSh0aGlzKX0sYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0ZW5zb3JUb1N0cmluZyh0aGlzLmRhdGFTeW5jKCksdGhpcy5zaGFwZSx0aGlzLmR0eXBlLHQpfSxhLnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci50aWxlKHRoaXMsdCl9LGEucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbihhLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5nYXRoZXIodGhpcyxhLGUpfSxhLnByb3RvdHlwZS5tYXRNdWw9ZnVuY3Rpb24oYSxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1hdE11bCh0aGlzLGEsZSxuKX0sYS5wcm90b3R5cGUuZG90PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5kb3QodGhpcyx0KX0sYS5wcm90b3R5cGUubm9ybT1mdW5jdGlvbihhLG4sbyl7cmV0dXJuIHZvaWQgMD09PWEmJihhPVwiZXVjbGlkZWFuXCIpLHZvaWQgMD09PW4mJihuPW51bGwpLHZvaWQgMD09PW8mJihvPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5ub3JtKHRoaXMsYSxuLG8pfSxhLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zbGljZSh0aGlzLGEsZSl9LGEucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnJldmVyc2UodGhpcyx0KX0sYS5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmNvbmNhdChbdGhpcyxhXSxlKX0sYS5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3BsaXQodGhpcyxhLGUpfSxhLnByb3RvdHlwZS5zdGFjaz1mdW5jdGlvbihhLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSxvcEhhbmRsZXIuc3RhY2soW3RoaXMsYV0sZSl9LGEucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksb3BIYW5kbGVyLnVuc3RhY2sodGhpcyxlKX0sYS5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLG9wSGFuZGxlci5wYWQodGhpcyxhLGUpfSxhLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24oYSxlLHQscyxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjAwMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYmF0Y2hOb3JtYWxpemF0aW9uKHRoaXMsYSxlLHQscyxuKX0sYS5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKGEsbil7cmV0dXJuIHZvaWQgMD09PWEmJihhPW51bGwpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hbGwodGhpcyxhLG4pfSxhLnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24oYSxuKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9bnVsbCksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFueSh0aGlzLGEsbil9LGEucHJvdG90eXBlLmxvZ1N1bUV4cD1mdW5jdGlvbihhLG4pe3JldHVybiB2b2lkIDA9PT1hJiYoYT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubG9nU3VtRXhwKHRoaXMsYSxuKX0sYS5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKGEsbil7cmV0dXJuIHZvaWQgMD09PWEmJihhPW51bGwpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zdW0odGhpcyxhLG4pfSxhLnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKGEsbil7cmV0dXJuIHZvaWQgMD09PWEmJihhPW51bGwpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5wcm9kKHRoaXMsYSxuKX0sYS5wcm90b3R5cGUubWVhbj1mdW5jdGlvbihhLG4pe3JldHVybiB2b2lkIDA9PT1hJiYoYT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubWVhbih0aGlzLGEsbil9LGEucHJvdG90eXBlLm1pbj1mdW5jdGlvbihhLG4pe3JldHVybiB2b2lkIDA9PT1hJiYoYT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubWluKHRoaXMsYSxuKX0sYS5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKGEsbil7cmV0dXJuIHZvaWQgMD09PWEmJihhPW51bGwpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5tYXgodGhpcyxhLG4pfSxhLnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFyZ01pbih0aGlzLHQpfSxhLnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFyZ01heCh0aGlzLHQpfSxhLnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5jYXN0KHRoaXMsdCl9LGEucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYWRkKHRoaXMsdCl9LGEucHJvdG90eXBlLmFkZFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYWRkU3RyaWN0KHRoaXMsdCl9LGEucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hdGFuMih0aGlzLHQpfSxhLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnN1Yih0aGlzLHQpfSxhLnByb3RvdHlwZS5zdWJTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnN1YlN0cmljdCh0aGlzLHQpfSxhLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnBvdyh0aGlzLHQpfSxhLnByb3RvdHlwZS5wb3dTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnBvd1N0cmljdCh0aGlzLHQpfSxhLnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm11bCh0aGlzLHQpfSxhLnByb3RvdHlwZS5tdWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm11bFN0cmljdCh0aGlzLHQpfSxhLnByb3RvdHlwZS5kaXY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmRpdih0aGlzLHQpfSxhLnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZmxvb3JEaXYodGhpcyx0KX0sYS5wcm90b3R5cGUuZGl2U3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5kaXZTdHJpY3QodGhpcyx0KX0sYS5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubWluaW11bSh0aGlzLHQpfSxhLnByb3RvdHlwZS5taW5pbXVtU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5taW5pbXVtU3RyaWN0KHRoaXMsdCl9LGEucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1heGltdW0odGhpcyx0KX0sYS5wcm90b3R5cGUubWF4aW11bVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubWF4aW11bVN0cmljdCh0aGlzLHQpfSxhLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1vZCh0aGlzLHQpfSxhLnByb3RvdHlwZS5tb2RTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm1vZFN0cmljdCh0aGlzLHQpfSxhLnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3F1YXJlZERpZmZlcmVuY2UodGhpcyx0KX0sYS5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0KHRoaXMsdCl9LGEucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIudHJhbnNwb3NlKHRoaXMsdCl9LGEucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5ub3RFcXVhbCh0aGlzLHQpfSxhLnByb3RvdHlwZS5ub3RFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubm90RXF1YWxTdHJpY3QodGhpcyx0KX0sYS5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubGVzcyh0aGlzLHQpfSxhLnByb3RvdHlwZS5sZXNzU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sZXNzU3RyaWN0KHRoaXMsdCl9LGEucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5lcXVhbCh0aGlzLHQpfSxhLnByb3RvdHlwZS5lcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZXF1YWxTdHJpY3QodGhpcyx0KX0sYS5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sZXNzRXF1YWwodGhpcyx0KX0sYS5wcm90b3R5cGUubGVzc0VxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sZXNzRXF1YWxTdHJpY3QodGhpcyx0KX0sYS5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZ3JlYXRlcih0aGlzLHQpfSxhLnByb3RvdHlwZS5ncmVhdGVyU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5ncmVhdGVyU3RyaWN0KHRoaXMsdCl9LGEucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZ3JlYXRlckVxdWFsKHRoaXMsdCl9LGEucHJvdG90eXBlLmdyZWF0ZXJFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZ3JlYXRlckVxdWFsU3RyaWN0KHRoaXMsdCl9LGEucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxvZ2ljYWxBbmQodGhpcyx0KX0sYS5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sb2dpY2FsT3IodGhpcyx0KX0sYS5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sb2dpY2FsTm90KHRoaXMpfSxhLnByb3RvdHlwZS5sb2dpY2FsWG9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5sb2dpY2FsWG9yKHRoaXMsdCl9LGEucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLndoZXJlKGEsdGhpcyxlKX0sYS5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm5lZyh0aGlzKX0sYS5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5jZWlsKHRoaXMpfSxhLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5mbG9vcih0aGlzKX0sYS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zaWduKHRoaXMpfSxhLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZXhwKHRoaXMpfSxhLnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5leHBtMSh0aGlzKX0sYS5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmxvZyh0aGlzKX0sYS5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubG9nMXAodGhpcyl9LGEucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3FydCh0aGlzKX0sYS5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIucnNxcnQodGhpcyl9LGEucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zcXVhcmUodGhpcyl9LGEucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIucmVjaXByb2NhbCh0aGlzKX0sYS5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFicyh0aGlzKX0sYS5wcm90b3R5cGUuY2xpcEJ5VmFsdWU9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY2xpcEJ5VmFsdWUodGhpcyxhLGUpfSxhLnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnJlbHUodGhpcyl9LGEucHJvdG90eXBlLmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5lbHUodGhpcyl9LGEucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc2VsdSh0aGlzKX0sYS5wcm90b3R5cGUubGVha3lSZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0uMiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubGVha3lSZWx1KHRoaXMsdCl9LGEucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5wcmVsdSh0aGlzLHQpfSxhLnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNpZ21vaWQodGhpcyl9LGEucHJvdG90eXBlLmxvZ1NpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubG9nU2lnbW9pZCh0aGlzKX0sYS5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc29mdHBsdXModGhpcyl9LGEucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci56ZXJvc0xpa2UodGhpcyl9LGEucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLm9uZXNMaWtlKHRoaXMpfSxhLnByb3RvdHlwZS5zaW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc2luKHRoaXMpfSxhLnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY29zKHRoaXMpfSxhLnByb3RvdHlwZS50YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIudGFuKHRoaXMpfSxhLnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmFzaW4odGhpcyl9LGEucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYWNvcyh0aGlzKX0sYS5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hdGFuKHRoaXMpfSxhLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnNpbmgodGhpcyl9LGEucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuY29zaCh0aGlzKX0sYS5wcm90b3R5cGUudGFuaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci50YW5oKHRoaXMpfSxhLnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5hc2luaCh0aGlzKX0sYS5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYWNvc2godGhpcyl9LGEucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmF0YW5oKHRoaXMpfSxhLnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuZXJmKHRoaXMpfSxhLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5yb3VuZCh0aGlzKX0sYS5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3RlcCh0aGlzLHQpfSxhLnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc29mdG1heCh0aGlzLHQpfSxhLnByb3RvdHlwZS5sb2dTb2Z0bWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubG9nU29mdG1heCh0aGlzLHQpfSxhLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbihhLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuaW1hZ2UucmVzaXplQmlsaW5lYXIodGhpcyxhLGUpfSxhLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmltYWdlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcih0aGlzLGEsZSl9LGEucHJvdG90eXBlLmNvbnYxZD1mdW5jdGlvbihzLGUsdCxyLGkscCl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTldDXCIpLHZvaWQgMD09PWkmJihpPTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmNvbnYxZCh0aGlzLHMsZSx0LHIsaSxwKX0sYS5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHMsZSx0LHIsaSxwKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJOSFdDXCIpLHZvaWQgMD09PWkmJihpPVsxLDFdKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5jb252MmQodGhpcyxzLGUsdCxyLGkscCl9LGEucHJvdG90eXBlLmNvbnYyZFRyYW5zcG9zZT1mdW5jdGlvbihhLGUsdCxyLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5jb252MmRUcmFuc3Bvc2UodGhpcyxhLGUsdCxyLG4pfSxhLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24ocyxlLHQscixpLHApe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5IV0NcIiksdm9pZCAwPT09aSYmKGk9WzEsMV0pLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmRlcHRod2lzZUNvbnYyZCh0aGlzLHMsZSx0LHIsaSxwKX0sYS5wcm90b3R5cGUuc2VwYXJhYmxlQ29udjJkPWZ1bmN0aW9uKHMsZSx0LHIsbixpKXtyZXR1cm4gdm9pZCAwPT09biYmKG49WzEsMV0pLHZvaWQgMD09PWkmJihpPVwiTkhXQ1wiKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zZXBhcmFibGVDb252MmQodGhpcyxzLGUsdCxyLG4saSl9LGEucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24oYSxlLHQscil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmF2Z1Bvb2wodGhpcyxhLGUsdCxyKX0sYS5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbihhLGUsdCxyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIubWF4UG9vbCh0aGlzLGEsZSx0LHIpfSxhLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbj1mdW5jdGlvbihhLG8scyxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9NSksdm9pZCAwPT09byYmKG89MSksdm9pZCAwPT09cyYmKHM9MSksdm9pZCAwPT09aSYmKGk9LjUpLG9wSGFuZGxlci5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbih0aGlzLGEsbyxzLGkpfSxhLnByb3RvdHlwZS5wb29sPWZ1bmN0aW9uKGEsZSx0LHIsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnBvb2wodGhpcyxhLGUsdCxyLG4pfSxhLnByb3RvdHlwZS52YXJpYWJsZT1mdW5jdGlvbihhLG4sdCl7cmV0dXJuIHZvaWQgMD09PWEmJihhPSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLFZhcmlhYmxlLnZhcmlhYmxlKHRoaXMsYSxuLHQpfSxhLnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIudW5zb3J0ZWRTZWdtZW50U3VtKHRoaXMsYSxlKX0sYS5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuYmF0Y2hUb1NwYWNlTkQodGhpcyxhLGUpfSxhLnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zcGFjZVRvQmF0Y2hORCh0aGlzLGEsZSl9LGEucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24oYSxuKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9MSksdm9pZCAwPT09biYmKG49ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLnRvcGsodGhpcyxhLG4pfSxhLnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24oYSxlLHQscixzKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09cyYmKHM9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3RyaWRlZFNsaWNlKHRoaXMsYSxlLHQscixzKX0sYS5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb3BIYW5kbGVyLmRlcHRoVG9TcGFjZSh0aGlzLGEsZSl9LGEucHJvdG90eXBlLmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG9wSGFuZGxlci5zcGVjdHJhbC5mZnQodGhpcyl9LGEucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvcEhhbmRsZXIuc3BlY3RyYWwuaWZmdCh0aGlzKX0sYX0oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVuc29yLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISF0JiZudWxsIT10LnNoYXBlJiZudWxsIT10LmR0eXBlfX0pO3ZhciBWYXJpYWJsZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBzKGUsdCxzKXt2b2lkIDA9PT10JiYodD0hMCk7dmFyIG49YS5jYWxsKHRoaXMsZS5zaGFwZSxlLmR0eXBlLG51bGwsZS5kYXRhSWQpfHx0aGlzO24udHJhaW5hYmxlPXQsbi5uYW1lPXMsbnVsbD09bi5uYW1lJiYobi5uYW1lPXRyYWNrZXJGbigpLm5leHRWYXJpYWJsZUlkKCkudG9TdHJpbmcoKSk7dHJ5e3RyYWNrZXJGbigpLnJlZ2lzdGVyVmFyaWFibGUobil9Y2F0Y2godCl7dGhyb3cgdHJhY2tlckZuKCkuZGlzcG9zZVRlbnNvcihuKSx0fXJldHVybiBufXJldHVybiBfX2V4dGVuZHMocyxhKSxzLnZhcmlhYmxlPWZ1bmN0aW9uKHQsYSxpLG4pe3JldHVybiB2b2lkIDA9PT1hJiYoYT0hMCksbnVsbCE9biYmbiE9PXQuZHR5cGUmJih0PXQuYXNUeXBlKG4pKSxuZXcgcyh0LGEsaSl9LHMucHJvdG90eXBlLmFzc2lnbj1mdW5jdGlvbih0KXtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJkdHlwZSBvZiB0aGUgbmV3IHZhbHVlIChcIit0LmR0eXBlK1wiKSBhbmQgcHJldmlvdXMgdmFsdWUgKFwiK3RoaXMuZHR5cGUrXCIpIG11c3QgbWF0Y2hcIik7aWYoIWFycmF5c0VxdWFsKHQuc2hhcGUsdGhpcy5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrdC5zaGFwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLnNoYXBlK1wiKSBtdXN0IG1hdGNoXCIpO3RyYWNrZXJGbigpLmRpc3Bvc2VUZW5zb3IodGhpcyksdGhpcy5kYXRhSWQ9dC5kYXRhSWQsdHJhY2tlckZuKCkucmVnaXN0ZXJUZW5zb3IodGhpcyl9LHN9KFRlbnNvcik7T2JqZWN0LmRlZmluZVByb3BlcnR5KFZhcmlhYmxlLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBUZW5zb3ImJm51bGwhPXQuYXNzaWduJiZ0LmFzc2lnbiBpbnN0YW5jZW9mIEZ1bmN0aW9ufX0pO3ZhciB2YXJpYWJsZT1WYXJpYWJsZS52YXJpYWJsZSxFbmdpbmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEsZSx0KXt0aGlzLmJhY2tlbmQ9YSx0aGlzLnNhZmVNb2RlPWUsdGhpcy5kZWJ1Z01vZGU9dCx0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXM9e30sdGhpcy5uZXh0VGFwZU5vZGVJZD0wLHRoaXMubnVtQnl0ZXM9MCx0aGlzLm51bVRlbnNvcnM9MCx0aGlzLm51bURhdGFCdWZmZXJzPTAsdGhpcy5wcm9maWxpbmc9ITEsdGhpcy5ncmFkaWVudFNjb3BlQ291bnQ9MCx0aGlzLmN1c3RvbUdyYWRpZW50RGVwdGg9MCx0aGlzLmtlZXBUZW5zb3JzPW5ldyBTZXQsdGhpcy50ZW5zb3JJbmZvPW5ldyBXZWFrTWFwLHRoaXMuYWN0aXZlU2NvcGU9e3RyYWNrOltdLG5hbWU6XCJkZWZhdWx0IHNjb3BlXCJ9LHRoaXMuc2NvcGVTdGFjaz1bdGhpcy5hY3RpdmVTY29wZV0sdGhpcy5wcm9maWxlcj1uZXcgUHJvZmlsZXIoYSksdGhpcy5hY3RpdmVQcm9maWxlPXtuZXdCeXRlczowLG5ld1RlbnNvcnM6MCxwZWFrQnl0ZXM6MCxrZXJuZWxzOltdLHJlc3VsdDpudWxsfX1yZXR1cm4gdC5wcm90b3R5cGUubW92ZURhdGE9ZnVuY3Rpb24odCl7dGhpcy53cml0ZSh0LHRoaXMucmVhZFN5bmModCkpfSx0LnByb3RvdHlwZS50aWR5PWZ1bmN0aW9uKHMsZSxpKXt2YXIgcD10aGlzO3ZvaWQgMD09PWkmJihpPSExKTt2YXIgbj1udWxsLGw7aWYobnVsbD09ZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygcyl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIHRpZHkoKVwiKTtlPXN9ZWxzZXtpZihcInN0cmluZ1wiIT10eXBlb2YgcyYmIShzIGluc3RhbmNlb2YgU3RyaW5nKSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBzdHJpbmdcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgMm5kIGFyZ3VtZW50IHRvIHRpZHkoKSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7bj1zfXJldHVybiB0aGlzLnNjb3BlZFJ1bihmdW5jdGlvbigpe3JldHVybiBwLnN0YXJ0U2NvcGUobixpKX0sZnVuY3Rpb24oKXtyZXR1cm4gcC5lbmRTY29wZShsLGkpfSxmdW5jdGlvbigpe3JldHVybihsPWUoKSlpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksbH0pfSx0LnByb3RvdHlwZS5zY29wZWRSdW49ZnVuY3Rpb24oYSxvLGUpe2EoKTt0cnl7dmFyIHQ9ZSgpO3JldHVybiBvKCksdH1jYXRjaCh0KXt0aHJvdyBvKCksdH19LHQucHJvdG90eXBlLm5leHRUZW5zb3JJZD1mdW5jdGlvbigpe3JldHVybiB0Lm5leHRUZW5zb3JJZCsrfSx0LnByb3RvdHlwZS5uZXh0VmFyaWFibGVJZD1mdW5jdGlvbigpe3JldHVybiB0Lm5leHRWYXJpYWJsZUlkKyt9LHQucHJvdG90eXBlLnJ1bktlcm5lbD1mdW5jdGlvbihwLGQsdCl7dmFyIGU9dGhpcyxyPVtdLGE9ZnVuY3Rpb24odCl7cmV0dXJuIHIucHVzaCh0KSx0fSxvPXRoaXMuYWN0aXZlU2NvcGUubmFtZSxzPXRoaXMubnVtQnl0ZXMsaT10aGlzLm51bVRlbnNvcnMsbDtpZih0aGlzLnNjb3BlZFJ1bihmdW5jdGlvbigpe3JldHVybiBlLmN1c3RvbUdyYWRpZW50RGVwdGgrK30sZnVuY3Rpb24oKXtyZXR1cm4gZS5jdXN0b21HcmFkaWVudERlcHRoLS19LGZ1bmN0aW9uKCl7bD1lLmRlYnVnTW9kZSgpP2UucHJvZmlsZXIucHJvZmlsZUtlcm5lbChvLGZ1bmN0aW9uKCl7cmV0dXJuIHAoZS5iYWNrZW5kLGEpfSk6cChlLmJhY2tlbmQsYSl9KSx0aGlzLnNob3VsZFJlY29yZCgpKXt2YXIgdT17aWQ6dGhpcy5uZXh0VGFwZU5vZGVJZCsrLG5hbWU6byxpbnB1dHM6ZCxvdXRwdXRzOkFycmF5LmlzQXJyYXkobCk/bDpbbF19O251bGwhPXQmJih1LmdyYWRpZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0KGEscil9KSx0aGlzLmFjdGl2ZVRhcGUucHVzaCh1KX1yZXR1cm4gdGhpcy5wcm9maWxpbmcmJnRoaXMuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLnB1c2goe25hbWU6byxieXRlc0FkZGVkOnRoaXMubnVtQnl0ZXMtcyx0b3RhbEJ5dGVzU25hcHNob3Q6dGhpcy5udW1CeXRlcyx0ZW5zb3JzQWRkZWQ6dGhpcy5udW1UZW5zb3JzLWksdG90YWxUZW5zb3JzU25hcHNob3Q6dGhpcy5udW1UZW5zb3JzLGlucHV0U2hhcGVzOk9iamVjdC5rZXlzKGQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZFt0XS5zaGFwZX0pLG91dHB1dFNoYXBlOkFycmF5LmlzQXJyYXkobCk/bC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KTpsLnNoYXBlfSksbH0sdC5wcm90b3R5cGUucmVnaXN0ZXJUZW5zb3I9ZnVuY3Rpb24oYSl7dmFyIGU9dGhpcy50ZW5zb3JJbmZvLmhhcyhhLmRhdGFJZCk/dGhpcy50ZW5zb3JJbmZvLmdldChhLmRhdGFJZCkucmVmQ291bnQ6MDt0aGlzLm51bVRlbnNvcnMrKywwPT09ZSYmKHRoaXMubnVtRGF0YUJ1ZmZlcnMrKyxcImNvbXBsZXg2NFwiIT09YS5kdHlwZSYmKHRoaXMubnVtQnl0ZXMrPXNpemVGcm9tU2hhcGUoYS5zaGFwZSkqYnl0ZXNQZXJFbGVtZW50KGEuZHR5cGUpKSx0aGlzLnRlbnNvckluZm8uc2V0KGEuZGF0YUlkLHtiYWNrZW5kOnRoaXMuYmFja2VuZCxkdHlwZTphLmR0eXBlLHNoYXBlOmEuc2hhcGUscmVmQ291bnQ6MH0pLHRoaXMuYmFja2VuZC5yZWdpc3RlcihhLmRhdGFJZCxhLnNoYXBlLGEuZHR5cGUpKSx0aGlzLnRlbnNvckluZm8uZ2V0KGEuZGF0YUlkKS5yZWZDb3VudCsrLGEgaW5zdGFuY2VvZiBWYXJpYWJsZXx8dGhpcy50cmFjayhhKX0sdC5wcm90b3R5cGUucmVnaXN0ZXJWYXJpYWJsZT1mdW5jdGlvbih0KXtpZihudWxsIT10aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdC5uYW1lXSl0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSB3aXRoIG5hbWUgXCIrdC5uYW1lK1wiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7dGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV09dH0sdC5wcm90b3R5cGUuZGlzcG9zZVRlbnNvcj1mdW5jdGlvbih0KXt0aGlzLnRlbnNvckluZm8uaGFzKHQuZGF0YUlkKSYmKHRoaXMua2VlcFRlbnNvcnMuaGFzKHQuaWQpJiZ0aGlzLmtlZXBUZW5zb3JzLmRlbGV0ZSh0LmlkKSx0aGlzLm51bVRlbnNvcnMtLSwxPj10aGlzLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudD8odGhpcy50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkuYmFja2VuZC5kaXNwb3NlRGF0YSh0LmRhdGFJZCksdGhpcy5udW1EYXRhQnVmZmVycy0tLFwiY29tcGxleDY0XCIhPT10LmR0eXBlJiYodGhpcy5udW1CeXRlcy09c2l6ZUZyb21TaGFwZSh0LnNoYXBlKSpieXRlc1BlckVsZW1lbnQodC5kdHlwZSkpLHRoaXMudGVuc29ySW5mby5kZWxldGUodC5kYXRhSWQpKTp0aGlzLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudC0tKX0sdC5wcm90b3R5cGUuZGlzcG9zZVZhcmlhYmxlcz1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMpe3ZhciBlPXRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1thXTt0aGlzLmRpc3Bvc2VUZW5zb3IoZSksZGVsZXRlIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1thXX19LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuYmFja2VuZC5tZW1vcnkoKTtyZXR1cm4gdC5udW1UZW5zb3JzPXRoaXMubnVtVGVuc29ycyx0Lm51bURhdGFCdWZmZXJzPXRoaXMubnVtRGF0YUJ1ZmZlcnMsdC5udW1CeXRlcz10aGlzLm51bUJ5dGVzLHR9LHQucHJvdG90eXBlLnByb2ZpbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvZmlsaW5nPSEwLGU9dGhpcy5udW1CeXRlcyxuPXRoaXMubnVtVGVuc29ycyx0aGlzLmFjdGl2ZVByb2ZpbGUua2VybmVscz1bXSx0aGlzLmFjdGl2ZVByb2ZpbGUucmVzdWx0PWEoKSx0aGlzLnByb2ZpbGluZz0hMSx0aGlzLmFjdGl2ZVByb2ZpbGUucGVha0J5dGVzPV9NYXRobWF4LmFwcGx5KE1hdGgsdGhpcy5hY3RpdmVQcm9maWxlLmtlcm5lbHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvdGFsQnl0ZXNTbmFwc2hvdH0pKSx0aGlzLmFjdGl2ZVByb2ZpbGUubmV3Qnl0ZXM9dGhpcy5udW1CeXRlcy1lLHRoaXMuYWN0aXZlUHJvZmlsZS5uZXdUZW5zb3JzPXRoaXMubnVtVGVuc29ycy1uLFsyLHRoaXMuYWN0aXZlUHJvZmlsZV19KX0pfSx0LnByb3RvdHlwZS5zaG91bGRSZWNvcmQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5hY3RpdmVUYXBlJiYwPT09dGhpcy5jdXN0b21HcmFkaWVudERlcHRofSx0LnByb3RvdHlwZS5hZGRUYXBlTm9kZT1mdW5jdGlvbihhLGUscyl7dmFyIHI9e307YS5mb3JFYWNoKGZ1bmN0aW9uKGEsZSl7cltlXT1hfSk7dmFyIHQ9e2lkOnRoaXMubmV4dFRhcGVOb2RlSWQrKyxuYW1lOnRoaXMuYWN0aXZlU2NvcGUubmFtZSxpbnB1dHM6cixvdXRwdXRzOltlXSxncmFkaWVudDpmdW5jdGlvbihhKXt2YXIgbj17fTtyZXR1cm4gcyhhKS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7bltlXT1mdW5jdGlvbigpe3JldHVybiB0fX0pLG59fTt0aGlzLmFjdGl2ZVRhcGUucHVzaCh0KX0sdC5wcm90b3R5cGUua2VlcD1mdW5jdGlvbih0KXtpZigxPT09dGhpcy5zY29wZVN0YWNrLmxlbmd0aCYmdGhpcy5zYWZlTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJTYWZlIG1vZGUgaXMgT04uIEVuY2xvc2UgYWxsIHRlbnNvciBvcGVyYXRpb25zIGluc2lkZSB0Zi50aWR5KCk6IHRmLnRpZHkoKCkgPT4gey4uLn0pIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cIik7cmV0dXJuIHRoaXMua2VlcFRlbnNvcnMuYWRkKHQuaWQpLHR9LHQucHJvdG90eXBlLnN0YXJ0U2NvcGU9ZnVuY3Rpb24oYSxlKXt2b2lkIDA9PT1lJiYoZT0hMSksZSYmMD09PXRoaXMuZ3JhZGllbnRTY29wZUNvdW50JiYodGhpcy5hY3RpdmVUYXBlPVtdKSxlJiZ0aGlzLmdyYWRpZW50U2NvcGVDb3VudCsrO3ZhciBuPXt0cmFjazpbXSxuYW1lOlwidW5uYW1lZCBzY29wZVwifTthJiYobi5uYW1lPWEpLHRoaXMuc2NvcGVTdGFjay5wdXNoKG4pLHRoaXMuYWN0aXZlU2NvcGU9bn0sdC5wcm90b3R5cGUuZW5kU2NvcGU9ZnVuY3Rpb24ocCxlKXt2YXIgbD10aGlzO3ZvaWQgMD09PWUmJihlPSExKSxlJiYodGhpcy5ncmFkaWVudFNjb3BlQ291bnQtLSwwPT09dGhpcy5ncmFkaWVudFNjb3BlQ291bnQmJih0aGlzLmFjdGl2ZVRhcGU9bnVsbCkpO3ZhciByPW5ldyBTZXQodGhpcy5rZWVwVGVuc29ycyksbj1nZXRUZW5zb3JzSW5Db250YWluZXIocCk7bi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiByLmFkZCh0LmlkKX0pO2Zvcih2YXIgbz0wLGQ7bzx0aGlzLmFjdGl2ZVNjb3BlLnRyYWNrLmxlbmd0aDtvKyspZD10aGlzLmFjdGl2ZVNjb3BlLnRyYWNrW29dLHIuaGFzKGQuaWQpfHwobnVsbD09dGhpcy5hY3RpdmVUYXBlP2QuZGlzcG9zZSgpOm4ucHVzaChkKSk7dmFyIHU9dGhpcy5zY29wZVN0YWNrLnBvcCgpO3RoaXMuYWN0aXZlU2NvcGU9MD09PXRoaXMuc2NvcGVTdGFjay5sZW5ndGg/e3RyYWNrOltdLG5hbWU6XCJkZWZhdWx0IHNjb3BlXCJ9OnRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoLTFdLG4uZm9yRWFjaChmdW5jdGlvbih0KXshbC5rZWVwVGVuc29ycy5oYXModC5pZCkmJmlzVGVuc29ySW5MaXN0KHQsdS50cmFjaykmJmwudHJhY2sodCl9KX0sdC5wcm90b3R5cGUuZ3JhZGllbnRzPWZ1bmN0aW9uKHAsZSx0LHIpe3ZhciBsPXRoaXM7cmV0dXJuIHZvaWQgMD09PXImJihyPSExKSxhc3NlcnQoMDxlLmxlbmd0aCxcImdyYWRpZW50cygpIHJlY2VpdmVkIGFuIGVtcHR5IGxpc3Qgb2YgeHMuXCIpLHRoaXMudGlkeShcImdyYWRpZW50c1wiLGZ1bmN0aW9uKCl7dmFyIG49cCgpO2Fzc2VydChuIGluc3RhbmNlb2YgVGVuc29yLFwiVGhlIHJlc3VsdCB5IHJldHVybmVkIGJ5IGYoKSBtdXN0IGJlIGEgdGVuc29yLlwiKTt2YXIgYT1nZXRGaWx0ZXJlZE5vZGVzWFRvWShsLmFjdGl2ZVRhcGUsZSxuKTtpZighciYmMD09PWEubGVuZ3RoJiYwPGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlIHRoYXQgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4IHRvIHkuXCIpO3ZhciBvPXt9O3JldHVybiBvW24uaWRdPW51bGw9PXQ/b25lcyhuLnNoYXBlKTp0LGJhY2twcm9wYWdhdGVHcmFkaWVudHMobyxhKSx7dmFsdWU6bixncmFkczplLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gb1t0LmlkXX0pfX0sITApfSx0LnByb3RvdHlwZS5jdXN0b21HcmFkPWZ1bmN0aW9uKHIpe3ZhciBlPXRoaXM7cmV0dXJuIGFzc2VydChpc0Z1bmN0aW9uKHIpLFwiVGhlIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKSxmdW5jdGlvbigpe2Zvcih2YXIgcz1bXSx0PTAsbyxpO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspc1t0XT1hcmd1bWVudHNbdF07cmV0dXJuKGFzc2VydChzLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgVGVuc29yfSksXCJUaGUgYXJncyBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSh4MSwgeDIsLi4uKSBtdXN0IGFsbCBiZSB0ZW5zb3JzXCIpLGUuc2NvcGVkUnVuKGZ1bmN0aW9uKCl7cmV0dXJuIGUuY3VzdG9tR3JhZGllbnREZXB0aCsrfSxmdW5jdGlvbigpe3JldHVybiBlLmN1c3RvbUdyYWRpZW50RGVwdGgtLX0sZnVuY3Rpb24oKXtpPWUudGlkeShyLm5hbWUsZnVuY3Rpb24oKXt2YXIgZT1yLmFwcGx5KHZvaWQgMCxzKSx0PWUudmFsdWUsbj1lLmdyYWRGdW5jO3JldHVybiBhc3NlcnQodCBpbnN0YW5jZW9mIFRlbnNvcixcIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLnZhbHVlYCBpcyBhIHRlbnNvclwiKSxhc3NlcnQoaXNGdW5jdGlvbihuKSxcIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uLlwiKSxvPW4sdH0sITApfSksZS5zaG91bGRSZWNvcmQoKSkmJmUuYWRkVGFwZU5vZGUocyxpLGZ1bmN0aW9uKGEpe3ZhciBlPW8oYSksdD1BcnJheS5pc0FycmF5KGUpP2U6W2VdO3JldHVybiBhc3NlcnQodC5sZW5ndGg9PT1zLmxlbmd0aCxcIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc2FtZSBudW1iZXIgb2YgdGVuc29ycyBhcyBpbnB1dHMgcGFzc2VkIHRvIGYoLi4uKS5cIiksYXNzZXJ0KHQuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBUZW5zb3J9KSxcIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2Ygb25seSB0ZW5zb3JzLlwiKSx0fSksaX19LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGEsZSl7dmFyIHQ9dGhpcy50ZW5zb3JJbmZvLmdldChhKTt0aGlzLmJhY2tlbmQhPT10LmJhY2tlbmQmJih0LmJhY2tlbmQuZGlzcG9zZURhdGEoYSksdC5iYWNrZW5kPXRoaXMuYmFja2VuZCx0aGlzLmJhY2tlbmQucmVnaXN0ZXIoYSx0LnNoYXBlLHQuZHR5cGUpKSx0aGlzLmJhY2tlbmQud3JpdGUoYSxlKX0sdC5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGVuc29ySW5mby5nZXQodCkuYmFja2VuZC5yZWFkU3luYyh0KX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWQodCl9LHQucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmZyb21QaXhlbHMoYSxlKX0sdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbihhKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG87cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT1ub3coKSxbNCx0aGlzLmJhY2tlbmQudGltZShhKV07Y2FzZSAxOnJldHVybihvPXQuc2VudCgpKS53YWxsTXM9bm93KCktZSxbMixvXTt9fSl9KX0sdC5wcm90b3R5cGUudHJhY2s9ZnVuY3Rpb24odCl7aWYoMT09PXRoaXMuc2NvcGVTdGFjay5sZW5ndGgmJnRoaXMuc2FmZU1vZGUpdGhyb3cgbmV3IEVycm9yKFwiU2FmZSBtb2RlIGlzIE9OLiBFbmNsb3NlIGFsbCB0ZW5zb3Igb3BlcmF0aW9ucyBpbnNpZGUgdGYudGlkeSgpOiB0Zi50aWR5KCgpID0+IHtvcCgpOy4uLn0pOyB0byBhdm9pZCBtZW1vcnkgbGVha3MuXCIpO3JldHVybiB0aGlzLmFjdGl2ZVNjb3BlLnRyYWNrLnB1c2godCksdH0sdC5uZXh0VGVuc29ySWQ9MCx0Lm5leHRWYXJpYWJsZUlkPTAsdH0oKSxUeXBlOyFmdW5jdGlvbih0KXt0W3QuTlVNQkVSPTBdPVwiTlVNQkVSXCIsdFt0LkJPT0xFQU49MV09XCJCT09MRUFOXCIsdFt0LlNUUklORz0yXT1cIlNUUklOR1wifShUeXBlfHwoVHlwZT17fSkpO3ZhciBVUkxfUFJPUEVSVElFUz1be25hbWU6XCJERUJVR1wiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIklTX0JST1dTRVJcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIsdHlwZTpUeXBlLkJPT0xFQU59LHtuYW1lOlwiV0VCR0xfQ1BVX0ZPUldBUkRcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJXRUJHTF9QQUNLX0JBVENITk9STUFMSVpBVElPTlwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIldFQkdMX0NPTlZfSU0yQ09MXCIsdHlwZTpUeXBlLkJPT0xFQU59LHtuYW1lOlwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiLHR5cGU6VHlwZS5OVU1CRVJ9LHtuYW1lOlwiV0VCR0xfUEFHSU5HX0VOQUJMRURcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiLHR5cGU6VHlwZS5OVU1CRVJ9LHtuYW1lOlwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIsdHlwZTpUeXBlLkJPT0xFQU59LHtuYW1lOlwiV0VCR0xfVkVSU0lPTlwiLHR5cGU6VHlwZS5OVU1CRVJ9LHtuYW1lOlwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiLHR5cGU6VHlwZS5CT09MRUFOfSx7bmFtZTpcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIix0eXBlOlR5cGUuTlVNQkVSfSx7bmFtZTpcIkJBQ0tFTkRcIix0eXBlOlR5cGUuU1RSSU5HfSx7bmFtZTpcIkVQU0lMT05cIix0eXBlOlR5cGUuTlVNQkVSfSx7bmFtZTpcIlBST0RcIix0eXBlOlR5cGUuQk9PTEVBTn0se25hbWU6XCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIsdHlwZTpUeXBlLkJPT0xFQU59XSxURU5TT1JGTE9XSlNfRkxBR1NfUFJFRklYPVwidGZqc2ZsYWdzXCIsRVBTSUxPTl9GTE9BVDE2PS4wMDEsVEVTVF9FUFNJTE9OX0ZMT0FUMTY9LjEsRVBTSUxPTl9GTE9BVDMyPTFlLTcsVEVTVF9FUFNJTE9OX0ZMT0FUMzI9LjAwMSxFbnZpcm9ubWVudD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5mZWF0dXJlcz17fSx0aGlzLnJlZ2lzdHJ5PXt9LG51bGwhPXQmJih0aGlzLmZlYXR1cmVzPXQpLHRoaXMuZ2V0KFwiREVCVUdcIikmJmNvbnNvbGUud2FybihcIkRlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsIGJlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiBUaGlzIHNpZ25pZmljYW50bHkgaW1wYWN0cyBwZXJmb3JtYW5jZS5cIil9cmV0dXJuIHQuc2V0QmFja2VuZD1mdW5jdGlvbihhLGUpe2lmKHZvaWQgMD09PWUmJihlPSExKSwhKGEgaW4gRU5WLnJlZ2lzdHJ5KSl0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kIG5hbWUgJ1wiK2ErXCInIG5vdCBmb3VuZCBpbiByZWdpc3RyeVwiKTtFTlYuZW5naW5lLmJhY2tlbmQ9RU5WLmZpbmRCYWNrZW5kKGEpLEVOVi5iYWNrZW5kTmFtZT1hfSx0LmdldEJhY2tlbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gRU5WLmluaXRFbmdpbmUoKSxFTlYuYmFja2VuZE5hbWV9LHQuZGlzcG9zZVZhcmlhYmxlcz1mdW5jdGlvbigpe0VOVi5lbmdpbmUuZGlzcG9zZVZhcmlhYmxlcygpfSx0Lm1lbW9yeT1mdW5jdGlvbigpe3JldHVybiBFTlYuZW5naW5lLm1lbW9yeSgpfSx0LnByb2ZpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIEVOVi5lbmdpbmUucHJvZmlsZSh0KX0sdC50aWR5PWZ1bmN0aW9uKGEsZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLEVOVi5lbmdpbmUudGlkeShhLGUsdCl9LHQuZGlzcG9zZT1mdW5jdGlvbih0KXtnZXRUZW5zb3JzSW5Db250YWluZXIodCkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5kaXNwb3NlKCl9KX0sdC5rZWVwPWZ1bmN0aW9uKHQpe3JldHVybiBFTlYuZW5naW5lLmtlZXAodCl9LHQudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gRU5WLmVuZ2luZS50aW1lKHQpfSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5mZWF0dXJlcz90aGlzLmZlYXR1cmVzW3RdOih0aGlzLmZlYXR1cmVzW3RdPXRoaXMuZXZhbHVhdGVGZWF0dXJlKHQpLHRoaXMuZmVhdHVyZXNbdF0pfSx0LnByb3RvdHlwZS5nZXRGZWF0dXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZlYXR1cmVzfSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxlKXt0aGlzLmZlYXR1cmVzW2FdPWV9LHQucHJvdG90eXBlLmdldEJlc3RCYWNrZW5kTmFtZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7aWYoMD09PU9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJObyBiYWNrZW5kIGZvdW5kIGluIHJlZ2lzdHJ5LlwiKTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOmUsZW50cnk6YS5yZWdpc3RyeVtlXX19KS5zb3J0KGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGUuZW50cnkucHJpb3JpdHktYS5lbnRyeS5wcmlvcml0eX0pWzBdLm5hbWV9LHQucHJvdG90eXBlLmV2YWx1YXRlRmVhdHVyZT1mdW5jdGlvbihhKXtpZihcIkRFQlVHXCI9PT1hKXJldHVybiExO2lmKFwiSVNfQlJPV1NFUlwiPT09YSlyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93O2lmKFwiSVNfTk9ERVwiPT09YSlyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmdm9pZCAwIT09cHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKFwiSVNfQ0hST01FXCI9PT1hKXJldHVybiBpc0Nocm9tZSgpO2lmKFwiV0VCR0xfQ1BVX0ZPUldBUkRcIj09PWEpcmV0dXJuITA7aWYoXCJXRUJHTF9QQUNLX0JBVENITk9STUFMSVpBVElPTlwiPT09YSlyZXR1cm4hMTtpZihcIldFQkdMX0xBWklMWV9VTlBBQ0tcIj09PWEpcmV0dXJuITE7aWYoXCJXRUJHTF9DT05WX0lNMkNPTFwiPT09YSlyZXR1cm4hMTtpZihcIldFQkdMX1BBR0lOR19FTkFCTEVEXCI9PT1hKXJldHVybiB0aGlzLmdldChcIklTX0JST1dTRVJcIikmJiF0aGlzLmdldChcIlBST0RcIik7aWYoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCI9PT1hKXJldHVybiBnZXRXZWJHTE1heFRleHR1cmVTaXplKHRoaXMuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKSk7aWYoXCJJU19URVNUXCI9PT1hKXJldHVybiExO2lmKFwiQkFDS0VORFwiPT09YSlyZXR1cm4gdGhpcy5nZXRCZXN0QmFja2VuZE5hbWUoKTtpZihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCI9PT1hKXt2YXIgZT10aGlzLmdldChcIldFQkdMX1ZFUlNJT05cIik7cmV0dXJuIDA9PT1lPzA6Z2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uKGUpfWlmKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCI9PT1hKXJldHVybiAwPHRoaXMuZ2V0KFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikmJiFpc01vYmlsZSgpO2lmKFwiSEFTX1dFQkdMXCI9PT1hKXJldHVybiAwPHRoaXMuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKTtpZihcIldFQkdMX1ZFUlNJT05cIj09PWEpcmV0dXJuIGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgyKT8yOmlzV2ViR0xWZXJzaW9uRW5hYmxlZCgxKT8xOjA7aWYoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCI9PT1hKXJldHVybiBpc1JlbmRlclRvRmxvYXRUZXh0dXJlRW5hYmxlZCh0aGlzLmdldChcIldFQkdMX1ZFUlNJT05cIikpO2lmKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiPT09YSlyZXR1cm4gaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQodGhpcy5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpKTtpZihcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCI9PT1hKXJldHVybiBpc1dlYkdMRmVuY2VFbmFibGVkKHRoaXMuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKSk7aWYoXCJXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNXCI9PT1hKXJldHVybiB0aGlzLmdldChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/NDowO2lmKFwiVEVTVF9FUFNJTE9OXCI9PT1hKXJldHVybiAzMj09PXRoaXMuYmFja2VuZC5mbG9hdFByZWNpc2lvbigpP1RFU1RfRVBTSUxPTl9GTE9BVDMyOlRFU1RfRVBTSUxPTl9GTE9BVDE2O2lmKFwiRVBTSUxPTlwiPT09YSlyZXR1cm4gMzI9PT10aGlzLmJhY2tlbmQuZmxvYXRQcmVjaXNpb24oKT9FUFNJTE9OX0ZMT0FUMzI6RVBTSUxPTl9GTE9BVDE2O2lmKFwiUFJPRFwiPT09YSlyZXR1cm4hMTtpZihcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIj09PWEpcmV0dXJuIXRoaXMuZ2V0KFwiUFJPRFwiKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZlYXR1cmUgXCIrYStcIi5cIil9LHQucHJvdG90eXBlLnNldEZlYXR1cmVzPWZ1bmN0aW9uKHQpe3RoaXMuZmVhdHVyZXM9T2JqZWN0LmFzc2lnbih7fSx0KX0sdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmZlYXR1cmVzPWdldEZlYXR1cmVzRnJvbVVSTCgpLG51bGwhPXRoaXMuZ2xvYmFsRW5naW5lJiYodGhpcy5nbG9iYWxFbmdpbmU9bnVsbCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJhY2tlbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5naW5lLmJhY2tlbmR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZmluZEJhY2tlbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5yZWdpc3RyeT90aGlzLnJlZ2lzdHJ5W3RdLmJhY2tlbmQ6bnVsbH0sdC5wcm90b3R5cGUucmVnaXN0ZXJCYWNrZW5kPWZ1bmN0aW9uKHMsZSx0LGkpe3ZhciBuPXRoaXM7aWYodm9pZCAwPT09dCYmKHQ9MSkscyBpbiB0aGlzLnJlZ2lzdHJ5KXJldHVybiBjb25zb2xlLndhcm4ocytcIiBiYWNrZW5kIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQuIFJldXNpbmcgZXhpc3RpbmcgYmFja2VuZFwiKSxudWxsIT1pJiZpKGZ1bmN0aW9uKCl7cmV0dXJuIG4uZW5naW5lfSksITE7dHJ5e3ZhciBvPWUoKTtyZXR1cm4gby5zZXREYXRhTW92ZXIoe21vdmVEYXRhOmZ1bmN0aW9uKHQpe3JldHVybiBuLmVuZ2luZS5tb3ZlRGF0YSh0KX19KSx0aGlzLnJlZ2lzdHJ5W3NdPXtiYWNrZW5kOm8scHJpb3JpdHk6dH0sITB9Y2F0Y2goZSl7cmV0dXJuIGNvbnNvbGUud2FybihcIlJlZ2lzdHJhdGlvbiBvZiBiYWNrZW5kIFwiK3MrXCIgZmFpbGVkXCIpLGNvbnNvbGUud2FybihlLnN0YWNrfHxlLm1lc3NhZ2UpLCExfX0sdC5wcm90b3R5cGUucmVtb3ZlQmFja2VuZD1mdW5jdGlvbih0KXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeSkpdGhyb3cgbmV3IEVycm9yKHQrXCIgYmFja2VuZCBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7dGhpcy5yZWdpc3RyeVt0XS5iYWNrZW5kLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5yZWdpc3RyeVt0XX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZW5naW5lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXRFbmdpbmUoKSx0aGlzLmdsb2JhbEVuZ2luZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5pbml0RW5naW5lPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZihudWxsPT10aGlzLmdsb2JhbEVuZ2luZSl7dGhpcy5iYWNrZW5kTmFtZT10aGlzLmdldChcIkJBQ0tFTkRcIik7dmFyIGU9dGhpcy5maW5kQmFja2VuZCh0aGlzLmJhY2tlbmROYW1lKTt0aGlzLmdsb2JhbEVuZ2luZT1uZXcgRW5naW5lKGUsITEsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXQoXCJERUJVR1wiKX0pfX0sdH0oKSxFTlY9Z2V0T3JNYWtlRW52aXJvbm1lbnQoKSxlbnZpcm9ubWVudD1PYmplY3QuZnJlZXplKHtFbnZpcm9ubWVudDpFbnZpcm9ubWVudCxFTlY6RU5WfSksdGlkeT1FbnZpcm9ubWVudC50aWR5LGtlZXA9RW52aXJvbm1lbnQua2VlcCxkaXNwb3NlPUVudmlyb25tZW50LmRpc3Bvc2UsUEFSQUxMRUxJWkVfVEhSRVNIT0xEPTMwLHNvZnRtYXg9b3Aoe3NvZnRtYXhfOnNvZnRtYXhffSksbG9nU29mdG1heD1vcCh7bG9nU29mdG1heF86bG9nU29mdG1heF99KSxjb21wbGV4PW9wKHtjb21wbGV4Xzpjb21wbGV4X30pLHJlYWw9b3Aoe3JlYWxfOnJlYWxffSksaW1hZz1vcCh7aW1hZ186aW1hZ199KSxvbmVzTGlrZT1vcCh7b25lc0xpa2VfOm9uZXNMaWtlX30pLHplcm9zTGlrZT1vcCh7emVyb3NMaWtlXzp6ZXJvc0xpa2VffSksTUFYX1RFWFRVUkVfU0laRSxEVHlwZSxSYW5rLFVwY2FzdEludDMyQW5kTWFwLFVwY2FzdEJvb2xBbmRNYXAsVXBjYXN0RmxvYXQzMkFuZE1hcCxVcGNhc3RDb21wbGV4NjRBbmRNYXA7IWZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiaW50MzJcIix0LmJvb2w9XCJib29sXCJ9KERUeXBlfHwoRFR5cGU9e30pKSxmdW5jdGlvbih0KXt0LlIwPVwiUjBcIix0LlIxPVwiUjFcIix0LlIyPVwiUjJcIix0LlIzPVwiUjNcIix0LlI0PVwiUjRcIix0LlI1PVwiUjVcIix0LlI2PVwiUjZcIn0oUmFua3x8KFJhbms9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImludDMyXCIsdC5ib29sPVwiaW50MzJcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RJbnQzMkFuZE1hcHx8KFVwY2FzdEludDMyQW5kTWFwPXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiZmxvYXQzMlwiLHQuaW50MzI9XCJpbnQzMlwiLHQuYm9vbD1cImJvb2xcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RCb29sQW5kTWFwfHwoVXBjYXN0Qm9vbEFuZE1hcD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiZmxvYXQzMlwiLHQuYm9vbD1cImZsb2F0MzJcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RGbG9hdDMyQW5kTWFwfHwoVXBjYXN0RmxvYXQzMkFuZE1hcD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImNvbXBsZXg2NFwiLHQuaW50MzI9XCJjb21wbGV4NjRcIix0LmJvb2w9XCJjb21wbGV4NjRcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShVcGNhc3RDb21wbGV4NjRBbmRNYXB8fChVcGNhc3RDb21wbGV4NjRBbmRNYXA9e30pKTt2YXIgdXBjYXN0VHlwZU1hcD17ZmxvYXQzMjpVcGNhc3RGbG9hdDMyQW5kTWFwLGludDMyOlVwY2FzdEludDMyQW5kTWFwLGJvb2w6VXBjYXN0Qm9vbEFuZE1hcCxjb21wbGV4NjQ6VXBjYXN0Q29tcGxleDY0QW5kTWFwfSxEYXRhU3RvcmFnZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5kYXRhTW92ZXI9dCx0aGlzLmRhdGE9bmV3IFdlYWtNYXB9cmV0dXJuIHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmhhcyh0KXx8dGhpcy5kYXRhTW92ZXIubW92ZURhdGEodCksdGhpcy5kYXRhLmdldCh0KX0sdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsZSl7dGhpcy5kYXRhLnNldChhLGUpfSx0LnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5oYXModCl9LHQucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmRlbGV0ZSh0KX0sdH0oKSxBcmdNaW5NYXhQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHAsZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgcj1wLndpbmRvd1NpemUsbj1wLmJhdGNoU2l6ZSxvPXAuaW5TaXplLGE9X01hdGhjZWlsKG8vcik7dHx8dGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiZXN0SW5kaWNlc0FcIiksdGhpcy5vdXRwdXRTaGFwZT1bbixhXTt2YXIgaT1cIm1heFwiPT09ZT9cIj5cIjpcIjxcIixzPXQ/XCJpbk9mZnNldCArIGk7XCI6XCJyb3VuZChnZXRCZXN0SW5kaWNlc0EoYmF0Y2gsIGluT2Zmc2V0ICsgaSkpO1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIityK1wiO1xcblxcbiAgICAgICAgaW50IGJlc3RJbmRleCA9IGluT2Zmc2V0O1xcbiAgICAgICAgZmxvYXQgYmVzdFZhbHVlID0gZ2V0QShiYXRjaCwgYmVzdEluZGV4KTtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcitcIjsgaSsrKSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IFwiK3MrXCI7XFxuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEEoYmF0Y2gsIGluSWR4KTtcXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSBcIitpK1wiIGJlc3RWYWx1ZSkge1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpbklkeDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGJlc3RJbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihwKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1wLmluU2hhcGU7dmFyIGU9cC5maWx0ZXJIZWlnaHQsdD1wLmZpbHRlcldpZHRoLHI9cC5zdHJpZGVIZWlnaHQsbj1wLnN0cmlkZVdpZHRoLG89cC5kaWxhdGlvbkhlaWdodCxhPXAuZGlsYXRpb25XaWR0aCxpPXAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHM9cC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxkPWktMS1wLnBhZEluZm8udG9wLGw9cy0xLXAucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrZCtcIiwgXCIrbCtcIik7XFxuICAgICAgY29uc3QgZmxvYXQgYXZnTXVsdGlwbGllciA9IGZsb2F0KFwiKzEvKGUqdCkrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2krXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIrbytcIikge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Aub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitzK1wiO1xcbiAgICAgICAgICAgIHdDKz0gXCIrYStcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK24rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIitwLm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcblxcbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIGF2Z011bHRpcGxpZXI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxCYXRjaE5vcm1Qcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHAsZSx0LHIsbixvKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMuc3VwcG9ydHNCcm9hZGNhc3Rpbmc9ITAsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHAsZSksYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUocCx0KTt2YXIgYT1cIjAuMFwiO251bGwhPXImJihhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShwLHIpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGE9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO3ZhciBsPVwiMS4wXCI7bnVsbCE9biYmKGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHAsbiksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJzY2FsZVwiKSxsPVwiZ2V0U2NhbGVBdE91dENvb3JkcygpXCIpLHRoaXMub3V0cHV0U2hhcGU9cCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBvZmZzZXQgPSBcIithK1wiO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBcIitsK1wiO1xcbiAgICAgICAgZmxvYXQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIGZsb2F0KFwiK28rXCIpKTtcXG4gICAgICAgIHNldE91dHB1dChkb3QodmVjMyh4LCAtbWVhbiwgb2Zmc2V0KSwgdmVjMyhpbnYsIGludiwgMSkpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxCYXRjaE5vcm1QYWNrZWRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHAsZSx0LHIsbixvKXt0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nPSEwLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiXSxhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShwLGUpLGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHAsdCk7dmFyIGE9YnJvYWRjYXN0U2FtcGxlKFwibWVhblwiLGUubGVuZ3RoKSxpPWJyb2FkY2FzdFNhbXBsZShcInZhcmlhbmNlXCIsdC5sZW5ndGgpLHM9XCJ2ZWM0IG9mZnNldCA9IHZlYzQoMC4wKVwiO251bGwhPXImJihhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShwLHIpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLHM9YnJvYWRjYXN0U2FtcGxlKFwib2Zmc2V0XCIsci5sZW5ndGgpKTt2YXIgZD1cInZlYzQgc2NhbGUgPSB2ZWM0KDEuMClcIjtudWxsIT1uJiYoYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUocCxuKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLGQ9YnJvYWRjYXN0U2FtcGxlKFwic2NhbGVcIixuLmxlbmd0aCkpLHRoaXMub3V0cHV0U2hhcGU9cCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIFwiK3MrXCI7XFxuICAgICAgICBcIitkK1wiO1xcblxcbiAgICAgICAgdmVjNCB4ID0gZ2V0WChyYy54LCByYy55LCByYy56LCByYy53KTtcXG4gICAgICAgIFwiK2ErXCI7XFxuICAgICAgICBcIitpK1wiO1xcblxcbiAgICAgICAgdmVjNCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgdmVjNChcIitvK1wiKSk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksQ09NUExFWF9NVUxUSVBMWT17UkVBTDpcInJldHVybiBhcmVhbCAqIGJyZWFsIC0gYWltYWcgKiBiaW1hZztcIixJTUFHOlwicmV0dXJuIGFyZWFsICogYmltYWcgKyBhaW1hZyAqIGJyZWFsO1wifSxCaW5hcnlPcENvbXBsZXhQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVJlYWxcIixcIkFJbWFnXCIsXCJCUmVhbFwiLFwiQkltYWdcIl0sdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZz0hMCx0aGlzLm91dHB1dFNoYXBlPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsdCksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wQ29tcGxleChcXG4gICAgICAgICAgZmxvYXQgYXJlYWwsIGZsb2F0IGFpbWFnLCBmbG9hdCBicmVhbCwgZmxvYXQgYmltYWcpIHtcXG4gICAgICAgIFwiK2ErXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYXJlYWwgPSBnZXRBUmVhbEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBhaW1hZyA9IGdldEFJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJyZWFsID0gZ2V0QlJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYmltYWcgPSBnZXRCSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BDb21wbGV4KGFyZWFsLCBhaW1hZywgYnJlYWwsIGJpbWFnKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksQ0hFQ0tfTkFOX1NOSVBQRVQ9XCJcXG4gIGlmIChpc05hTihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNOYU4oYikpIHJldHVybiBiO1xcblwiLEFERD1cInJldHVybiBhICsgYjtcIixTVUI9XCJyZXR1cm4gYSAtIGI7XCIsTVVMPVwicmV0dXJuIGEgKiBiO1wiLERJVj1cImlmIChhID09IGIpIHJldHVybiAxLjA7XFxuICByZXR1cm4gYSAvIGI7XCIsSU5UX0RJVj1cIlxcbiAgZmxvYXQgcmVzdWx0U2lnbiA9IHNpZ24oYSkgKiBzaWduKGIpO1xcbiAgaW50IGlhID0gcm91bmQoYSk7XFxuICBpbnQgaWIgPSByb3VuZChiKTtcXG4gIGludCByZXN1bHQgPSBpYSAvIGliO1xcbiAgaW50IGFtb2RiID0gaWEgLSBpYiAqIHJlc3VsdDtcXG5cXG4gIGlmIChyZXN1bHRTaWduIDwgMC4wICYmIGFtb2RiICE9IDApIHtcXG4gICAgcmVzdWx0IC09IDE7XFxuICB9XFxuICByZXR1cm4gZmxvYXQocmVzdWx0KTtcXG5cIixQT1c9XCJcXG5pZihhIDwgMC4wICYmIGZsb29yKGIpIDwgYil7XFxuICByZXR1cm4gTkFOO1xcbn1cXG5yZXR1cm4gKHJvdW5kKG1vZChiLCAyLjApKSA9PSAwIHx8IHJvdW5kKG1vZChiLCAyLjApKSA9PSAyKSA/XFxuICAgIHBvdyhhYnMoYSksIGIpIDogc2lnbihhKSAqIHBvdyhhYnMoYSksIGIpO1xcblwiLFNRVUFSRURfRElGRkVSRU5DRT1cInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIixFUVVBTD1cInJldHVybiBmbG9hdChhID09IGIpO1wiLE5PVF9FUVVBTD1cInJldHVybiBmbG9hdChhICE9IGIpO1wiLExFU1M9XCJyZXR1cm4gZmxvYXQoYSA8IGIpO1wiLExFU1NfRVFVQUw9XCJyZXR1cm4gZmxvYXQoYSA8PSBiKTtcIixHUkVBVEVSPVwicmV0dXJuIGZsb2F0KGEgPiBiKTtcIixHUkVBVEVSX0VRVUFMPVwicmV0dXJuIGZsb2F0KGEgPj0gYik7XCIsTE9HSUNBTF9BTkQ9XCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1wiLExPR0lDQUxfT1I9XCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgfHwgYiA+PSAxLjApO1wiLE1BWD1DSEVDS19OQU5fU05JUFBFVCtcIlxcbiAgcmV0dXJuIG1heChhLCBiKTtcXG5cIixNSU49Q0hFQ0tfTkFOX1NOSVBQRVQrXCJcXG4gIHJldHVybiBtaW4oYSwgYik7XFxuXCIsTU9EPVwiaWYgKGIgPT0gMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIG1vZChhLCBiKTtcIixBVEFOMj1DSEVDS19OQU5fU05JUFBFVCtcIlxcbiAgcmV0dXJuIGF0YW4oYSwgYik7XFxuXCIsRUxVX0RFUj1cInJldHVybiAoYiA+PSAxLjApID8gYSA6IGEgKiAoYiArIDEuMCk7XCIsQmluYXJ5T3BQcm9ncmFtPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChhLGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZz0hMCx0aGlzLm91dHB1dFNoYXBlPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsdCksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgTkFOO1xcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIithK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7bnVsbD09YS5zdGFydExvYyYmKGEuc3RhcnRMb2M9ZS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHQsXCJOQU5cIiksbnVsbD09YS5zdGFydExvYyl8fGUuZ2wudW5pZm9ybTFmKGEuc3RhcnRMb2MsTmFOKX19LHR9KCksQ2xpcFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSxlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9YSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCBmbG9hdChcIitlK1wiKSwgZmxvYXQoXCIrdCtcIikpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxDb21wbGV4QWJzUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHJlYWwgPSBnZXRSZWFsQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGltYWcgPSBnZXRJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzIgdiA9IHZlYzIocmVhbCwgaW1hZyk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoc3FydChkb3QodiwgdikpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxDb25jYXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWNvbXB1dGVPdXRTaGFwZShbYSxlXSwxKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgeVIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xcblxcbiAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICBpZiAoeUMgPCBcIithWzFdK1wiKSB7XFxuICAgICAgICAgIHZhbHVlID0gZ2V0QSh5UiwgeUMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgeUMgLT0gXCIrYVsxXStcIjtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRCKHlSLCB5Qyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLENvbnYyRERlckZpbHRlclByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9YS5maWx0ZXJTaGFwZTt2YXIgZT1hLnN0cmlkZUhlaWdodCx0PWEuc3RyaWRlV2lkdGgscj1hLnBhZEluZm8udG9wLG49YS5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIithLmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIithLm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIitlK1wiIC0gXCIrcitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK2EuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrYS5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK3QrXCIgLSBcIituK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIithLmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksQ29udjJERGVySW5wdXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHMpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXMuaW5TaGFwZTt2YXIgZT1zLmZpbHRlckhlaWdodCx0PXMuZmlsdGVyV2lkdGgscj1zLnN0cmlkZUhlaWdodCxuPXMuc3RyaWRlV2lkdGgsbz1lLTEtcy5wYWRJbmZvLnRvcCxhPXQtMS1zLnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK28rXCIsIFwiK2ErXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2UrXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIitzLm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrZStcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3QrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIituK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrcy5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIit0K1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIitzLm91dENoYW5uZWxzK1wiOyBkMisrKSB7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24ocyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9cy5maWx0ZXJTaGFwZTt2YXIgZT1zLnN0cmlkZUhlaWdodCx0PXMuc3RyaWRlV2lkdGgscj1zLnBhZEluZm8udG9wLG49cy5wYWRJbmZvLmxlZnQsbz1zLm91dENoYW5uZWxzL3MuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZG0gPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGQxICogXCIrbytcIiArIGRtO1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIC8vIFRPRE86IFZlYzQgb3ZlciB0aGUgYmF0Y2ggc2l6ZVxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIitzLmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIitzLm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIitlK1wiIC0gXCIrcitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3MuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrcy5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK3QrXCIgLSBcIituK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIitzLmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHApe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXAuaW5TaGFwZTt2YXIgZT1wLmZpbHRlckhlaWdodCx0PXAuZmlsdGVyV2lkdGgscj1wLnN0cmlkZUhlaWdodCxuPXAuc3RyaWRlV2lkdGgsbz1lLTEtcC5wYWRJbmZvLnRvcCxhPXQtMS1wLnBhZEluZm8ubGVmdCxpPXAub3V0Q2hhbm5lbHMvcC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitlK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrcC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK2UrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit0K1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbitcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Aub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrdCtcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAvLyBUT0RPOiBWZWM0IG92ZXIgdGhlIGNoYW5uZWxNdWxcXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgXCIraStcIjsgZG0rKykge1xcbiAgICAgICAgICAgICAgaW50IGQyID0gZDEgKiBcIitpK1wiICsgZG07XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLENvbnYyRFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24ocCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT1wLm91dFNoYXBlO3ZhciBlPXAucGFkSW5mby50b3AsdD1wLnBhZEluZm8ubGVmdCxyPXAuc3RyaWRlSGVpZ2h0LG49cC5zdHJpZGVXaWR0aCxvPXAuZGlsYXRpb25IZWlnaHQsYT1wLmRpbGF0aW9uV2lkdGgsaT1wLmZpbHRlckhlaWdodCxzPXAuZmlsdGVyV2lkdGgsZD00Kl9NYXRoZmxvb3IocC5pbkNoYW5uZWxzLzQpLGw9cC5pbkNoYW5uZWxzJTQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIityK1wiLCBcIituK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrZStcIiwgXCIrdCtcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitpK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIitvK1wiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3AuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrcytcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIithK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrcC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiK2QrXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKFwiKygxPT1sKStcIikge1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2QrXCIpICpcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2QrXCIsIGQyKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT1sKStcIikge1xcbiAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitkK1wiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitkK1wiICsgMSlcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZCtcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PWwpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2QrXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2QrXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitkK1wiICsgMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrZCtcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2QrXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxEZXB0aHdpc2VDb252MkRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9ZC5vdXRTaGFwZTt2YXIgZT1kLmluSGVpZ2h0LHQ9ZC5pbldpZHRoLHI9ZC5wYWRJbmZvLnRvcCxuPWQucGFkSW5mby5sZWZ0LG89ZC5zdHJpZGVIZWlnaHQsYT1kLnN0cmlkZVdpZHRoLGk9ZC5kaWxhdGlvbkhlaWdodCxzPWQuZGlsYXRpb25XaWR0aCx1PWQuZmlsdGVySGVpZ2h0LGw9ZC5maWx0ZXJXaWR0aCxjPWQub3V0Q2hhbm5lbHMvZC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK3IrXCIsIFwiK24rXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDIgLyBcIitjK1wiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIrYytcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE9ETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrdStcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIraStcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIitlK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2wrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrcytcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcod1IsIHdDLCBkMSwgcSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLENyb3BBbmRSZXNpemVQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGIsZSx0LHIsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCIsXCJCb3hlc1wiLFwiQm94SW5kXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89YlswXSxhPWJbMV0saT1iWzJdLHM9YlszXSx1PWVbMF0sbD10WzBdLGM9dFsxXTt0aGlzLm91dHB1dFNoYXBlPVt1LGwsYyxzXTt2YXIgcD1cImJpbGluZWFyXCI9PT1yPzE6MCxkPVthLTErXCIuMFwiLGktMStcIi4wXCJdLGg9ZFswXSxmPWRbMV0sbT0xPGw/W1wiXCIrKGEtMSkvKGwtMSksXCIoeTIteTEpICogaGVpZ2h0X3JhdGlvXCIsXCJ5MSpcIitoK1wiICsgZmxvYXQoeSkqKGhlaWdodF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh5MSt5MikgKiBcIitoXSxnPW1bMF0sTj1tWzFdLHk9bVsyXSx4PTE8Yz9bXCJcIisoaS0xKS8oYy0xKSxcIih4Mi14MSkgKiB3aWR0aF9yYXRpb1wiLFwieDEqXCIrZitcIiArIGZsb2F0KHgpKih3aWR0aF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh4MSt4MikgKiBcIitmXSxJPXhbMF0sdj14WzFdLEM9eFsyXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0X3JhdGlvID0gZmxvYXQoXCIrZytcIik7XFxuICAgICAgY29uc3QgZmxvYXQgd2lkdGhfcmF0aW8gPSBmbG9hdChcIitJK1wiKTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgLy8gZ2V0IGJveCB2YWxzXFxuICAgICAgICBmbG9hdCB5MSA9IGdldEJveGVzKGIsMCk7XFxuICAgICAgICBmbG9hdCB4MSA9IGdldEJveGVzKGIsMSk7XFxuICAgICAgICBmbG9hdCB5MiA9IGdldEJveGVzKGIsMik7XFxuICAgICAgICBmbG9hdCB4MiA9IGdldEJveGVzKGIsMyk7XFxuXFxuICAgICAgICAvLyBnZXQgaW1hZ2UgaW4gYmF0Y2ggaW5kZXhcXG4gICAgICAgIGludCBiSW5kID0gcm91bmQoZ2V0Qm94SW5kKGIpKTtcXG4gICAgICAgIGlmKGJJbmQgPCAwIHx8IGJJbmQgPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCBoZWlnaHRfc2NhbGUgPSBcIitOK1wiO1xcbiAgICAgICAgZmxvYXQgd2lkdGhfc2NhbGUgPSBcIit2K1wiO1xcblxcbiAgICAgICAgZmxvYXQgaW5feSA9IFwiK3krXCI7XFxuICAgICAgICBpZiggaW5feSA8IDAuMCB8fCBpbl95ID4gXCIraCtcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgaW5feCA9IFwiK0MrXCI7XFxuICAgICAgICBpZiggaW5feCA8IDAuMCB8fCBpbl94ID4gXCIrZitcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoaW5feSxpbl94KTtcXG4gICAgICAgIGlmKFwiK3ArXCIgPT0gMSkge1xcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgICAgaXZlYzIgc291cmNlRmxvb3JSQyA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleFJDKTtcXG4gICAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG5cXG4gICAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZU5lYXJlc3RSQyA9IGl2ZWMyKGZsb29yKFxcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleFJDICsgdmVjMigwLjUsMC41KSkpO1xcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEltYWdlKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCk7XFxuICAgICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19KCksU0FNUExFXzFEX1NOSVBQRVQ9XCJcXG52ZWMyIFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG52ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcXG4gIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixTQU1QTEVfMkRfU05JUFBFVD1cIlxcbnZlYzIgVVZmcm9tMkQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgbnVtQywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gcm93ICogbnVtQyArIGNvbDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcbnZlYzIgcGFja2VkVVZmcm9tMkQoaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IHRleE51bVIsXFxuICBpbnQgdGV4TnVtQywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsU0FNUExFXzNEX1NOSVBQRVQ9XCJcXG52ZWMyIFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICsgZGVwdGg7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG52ZWMyIHBhY2tlZFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQyxcXG4gICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxcbiAgICBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSBiICogdGV4ZWxzSW5CYXRjaCArIChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLFNBTVBMRV80RF9TTklQUEVUPVwiXFxudmVjMiBVVmZyb200RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHN0cmlkZTIsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgaW50IGRlcHRoMikge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aCAqIHN0cmlkZTIgKyBkZXB0aDI7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG52ZWMyIHBhY2tlZFVWZnJvbTREKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHRleGVsc0luQmF0Y2gyLFxcbiAgICBpbnQgdGV4ZWxzSW5CYXRjaCwgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IGIyLCBpbnQgYixcXG4gICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gYjIgKiB0ZXhlbHNJbkJhdGNoMiArIGIgKiB0ZXhlbHNJbkJhdGNoICtcXG4gICAgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsU0FNUExFXzVEX1NOSVBQRVQ9XCJcXG52ZWMyIFVWZnJvbTVEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgc3RyaWRlMiwgaW50IHN0cmlkZTMsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgK1xcbiAgICAgICAgICAgICAgZGVwdGggKiBzdHJpZGUyICsgZGVwdGgyICogc3RyaWRlMyArIGRlcHRoMztcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLFNBTVBMRV82RF9TTklQUEVUPVwiXFxudmVjMiBVVmZyb202RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHN0cmlkZTIsIGludCBzdHJpZGUzLCBpbnQgc3RyaWRlNCxcXG4gICAgaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoICogc3RyaWRlMiArIGRlcHRoMiAqXFxuICAgIHN0cmlkZTMgKyBkZXB0aDMgKiBzdHJpZGU0ICsgZGVwdGg0O1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVD1cIlxcbiAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcXG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICB9XFxuXCIsRkxPQVRfVEVYVFVSRV9TRVRfUl9TTklQUEVUPVwiXFxuICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgfVxcblwiLEZMT0FUX1RFWFRVUkVfU0VUX1JHQkFfU05JUFBFVD1cIlxcbiAgdm9pZCBzZXRPdXRwdXQodmVjNCB2YWwpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmFsO1xcbiAgfVxcblwiLFNIQURFUl9QUkVGSVg9XCJcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xcblxcbiAgc3RydWN0IGl2ZWM1XFxuICB7XFxuICAgIGludCB4O1xcbiAgICBpbnQgeTtcXG4gICAgaW50IHo7XFxuICAgIGludCB3O1xcbiAgICBpbnQgdTtcXG4gIH07XFxuXFxuICBzdHJ1Y3QgaXZlYzZcXG4gIHtcXG4gICAgaW50IHg7XFxuICAgIGludCB5O1xcbiAgICBpbnQgejtcXG4gICAgaW50IHc7XFxuICAgIGludCB1O1xcbiAgICBpbnQgdjtcXG4gIH07XFxuXFxuICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xcbiAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XFxuICB9XFxuXFxuICBib29sIGhhc05hTih2ZWM0IHZhbHVlcykge1xcbiAgICB2ZWM0IHYxID0gdmFsdWVzICogdmFsdWVzO1xcbiAgICB2ZWM0IHYyID0gdmFsdWVzICogdmFsdWVzO1xcbiAgICByZXR1cm4gYW55KG5vdEVxdWFsKHYxLCB2MikpO1xcbiAgfVxcblxcbiAgZmxvYXQgZ2V0TmFOKHZlYzQgdmFsdWVzKSB7XFxuICAgIHJldHVybiBkb3QodmVjNCgxKSwgdmFsdWVzKTtcXG4gIH1cXG5cXG4gIGludCByb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICB9XFxuXFxuICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcXG4gICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gIH1cXG5cXG4gIC8vQmFzZWQgb24gdGhlIHdvcmsgb2YgRGF2ZSBIb3NraW5zXFxuICAvL2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80ZGpTUldcXG4gICNkZWZpbmUgSEFTSFNDQUxFMSA0NDMuODk3NVxcbiAgZmxvYXQgcmFuZG9tKGZsb2F0IHNlZWQpe1xcbiAgICB2ZWMyIHAgPSByZXN1bHRVViAqIHNlZWQ7XFxuICAgIHZlYzMgcDMgID0gZnJhY3QodmVjMyhwLnh5eCkgKiBIQVNIU0NBTEUxKTtcXG4gICAgcDMgKz0gZG90KHAzLCBwMy55enggKyAxOS4xOSk7XFxuICAgIHJldHVybiBmcmFjdCgocDMueCArIHAzLnkpICogcDMueik7XFxuICB9XFxuXFxuICBcIitTQU1QTEVfMURfU05JUFBFVCtcIlxcbiAgXCIrU0FNUExFXzJEX1NOSVBQRVQrXCJcXG4gIFwiK1NBTVBMRV8zRF9TTklQUEVUK1wiXFxuICBcIitTQU1QTEVfNERfU05JUFBFVCtcIlxcbiAgXCIrU0FNUExFXzVEX1NOSVBQRVQrXCJcXG4gIFwiK1NBTVBMRV82RF9TTklQUEVUK1wiXFxuXCIsU0hBREVSX1BBQ0tFRF9QUkVGSVg9XCJcXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xcbiAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XFxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XFxuICB9XFxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xcbiAgICBmbG9hdCBtb2RDb29yZCA9IG1vZChmbG9hdChkaW0pLCAyLik7XFxuICAgIHJldHVybiBtb2RDb29yZCA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZztcXG4gIH1cXG5cIixDdW1TdW1Qcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHMsZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPXM7dmFyIHI9cy5sZW5ndGgsbj1zW3MubGVuZ3RoLTFdLG89dD9cIjxcIjpcIj5cIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgaW50IGdldEluZGV4KGludCBpKSB7XFxuICAgICAgICBcIisodD9cInJldHVybiBcIituK1wiIC1pIC0gMTtcIjpcInJldHVybiBpO1wiKStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitnZXRDb29yZHNEYXRhVHlwZShyKStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBlbmQgPSBcIitnZXRGaW5hbENvb3JkKHIsXCJjb29yZHNcIikrXCI7XFxuICAgICAgICBmbG9hdCB2YWwgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBpID0gXCIrbitcIiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XFxuICAgICAgICAgIGludCBpZHggPSBnZXRJbmRleChpKTtcXG4gICAgICAgICAgaWYgKGlkeCBcIitvK1wiIGVuZCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChpZHggPT0gZW5kICYmIFwiK2UrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBcIitnZXRGaW5hbENvb3JkKHIsXCJjb29yZHNcIikrXCIgPSBpZHg7XFxuICAgICAgICAgIHZhbCArPSBnZXRYKFwiK2dldENvb3JkcyhyLFwiY29vcmRzXCIpK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLERlcHRoVG9TcGFjZVByb2dyYW09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEsZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9YSx0aGlzLmJsb2NrU2l6ZT1lLHRoaXMuZGF0YUZvcm1hdD10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgIGludCBoID0gXCIrdGhpcy5nZXRIZWlnaHRDb29yZFN0cmluZygpK1wiO1xcbiAgICAgIGludCB3ID0gXCIrdGhpcy5nZXRXaWR0aENvb3JkU3RyaW5nKCkrXCI7XFxuICAgICAgaW50IGQgPSBcIit0aGlzLmdldERlcHRoQ29vcmRTdHJpbmcoKStcIjtcXG5cXG4gICAgICBpbnQgaW5faCA9IGggLyBcIitlK1wiO1xcbiAgICAgIGludCBvZmZzZXRfaCA9IGltb2QoaCwgXCIrZStcIik7XFxuICAgICAgaW50IGluX3cgPSB3IC8gXCIrZStcIjtcXG4gICAgICBpbnQgb2Zmc2V0X3cgPSBpbW9kKHcsIFwiK2UrXCIpO1xcbiAgICAgIGludCBvZmZzZXRfZCA9IChvZmZzZXRfaCAqIFwiK2UrXCIgKyBvZmZzZXRfdykgKlxcbiAgICAgICAgXCIrdGhpcy5nZXRPdXRwdXREZXB0aFNpemUoKStcIjtcXG4gICAgICBpbnQgaW5fZCA9IGQgKyBvZmZzZXRfZDtcXG5cXG4gICAgICBmbG9hdCByZXN1bHQgPSBcIit0aGlzLmdldElucHV0U2FtcGxpbmdTdHJpbmcoKStcIjtcXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgfVxcbiAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEhlaWdodENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMV1cIjpcImNvb3Jkc1syXVwifSx0LnByb3RvdHlwZS5nZXRXaWR0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMl1cIjpcImNvb3Jkc1szXVwifSx0LnByb3RvdHlwZS5nZXREZXB0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbM11cIjpcImNvb3Jkc1sxXVwifSx0LnByb3RvdHlwZS5nZXRPdXRwdXREZXB0aFNpemU9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD90aGlzLm91dHB1dFNoYXBlWzNdOnRoaXMub3V0cHV0U2hhcGVbMV19LHQucHJvdG90eXBlLmdldElucHV0U2FtcGxpbmdTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImdldFgoYiwgaW5faCwgaW5fdywgaW5fZClcIjpcImdldFgoYiwgaW5fZCwgaW5faCwgaW5fdylcIn0sdH0oKSxFbmNvZGVGbG9hdFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICAgIGNvbnN0IGZsb2F0IEZMT0FUX01JTiA9IDEuMTc1NDk0MzVlLTM4O1xcblxcbiAgICAgIGxvd3AgdmVjNCBlbmNvZGVfZmxvYXQoaGlnaHAgZmxvYXQgdikge1xcbiAgICAgICAgaWYgKGlzTmFOKHYpKSB7XFxuICAgICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcXG5cXG4gICAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XFxuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaGlnaHAgdmVjNCBjID0gdmVjNCgwLDAsMCwwKTtcXG5cXG4gICAgICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XFxuICAgICAgICBtIC09IGNbMl0gLyAxMjguMDtcXG4gICAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xcbiAgICAgICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xcblxcbiAgICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgICBjWzNdID0gZmxvb3IoZWJpYXMgLyAyLjApO1xcbiAgICAgICAgZWJpYXMgLT0gY1szXSAqIDIuMDtcXG4gICAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcXG5cXG4gICAgICAgIHJldHVybiBjIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGVuY29kZV9mbG9hdCh4KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxDT01QTEVYX0ZGVD17UkVBTDpcInJldHVybiByZWFsICogZXhwUiAtIGltYWcgKiBleHBJO1wiLElNQUc6XCJyZXR1cm4gcmVhbCAqIGV4cEkgKyBpbWFnICogZXhwUjtcIn0sRkZUUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihzLGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInJlYWxcIixcImltYWdcIl07dmFyIHI9ZVsxXTt0aGlzLm91dHB1dFNoYXBlPWU7dmFyIG49dD9cIjIuMCAqIFwiK19NYXRoUEk6XCItMi4wICogXCIrX01hdGhQSSxvPXQ/citcIi4wXCI6XCIxLjBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyID0gXCIrbitcIjtcXG5cXG4gICAgICBmbG9hdCB1bmFyeU9wQ29tcGxleChmbG9hdCByZWFsLCBmbG9hdCBleHBSLCBmbG9hdCBpbWFnLCBmbG9hdCBleHBJKSB7XFxuICAgICAgICBcIitzK1wiXFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IG11bE1hdERGVChpbnQgYmF0Y2gsIGludCBpbmRleCkge1xcbiAgICAgICAgZmxvYXQgaW5kZXhSYXRpbyA9IGZsb2F0KGluZGV4KSAvIGZsb2F0KFwiK3IrXCIpO1xcbiAgICAgICAgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvID1cXG4gICAgICAgICAgICBleHBvbmVudE11bHRpcGxpZXIgKiBpbmRleFJhdGlvO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIityK1wiOyBpKyspIHtcXG4gICAgICAgICAgLy8geCA9ICgtMnwyICogUEkgLyBOKSAqIGluZGV4ICogaTtcXG4gICAgICAgICAgZmxvYXQgeCA9IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyAqIGZsb2F0KGkpO1xcbiAgICAgICAgICBmbG9hdCBleHBSID0gY29zKHgpO1xcbiAgICAgICAgICBmbG9hdCBleHBJID0gc2luKHgpO1xcbiAgICAgICAgICBmbG9hdCByZWFsID0gZ2V0UmVhbChiYXRjaCwgaSk7XFxuICAgICAgICAgIGZsb2F0IGltYWcgPSBnZXRJbWFnKGJhdGNoLCBpKTtcXG5cXG4gICAgICAgICAgcmVzdWx0ICs9XFxuICAgICAgICAgICAgICB1bmFyeU9wQ29tcGxleChyZWFsLCBleHBSLCBpbWFnLCBleHBJKSAvIFwiK28rXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChtdWxNYXRERlQoY29vcmRzWzBdLCBjb29yZHNbMV0pKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxGcm9tUGl4ZWxzUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgZT1hWzBdLHQ9YVsxXTt0aGlzLm91dHB1dFNoYXBlPWEsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK3QrXCIuMCwgXCIrZStcIi4wKTtcXG5cXG4gICAgICAgIHZlYzQgdmFsdWVzID0gdGV4dHVyZTJEKEEsIHV2KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlO1xcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMucjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMSkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAyKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDMpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChmbG9vcih2YWx1ZSAqIDI1NS4wICsgMC41KSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksR2F0aGVyUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihzLGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcImluZGljZXNcIl07dmFyIHI9cy5zbGljZSgpO3JbdF09ZSx0aGlzLm91dHB1dFNoYXBlPXIsdGhpcy5yYW5rPXIubGVuZ3RoO3ZhciBuPWdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayksbz1nZXRTb3VyY2VDb29yZHMocyx0KTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbitcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrbytcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEdhdGhlck5EUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihzLGUsdCl7dGhpcy5zbGljZURpbT1zLHRoaXMuc3RyaWRlcz1lLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgcj1nZXRDb29yZHNEYXRhVHlwZShlLmxlbmd0aCksbj1nZXRDb29yZHNEYXRhVHlwZSh0Lmxlbmd0aCksbz0xPHRoaXMuc2xpY2VEaW0/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrcitcIiBzdHJpZGVzID0gXCIrcitcIihcIit0aGlzLnN0cmlkZXMrXCIpO1xcbiAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrbitcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGZsYXR0ZW5JbmRleCA9IDA7XFxuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrdGhpcy5zbGljZURpbStcIjsgaisrKSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHNbMF0sIGopKTtcXG4gICAgICAgICAgICBmbGF0dGVuSW5kZXggKz0gaW5kZXggKiBcIitvK1wiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKGZsYXR0ZW5JbmRleCwgY29vcmRzWzFdKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9fSgpLFRleHR1cmVVc2FnZSxQaHlzaWNhbFRleHR1cmVUeXBlOyFmdW5jdGlvbih0KXt0W3QuUkVOREVSPTBdPVwiUkVOREVSXCIsdFt0LlVQTE9BRD0xXT1cIlVQTE9BRFwiLHRbdC5QSVhFTFM9Ml09XCJQSVhFTFNcIix0W3QuRE9XTkxPQUQ9M109XCJET1dOTE9BRFwifShUZXh0dXJlVXNhZ2V8fChUZXh0dXJlVXNhZ2U9e30pKSxmdW5jdGlvbih0KXt0W3QuVU5QQUNLRURfRkxPQVQxNj0wXT1cIlVOUEFDS0VEX0ZMT0FUMTZcIix0W3QuVU5QQUNLRURfRkxPQVQzMj0xXT1cIlVOUEFDS0VEX0ZMT0FUMzJcIix0W3QuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFPTJdPVwiUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFXCIsdFt0LlBBQ0tFRF8yWDJfRkxPQVQzMj0zXT1cIlBBQ0tFRF8yWDJfRkxPQVQzMlwiLHRbdC5QQUNLRURfMlgyX0ZMT0FUMTY9NF09XCJQQUNLRURfMlgyX0ZMT0FUMTZcIn0oUGh5c2ljYWxUZXh0dXJlVHlwZXx8KFBoeXNpY2FsVGV4dHVyZVR5cGU9e30pKTt2YXIgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkPSExLGxpbmVOdW1iZXJSZWdleD0vRVJST1I6IFswLTldKzooWzAtOV0rKTovZyx3ZWJnbF91dGlsPU9iamVjdC5mcmVlemUoe2NhbGxBbmRDaGVjazpjYWxsQW5kQ2hlY2ssZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmc6ZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcsY2hlY2tXZWJHTEVycm9yOmNoZWNrV2ViR0xFcnJvcixnZXRXZWJHTEVycm9yTWVzc2FnZTpnZXRXZWJHTEVycm9yTWVzc2FnZSxnZXRFeHRlbnNpb25PclRocm93OmdldEV4dGVuc2lvbk9yVGhyb3csY3JlYXRlVmVydGV4U2hhZGVyOmNyZWF0ZVZlcnRleFNoYWRlcixjcmVhdGVGcmFnbWVudFNoYWRlcjpjcmVhdGVGcmFnbWVudFNoYWRlcixjcmVhdGVQcm9ncmFtOmNyZWF0ZVByb2dyYW0sbGlua1Byb2dyYW06bGlua1Byb2dyYW0sdmFsaWRhdGVQcm9ncmFtOnZhbGlkYXRlUHJvZ3JhbSxjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXI6Y3JlYXRlU3RhdGljVmVydGV4QnVmZmVyLGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyOmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyLGdldE51bUNoYW5uZWxzOmdldE51bUNoYW5uZWxzLGNyZWF0ZVRleHR1cmU6Y3JlYXRlVGV4dHVyZSx2YWxpZGF0ZVRleHR1cmVTaXplOnZhbGlkYXRlVGV4dHVyZVNpemUsY3JlYXRlRnJhbWVidWZmZXI6Y3JlYXRlRnJhbWVidWZmZXIsYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTpiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlLGJpbmRUZXh0dXJlVW5pdDpiaW5kVGV4dHVyZVVuaXQsdW5iaW5kVGV4dHVyZVVuaXQ6dW5iaW5kVGV4dHVyZVVuaXQsZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c6Z2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3csZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbjpnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uLGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI6YmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcixiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjpiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcixiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjpiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcix1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI6dW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyLHZhbGlkYXRlRnJhbWVidWZmZXI6dmFsaWRhdGVGcmFtZWJ1ZmZlcixnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTpnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZSxnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlOmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUsaXNSZXNoYXBlRnJlZTppc1Jlc2hhcGVGcmVlfSksZ3BncHVfdXRpbD1PYmplY3QuZnJlZXplKHtjcmVhdGVWZXJ0ZXhTaGFkZXI6Y3JlYXRlVmVydGV4U2hhZGVyJDEsY3JlYXRlVmVydGV4QnVmZmVyOmNyZWF0ZVZlcnRleEJ1ZmZlcixjcmVhdGVJbmRleEJ1ZmZlcjpjcmVhdGVJbmRleEJ1ZmZlcixnZXRUZXh0dXJlQ29uZmlnOmdldFRleHR1cmVDb25maWcsY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU6Y3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUsY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU6Y3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUsY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU6Y3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUsY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZTpjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlLGNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlOmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlLGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtczpiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMsdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlOnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSx1cGxvYWRNYXRyaXhUb1RleHR1cmU6dXBsb2FkTWF0cml4VG9UZXh0dXJlLHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZTp1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUsbWF5YmVDcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZTptYXliZUNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlLGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI6ZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcixkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTpkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSxkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTpkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSxkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlOmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmV9KSxHUEdQVUNvbnRleHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMub3V0cHV0VGV4dHVyZT1udWxsLHRoaXMucHJvZ3JhbT1udWxsLHRoaXMuZGlzcG9zZWQ9ITEsdGhpcy5hdXRvRGVidWdWYWxpZGF0ZT0hMSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQ9ITEsdGhpcy5pdGVtc1RvUG9sbD1bXSx0aGlzLmdsPW51bGw9PXQ/Z2V0V2ViR0xDb250ZXh0KEVOVi5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpKTp0LDE9PT1FTlYuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKT8odGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb249Z2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLEVOVi5nZXQoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpfHwodGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPWdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCxcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksdGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSkpOnRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj1nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMudmVydGV4QnVmZmVyPWNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmdsKSx0aGlzLmluZGV4QnVmZmVyPWNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuZ2wpLHRoaXMuZnJhbWVidWZmZXI9Y3JlYXRlRnJhbWVidWZmZXIodGhpcy5nbCksdGhpcy50ZXh0dXJlQ29uZmlnPWdldFRleHR1cmVDb25maWcodGhpcy5nbCx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pfXJldHVybiB0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZighdGhpcy5kaXNwb3NlZCl7bnVsbCE9dGhpcy5wcm9ncmFtJiZjb25zb2xlLndhcm4oXCJEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLlwiKSxudWxsIT10aGlzLm91dHB1dFRleHR1cmUmJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggdGV4dHVyZS4gIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIG91dHB1dCBtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSBkaXNwb3NpbmcuXCIpO3ZhciBlPXRoaXMuZ2w7Y2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5maW5pc2goKX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmRlbGV0ZUZyYW1lYnVmZmVyKGEuZnJhbWVidWZmZXIpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG51bGwpfSksY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbnVsbCl9KSxjYWxsQW5kQ2hlY2soZSxmdW5jdGlvbigpe3JldHVybiBlLmRlbGV0ZUJ1ZmZlcihhLmluZGV4QnVmZmVyKX0pLHRoaXMuZGlzcG9zZWQ9ITB9fSx0LnByb3RvdHlwZS5lbmFibGVBdXRvbWF0aWNEZWJ1Z1ZhbGlkYXRpb249ZnVuY3Rpb24odCl7dGhpcy5hdXRvRGVidWdWYWxpZGF0ZT10LGVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKHQpfSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZT1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsYSxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUodGhpcy5nbCxhLGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZSh0aGlzLmdsLGEsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmU9ZnVuY3Rpb24oYSxlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdsLGEsZSl9LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUodGhpcy5nbCxhLGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZT1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUodGhpcy5nbCxhLGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuZGVsZXRlTWF0cml4VGV4dHVyZT1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5vdXRwdXRUZXh0dXJlPT09YSYmKHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcih0aGlzLmdsLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMub3V0cHV0VGV4dHVyZT1udWxsKSxjYWxsQW5kQ2hlY2sodGhpcy5nbCxmdW5jdGlvbigpe3JldHVybiBlLmdsLmRlbGV0ZVRleHR1cmUoYSl9KX0sdC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9UZXh0dXJlPWZ1bmN0aW9uKGEsZSx0LHIpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIG49Z2V0TnVtQ2hhbm5lbHMoKTtyZXR1cm4gdXBsb2FkTWF0cml4VG9UZXh0dXJlKHRoaXMuZ2wsYSxlLHQscixuLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZT1mdW5jdGlvbihhLGUsdCxyLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSh0aGlzLmdsLGEsZSx0LHIsbix0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZT1mdW5jdGlvbihhLGUsdCl7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcihhLGZ1bmN0aW9uKCl7cmV0dXJuIGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKHIuZ2wsZSx0LHIudGV4dHVyZUNvbmZpZyl9KX0sdC5wcm90b3R5cGUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU9ZnVuY3Rpb24oYSxlLHQpe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIoYSxmdW5jdGlvbigpe3JldHVybiBkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShyLmdsLGUsdCxyLnRleHR1cmVDb25maWcpfSl9LHQucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI9ZnVuY3Rpb24oYSxlLHQpe3JldHVybiBkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKHRoaXMuZ2wsYSxlLHQsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUubWF5YmVDcmVhdGVCdWZmZXJGcm9tVGV4dHVyZT1mdW5jdGlvbihhLGUsdCl7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoYSk7dmFyIHI9bWF5YmVDcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZSh0aGlzLmdsLGEsZSx0LHRoaXMudGV4dHVyZUNvbmZpZyk7cmV0dXJuIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKSxyfSx0LnByb3RvdHlwZS5jcmVhdGVBbmRXYWl0Rm9yRmVuY2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNyZWF0ZUZlbmNlKHRoaXMuZ2wpO3JldHVybiB0aGlzLnBvbGxGZW5jZSh0KX0sdC5wcm90b3R5cGUuY3JlYXRlRmVuY2U9ZnVuY3Rpb24ocyl7dmFyIGU9dGhpcyxuLGk7aWYoRU5WLmdldChcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIpKXt2YXIgcD1zLG89cC5mZW5jZVN5bmMocC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwwKTtzLmZsdXNoKCksaT1mdW5jdGlvbigpe3ZhciB0PXAuY2xpZW50V2FpdFN5bmMobywwLDApO3JldHVybiB0PT09cC5BTFJFQURZX1NJR05BTEVEfHx0PT09cC5DT05ESVRJT05fU0FUSVNGSUVEfSxuPW99ZWxzZSAwPEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT8obj10aGlzLmJlZ2luUXVlcnkoKSx0aGlzLmVuZFF1ZXJ5KCksaT1mdW5jdGlvbigpe3JldHVybiBlLmlzUXVlcnlBdmFpbGFibGUobixFTlYuZ2V0KFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpfSk6aT1mdW5jdGlvbigpe3JldHVybiEwfTtyZXR1cm57cXVlcnk6bixpc0ZlbmNlUGFzc2VkOml9fSx0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlPWZ1bmN0aW9uKHMsZSx0LHIsbixvKXt2YXIgYT10aGlzO3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHMsZnVuY3Rpb24oKXtyZXR1cm4gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShhLmdsLGUsdCxyLG4sbyxhLnRleHR1cmVDb25maWcpfSl9LHQucHJvdG90eXBlLmNyZWF0ZVByb2dyYW09ZnVuY3Rpb24oYSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgZT10aGlzLmdsLHQ9Y3JlYXRlRnJhZ21lbnRTaGFkZXIoZSxhKSxyPWNyZWF0ZVZlcnRleFNoYWRlciQxKGUpLG49Y3JlYXRlUHJvZ3JhbShlKTtyZXR1cm4gY2FsbEFuZENoZWNrKGUsZnVuY3Rpb24oKXtyZXR1cm4gZS5hdHRhY2hTaGFkZXIobixyKX0pLGNhbGxBbmRDaGVjayhlLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXR0YWNoU2hhZGVyKG4sdCl9KSxsaW5rUHJvZ3JhbShlLG4pLHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUmJnZhbGlkYXRlUHJvZ3JhbShlLG4pLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZHx8KHRoaXMuc2V0UHJvZ3JhbShuKSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQ9YmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGUsdGhpcy5wcm9ncmFtLHRoaXMudmVydGV4QnVmZmVyKSksbn0sdC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbT1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksYT09PXRoaXMucHJvZ3JhbSYmKHRoaXMucHJvZ3JhbT1udWxsKSxudWxsIT1hJiZjYWxsQW5kQ2hlY2sodGhpcy5nbCxmdW5jdGlvbigpe3JldHVybiBlLmdsLmRlbGV0ZVByb2dyYW0oYSl9KX0sdC5wcm90b3R5cGUuc2V0UHJvZ3JhbT1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5wcm9ncmFtPWEsbnVsbCE9dGhpcy5wcm9ncmFtJiZ0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlJiZ2YWxpZGF0ZVByb2dyYW0odGhpcy5nbCx0aGlzLnByb2dyYW0pLGNhbGxBbmRDaGVjayh0aGlzLmdsLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wudXNlUHJvZ3JhbShhKX0pfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb249ZnVuY3Rpb24oYSxlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0P2dldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KHRoaXMuZ2wsYSxlKTpnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uKHRoaXMuZ2wsYSxlKX0sdC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb249ZnVuY3Rpb24oYSxlKXt2YXIgdD10aGlzO3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGNhbGxBbmRDaGVjayh0aGlzLmdsLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2wuZ2V0QXR0cmliTG9jYXRpb24oYSxlKX0pfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24oYSxlKX0sdC5wcm90b3R5cGUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKGEsZSx0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpLGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIodGhpcy5nbCx0aGlzLnByb2dyYW0sYSxlLHQpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKGEsZSx0KXt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIoYSx0LGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHMsZSx0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciByPWdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KGUsdCksbj1yWzBdLG89clsxXTt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIocyxuLG8pfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbihhLGUsdCxyKXt0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKHQsYSxyLGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcInNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uIG5vdCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLmRlYnVnVmFsaWRhdGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnByb2dyYW0mJnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLHRoaXMucHJvZ3JhbSksdmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKX0sdC5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW09ZnVuY3Rpb24oKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO3ZhciB0PXRoaXMuZ2w7dGhpcy5hdXRvRGVidWdWYWxpZGF0ZSYmdGhpcy5kZWJ1Z1ZhbGlkYXRlKCksY2FsbEFuZENoZWNrKHQsZnVuY3Rpb24oKXtyZXR1cm4gdC5kcmF3RWxlbWVudHModC5UUklBTkdMRVMsNix0LlVOU0lHTkVEX1NIT1JULDApfSl9LHQucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjYWxsQW5kQ2hlY2sodGhpcy5nbCxmdW5jdGlvbigpe3JldHVybiB0LmdsLmZpbmlzaCgpfSl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24mJih0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbj1nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsMj09PUVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT9cIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIjpcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKSksdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb259LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmJlZ2luUXVlcnk9ZnVuY3Rpb24oKXtpZigyPT09RU5WLmdldChcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKXt2YXIgYT10aGlzLmdsLGU9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCksdD1hLmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIGEuYmVnaW5RdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQsdCksdH12YXIgcj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSxuPXIuY3JlYXRlUXVlcnlFWFQoKTtyZXR1cm4gci5iZWdpblF1ZXJ5RVhUKHIuVElNRV9FTEFQU0VEX0VYVCxuKSxufSx0LnByb3RvdHlwZS5lbmRRdWVyeT1mdW5jdGlvbigpe2lmKDIhPT1FTlYuZ2V0KFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpe3ZhciBhPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO2EuZW5kUXVlcnlFWFQoYS5USU1FX0VMQVBTRURfRVhUKX1lbHNle3ZhciBlPXRoaXMuZ2wsdD10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtlLmVuZFF1ZXJ5KHQuVElNRV9FTEFQU0VEX0VYVCl9fSx0LnByb3RvdHlwZS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lPWZ1bmN0aW9uKGEpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHJlcGVhdGVkVHJ5KGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGlzcG9zZWR8fGUuaXNRdWVyeUF2YWlsYWJsZShhLEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KV07Y2FzZSAxOnJldHVybiB0LnNlbnQoKSxbMix0aGlzLmdldFF1ZXJ5VGltZShhLEVOVi5nZXQoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSldO319KX0pfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWU9ZnVuY3Rpb24oYSxlKXtpZigwPT09ZSlyZXR1cm4gbnVsbDtpZigyPT09ZSl7dmFyIHQ9dGhpcy5nbDtyZXR1cm4gdC5nZXRRdWVyeVBhcmFtZXRlcihhLHQuUVVFUllfUkVTVUxUKS8xZTZ9dmFyIHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7cmV0dXJuIHIuZ2V0UXVlcnlPYmplY3RFWFQoYSxyLlFVRVJZX1JFU1VMVF9FWFQpLzFlNn0sdC5wcm90b3R5cGUuaXNRdWVyeUF2YWlsYWJsZT1mdW5jdGlvbihhLGUpe2lmKDA9PT1lKXJldHVybiEwO2lmKDI9PT1lKXt2YXIgdD10aGlzLmdsLHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCkscz10LmdldFF1ZXJ5UGFyYW1ldGVyKGEsdC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIoci5HUFVfRElTSk9JTlRfRVhUKSkscyYmIXRoaXMuZGlzam9pbnR9cmV0dXJuIHM9KHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCkpLmdldFF1ZXJ5T2JqZWN0RVhUKGEsci5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCksbnVsbD09dGhpcy5kaXNqb2ludCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIoci5HUFVfRElTSk9JTlRfRVhUKSkscyYmIXRoaXMuZGlzam9pbnR9LHQucHJvdG90eXBlLnBvbGxGZW5jZT1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0KXtlLmFkZEl0ZW1Ub1BvbGwoZnVuY3Rpb24oKXtyZXR1cm4gYS5pc0ZlbmNlUGFzc2VkKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIHQoKX0pfSl9LHQucHJvdG90eXBlLnBvbGxJdGVtcz1mdW5jdGlvbigpe2Zvcih2YXIgYT1iaW5TZWFyY2hMYXN0VHJ1ZSh0aGlzLml0ZW1zVG9Qb2xsLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc0RvbmVGbn0pKSxlPTA7ZTw9YTsrK2UpKDAsdGhpcy5pdGVtc1RvUG9sbFtlXS5yZXNvbHZlRm4pKCk7dGhpcy5pdGVtc1RvUG9sbD10aGlzLml0ZW1zVG9Qb2xsLnNsaWNlKGErMSl9LHQucHJvdG90eXBlLmFkZEl0ZW1Ub1BvbGw9ZnVuY3Rpb24oYSxlKXt2YXIgdD10aGlzO3RoaXMuaXRlbXNUb1BvbGwucHVzaCh7aXNEb25lRm46YSxyZXNvbHZlRm46ZX0pLDE8dGhpcy5pdGVtc1RvUG9sbC5sZW5ndGh8fHJlcGVhdGVkVHJ5KGZ1bmN0aW9uKCl7cmV0dXJuIHQucG9sbEl0ZW1zKCksMD09PXQuaXRlbXNUb1BvbGwubGVuZ3RofSl9LHQucHJvdG90eXBlLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbih0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHRoaXMuZ2wsdCx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlJiZ2YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpfSx0LnByb3RvdHlwZS51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbigpe251bGw9PXRoaXMub3V0cHV0VGV4dHVyZT91bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCx0aGlzLmZyYW1lYnVmZmVyKTooYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCx0aGlzLm91dHB1dFRleHR1cmUsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSYmdmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKSl9LHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyPWZ1bmN0aW9uKGEsZSl7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoYSk7dmFyIHQ9ZSgpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCksdH0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcj1mdW5jdGlvbihhLGUsdCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgcj10aGlzLmdsO2JpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHIsYSx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlJiZ2YWxpZGF0ZUZyYW1lYnVmZmVyKHIpLHRoaXMub3V0cHV0VGV4dHVyZT1hLGNhbGxBbmRDaGVjayhyLGZ1bmN0aW9uKCl7cmV0dXJuIHIudmlld3BvcnQoMCwwLGUsdCl9KSxjYWxsQW5kQ2hlY2socixmdW5jdGlvbigpe3JldHVybiByLnNjaXNzb3IoMCwwLGUsdCl9KX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXI9ZnVuY3Rpb24oYSxlLHQscil7dmFyIG49dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLGNhbGxBbmRDaGVjayh0aGlzLmdsLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZ2wuc2Npc3NvcihhLGUsdCxyKX0pfSx0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmRpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LlwiKX0sdC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbT1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMucHJvZ3JhbSl0aHJvdyBuZXcgRXJyb3IoXCJObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LlwiKX0sdH0oKSxJbTJDb2xQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKG0sZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPW07dmFyIHI9dC5maWx0ZXJXaWR0aCxuPXQuaW5DaGFubmVscyxvPXQuc3RyaWRlV2lkdGgsYT10LnN0cmlkZUhlaWdodCxpPXQucGFkSW5mbyxzPXQub3V0V2lkdGgsdT10LmRpbGF0aW9uV2lkdGgsbD10LmRpbGF0aW9uSGVpZ2h0LGM9aS5sZWZ0LHA9aS50b3AsZD1uKnI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuXFxuICAgICAgICBmb3IoaW50IHJvdz0wOyByb3c8PTE7IHJvdysrKSB7XFxuICAgICAgICAgIGZvcihpbnQgY29sPTA7IGNvbDw9MTsgY29sKyspIHtcXG4gICAgICAgICAgICBpbnQgYmxvY2tJbmRleCA9IHJjLnkgKyBjb2w7XFxuICAgICAgICAgICAgaW50IHBvcyA9IHJjLnggKyByb3c7XFxuXFxuICAgICAgICAgICAgaWYoYmxvY2tJbmRleCA+PSBcIittWzFdK1wiIHx8IHBvcyA+PSBcIittWzBdK1wiKSBjb250aW51ZTtcXG5cXG4gICAgICAgICAgICBpbnQgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gKFwiK3MrXCIpKSAqIFwiK2ErXCIgLSBcIitwK1wiO1xcbiAgICAgICAgICAgIGludCBkMCA9IG9mZnNldFkgKyBcIitsK1wiICogKHBvcyAvIFwiK2QrXCIpO1xcblxcbiAgICAgICAgICAgIGlmKGQwID49IFwiK2VbMF0rXCIgfHwgZDAgPCAwKSBjb250aW51ZTtcXG5cXG4gICAgICAgICAgICBpbnQgb2Zmc2V0WCA9IGludChtb2QoZmxvYXQoYmxvY2tJbmRleCksIFwiK3MrXCIuKSAqIFwiK28rXCIuIC0gXCIrYytcIi4pO1xcbiAgICAgICAgICAgIGludCBkMSA9IG9mZnNldFggKyBcIit1K1wiICogKGludChtb2QoZmxvYXQocG9zKSwgXCIrZCtcIi4pIC8gXCIrbitcIi4pKTtcXG5cXG4gICAgICAgICAgICBpZihkMSA+PSBcIitlWzFdK1wiIHx8IGQxIDwgMCkgY29udGludWU7XFxuXFxuICAgICAgICAgICAgcmVzdWx0W3JvdyAqIDIgKyBjb2xdID0gZ2V0QShkMCwgZDEsIGludChtb2QoZmxvYXQocG9zKSwgXCIrbitcIi4pKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifX0oKSxMUk5Qcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHAsZSx0LHIsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz1lLGk9cFszXS0xLHM7dGhpcy5vdXRwdXRTaGFwZT1wO3ZhciBsPVwiZmxvYXQoXCIrdCtcIikgKyBmbG9hdChcIityK1wiKSAqIHN1bVwiO3M9LjU9PT1uP1wiaW52ZXJzZXNxcnQoXCIrbCtcIilcIjoxPT09bj9cIjEuMC8oXCIrbCtcIilcIjpcImV4cChsb2coXCIrbCtcIikgKiBmbG9hdCgtXCIrbitcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFgoYiwgciwgYywgZCk7XFxuICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBqID0gLVwiK28rXCI7IGogPD0gXCIrbytcIjsgaisrKSB7XFxuICAgICAgICAgIGludCBpZHggPSBkICsgajtcXG4gICAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8PSAgXCIraStcIikge1xcbiAgICAgICAgICAgIGZsb2F0IHogPSBnZXRYKGIsIHIsIGMsIGlkeCk7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCB2YWwgPSB4ICogXCIrcytcIjtcXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLExSTkdyYWRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsZSx0LHIsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImlucHV0SW1hZ2VcIixcIm91dHB1dEltYWdlXCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9YSx0aGlzLmRlcHRoPWFbM10sdGhpcy5kZXB0aFJhZGl1cz1lLHRoaXMuYmlhcz10LHRoaXMuYWxwaGE9cix0aGlzLmJldGE9bix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBkID0gMDsgZCA8IFwiK3RoaXMuZGVwdGgrXCI7ICsrZCkge1xcbiAgICAgICAgICBpbnQgZGVwdGhCZWdpbiA9IGludChtYXgoMC4wLCBmbG9hdChkIC0gXCIrZStcIikpKTtcXG4gICAgICAgICAgaW50IGRlcHRoRW5kID0gaW50KG1pbihmbG9hdChcIit0aGlzLmRlcHRoK1wiKSxcXG4gICAgICAgICAgICAgIGZsb2F0KGQgKyBcIitlK1wiICsgMSkpKTtcXG5cXG4gICAgICAgICAgY29uc3QgaW50IE1JTl9ERVBUSF9CRUdJTiA9IDA7XFxuICAgICAgICAgIGNvbnN0IGludCBNQVhfREVQVEhfRU5EID0gXCIrdGhpcy5kZXB0aCtcIjtcXG5cXG4gICAgICAgICAgZmxvYXQgbm9ybSA9IDAuMDtcXG4gICAgICAgICAgZm9yIChpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsraykge1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCkge1xcbiAgICAgICAgICAgICAgbm9ybSArPSBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspICogZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbm9ybSA9IGZsb2F0KFwiK3IrXCIpICogbm9ybSArIGZsb2F0KFwiK3QrXCIpO1xcblxcbiAgICAgICAgICBmb3IoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spe1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCl7XFxuICAgICAgICAgICAgICBmbG9hdCBkeWkgPSAtMi4wICogZmxvYXQoXCIrcitcIilcXG4gICAgICAgICAgICAgICAgKiBmbG9hdChcIituK1wiKVxcbiAgICAgICAgICAgICAgICAqIGdldElucHV0SW1hZ2UoYiAsciAsYywgaykgKiBnZXRPdXRwdXRJbWFnZShiLCByLCBjLCBkKVxcbiAgICAgICAgICAgICAgICAvIG5vcm07XFxuICAgICAgICAgICAgICBpZiAoayA9PSBkKSB7XFxuICAgICAgICAgICAgICAgIGR5aSArPSBwb3cobm9ybSwgLTEuMCAqIFwiK24rXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKGsgPT0gY29vcmRzWzNdKSB7XFxuICAgICAgICAgICAgICAgIGR5aSAqPSBnZXREeShiLCByLCBjLCBkKTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGR5aTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHApe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9cC5pblNoYXBlO3ZhciBlPXAuc3RyaWRlSGVpZ2h0LHQ9cC5zdHJpZGVXaWR0aCxyPXAuZGlsYXRpb25IZWlnaHQsbj1wLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxvPXAuZWZmZWN0aXZlRmlsdGVyV2lkdGgsYT1uLTEtcC5wYWRJbmZvLnRvcCxpPW8tMS1wLnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2ErXCIsIFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK24rXCI7XFxuICAgICAgICAgIHdSICs9IFwiK3IrXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrZStcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIitwLm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrbytcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK3QrXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIitwLm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiKyhuKm8tMSkrXCIgLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIrbytcIiArIHdDO1xcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLE1hdE11bFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZCxlLG0saCl7dm9pZCAwPT09bSYmKG09ITEpLHZvaWQgMD09PWgmJihoPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wibWF0cml4QVwiLFwibWF0cml4QlwiXTt2YXIgdD1kWzBdLG89bT9kWzJdOmRbMV0sYT1oP2VbMV06ZVsyXSxpPW0/ZFsxXTpkWzJdO3RoaXMub3V0cHV0U2hhcGU9W3QsbyxhXTt2YXIgcz1mdW5jdGlvbihhLGUpe3JldHVybiBtP1wiYmF0Y2gsIFwiK2UrXCIgKyBcIithK1wiLCBhUm93XCI6XCJiYXRjaCwgYVJvdywgXCIrZStcIiArIFwiK2F9LHU9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gaD9cImJhdGNoLCBiQ29sLCBcIitlK1wiICsgXCIrYTpcImJhdGNoLCBcIitlK1wiICsgXCIrYStcIiwgYkNvbFwifSxsPTQqX01hdGhmbG9vcihpLzQpLGM9aSU0O3RoaXMudXNlckNvZGU9XCIgZmxvYXQgZG90QVJvd0JDb2woaW50IGJhdGNoLCBpbnQgYVJvdywgaW50IGJDb2wpIHtcXG4gICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitsK1wiOyBpICs9IDQpIHtcXG4gICAgICAgIHZlYzQgYSA9IHZlYzQoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIrcygwLFwiaVwiKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIrcygxLFwiaVwiKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIrcygyLFwiaVwiKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIrcygzLFwiaVwiKStcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWM0IGIgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK3UoMCxcImlcIikrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK3UoMSxcImlcIikrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK3UoMixcImlcIikrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK3UoMyxcImlcIikrXCIpXFxuICAgICAgICApO1xcblxcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFwiKygxPT1jKStcIikge1xcbiAgICAgICAgcmVzdWx0ICs9IGdldE1hdHJpeEEoXCIrcygwLGwpK1wiKSAqXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrdSgwLGwpK1wiKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiKygyPT1jKStcIikge1xcbiAgICAgICAgdmVjMiBhID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIitzKDAsbCkrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiK3MoMSxsKStcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMyIGIgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK3UoMCxsKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrdSgxLGwpK1wiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHJlc3VsdCArPSBkb3QoYSwgYik7XFxuICAgICAgfSBlbHNlIGlmIChcIisoMz09YykrXCIpIHtcXG4gICAgICAgIHZlYzMgYSA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIrcygwLGwpK1wiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIitzKDEsbCkrXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiK3MoMixsKStcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMzIGIgPSB2ZWMzKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiK3UoMCxsKStcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIrdSgxLGwpK1wiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIit1KDIsbCkrXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgaXZlYzMgcmVzQlJDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGRvdEFSb3dCQ29sKHJlc0JSQy54LCByZXNCUkMueSwgcmVzQlJDLnopKTtcXG4gICAgfVxcbiAgICBcIn19KCksTWF0TXVsUGFja2VkUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihwLGUsdCxyLGQpe3ZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1kJiYoZD0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIm1hdHJpeEFcIixcIm1hdHJpeEJcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10O3ZhciBtPXI/cFswXTpwWzFdLGE9X01hdGhjZWlsKG0vMiksaT1yP1wiaSAqIDIsIHJjLnhcIjpcInJjLngsIGkgKiAyXCIscz1kP1wicmMueSwgaSAqIDJcIjpcImkgKiAyLCByYy55XCIsdT1yP1tcImEueHh5eVwiLFwiYS56end3XCJdOltcImEueHh6elwiLFwiYS55eXd3XCJdLGw9ZD9bXCJiLnh6eHpcIixcImIueXd5d1wiXTpbXCJiLnh5eHlcIixcImIuend6d1wiXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgc2hhcmVkRGltZW5zaW9uID0gXCIrYStcIi4wO1xcblxcbiAgICAgIHZlYzQgZG90MngyQVJvd0JDb2woaXZlYzIgcmMpIHtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrYStcIjsgaSsrKSB7XFxuICAgICAgICAgIHZlYzQgYSA9IGdldE1hdHJpeEEoXCIraStcIik7XFxuICAgICAgICAgIHZlYzQgYiA9IGdldE1hdHJpeEIoXCIrcytcIik7XFxuXFxuICAgICAgICAgIHJlc3VsdCArPSAoXCIrdVswXStcIiAqIFwiK2xbMF0rXCIpICsgKFwiK3VbMV0rXCIgKiBcIitsWzFdK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZG90MngyQVJvd0JDb2wocmMpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxNdWx0aW5vbWlhbFByb2dyYW09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEsZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicHJvYnNcIl0sdGhpcy5vdXRwdXRTaGFwZT1bYSx0XSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBzZWVkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcblxcbiAgICAgICAgZmxvYXQgciA9IHJhbmRvbShzZWVkKTtcXG4gICAgICAgIGZsb2F0IGNkZiA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrKGUtMSkrXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIisoZS0xKStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbih0LHIpe251bGw9PWUuc2VlZExvYyYmKGUuc2VlZExvYz10LmdldFVuaWZvcm1Mb2NhdGlvbihyLFwic2VlZFwiKSksdC5nbC51bmlmb3JtMWYoZS5zZWVkTG9jLGEpfX0sdH0oKSxPbmVIb3RQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsZSx0LHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9W2EsZV0sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIityK1wiKSwgZmxvYXQoXCIrdCtcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFBhY2tQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHMpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9czt2YXIgZT1zLmxlbmd0aCx0PWdldENoYW5uZWxzKFwicmNcIixlKSxyPWdldENvb3Jkc0RhdGFUeXBlKGUpLG49Z2V0T3V0T2ZCb3VuZHNDb25kaXRpb24oZSxzLHQpLG89Z2V0U2V0dXAoZSxzW3MubGVuZ3RoLTFdLHNbcy5sZW5ndGgtMl0sdCksYT1nZXRPdXRwdXQocyx0KTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrcitcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgaWYoXCIrbitcIikge1xcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDApO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIrbytcIlxcblxcbiAgICAgICAgICBzZXRPdXRwdXQodmVjNChcIithK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19KCksUGFkUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihwLGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiBlWzBdK3BbdF0rZVsxXX0pO3ZhciByPXAubGVuZ3RoLG49Z2V0Q29vcmRzRGF0YVR5cGUociksbz1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pLmpvaW4oXCIsXCIpLGE9ZS5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVswXStwW3RdfSkuam9pbihcIixcIiksaT1bXCJjb29yZHNbMF1cIixcImNvb3Jkc1sxXVwiLFwiY29vcmRzWzJdXCIsXCJjb29yZHNbM11cIl0uc2xpY2UoMCxyKTt0aGlzLnVzZXJDb2RlPTE9PT1yP1wiXFxuICAgICAgICBpbnQgc3RhcnQgPSBcIitvK1wiO1xcbiAgICAgICAgaW50IGVuZCA9IFwiK2ErXCI7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGlmIChvdXRDIDwgc3RhcnQgfHwgb3V0QyA+PSBlbmQpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrdCtcIikpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNldE91dHB1dChnZXRYKG91dEMgLSBzdGFydCkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgXCI6XCJcXG4gICAgICBcIituK1wiIHN0YXJ0ID0gXCIrbitcIihcIitvK1wiKTtcXG4gICAgICBcIituK1wiIGVuZCA9IFwiK24rXCIoXCIrYStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbitcIiBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoYW55KGxlc3NUaGFuKG91dEMsIHN0YXJ0KSkgfHwgYW55KGdyZWF0ZXJUaGFuRXF1YWwob3V0QywgZW5kKSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK3QrXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIFwiK24rXCIgY29vcmRzID0gb3V0QyAtIHN0YXJ0O1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIitpK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19KCksUG9vbDJEUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih5LGUsdCl7aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sXCJhdmdcIj09PWUmJnQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuXCIpO3ZhciByPXkuZmlsdGVyV2lkdGgsbj15LnN0cmlkZUhlaWdodCxvPXkuc3RyaWRlV2lkdGgsYT15LmRpbGF0aW9uSGVpZ2h0LGk9eS5kaWxhdGlvbldpZHRoLHM9eS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT15LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGw9eS5wYWRJbmZvLnRvcCxjPXkucGFkSW5mby5sZWZ0O3RoaXMub3V0cHV0U2hhcGU9eS5vdXRTaGFwZTt2YXIgcD1cImF2Z1wiPT09ZSxkPVwiMC4wXCI7aWYocHx8KGQ9XCItMS4wIC8gMC4wXCIpLHQpdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK24rXCIsIFwiK28rXCIpO1xcbiAgICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2wrXCIsIFwiK2MrXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3MrXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIithK1wiKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3kuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrdStcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIraStcIikge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIreS5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcblxcbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBjdXJyTWluTWF4VmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSB3UiAqIFwiK3UrXCIgKyB3QztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7ZWxzZXt2YXIgYj1lK1wiKFwiK2UrXCIoXCIrZStcIihtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKVwiO1wiYXZnXCI9PT1lJiYoYj1cImF2Z1ZhbHVlIC8gY291bnRcIik7dmFyIHg9NCpfTWF0aGZsb29yKHIvNCksbT1yJTQsZz1cIlxcbiAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBtYXgodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK24rXCIsIFwiK28rXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitsK1wiLCBcIitjK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIrZCtcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgeFIsIGludCB4QywgaW50IGQpIHtcXG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIreS5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgY291bnQgKz0gMS4wO1xcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIitkK1wiKTtcXG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcbiAgICAgICAgY291bnQgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrcytcIjtcXG4gICAgICAgICAgICB3UiArPSBcIithK1wiKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIreS5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit4K1wiOyB3QyArPSA0KSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2krXCI7XFxuXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIraStcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiK2krXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDMgKiBcIitpK1wiLCBkKVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgXCIreCtcIjtcXG4gICAgICAgICAgaWYgKFwiKygxPT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PW0pK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIraStcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK2krXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiBcIitpK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK2IrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9fX0oKSxSZWR1Y2VQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKG0sZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIHQ9bS53aW5kb3dTaXplLHI9bS5iYXRjaFNpemUsbj1tLmluU2l6ZSxvPV9NYXRoY2VpbChuL3QpO3RoaXMub3V0cHV0U2hhcGU9W3Isb107dmFyIGE9XCIwLjBcIixnPVwiXCI7XCJwcm9kXCI9PT1lP2E9XCIxLjBcIjpcIm1pblwiPT09ZT8oYT1cIjEuMCAvIDAuMFwiLGc9XCJtaW5cIik6XCJtYXhcIj09ZSYmKGE9XCItMS4wIC8gMC4wXCIsZz1cIm1heFwiKTt2YXIgZj1lK1wiKFwiK2UrXCIoXCIrZStcIihtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKVwiO1wic3VtXCI9PT1lP2Y9XCJzdW1WYWx1ZVwiOlwicHJvZFwiPT09ZT9mPVwicHJvZFZhbHVlXCI6XCJhbGxcIj09PWU/Zj1cImFsbFZhbHVlXCI6XCJhbnlcIj09ZSYmKGY9XCJhbnlWYWx1ZVwiKTt2YXIgeT00Kl9NYXRoZmxvb3IodC80KSxsPXQlNCxjPVwiXFxuICAgICAgaWYgKFwiKyhcInN1bVwiPT09ZSkrXCIpIHtcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIrKFwicHJvZFwiPT09ZSkrXCIpIHtcXG4gICAgICAgIHZlYzIgdG1wID0gdmVjMih2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgKiB2ZWMyKHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcXG4gICAgICAgIHByb2RWYWx1ZSAqPSB0bXBbMF0gKiB0bXBbMV07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gXCIrZytcIih2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiLGI9XCJ2ZWM0XCI7XCJhbGxcIj09PWU/KGE9XCIxLjBcIixjPVwiXFxuICAgICAgICBib29sIHJlZHVjZWRBbGxWYWx1ZSA9IGFsbCh2YWx1ZXMpO1xcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbGxWYWx1ZSk7XFxuICAgICAgICBhbGxWYWx1ZSA9IGZsb2F0KGFsbFZhbHVlID49IDEuMCAmJiBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID49IDEuMCk7XFxuICAgICAgXCIsYj1cImJ2ZWM0XCIpOlwiYW55XCI9PWUmJihhPVwiMC4wXCIsYz1cIlxcbiAgICAgICAgYm9vbCByZWR1Y2VkQW55VmFsdWUgPSBhbnkodmFsdWVzKTtcXG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPSBmbG9hdChyZWR1Y2VkQW55VmFsdWUpO1xcbiAgICAgICAgYW55VmFsdWUgPSBmbG9hdChhbnlWYWx1ZSA+PSAxLjAgfHwgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA+PSAxLjApO1xcbiAgICAgIFwiLGI9XCJidmVjNFwiKTt2YXIgeD1cIlwiOzA8biV0JiYoeD1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIituK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2ErXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIit4K1wiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIit0K1wiO1xcblxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIrYStcIik7XFxuICAgICAgICBmbG9hdCBwcm9kVmFsdWUgPSAxLjA7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG4gICAgICAgIGZsb2F0IGFsbFZhbHVlID0gMS4wO1xcbiAgICAgICAgZmxvYXQgYW55VmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3krXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIFwiK2IrXCIgdmFsdWVzID0gXCIrYitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2MrXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIreStcIjtcXG4gICAgICAgIGlmIChcIisoMT09bCkrXCIpIHtcXG4gICAgICAgICAgXCIrYitcIiB2YWx1ZXMgPSBcIitiK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09bCkrXCIpIHtcXG4gICAgICAgICAgXCIrYitcIiB2YWx1ZXMgPSBcIitiK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2MrXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PWwpK1wiKSB7XFxuICAgICAgICAgIFwiK2IrXCIgdmFsdWVzID0gXCIrYitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK2YrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFJlc2hhcGVQYWNrZWRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGEsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT1hO2Zvcih2YXIgdD1cIlwiLHM9MCxpOzQ+cztzKyspaT1cInRoaXNSQyA9IHJjO1wiLDE9PXMlMiYmKGkrPVwidGhpc1JDLnogKz0gMTtcIiksMTxzJiYoaSs9XCJ0aGlzUkMueSArPSAxO1wiKSx0Kz1cIlxcbiAgICAgICAgXCIraStcIlxcbiAgICAgICAgXCIrKDA8cz9cImlmKHRoaXNSQy55IDwgcm93cyAmJiB0aGlzUkMueiA8IGNvbHMpe1wiOlwiXCIpK1wiXFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBnZXRGbGF0SW5kZXgodGhpc1JDKTtcXG5cXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5wdXRSQ0lubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcXG5cXG4gICAgICAgICAgcmVzdWx0W1wiK3MrXCJdID1cXG4gICAgICAgICAgICBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlucHV0UkNJbm5lckRpbXMpO1xcbiAgICAgICAgXCIrKDA8cz9cIn1cIjpcIlwiKStcIlxcbiAgICAgIFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitnZXRSZXNoYXBlZElucHV0Q29vcmRzKGUpK1wiXFxuICAgICAgXCIrZ2V0RmxhdEluZGV4KGEpK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBpdmVjMyB0aGlzUkM7XFxuICAgICAgICBpbnQgcm93cyA9IFwiK2FbMV0rXCI7XFxuICAgICAgICBpbnQgY29scyA9IFwiK2FbMl0rXCI7XFxuXFxuICAgICAgICBcIit0K1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxSZXNpemVCaWxpbmVhckJhY2twcm9wUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih5LGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLnNoYXBlO3ZhciByPWUuc2hhcGUsbj1yWzFdLG89clsyXSxhPXkuc2hhcGUsaT1hWzFdLHM9YVsyXSx1PVt0JiYxPGk/bi0xOm4sdCYmMTxzP28tMTpvXSxsPVt0JiYxPGk/aS0xOmksdCYmMTxzP3MtMTpzXSxjPXVbMF0vbFswXSxwPXVbMV0vbFsxXSxkPTEvYyxoPTEvcCxmPTIqX01hdGhjZWlsKGQpKzIsbT0yKl9NYXRoY2VpbChoKSsyO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2MrXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KFwiK3ArXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIitkK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdChcIitoK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIrZitcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIrbStcIik7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXFxuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeVIgPSBpbnQoc3RhcnRSTGVycCAtIGZsb2F0KHdpbkhlaWdodCAvIDIpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKTtcXG5cXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XFxuXFxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gXCIraStcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcXG5cXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gXCIrcytcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IGR4UiA9IGZsb2F0KGR5UikgKiBoZWlnaHRTY2FsZTtcXG4gICAgICAgICAgICBpbnQgdG9wRHhSSW5kZXggPSBpbnQoZmxvb3IoZHhSKSk7XFxuICAgICAgICAgICAgaW50IGJvdHRvbUR4UkluZGV4ID0gaW50KG1pbihjZWlsKGR4UiksIFwiKyhuLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeFJMZXJwID0gZHhSIC0gZmxvYXQodG9wRHhSSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeFJMZXJwID0gMS4wIC0gZHhSTGVycDtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeEMgPSBmbG9hdChkeUMpICogd2lkdGhTY2FsZTtcXG4gICAgICAgICAgICBpbnQgbGVmdER4Q0luZGV4ID0gaW50KGZsb29yKGR4QykpO1xcbiAgICAgICAgICAgIGludCByaWdodER4Q0luZGV4ID0gaW50KG1pbihjZWlsKGR4QyksIFwiKyhvLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeENMZXJwID0gZHhDIC0gZmxvYXQobGVmdER4Q0luZGV4KTtcXG4gICAgICAgICAgICBmbG9hdCBpbnZlcnNlRHhDTGVycCA9IDEuMCAtIGR4Q0xlcnA7XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcExlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9XFxuICAgICAgICAgICAgICAgIGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbUxlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21SaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFJlc2l6ZUJpbGluZWFyUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihwLGUsdCxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBuPXBbMF0sbz1wWzFdLGE9cFsyXSxpPXBbM107dGhpcy5vdXRwdXRTaGFwZT1bbixlLHQsaV07dmFyIHM9W3ImJjE8ZT9vLTE6byxyJiYxPHQ/YS0xOmFdLGQ9W3ImJjE8ZT9lLTE6ZSxyJiYxPHQ/dC0xOnRdO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIitzWzBdL2RbMF0rXCIsXFxuICAgICAgICAgIFwiK3NbMV0vZFsxXStcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiK28rXCIuMCwgXCIrYStcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMiBzb3VyY2VGbG9vclJDID0gaXZlYzIoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuXFxuICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcblxcbiAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxSZXNpemVOZWFyZXN0TmVpZ2JvckJhY2twcm9wUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih5LGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLnNoYXBlO3ZhciByPWUuc2hhcGUsbj1yWzFdLG89clsyXSxhPXkuc2hhcGUsaT1hWzFdLHM9YVsyXSx1PVt0JiYxPGk/bi0xOm4sdCYmMTxzP28tMTpvXSxsPVt0JiYxPGk/aS0xOmksdCYmMTxzP3MtMTpzXSxjPXVbMF0vbFswXSxwPXVbMV0vbFsxXSxkPTEvYyxoPTEvcCxmPTIqX01hdGhjZWlsKGQpKzIsbT0yKl9NYXRoY2VpbChoKSsyO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2MrXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KFwiK3ArXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIitkK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdChcIitoK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIrZitcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIrbStcIik7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXFxuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeVIgPSBpbnQoZmxvb3Ioc3RhcnRSTGVycCAtIGZsb2F0KHdpbkhlaWdodCAvIDIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5QyA9IGludChmbG9vcihzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSkpO1xcblxcbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XFxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XFxuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcXG5cXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBcIitpK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY1JvdyA9XFxuICAgICAgICAgICAgICBmbG9hdChcIit1WzBdK1wiKSAqXFxuICAgICAgICAgICAgICAgIChmbG9hdChkeVIpIC8gZmxvYXQoXCIrbFswXStcIikpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNDb2wgPVxcbiAgICAgICAgICAgICAgICBmbG9hdChcIit1WzFdK1wiKSAqXFxuICAgICAgICAgICAgICAgICAgKGZsb2F0KGR5QykgLyBmbG9hdChcIitsWzFdK1wiKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RSb3cgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIrbitcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrdCtcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNSb3cpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNSb3cpKSkpO1xcblxcbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Q29sID0gaW50KG1pbihcXG4gICAgICAgICAgICAgICAgZmxvYXQoaW50KFwiK28rXCIpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiK3QrXCIgPyBmbG9hdChyb3VuZChzb3VyY2VGcmFjQ29sKSkgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdChmbG9vcihzb3VyY2VGcmFjQ29sKSkpKTtcXG5cXG4gICAgICAgICAgICBpZiAociA9PSBzb3VyY2VOZWFyZXN0Um93ICYmIGMgPT0gc291cmNlTmVhcmVzdENvbCkge1xcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxSZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHAsZSx0LHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG49cFswXSxvPXBbMV0sYT1wWzJdLGk9cFszXTt0aGlzLm91dHB1dFNoYXBlPVtuLGUsdCxpXTt2YXIgcz1bciYmMTxlP28tMTpvLHImJjE8dD9hLTE6YV0sZD1bciYmMTxlP2UtMTplLHImJjE8dD90LTE6dF0sbD1yP1wiMC41XCI6XCIwLjBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIrc1swXS9kWzBdK1wiLFxcbiAgICAgICAgICBcIitzWzFdL2RbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIitvK1wiLjAsIFwiK2ErXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGZsb29yKHNvdXJjZUZyYWNJbmRleFJDICsgXCIrbCtcIikpKTtcXG5cXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0QShiLCBzb3VyY2VOZWFyZXN0UkMueCwgc291cmNlTmVhcmVzdFJDLnksIGQpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxSZXZlcnNlUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhLGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciB0PWEubGVuZ3RoO2lmKDQ8dCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstXCIrdCtcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYodGhpcy5vdXRwdXRTaGFwZT1hLDEhPT10KXt2YXIgcj1hLm1hcChmdW5jdGlvbih0LHIpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4tMSE9PWUuaW5kZXhPZih0KSYmMSE9PWFbdF0/YVt0XStcIiAtIGNvb3Jkc1tcIit0K1wiXSAtIDFcIjpcImNvb3Jkc1tcIit0K1wiXVwifShyKX0pLmpvaW4oXCIsXCIpLG49Z2V0Q29vcmRzRGF0YVR5cGUodCk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIityK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1lbHNlIHRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaW50IGNvb3JkID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKFwiK2FbMF0rXCIgLSBjb29yZCAtIDEpKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn19KCksU2NhdHRlclByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24obSxlLHQscixuLG8sYSl7dm9pZCAwPT09YSYmKGE9ITApLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ1cGRhdGVzXCIsXCJpbmRpY2VzXCIsXCJkZWZhdWx0VmFsdWVcIl0sdGhpcy5vdXRwdXRTaGFwZT1vO3ZhciBnPWdldENvb3Jkc0RhdGFUeXBlKG4ubGVuZ3RoKSxzPWdldENvb3Jkc0RhdGFUeXBlKG8ubGVuZ3RoKSx1PVwiXCI7MT09PXQ/dT1cImlcIjoyPT10JiYodT1cImksIGpcIik7dmFyIGY9XCJnZXRJbmRpY2VzKFwiK3UrXCIpXCIsYz1cIlwiOzE9PT1yP2M9XCJpXCI6Mj09ciYmKGM9XCJpLCBjb29yZHNbMV1cIik7dmFyIHk9XCJnZXRVcGRhdGVzKFwiK2MrXCIpXCIsZD0xPGU/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrZytcIiBzdHJpZGVzID0gXCIrZytcIihcIituK1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrcytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgICBib29sIGZvdW5kID0gZmFsc2U7XFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrbStcIjsgaSsrKSB7XFxuICAgICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gMDtcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK2UrXCI7IGorKykge1xcbiAgICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoXCIrZitcIik7XFxuICAgICAgICAgICAgICBmbGF0dGVuZWRJbmRleCArPSBpbmRleCAqIFwiK2QrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChmbGF0dGVuZWRJbmRleCA9PSBjb29yZHNbMF0pIHtcXG4gICAgICAgICAgICAgIHN1bSArPSBcIit5K1wiO1xcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQobWl4KGdldERlZmF1bHRWYWx1ZSgpLCBzdW0sIGZsb2F0KGZvdW5kKSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifX0oKSxTZWdtZW50T3BQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJzZWdtZW50SWRzXCJdO3ZhciBlPXQud2luZG93U2l6ZSxyPXQuYmF0Y2hTaXplLG49dC5pblNpemUsbz10Lm51bVNlZ21lbnRzLGE9bypfTWF0aGNlaWwobi9lKTt0aGlzLm91dHB1dFNoYXBlPVtyLGFdO3ZhciBpPTQqX01hdGhmbG9vcihlLzQpLHM9ZSU0LGw9XCJcIjswPG4lZSYmKGw9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbitcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIik7dmFyIGQ9XCJcIjswPG4lZSYmKGQ9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbitcIikge1xcbiAgICAgICAgICByZXR1cm4gLTEuMDtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2wrXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IGdldFNlZ21lbnRJZEF0SW5kZXgoaW50IGluSWR4KSB7XFxuICAgICAgICBcIitkK1wiXFxuICAgICAgICByZXR1cm4gZ2V0U2VnbWVudElkcyhpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IGludChmbG9vcihmbG9hdChvdXRJZHgpIC8gZmxvYXQoXFxuICAgICAgICAgIFwiK28rXCIpKSAqIGZsb2F0KFwiK2UrXCIpKTtcXG4gICAgICAgIGludCBjdXJyZW50U2VnID0gaW50KG1vZChmbG9hdChvdXRJZHgpLCBmbG9hdChcIitvK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2krXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgZmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMykpID09IGN1cnJlbnRTZWcgPyAxIDogMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitcIlxcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgZmlsdGVyKTtcXG4gICAgXCIrXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIraStcIjtcXG4gICAgICAgIGlmIChcIisoMT09cykrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgaW50IGluSWR4U2VnID0gaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKTtcXG5cXG4gICAgICAgICAgdmVjNCBmaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK1wiXFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBmaWx0ZXIpO1xcbiAgICBcIitcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09cykrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgZmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgICAwLFxcbiAgICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitcIlxcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgZmlsdGVyKTtcXG4gICAgXCIrXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PXMpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBmaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDIpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitcIlxcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgZmlsdGVyKTtcXG4gICAgXCIrXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChzdW1WYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksU2VsZWN0UHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihwLGUsdCl7dmFyIHIsZDtpZih0aGlzLnZhcmlhYmxlTmFtZXM9W1wiY1wiLFwiYVwiLFwiYlwiXSx0aGlzLm91dHB1dFNoYXBlPWUsNDx0KXRocm93IEVycm9yKFwiV2hlcmUgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09dClkPVwicmVzUkNcIixyPVwicmVzUkNcIjtlbHNle2Zvcih2YXIgYz1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCJdLGE9W10saT1bXSxzPTA7czxlLmxlbmd0aDtzKyspaS5wdXNoKFwiXCIrY1tzXSksczxwJiZhLnB1c2goXCJcIitjW3NdKTtyPWEuam9pbigpLGQ9aS5qb2luKCl9dmFyIG09Z2V0Q29vcmRzRGF0YVR5cGUodCk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK20rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGNWYWwgPSBnZXRDKFwiK3IrXCIpO1xcbiAgICAgICAgaWYgKGNWYWwgPj0gMS4wKSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRBKFwiK2QrXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRCKFwiK2QrXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwifX0oKSxTbGljZVByb2dyYW09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJzb3VyY2VcIl0sdGhpcy5vdXRwdXRTaGFwZT1hLHRoaXMucmFuaz1hLmxlbmd0aDt2YXIgZT1nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspLHQ9Z2V0Q29vcmRzJDEodGhpcy5yYW5rKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBcIitlK1wiIHN0YXJ0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2UrXCIgc291cmNlTG9jID0gc3RhcnQgKyBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRTb3VyY2UoXCIrdCtcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbihhKXt2YXIgZT10aGlzO2lmKGEubGVuZ3RoIT09dGhpcy5yYW5rKXRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiK3RoaXMucmFuaytcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHN0YXJ0IChcIithLmxlbmd0aCtcIilcIik7cmV0dXJuIGZ1bmN0aW9uKHQscil7aWYobnVsbCE9ZS5zdGFydExvY3x8KGUuc3RhcnRMb2M9dC5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJzdGFydFwiKSxudWxsIT1lLnN0YXJ0TG9jKSlpZigxPT09ZS5yYW5rKXQuZ2wudW5pZm9ybTFpKGUuc3RhcnRMb2MsYVswXSk7ZWxzZSBpZigyPT09ZS5yYW5rKXQuZ2wudW5pZm9ybTJpKGUuc3RhcnRMb2MsYVswXSxhWzFdKTtlbHNlIGlmKDM9PT1lLnJhbmspdC5nbC51bmlmb3JtM2koZS5zdGFydExvYyxhWzBdLGFbMV0sYVsyXSk7ZWxzZXtpZig0IT09ZS5yYW5rKXRocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIitlLnJhbmsrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7dC5nbC51bmlmb3JtNGkoZS5zdGFydExvYyxhWzBdLGFbMV0sYVsyXSxhWzNdKX19fSx0fSgpLFN0cmlkZWRTbGljZVByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24ocCxlLHQscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIG49dC5maWx0ZXIoZnVuY3Rpb24oYSxlKXtyZXR1cm4tMT09PXIuaW5kZXhPZihlKX0pO3RoaXMub3V0cHV0U2hhcGU9bjt2YXIgbz10Lmxlbmd0aCxhPWdldENvb3Jkc0RhdGFUeXBlKHQubGVuZ3RoKSxpPWdldENvb3Jkc0RhdGFUeXBlKG4ubGVuZ3RoKSxzPVwiXCI7aWYoMT09PW8pcz1cImNvb3JkcyAqIHN0cmlkZXMgKyBiZWdpblwiO2Vsc2V7dmFyIGQ9MDtzPXQubWFwKGZ1bmN0aW9uKGEsZSl7cmV0dXJuLTE9PT1yLmluZGV4T2YoZSk/KGQrKywxPT09bi5sZW5ndGg/XCJjb29yZHMgKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIjpcImNvb3Jkc1tcIisoZC0xKStcIl0gKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIik6XCJiZWdpbltcIitlK1wiXVwifSkuam9pbihcIixcIil9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2ErXCIgYmVnaW4gPSBcIithK1wiKFwiK3ArXCIpO1xcbiAgICAgIFwiK2ErXCIgc3RyaWRlcyA9IFwiK2ErXCIoXCIrZStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIraStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiK3MrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxUZXh0dXJlTWFuYWdlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5ncGdwdT10LHRoaXMubnVtVXNlZFRleHR1cmVzPTAsdGhpcy5udW1GcmVlVGV4dHVyZXM9MCx0aGlzLmZyZWVUZXh0dXJlcz17fSx0aGlzLmxvZ0VuYWJsZWQ9ITEsdGhpcy51c2VkVGV4dHVyZXM9e319cmV0dXJuIHQucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlPWZ1bmN0aW9uKHMsZSx0KXt2YXIgcj1nZXRQaHlzaWNhbEZyb21Mb2dpY2FsVGV4dHVyZVR5cGUoZSx0KSxvPWdldEtleUZyb21UZXh0dXJlU2hhcGUocyxyLHQpLGE7aWYobyBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW29dPVtdKSxvIGluIHRoaXMudXNlZFRleHR1cmVzfHwodGhpcy51c2VkVGV4dHVyZXNbb109W10pLDA8dGhpcy5mcmVlVGV4dHVyZXNbb10ubGVuZ3RoKXt0aGlzLm51bUZyZWVUZXh0dXJlcy0tLHRoaXMubnVtVXNlZFRleHR1cmVzKyssdGhpcy5sb2coKTt2YXIgcD10aGlzLmZyZWVUZXh0dXJlc1tvXS5zaGlmdCgpO3JldHVybiB0aGlzLnVzZWRUZXh0dXJlc1tvXS5wdXNoKHApLHB9cmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzKyssdGhpcy5sb2coKSxyPT09UGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfMlgyX0ZMT0FUMzI/YT10aGlzLmdwZ3B1LmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoc1swXSxzWzFdKTpyPT09UGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfMlgyX0ZMT0FUMTY/YT10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlKHNbMF0sc1sxXSk6cj09PVBoeXNpY2FsVGV4dHVyZVR5cGUuVU5QQUNLRURfRkxPQVQzMj9hPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUoc1swXSxzWzFdKTpyPT09UGh5c2ljYWxUZXh0dXJlVHlwZS5VTlBBQ0tFRF9GTE9BVDE2P2E9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZShzWzBdLHNbMV0pOnI9PT1QaHlzaWNhbFRleHR1cmVUeXBlLlBBQ0tFRF80WDFfVU5TSUdORURfQllURSYmKGE9dGhpcy5ncGdwdS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZShzWzBdLHNbMV0pKSx0aGlzLnVzZWRUZXh0dXJlc1tvXS5wdXNoKGEpLGF9LHQucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlPWZ1bmN0aW9uKHMsZSx0LHIpe2lmKG51bGwhPXRoaXMuZnJlZVRleHR1cmVzKXt2YXIgbj1nZXRLZXlGcm9tVGV4dHVyZVNoYXBlKGUsZ2V0UGh5c2ljYWxGcm9tTG9naWNhbFRleHR1cmVUeXBlKHQscikscik7biBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW25dPVtdKSx0aGlzLmZyZWVUZXh0dXJlc1tuXS5wdXNoKHMpLHRoaXMubnVtRnJlZVRleHR1cmVzKyssdGhpcy5udW1Vc2VkVGV4dHVyZXMtLTt2YXIgbz10aGlzLnVzZWRUZXh0dXJlc1tuXSxhPW8uaW5kZXhPZihzKTtpZigwPmEpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbGVhc2UgYSB0ZXh0dXJlIHRoYXQgd2FzIG5ldmVyIHByb3ZpZGVkIGJ5IHRoaXMgdGV4dHVyZSBtYW5hZ2VyXCIpO28uc3BsaWNlKGEsMSksdGhpcy5sb2coKX19LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbigpe2lmKHRoaXMubG9nRW5hYmxlZCl7dmFyIHQ9dGhpcy5udW1GcmVlVGV4dHVyZXMrdGhpcy5udW1Vc2VkVGV4dHVyZXM7Y29uc29sZS5sb2coXCJGcmVlL1VzZWRcIix0aGlzLm51bUZyZWVUZXh0dXJlcytcIiAvIFwiK3RoaXMubnVtVXNlZFRleHR1cmVzLFwiKFwiK3QrXCIpXCIpfX0sdC5wcm90b3R5cGUuZ2V0TnVtVXNlZFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzfSx0LnByb3RvdHlwZS5nZXROdW1GcmVlVGV4dHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1GcmVlVGV4dHVyZXN9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKG51bGwhPXRoaXMuZnJlZVRleHR1cmVzKXtmb3IodmFyIGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpdGhpcy5mcmVlVGV4dHVyZXNbZV0uZm9yRWFjaChmdW5jdGlvbihlKXthLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoZSl9KTtmb3IodmFyIGUgaW4gdGhpcy51c2VkVGV4dHVyZXMpdGhpcy51c2VkVGV4dHVyZXNbZV0uZm9yRWFjaChmdW5jdGlvbihlKXthLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoZSl9KTt0aGlzLmZyZWVUZXh0dXJlcz1udWxsLHRoaXMudXNlZFRleHR1cmVzPW51bGwsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wfX0sdH0oKSxUaWxlUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihzLGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2Zvcih2YXIgdD1BcnJheShzLmxlbmd0aCkscj0wO3I8dC5sZW5ndGg7cisrKXRbcl09c1tyXSplW3JdO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnJhbms9dC5sZW5ndGg7dmFyIGk9Z2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKSxvPWdldFNvdXJjZUNvb3JkcyQyKHMpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitpK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIitvK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksVHJhbnNwb3NlUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihzLGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2Zvcih2YXIgdD1BcnJheShzLmxlbmd0aCkscj0wO3I8dC5sZW5ndGg7cisrKXRbcl09c1tlW3JdXTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5yYW5rPXQubGVuZ3RoO3ZhciBpPWdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayksbz1nZXRTd2l0Y2hlZENvb3JkcyhlKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIitpK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGdldEEoXCIrbytcIikpO1xcbiAgICB9XFxuICAgIFwifX0oKSxFUkZfUD0uMzI3NTkxMSxFUkZfQTE9LjI1NDgyOTU5MixFUkZfQTI9LS4yODQ0OTY3MzYsRVJGX0EzPTEuNDIxNDEzNzQxLEVSRl9BND0tMS40NTMxNTIwMjcsRVJGX0E1PTEuMDYxNDA1NDI5LFNFTFVfU0NBTEVBTFBIQT0xLjc1ODA5OTM0MDg0NzM3NjgsU0VMVV9TQ0FMRT0xLjA1MDcwMDk4NzM1NTQ4MDUsVW5hcnlPcFByb2dyYW09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1hLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IE5BTjtcXG4gICAgICBmbG9hdCB1bmFyeU9wZXJhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBmdW5jdGlvbihlLHQpe251bGw9PWEuc3RhcnRMb2MmJihhLnN0YXJ0TG9jPWUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyh0LFwiTkFOXCIpLG51bGw9PWEuc3RhcnRMb2MpfHxlLmdsLnVuaWZvcm0xZihhLnN0YXJ0TG9jLE5hTil9fSx0fSgpLENIRUNLX05BTl9TTklQUEVUJDE9XCJpZiAoaXNOYU4oeCkpIHJldHVybiB4O1wiLEFCUz1cInJldHVybiBhYnMoeCk7XCIsUkVMVT1DSEVDS19OQU5fU05JUFBFVCQxK1wiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogeDtcXG5cIixFTFU9XCJyZXR1cm4gKHggPj0gMC4wKSA/IHggOiAoZXhwKHgpIC0gMS4wKTtcIixTRUxVPVwiXFxuICAvLyBTdGFibGUgYW5kIEF0dHJhY3RpbmcgRml4ZWQgUG9pbnQgKDAsIDEpIGZvciBOb3JtYWxpemVkIFdlaWdodHMuXFxuICAvLyBzZWU6IGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA2LjAyNTE1XFxuICBmbG9hdCBzY2FsZUFscGhhID0gXCIrU0VMVV9TQ0FMRUFMUEhBK1wiO1xcbiAgZmxvYXQgc2NhbGUgPSBcIitTRUxVX1NDQUxFK1wiO1xcbiAgcmV0dXJuICh4ID49IDAuMCkgPyBzY2FsZSAqIHggOiBzY2FsZUFscGhhICogKGV4cCh4KSAtIDEuMCk7XFxuXCIsTkVHPVwicmV0dXJuIC14O1wiLENFSUw9XCJyZXR1cm4gY2VpbCh4KTtcIixGTE9PUj1cInJldHVybiBmbG9vcih4KTtcIixTSUdOPVwiXFxuICBpZiAoaXNOYU4oeCkpIHsgcmV0dXJuIDAuMDsgfVxcbiAgcmV0dXJuIHNpZ24oeCk7XFxuXCIsUk9VTkQ9XCJcXG4gIC8vIE9wZW5HTCBFUyBkb2VzIG5vdCBzdXBwb3J0IHJvdW5kIGZ1bmN0aW9uLlxcbiAgLy8gVGhlIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBiYW5rZXIncyByb3VuZGluZy5cXG4gIGZsb2F0IGJhc2UgPSBmbG9vcih4KTtcXG4gIGlmICgoeCAtIGJhc2UpIDwgMC41KSB7XFxuICAgIHJldHVybiBmbG9vcih4KTtcXG4gIH0gZWxzZSBpZiAoKHggLSBiYXNlKSA+IDAuNSkge1xcbiAgICByZXR1cm4gY2VpbCh4KTtcXG4gIH0gZWxzZSB7XFxuICAgIGlmIChtb2QoYmFzZSwgMi4wKSA9PSAwLjApIHtcXG4gICAgICByZXR1cm4gYmFzZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gYmFzZSArIDEuMDtcXG4gICAgfVxcbiAgfVxcblwiLEVYUD1cInJldHVybiBleHAoeCk7XCIsRVhQTTE9XCJyZXR1cm4gZXhwKHgpIC0gMS4wO1wiLExPRz1cImlmICh4IDwgMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIGxvZyh4KTtcIixMT0cxUD1cInJldHVybiBsb2coMS4wICsgeCk7XCIsU1FSVD1cInJldHVybiBzcXJ0KHgpO1wiLFJTUVJUPVwicmV0dXJuIGludmVyc2VzcXJ0KHgpO1wiLFNJR01PSUQ9XCJyZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1wiLFNPRlRQTFVTPVwiXFxuICBmbG9hdCBlcHNpbG9uID0gMS4xOTIwOTI4OTU1MDc4MTI1ZS03O1xcbiAgZmxvYXQgdGhyZXNob2xkID0gbG9nKGVwc2lsb24pICsgMi4wO1xcblxcbiAgYm9vbCB0b29fbGFyZ2UgPSB4ID4gLXRocmVzaG9sZDtcXG4gIGJvb2wgdG9vX3NtYWxsID0geCA8IHRocmVzaG9sZDtcXG5cXG4gIGZsb2F0IHJlc3VsdDtcXG4gIGZsb2F0IGV4cF94ID0gZXhwKHgpO1xcblxcbiAgaWYgKHRvb19sYXJnZSl7XFxuICAgIHJlc3VsdCA9IHg7XFxuICB9XFxuICBlbHNlIGlmICh0b29fc21hbGwpe1xcbiAgICByZXN1bHQgPSBleHBfeDtcXG4gIH1cXG4gIGVsc2V7XFxuICAgIHJlc3VsdCA9IGxvZyhleHBfeCArIDEuMCk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcblwiLFNJTj1DSEVDS19OQU5fU05JUFBFVCQxK1wiXFxuICByZXR1cm4gc2luKHgpO1xcblwiLENPUz1DSEVDS19OQU5fU05JUFBFVCQxK1wiXFxuICByZXR1cm4gY29zKHgpO1xcblwiLFRBTj1cInJldHVybiB0YW4oeCk7XCIsQVNJTj1cInJldHVybiBhc2luKHgpO1wiLEFDT1M9XCJyZXR1cm4gYWNvcyh4KTtcIixBVEFOPUNIRUNLX05BTl9TTklQUEVUJDErXCJcXG4gIHJldHVybiBhdGFuKHgpO1xcblwiLFNJTkg9XCJcXG4gIGZsb2F0IGUyeCA9IGV4cCh4KTtcXG4gIHJldHVybiAoZTJ4IC0gMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIixDT1NIPVwiXFxuICBmbG9hdCBlMnggPSBleHAoLXgpO1xcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xcblwiLFRBTkg9XCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcXG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcXG5cIixBU0lOSD1cInJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxLjApKTtcIixBQ09TSD1DSEVDS19OQU5fU05JUFBFVCQxK1wiXFxuICBpZiAoeCA8IDEuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxLjApKTtcIixBVEFOSD1DSEVDS19OQU5fU05JUFBFVCQxK1wiXFxuICBpZiAoKHggPCAtMS4wKSB8fCAoeCA+IDEuMCkpIHJldHVybiBOQU47XFxuICByZXR1cm4gKGxvZygxLjAgKyB4KSAtIGxvZygxLjAgLSB4KSkgLyAyLjA7XCIsRVJGPVwiXFxuICAvLyBFcnJvciBmdW5jdGlvbiBpcyBjYWxjdWxhdGVkIGFwcHJveGltYXRlbHkgd2l0aCBlbGVtZW50YXJ5IGZ1bmN0aW9uLlxcbiAgLy8gU2VlIFxcXCJIYW5kYm9vayBvZiBNYXRoZW1hdGljYWwgRnVuY3Rpb25zIHdpdGggRm9ybXVsYXMsXFxuICAvLyBHcmFwaHMsIGFuZCBNYXRoZW1hdGljYWwgVGFibGVzXFxcIiwgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLlxcbiAgZmxvYXQgcCA9IFwiK0VSRl9QK1wiO1xcbiAgZmxvYXQgYTEgPSBcIitFUkZfQTErXCI7XFxuICBmbG9hdCBhMiA9IFwiK0VSRl9BMitcIjtcXG4gIGZsb2F0IGEzID0gXCIrRVJGX0EzK1wiO1xcbiAgZmxvYXQgYTQgPSBcIitFUkZfQTQrXCI7XFxuICBmbG9hdCBhNSA9IFwiK0VSRl9BNStcIjtcXG5cXG4gIGZsb2F0IHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xcbiAgcmV0dXJuIDEuMCAtICgoKCgoYTUqdCArIGE0KSp0KSArIGEzKSp0ICsgYTIpKnQgKyBhMSkqdCpleHAoLXgqeCk7XFxuXCIsU1FVQVJFPVwicmV0dXJuIHggKiB4O1wiLFJFQ0lQUk9DQUw9XCJyZXR1cm4gMS4wIC8geDtcIixMT0dJQ0FMX05PVD1cInJldHVybiBmbG9hdCghKHggPj0gMS4wKSk7XCIsVE9fSU5UPVwicmV0dXJuIGZsb2F0KGludCh4KSk7XCIsVW5wYWNrUHJvZ3JhbT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihzKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXM7dmFyIGU9cy5sZW5ndGgsdD1nZXRDaGFubmVscyhcInJjXCIsZSkscj1nZXRDb29yZHNEYXRhVHlwZShlKSxuPWdldFNvdXJjZUNvb3JkcyQxKGUsdCksbz10LnNsaWNlKC0yKSxhPTE9PT1lP1wicmNcIjpcInZlYzIoXCIrby5qb2luKFwiLFwiKStcIilcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrcitcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBwYWNrZWRJbnB1dCA9IGdldEEoXCIrbitcIik7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZ2V0Q2hhbm5lbChwYWNrZWRJbnB1dCwgXCIrYStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGNvbmNhdD1vcCh7Y29uY2F0Xzpjb25jYXRffSksY29uY2F0MWQ9b3Aoe2NvbmNhdDFkXzpjb25jYXQxZF99KSxjb25jYXQyZD1vcCh7Y29uY2F0MmRfOmNvbmNhdDJkX30pLGNvbmNhdDNkPW9wKHtjb25jYXQzZF86Y29uY2F0M2RffSksY29uY2F0NGQ9b3Aoe2NvbmNhdDRkXzpjb25jYXQ0ZF99KSxzcGxpdCQxPW9wKHtzcGxpdF86c3BsaXRffSksYWxlYT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24oYSxlLHQpe2Z1bmN0aW9uIHMoYSxlKXtyZXR1cm4gZS5jPWEuYyxlLnMwPWEuczAsZS5zMT1hLnMxLGUuczI9YS5zMixlfWZ1bmN0aW9uIG4obixlKXt2YXIgdD1uZXcgZnVuY3Rpb24oYSl7dmFyIG89dGhpcyxlPShzPTQwMjI4NzExOTcsZnVuY3Rpb24odCl7dD10LnRvU3RyaW5nKCk7Zm9yKHZhciBhPTAsbzthPHQubGVuZ3RoO2ErKylvPS4wMjUxOTYwMzI4MjQxNjkzOCoocys9dC5jaGFyQ29kZUF0KGEpKSxvLT1zPW8+Pj4wLHM9KG8qPXMpPj4+MCxzKz00Mjk0OTY3Mjk2KihvLT1zKTtyZXR1cm4gMjMyODMwNjQzNjUzODY5NjNlLTI2KihzPj4+MCl9KSxzO28ubmV4dD1mdW5jdGlvbigpe3ZhciB0PTIwOTE2Mzkqby5zMCsyMzI4MzA2NDM2NTM4Njk2M2UtMjYqby5jO3JldHVybiBvLnMwPW8uczEsby5zMT1vLnMyLG8uczI9dC0oby5jPTB8dCl9LG8uYz0xLG8uczA9ZShcIiBcIiksby5zMT1lKFwiIFwiKSxvLnMyPWUoXCIgXCIpLG8uczAtPWUoYSksMD5vLnMwJiYoby5zMCs9MSksby5zMS09ZShhKSwwPm8uczEmJihvLnMxKz0xKSxvLnMyLT1lKGEpLDA+by5zMiYmKG8uczIrPTEpLGU9bnVsbH0obikscj1lJiZlLnN0YXRlLG89dC5uZXh0O3JldHVybiBvLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDB8NDI5NDk2NzI5Nip0Lm5leHQoKX0sby5kb3VibGU9ZnVuY3Rpb24oKXtyZXR1cm4gbygpKzExMTAyMjMwMjQ2MjUxNTY1ZS0zMiooMHwyMDk3MTUyKm8oKSl9LG8ucXVpY2s9byxyJiYoXCJvYmplY3RcIj09dHlwZW9mIHImJnMocix0KSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHModCx7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9bjp0JiZ0LmFtZD90KGZ1bmN0aW9uKCl7cmV0dXJuIG59KTp0aGlzLmFsZWE9bn0oMCx0LCExKX0pLHhvcjEyOD1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24oYSxlLHQpe2Z1bmN0aW9uIHMoYSxlKXtyZXR1cm4gZS54PWEueCxlLnk9YS55LGUuej1hLnosZS53PWEudyxlfWZ1bmN0aW9uIG4obixlKXt2YXIgdD1uZXcgZnVuY3Rpb24oYSl7dmFyIG89dGhpcyxlPVwiXCI7by54PTAsby55PTAsby56PTAsby53PTAsby5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9by54Xm8ueDw8MTE7cmV0dXJuIG8ueD1vLnksby55PW8ueixvLno9by53LG8ud149by53Pj4+MTledF50Pj4+OH0sYT09PSgwfGEpP28ueD1hOmUrPWE7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aCs2NDt0Kyspby54Xj0wfGUuY2hhckNvZGVBdCh0KSxvLm5leHQoKX0obikscj1lJiZlLnN0YXRlLG89ZnVuY3Rpb24oKXtyZXR1cm4odC5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gby5kb3VibGU9ZnVuY3Rpb24oKXtkbyB2YXIgYT0oKHQubmV4dCgpPj4+MTEpKyh0Lm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLzIwOTcxNTI7d2hpbGUoMD09PWEpO3JldHVybiBhfSxvLmludDMyPXQubmV4dCxvLnF1aWNrPW8sciYmKFwib2JqZWN0XCI9PXR5cGVvZiByJiZzKHIsdCksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBzKHQse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPW46dCYmdC5hbWQ/dChmdW5jdGlvbigpe3JldHVybiBufSk6dGhpcy54b3IxMjg9bn0oMCx0LCExKX0pLHhvcndvdz1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24oYSxlLHQpe2Z1bmN0aW9uIHMoYSxlKXtyZXR1cm4gZS54PWEueCxlLnk9YS55LGUuej1hLnosZS53PWEudyxlLnY9YS52LGUuZD1hLmQsZX1mdW5jdGlvbiBuKG4sZSl7dmFyIHQ9bmV3IGZ1bmN0aW9uKGEpe3ZhciBvPXRoaXMsZT1cIlwiO28ubmV4dD1mdW5jdGlvbigpe3ZhciB0PW8ueF5vLng+Pj4yO3JldHVybiBvLng9by55LG8ueT1vLnosby56PW8udyxvLnc9by52LDB8KG8uZD0wfG8uZCszNjI0MzcpKyhvLnY9by52Xm8udjw8NF50XnQ8PDEpfSxvLng9MCxvLnk9MCxvLno9MCxvLnc9MCxvLnY9MCxhPT09KDB8YSk/by54PWE6ZSs9YTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoKzY0O3QrKylvLnhePTB8ZS5jaGFyQ29kZUF0KHQpLHQ9PWUubGVuZ3RoJiYoby5kPW8ueDw8MTBeby54Pj4+NCksby5uZXh0KCl9KG4pLHI9ZSYmZS5zdGF0ZSxvPWZ1bmN0aW9uKCl7cmV0dXJuKHQubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIG8uZG91YmxlPWZ1bmN0aW9uKCl7ZG8gdmFyIGE9KCh0Lm5leHQoKT4+PjExKSsodC5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8yMDk3MTUyO3doaWxlKDA9PT1hKTtyZXR1cm4gYX0sby5pbnQzMj10Lm5leHQsby5xdWljaz1vLHImJihcIm9iamVjdFwiPT10eXBlb2YgciYmcyhyLHQpLG8uc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcyh0LHt9KX0pLG99ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1uOnQmJnQuYW1kP3QoZnVuY3Rpb24oKXtyZXR1cm4gbn0pOnRoaXMueG9yd293PW59KDAsdCwhMSl9KSx4b3JzaGlmdDc9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGEsZSx0KXtmdW5jdGlvbiBzKGEsZSl7cmV0dXJuIGUueD1hLnguc2xpY2UoKSxlLmk9YS5pLGV9ZnVuY3Rpb24gbihuLGkpe251bGw9PW4mJihuPStuZXcgRGF0ZSk7dmFyIHQ9bmV3IGZ1bmN0aW9uKGEpe3ZhciBzPXRoaXM7cy5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9cy54LGE9cy5pLG4sbztyZXR1cm4gbj10W2FdLG89KG5ePW4+Pj43KV5uPDwyNCxvXj0obj10WzcmYSsxXSlebj4+PjEwLG9ePShuPXRbNyZhKzNdKV5uPj4+MyxvXj0obj10WzcmYSs0XSlebjw8NyxuPXRbNyZhKzddLG9ePShuXj1uPDwxMylebjw8OSx0W2FdPW8scy5pPTcmYSsxLG99LGZ1bmN0aW9uKGEsZSl7dmFyIG89W10sbjtpZihlPT09KDB8ZSkpb1swXT1lO2Vsc2UgZm9yKGU9XCJcIitlLG49MDtuPGUubGVuZ3RoOysrbilvWzcmbl09b1s3Jm5dPDwxNV5lLmNoYXJDb2RlQXQobikrb1s3Jm4rMV08PDEzO2Zvcig7OD5vLmxlbmd0aDspby5wdXNoKDApO2ZvcihuPTA7OD5uJiYwPT09b1tuXTsrK24pO2Zvcig4PT1uP29bN109LTE6b1tuXSxhLng9byxhLmk9MCxuPTI1NjswPG47LS1uKWEubmV4dCgpfShzLGEpfShuKSxyPWkmJmkuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybih0Lm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2RvIHZhciBhPSgodC5uZXh0KCk+Pj4xMSkrKHQubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvMjA5NzE1Mjt3aGlsZSgwPT09YSk7cmV0dXJuIGF9LG8uaW50MzI9dC5uZXh0LG8ucXVpY2s9byxyJiYoci54JiZzKHIsdCksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBzKHQse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPW46dCYmdC5hbWQ/dChmdW5jdGlvbigpe3JldHVybiBufSk6dGhpcy54b3JzaGlmdDc9bn0oMCx0LCExKX0pLHhvcjQwOTY9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGEsZSx0KXtmdW5jdGlvbiBzKGEsZSl7cmV0dXJuIGUuaT1hLmksZS53PWEudyxlLlg9YS5YLnNsaWNlKCksZX1mdW5jdGlvbiBuKG4saSl7bnVsbD09biYmKG49K25ldyBEYXRlKTt2YXIgdD1uZXcgZnVuY3Rpb24oYSl7dmFyIHM9dGhpcztzLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1zLncsaT1zLlgsbz1zLmkscCxsO3JldHVybiBzLnc9dD0wfHQrMTY0MDUzMTUyNyxsPWlbMTI3Jm8rMzRdLHA9aVtvPTEyNyZvKzFdLGxePWw8PDEzLHBePXA8PDE3LGxePWw+Pj4xNSxwXj1wPj4+MTIsbD1pW29dPWxecCxzLmk9bywwfGwrKHRedD4+PjE2KX0sZnVuY3Rpb24ocCxlKXt2YXIgbD1bXSxzPTEyOCxkLGMsbSxoLGc7Zm9yKGU9PT0oMHxlKT8oYz1lLGU9bnVsbCk6KGUrPVwiXFwwXCIsYz0wLHM9X01hdGhtYXgocyxlLmxlbmd0aCkpLG09MCxoPS0zMjtoPHM7KytoKWUmJihjXj1lLmNoYXJDb2RlQXQoKGgrMzIpJWUubGVuZ3RoKSksMD09PWgmJihnPWMpLGNePWM8PDEwLGNePWM+Pj4xNSxjXj1jPDw0LGNePWM+Pj4xMywwPD1oJiYoZz0wfGcrMTY0MDUzMTUyNyxtPTA9PShkPWxbMTI3JmhdXj1jK2cpP20rMTowKTtmb3IoMTI4PD1tJiYobFsxMjcmKGUmJmUubGVuZ3RofHwwKV09LTEpLG09MTI3LGg9NTEyOzA8aDstLWgpYz1sWzEyNyZtKzM0XSxkPWxbbT0xMjcmbSsxXSxjXj1jPDwxMyxkXj1kPDwxNyxjXj1jPj4+MTUsZF49ZD4+PjEyLGxbbV09Y15kO3Audz1nLHAuWD1sLHAuaT1tfShzLGEpfShuKSxyPWkmJmkuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybih0Lm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2RvIHZhciBhPSgodC5uZXh0KCk+Pj4xMSkrKHQubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvMjA5NzE1Mjt3aGlsZSgwPT09YSk7cmV0dXJuIGF9LG8uaW50MzI9dC5uZXh0LG8ucXVpY2s9byxyJiYoci5YJiZzKHIsdCksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBzKHQse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPW46dCYmdC5hbWQ/dChmdW5jdGlvbigpe3JldHVybiBufSk6dGhpcy54b3I0MDk2PW59KDAsdCwhMSl9KSx0eWNoZWk9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGEsZSx0KXtmdW5jdGlvbiBzKGEsZSl7cmV0dXJuIGUuYT1hLmEsZS5iPWEuYixlLmM9YS5jLGUuZD1hLmQsZX1mdW5jdGlvbiBuKG4sZSl7dmFyIHQ9bmV3IGZ1bmN0aW9uKGEpe3ZhciBzPXRoaXMsZT1cIlwiO3MubmV4dD1mdW5jdGlvbigpe3ZhciB0PXMuYixhPXMuYyxpPXMuZCxwPXMuYTtyZXR1cm4gdD10PDwyNV50Pj4+N15hLGE9MHxhLWksaT1pPDwyNF5pPj4+OF5wLHA9MHxwLXQscy5iPXQ9dDw8MjBedD4+PjEyXmEscy5jPWE9MHxhLWkscy5kPWk8PDE2XmE+Pj4xNl5wLHMuYT0wfHAtdH0scy5hPTAscy5iPTAscy5jPS0xNjQwNTMxNTI3LHMuZD0xMzY3MTMwNTUxLGE9PT1fTWF0aGZsb29yKGEpPyhzLmE9MHxhLzQyOTQ5NjcyOTYscy5iPTB8YSk6ZSs9YTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoKzIwO3QrKylzLmJePTB8ZS5jaGFyQ29kZUF0KHQpLHMubmV4dCgpfShuKSxyPWUmJmUuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybih0Lm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2RvIHZhciBhPSgodC5uZXh0KCk+Pj4xMSkrKHQubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvMjA5NzE1Mjt3aGlsZSgwPT09YSk7cmV0dXJuIGF9LG8uaW50MzI9dC5uZXh0LG8ucXVpY2s9byxyJiYoXCJvYmplY3RcIj09dHlwZW9mIHImJnMocix0KSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHModCx7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9bjp0JiZ0LmFtZD90KGZ1bmN0aW9uKCl7cmV0dXJuIG59KTp0aGlzLnR5Y2hlaT1ufSgwLHQsITEpfSksc2VlZHJhbmRvbT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbihhKXshZnVuY3Rpb24ocyxpKXtmdW5jdGlvbiBlKGEsZSxuKXt2YXIgbT1bXSxoPXQoZnVuY3Rpb24gcyhlLHQpe3ZhciByPVtdLG89dHlwZW9mIGUsYTtpZih0JiZcIm9iamVjdFwiPT1vKWZvcihhIGluIGUpdHJ5e3IucHVzaChzKGVbYV0sdC0xKSl9Y2F0Y2godCl7fXJldHVybiByLmxlbmd0aD9yOlwic3RyaW5nXCI9PW8/ZTplK1wiXFwwXCJ9KChlPTE9PWU/e2VudHJvcHk6ITB9OmV8fHt9KS5lbnRyb3B5P1thLHAocyldOm51bGw9PWE/ZnVuY3Rpb24oKXt0cnl7dmFyIHQ7cmV0dXJuIGMmJih0PWMucmFuZG9tQnl0ZXMpP3Q9dCgyNTYpOih0PW5ldyBVaW50OEFycmF5KDI1NiksKGQuY3J5cHRvfHxkLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXModCkpLHAodCl9Y2F0Y2godCl7dmFyIGE9ZC5uYXZpZ2F0b3Isbj1hJiZhLnBsdWdpbnM7cmV0dXJuWytuZXcgRGF0ZSxkLG4sZC5zY3JlZW4scChzKV19fSgpOmEsMyksbSksZz1uZXcgZnVuY3Rpb24oYSl7dmFyIHA9YS5sZW5ndGgsbD10aGlzLG49MCxkPWwuaT1sLmo9MCx1PWwuUz1bXSxzO2ZvcihwfHwoYT1bcCsrXSk7bjwyNTY7KXVbbl09bisrO2ZvcihuPTA7bjwyNTY7bisrKXVbbl09dVtkPTI1NSZkK2FbbiVwXSsocz11W25dKV0sdVtkXT1zOyhsLmc9ZnVuY3Rpb24oYSl7Zm9yKHZhciBuPTAscD1sLmksZD1sLmosdT1sLlMsczthLS07KXM9dVtwPTI1NSZwKzFdLG49bioyNTYrdVsyNTUmKHVbcF09dVtkPTI1NSZkK3NdKSsodVtkXT1zKV07cmV0dXJuIGwuaT1wLGwuaj1kLG59KSgyNTYpfShtKSxmPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPWcuZyg2KSxuPW8scz0wO2E8dTspYT0oYStzKSoyNTYsbio9MjU2LHM9Zy5nKDEpO2Zvcig7YT49bDspYS89MixuLz0yLHM+Pj49MTtyZXR1cm4oYStzKS9ufTtyZXR1cm4gZi5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfGcuZyg0KX0sZi5xdWljaz1mdW5jdGlvbigpe3JldHVybiBnLmcoNCkvNDI5NDk2NzI5Nn0sZi5kb3VibGU9Zix0KHAoZy5TKSxzKSwoZS5wYXNzfHxufHxmdW5jdGlvbihhLGUsdCxuKXtyZXR1cm4gbiYmKG4uUyYmcihuLGcpLGEuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcihnLHt9KX0pLHQ/KGkucmFuZG9tPWEsZSk6YX0pKGYsaCxcImdsb2JhbFwiaW4gZT9lLmdsb2JhbDp0aGlzPT1pLGUuc3RhdGUpfWZ1bmN0aW9uIHIoYSxlKXtyZXR1cm4gZS5pPWEuaSxlLmo9YS5qLGUuUz1hLlMuc2xpY2UoKSxlfWZ1bmN0aW9uIHQoYSxlKXtmb3IodmFyIHQ9YStcIlwiLG49MCxzO248dC5sZW5ndGg7KWVbMjU1Jm5dPTI1NSYoc149MTkqZVsyNTUmbl0pK3QuY2hhckNvZGVBdChuKyspO3JldHVybiBwKGUpfWZ1bmN0aW9uIHAodCl7cmV0dXJuIF9TdHJpbmdmcm9tQ2hhckNvZGUuYXBwbHkoMCx0KX12YXIgZD10aGlzLG89aS5wb3coMjU2LDYpLHU9aS5wb3coMiw1MiksbD0yKnUsYztpZihpLnNlZWRyYW5kb209ZSx0KGkucmFuZG9tKCkscyksYS5leHBvcnRzKXthLmV4cG9ydHM9ZTt0cnl7Yz1yZXF1aXJlKFwiY3J5cHRvXCIpfWNhdGNoKHQpe319fShbXSxNYXRoKX0pO3NlZWRyYW5kb20uYWxlYT1hbGVhLHNlZWRyYW5kb20ueG9yMTI4PXhvcjEyOCxzZWVkcmFuZG9tLnhvcndvdz14b3J3b3csc2VlZHJhbmRvbS54b3JzaGlmdDc9eG9yc2hpZnQ3LHNlZWRyYW5kb20ueG9yNDA5Nj14b3I0MDk2LHNlZWRyYW5kb20udHljaGVpPXR5Y2hlaTt2YXIgc2VlZHJhbmRvbSQxPXNlZWRyYW5kb20sc2VlZHJhbmRvbV8xPXNlZWRyYW5kb20kMS5hbGVhLE1QUmFuZEdhdXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChzLGUsdCxyLG4pe3RoaXMubWVhbj1zLHRoaXMuc3RkRGV2PWUsdGhpcy5kdHlwZT10LHRoaXMubmV4dFZhbD1OYU4sdGhpcy50cnVuY2F0ZWQ9cix0aGlzLnRydW5jYXRlZCYmKHRoaXMudXBwZXI9dGhpcy5tZWFuKzIqdGhpcy5zdGREZXYsdGhpcy5sb3dlcj10aGlzLm1lYW4tMip0aGlzLnN0ZERldik7dmFyIG89bnx8TWF0aC5yYW5kb20oKTt0aGlzLnJhbmRvbT1zZWVkcmFuZG9tXzEoby50b1N0cmluZygpKX1yZXR1cm4gdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7aWYoIWlzTmFOKHRoaXMubmV4dFZhbCkpe3ZhciBwPXRoaXMubmV4dFZhbDtyZXR1cm4gdGhpcy5uZXh0VmFsPU5hTixwfWZvcih2YXIgZT0hMSxsLGQ7IWU7KXt2YXIgdT12b2lkIDAsYz12b2lkIDAsbT12b2lkIDA7ZG8gbT0odT0yKnRoaXMucmFuZG9tKCktMSkqdSsoYz0yKnRoaXMucmFuZG9tKCktMSkqYzt3aGlsZSgxPD1tfHwwPT09bSk7dmFyIGg9X01hdGhzcXJ0KC0yKl9NYXRobG9nKG0pL20pO2w9dGhpcy5tZWFuK3RoaXMuc3RkRGV2KnUqaCxkPXRoaXMubWVhbit0aGlzLnN0ZERldipjKmgsdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQobCl8fChlPSEwKX1yZXR1cm4gdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQoZCl8fCh0aGlzLm5leHRWYWw9dGhpcy5jb252ZXJ0VmFsdWUoZCkpLHRoaXMuY29udmVydFZhbHVlKGwpfSx0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMuZHR5cGV8fFwiZmxvYXQzMlwiPT09dGhpcy5kdHlwZT90Ol9NYXRocm91bmQodCl9LHQucHJvdG90eXBlLmlzVmFsaWRUcnVuY2F0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8PXRoaXMudXBwZXImJnQ+PXRoaXMubG93ZXJ9LHR9KCksYmF0Y2hUb1NwYWNlTkQ9b3Aoe2JhdGNoVG9TcGFjZU5EXzpiYXRjaFRvU3BhY2VORF99KSxjYXN0PW9wKHtjYXN0XzpjYXN0X30pLGNsb25lPW9wKHtjbG9uZV86Y2xvbmVffSksY3Vtc3VtPW9wKHtjdW1zdW1fOmN1bXN1bV99KSxkZXB0aFRvU3BhY2U9b3Aoe2RlcHRoVG9TcGFjZV86ZGVwdGhUb1NwYWNlX30pLGV4cGFuZERpbXM9b3Aoe2V4cGFuZERpbXNfOmV4cGFuZERpbXNffSksZXllPW9wKHtleWVfOmV5ZV99KSxmcm9tUGl4ZWxzPW9wKHtmcm9tUGl4ZWxzXzpmcm9tUGl4ZWxzX30pLG11bHRpbm9taWFsPW9wKHttdWx0aW5vbWlhbF86bXVsdGlub21pYWxffSksb25lSG90PW9wKHtvbmVIb3RfOm9uZUhvdF99KSxwYWQ9b3Aoe3BhZF86cGFkX30pLHBhZDFkPW9wKHtwYWQxZF86cGFkMWRffSkscGFkMmQ9b3Aoe3BhZDJkXzpwYWQyZF99KSxwYWQzZD1vcCh7cGFkM2RfOnBhZDNkX30pLHBhZDRkPW9wKHtwYWQ0ZF86cGFkNGRffSkscmFuZD1vcCh7cmFuZF86cmFuZF99KSxyYW5kb21Ob3JtYWw9b3Aoe3JhbmRvbU5vcm1hbF86cmFuZG9tTm9ybWFsX30pLHJhbmRvbVVuaWZvcm09b3Aoe3JhbmRvbVVuaWZvcm1fOnJhbmRvbVVuaWZvcm1ffSkscmVzaGFwZT1vcCh7cmVzaGFwZV86cmVzaGFwZV99KSxzcGFjZVRvQmF0Y2hORD1vcCh7c3BhY2VUb0JhdGNoTkRfOnNwYWNlVG9CYXRjaE5EX30pLHNxdWVlemU9b3Aoe3NxdWVlemVfOnNxdWVlemVffSksc3RhY2s9b3Aoe3N0YWNrXzpzdGFja199KSx0aWxlPW9wKHt0aWxlXzp0aWxlX30pLHRydW5jYXRlZE5vcm1hbD1vcCh7dHJ1bmNhdGVkTm9ybWFsXzp0cnVuY2F0ZWROb3JtYWxffSksdW5zdGFjaz1vcCh7dW5zdGFja186dW5zdGFja199KSxzZXRkaWZmMWRBc3luYz1zZXRkaWZmMWRBc3luY18sQ1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTEQ9MTAsQkVGT1JFX1BBR0lOR19DT05TVEFOVD0zMDAsTUFUTVVMX1NIQVJFRF9ESU1fVEhSRVNIT0xEPTFlMyxNYXRoQmFja2VuZFdlYkdMPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChhLGUpe2lmKHZvaWQgMD09PWUmJihlPSEwKSx0aGlzLmdwZ3B1PWEsdGhpcy5kZWxheWVkU3RvcmFnZT1lLHRoaXMucGVuZGluZ1JlYWQ9bmV3IFdlYWtNYXAsdGhpcy5wZW5kaW5nRGlzcG9zYWw9bmV3IFdlYWtTZXQsdGhpcy5scnVEYXRhR1BVPVtdLHRoaXMubnVtQnl0ZXNJbkdQVT0wLHRoaXMudXBsb2FkV2FpdE1zPTAsdGhpcy5kb3dubG9hZFdhaXRNcz0wLHRoaXMuYmluYXJ5Q2FjaGU9e30sdGhpcy5kaXNwb3NlZD0hMSwxPkVOVi5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7aWYobnVsbD09YSl7dmFyIG49Z2V0V2ViR0xDb250ZXh0KEVOVi5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpKTt0aGlzLmdwZ3B1PW5ldyBHUEdQVUNvbnRleHQobiksdGhpcy5jYW52YXM9bi5jYW52YXMsdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5PSEwfWVsc2UgdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5PSExLHRoaXMuY2FudmFzPWEuZ2wuY2FudmFzO0VOVi5nZXQoXCJXRUJHTF9QQUdJTkdfRU5BQkxFRFwiKSYmKHRoaXMuTlVNX0JZVEVTX0JFRk9SRV9QQUdJTkc9d2luZG93LnNjcmVlbi5oZWlnaHQqd2luZG93LnNjcmVlbi53aWR0aCp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbypCRUZPUkVfUEFHSU5HX0NPTlNUQU5UKSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBUZXh0dXJlTWFuYWdlcih0aGlzLmdwZ3B1KX1yZXR1cm4gdC5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24oYSxlLHQpe2lmKHRoaXMudGV4RGF0YS5oYXMoYSkpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3RoaXMudGV4RGF0YS5zZXQoYSx7c2hhcGU6ZSxkdHlwZTp0LHZhbHVlczpudWxsLHRleHR1cmU6bnVsbCxjb21wbGV4VGVuc29yczpudWxsLHRleFNoYXBlOm51bGwsdXNhZ2U6VGV4dHVyZVVzYWdlLlJFTkRFUixpc1BhY2tlZDohMX0pfSx0LnByb3RvdHlwZS5zZXREYXRhTW92ZXI9ZnVuY3Rpb24odCl7dGhpcy50ZXhEYXRhPW5ldyBEYXRhU3RvcmFnZSh0KX0sdC5wcm90b3R5cGUuZnJvbVBpeGVscz1mdW5jdGlvbihzLHApe2lmKG51bGw9PXMpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5mcm9tUGl4ZWxzKCkgY2FuIG5vdCBiZSBudWxsXCIpO3ZhciB0PVtzLmhlaWdodCxzLndpZHRoXSxyPVtzLmhlaWdodCxzLndpZHRoLHBdO2lmKCEocyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnR8fHMgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50fHxzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fHMgaW5zdGFuY2VvZiBJbWFnZURhdGEpKXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuZnJvbVBpeGVscygpIG11c3QgYmUgZWl0aGVyIGFuIEhUTUxWaWRlb0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxDYW52YXNFbGVtZW50IG9yIEltYWdlRGF0YSwgYnV0IHdhcyBcIitzLmNvbnN0cnVjdG9yLm5hbWUpO2lmKHMgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KXtpZihudWxsPT10aGlzLmZyb21QaXhlbHMyRENvbnRleHQpe2lmKCFFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHBpeGVscyBmcm9tIEhUTUxJbWFnZUVsZW1lbnQgb3V0c2lkZSB0aGUgYnJvd3Nlci5cIik7aWYoXCJjb21wbGV0ZVwiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRE9NIGlzIG5vdCByZWFkeSB5ZXQuIFBsZWFzZSBjYWxsIHRmLmZyb21QaXhlbHMoKSBvbmNlIHRoZSBET00gaXMgcmVhZHkuIE9uZSB3YXkgdG8gZG8gdGhhdCBpcyB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBET01Db250ZW50TG9hZGVkYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0XCIpO3RoaXMuZnJvbVBpeGVsczJEQ29udGV4dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKX10aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLndpZHRoPXMud2lkdGgsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy5oZWlnaHQ9cy5oZWlnaHQsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShzLDAsMCxzLndpZHRoLHMuaGVpZ2h0KSxzPXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXN9dmFyIG49dGhpcy5tYWtlVGVuc29ySGFuZGxlKHQsXCJpbnQzMlwiKTt0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKS51c2FnZT1UZXh0dXJlVXNhZ2UuUElYRUxTLHRoaXMuZ3BncHUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2V0VGV4dHVyZShuLmRhdGFJZCkscyk7dmFyIG89bmV3IEZyb21QaXhlbHNQcm9ncmFtKHIpLGE9dGhpcy5jb21waWxlQW5kUnVuKG8sW25dKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShuLmRhdGFJZCksYX0sdC5wcm90b3R5cGUubWFrZVRlbnNvckhhbmRsZT1mdW5jdGlvbihhLGUpe3ZhciB0PXt9O3JldHVybiB0aGlzLnJlZ2lzdGVyKHQsYSxlKSx7ZGF0YUlkOnQsc2hhcGU6YSxkdHlwZTplfX0sdC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24ocCxlKXtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIk1hdGhCYWNrZW5kV2ViR0wud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbFwiKTt2YXIgdD10aGlzLnRleERhdGEuZ2V0KHApLHI9dC50ZXh0dXJlLG49dC50ZXhTaGFwZSxvPXQudXNhZ2UsYT10LmR0eXBlLGk9dC5pc1BhY2tlZDtpZihcImNvbXBsZXg2NFwiPT09YSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gYSBjb21wbGV4NjQgZHR5cGUuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7bnVsbCE9ciYmKHRoaXMucmVsZWFzZVRleHR1cmUocCxyLG4sbyxpKSx0LnRleHR1cmU9bnVsbCx0LnRleFNoYXBlPW51bGwpLHQudXNhZ2U9VGV4dHVyZVVzYWdlLlVQTE9BRCx0LnZhbHVlcz1lLHRoaXMuZGVsYXllZFN0b3JhZ2V8fHRoaXMudXBsb2FkVG9HUFUocCl9LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHApe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQocCksdD1lLnZhbHVlcyxyPWUuZHR5cGUsbj1lLmNvbXBsZXhUZW5zb3JzO2lmKG51bGwhPXQpcmV0dXJuIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUocCk7dmFyIG89bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnMscyxsO3JldHVybiBsPShvJiYocz1wZXJmb3JtYW5jZS5ub3coKSksXCJjb21wbGV4NjRcIj09PXIpP21lcmdlUmVhbEFuZEltYWdBcnJheXMobi5yZWFsLmRhdGFTeW5jKCksbi5pbWFnLmRhdGFTeW5jKCkpOnRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUocCksbyYmKHRoaXMuZG93bmxvYWRXYWl0TXMrPXBlcmZvcm1hbmNlLm5vdygpLXMpLHRoaXMuY29udmVydEFuZENhY2hlT25DUFUocCxsKX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbihwKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBkLGUsbSxoLGcsZix5LGIseDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMucGVuZGluZ1JlYWQuaGFzKHApKXJldHVybiBkPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHApLFsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3JldHVybiBkLnB1c2godCl9KV07aWYoZT10aGlzLnRleERhdGEuZ2V0KHApLG09ZS50ZXh0dXJlLGg9ZS52YWx1ZXMsZz1lLnRleFNoYXBlLG51bGwhPWgpcmV0dXJuWzIsdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVShwKV07aWYodGhpcy5wZW5kaW5nUmVhZC5zZXQocCxbXSksIUVOVi5nZXQoXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpJiYyPT09RU5WLmdldChcIldFQkdMX1ZFUlNJT05cIikpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yLmRhdGEoKSB3aXRoIFdFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQ9ZmFsc2UgYW5kIFdFQkdMX1ZFUlNJT049MiBub3QgeWV0IHN1cHBvcnRlZC5cIik7cmV0dXJuIGY9dGhpcy5ncGdwdS5tYXliZUNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlKG0sZ1swXSxnWzFdKSxbNCx0aGlzLmdwZ3B1LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpXTtjYXNlIDE6cmV0dXJuIHQuc2VudCgpLHk9ZiBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZT90aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKHApOnRoaXMuZ3BncHUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcihmLGdbMF0sZ1sxXSksYj10aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHAseSkseD10aGlzLnBlbmRpbmdSZWFkLmdldChwKSx0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZShwKSx4LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQoYil9KSx0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXMocCkmJih0aGlzLnBlbmRpbmdEaXNwb3NhbC5kZWxldGUocCksdGhpcy5kaXNwb3NlRGF0YShwKSksWzIsYl07fX0pfSl9LHQucHJvdG90eXBlLmdldFZhbHVlc0Zyb21UZXh0dXJlPWZ1bmN0aW9uKG0pe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQobSksdD1lLnNoYXBlLHI9ZS5kdHlwZSxuPWUudGV4dHVyZSxvPWUudGV4U2hhcGU7aWYoRU5WLmdldChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikpe2lmKHRoaXMudGV4RGF0YS5nZXQobSkuaXNQYWNrZWQpe3ZhciBhPXNpemVGcm9tU2hhcGUodC5zbGljZSgwLHQubGVuZ3RoLTIpKSxpPTE8dC5sZW5ndGg/dFt0Lmxlbmd0aC0yXToxLHM9dFt0Lmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5ncGdwdS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlKG4sYSxpLHMsb1swXSxvWzFdKX1yZXR1cm4gdGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShuLG9bMF0sb1sxXSl9dmFyIHU9dGhpcy5tYWtlVGVuc29ySGFuZGxlKHQsXCJmbG9hdDMyXCIpO3Uuc2l6ZT1zaXplRnJvbVNoYXBlKHQpLHRoaXMudGV4RGF0YS5nZXQodS5kYXRhSWQpLnVzYWdlPVRleHR1cmVVc2FnZS5ET1dOTE9BRDt2YXIgbD1uZXcgRW5jb2RlRmxvYXRQcm9ncmFtKHQpO3RoaXMuY29tcGlsZUFuZFJ1bihsLFt7c2hhcGU6dCxkdHlwZTpyLGRhdGFJZDptfV0sdSxudWxsLCExKTt2YXIgYz10aGlzLnRleERhdGEuZ2V0KHUuZGF0YUlkKSxwPXRoaXMuZ3BncHUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmUoYy50ZXh0dXJlLGMudGV4U2hhcGVbMF0sYy50ZXhTaGFwZVsxXSk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEodS5kYXRhSWQpLHB9LHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24ocCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxsLGQsYyxtLGgsZztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPXRoaXMuYWN0aXZlVGltZXJzLGw9W10sZD0hMSxudWxsPT10aGlzLnByb2dyYW1UaW1lcnNTdGFjaz8odGhpcy5wcm9ncmFtVGltZXJzU3RhY2s9bCxkPSEwKTp0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKGwpLHRoaXMuYWN0aXZlVGltZXJzPWwscCgpLGM9ZmxhdHRlbih0aGlzLmFjdGl2ZVRpbWVycy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucXVlcnl9KSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSksbT1mbGF0dGVuKHRoaXMuYWN0aXZlVGltZXJzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pLHRoaXMuYWN0aXZlVGltZXJzPWUsZCYmKHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPW51bGwpLFs0LFByb21pc2UuYWxsKGMpXTtjYXNlIDE6cmV0dXJuIGg9dC5zZW50KCksZz17dXBsb2FkV2FpdE1zOnRoaXMudXBsb2FkV2FpdE1zLGRvd25sb2FkV2FpdE1zOnRoaXMuZG93bmxvYWRXYWl0TXMsa2VybmVsTXM6c3VtKGgpLGdldEV4dHJhUHJvZmlsZUluZm86ZnVuY3Rpb24oKXtyZXR1cm4gaC5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm57bmFtZTptW2VdLG1zOmF9fSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWUrXCI6IFwiK3QubXN9KS5qb2luKFwiLCBcIil9LHdhbGxNczpudWxsfSx0aGlzLnVwbG9hZFdhaXRNcz0wLHRoaXMuZG93bmxvYWRXYWl0TXM9MCxbMixnXTt9fSl9KX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJue3VucmVsaWFibGU6ITEsbnVtQnl0ZXNJbkdQVTp0aGlzLm51bUJ5dGVzSW5HUFV9fSx0LnByb3RvdHlwZS5zdGFydFRpbWVyPWZ1bmN0aW9uKCl7cmV0dXJuIDA8RU5WLmdldChcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpP3RoaXMuZ3BncHUuYmVnaW5RdWVyeSgpOntzdGFydE1zOnBlcmZvcm1hbmNlLm5vdygpLGVuZE1zOm51bGx9fSx0LnByb3RvdHlwZS5lbmRUaW1lcj1mdW5jdGlvbih0KXtyZXR1cm4gMDxFTlYuZ2V0KFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik/KHRoaXMuZ3BncHUuZW5kUXVlcnkoKSx0KToodC5lbmRNcz1wZXJmb3JtYW5jZS5ub3coKSx0KX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKGEpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gMDxFTlYuZ2V0KFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik/WzIsdGhpcy5ncGdwdS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKGEpXTpbMiwoZT1hKS5lbmRNcy1lLnN0YXJ0TXNdfSl9KX0sdC5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24ocyl7aWYoIXRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyhzKSlpZih0aGlzLnBlbmRpbmdSZWFkLmhhcyhzKSl0aGlzLnBlbmRpbmdEaXNwb3NhbC5hZGQocyk7ZWxzZSBpZih0aGlzLnRleERhdGEuaGFzKHMpKXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHMpLHQ9ZS50ZXh0dXJlLHI9ZS50ZXhTaGFwZSxuPWUudXNhZ2Usbz1lLmNvbXBsZXhUZW5zb3JzLGE9ZS5pc1BhY2tlZDtudWxsIT10JiZ0aGlzLnJlbGVhc2VUZXh0dXJlKHMsdCxyLG4sYSksbnVsbCE9byYmKG8ucmVhbC5kaXNwb3NlKCksby5pbWFnLmRpc3Bvc2UoKSksdGhpcy50ZXhEYXRhLmRlbGV0ZShzKX19LHQucHJvdG90eXBlLmdldFRleHR1cmU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudXBsb2FkVG9HUFUodCksdGhpcy50ZXhEYXRhLmdldCh0KS50ZXh0dXJlfSx0LnByb3RvdHlwZS5nZXRDUFVCYWNrZW5kPWZ1bmN0aW9uKCl7cmV0dXJuIEVOVi5nZXQoXCJXRUJHTF9DUFVfRk9SV0FSRFwiKT8obnVsbD09dGhpcy5jcHVCYWNrZW5kJiYodGhpcy5jcHVCYWNrZW5kPUVOVi5maW5kQmFja2VuZChcImNwdVwiKSksdGhpcy5jcHVCYWNrZW5kKTpudWxsfSx0LnByb3RvdHlwZS5zaG91bGRFeGVjdXRlT25DUFU9ZnVuY3Rpb24oYSxuKXt2YXIgbz10aGlzO3JldHVybiB2b2lkIDA9PT1uJiYobj1DUFVfSEFORE9GRl9TSVpFX1RIUkVTSE9MRCksbnVsbCE9dGhpcy5nZXRDUFVCYWNrZW5kKCkmJmEuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PW8udGV4RGF0YS5nZXQodC5kYXRhSWQpLnRleHR1cmUmJnQuc2l6ZTxufSl9LHQucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdwZ3B1fSx0LnByb3RvdHlwZS5nZXRDYW52YXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYW52YXN9LHQucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24oYSxlKXt2YXIgdD10aGlzLm1ha2VPdXRwdXRBcnJheShhLnNoYXBlLFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpFTlYuZW5naW5lLmtlZXAoYS5jbG9uZSgpKSxpbWFnOkVOVi5lbmdpbmUua2VlcChlLmNsb25lKCkpfSx0fSx0LnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmNsb25lKCl9LHQucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLmltYWcuY2xvbmUoKX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24oYSxlLHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFthXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zbGljZShhLGUsdCk7dmFyIHI9bmV3IFNsaWNlUHJvZ3JhbSh0KSxuPXIuZ2V0Q3VzdG9tU2V0dXBGdW5jKGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbYV0sbnVsbCxuKX0sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKG0sZSx0LHIsbixvLGEsaSxzKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbbV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc3RyaWRlZFNsaWNlKG0sZSx0LHIsbixvLGEsaSxzKTt2YXIgdT1nZXRTdHJpZGVkU2xpY2VkSW5mbyhtLnNoYXBlLGUsdCxyLG4sbyxhLGkscyksbD11WzBdLGM9dVsxXSxwPXVbMl0sZD1jLmZpbHRlcihmdW5jdGlvbihhLGUpe3JldHVybi0xPT09cC5pbmRleE9mKGUpfSk7aWYoZC5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dH0pKXJldHVybiB0ZW5zb3IoW10sZCk7dmFyIGg9bmV3IFN0cmlkZWRTbGljZVByb2dyYW0obCxyLGMscCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLFttXSl9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgUmV2ZXJzZVByb2dyYW0oYS5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2FdKX0sdC5wcm90b3R5cGUuY29uY2F0MlRlbnNvcnM9ZnVuY3Rpb24ocyxlLHQpe3ZhciByPWNvbXB1dGVPdXRTaGFwZShbcy5zaGFwZSxlLnNoYXBlXSx0KSxuPXMuYXMyRCgtMSxzaXplRnJvbVNoYXBlKHMuc2hhcGUuc2xpY2UodCkpKSxvPWUuYXMyRCgtMSxzaXplRnJvbVNoYXBlKGUuc2hhcGUuc2xpY2UodCkpKSxhPW5ldyBDb25jYXRQcm9ncmFtKG4uc2hhcGUsby5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFtuLG9dKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oYSxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShhKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmNvbmNhdChhLGUpO2lmKDE9PT1hLmxlbmd0aClyZXR1cm4gYVswXTtmb3IodmFyIHQ9YVswXSxvPTE7bzxhLmxlbmd0aDsrK28pdD10aGlzLmNvbmNhdDJUZW5zb3JzKHQsYVtvXSxlKTtyZXR1cm4gdH0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKGEpe3ZhciBlPW5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLE5FRyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFthXSl9LHQucHJvdG90eXBlLmJhdGNoTWF0TXVsPWZ1bmN0aW9uKG0sZyx5LHIpe3ZhciBuPXk/bS5zaGFwZVsyXTptLnNoYXBlWzFdLG89cj9nLnNoYXBlWzFdOmcuc2hhcGVbMl0sYT15P20uc2hhcGVbMV06bS5zaGFwZVsyXSxpPW0uc2hhcGVbMF07aWYoKDE9PT1ufHwxPT09bykmJmE+TUFUTVVMX1NIQVJFRF9ESU1fVEhSRVNIT0xEKXt5JiYobT1tLnRyYW5zcG9zZShbMCwyLDFdKSksciYmKGc9Zy50cmFuc3Bvc2UoWzAsMiwxXSkpO3ZhciBzPTE9PT1vP206bS5hczNEKGksYSwxKSx1PTE9PT1vPzI6MSxsPTE9PT1vP2cuYXMzRChpLDEsYSk6ZztyZXR1cm4gdGhpcy5tdWx0aXBseShzLGwpLnN1bSh1LCEwKX1pZigxPT09aSl7dmFyIGM9bS5hczJEKG0uc2hhcGVbMV0sbS5zaGFwZVsyXSkscD1nLmFzMkQoZy5zaGFwZVsxXSxnLnNoYXBlWzJdKSxkPW5ldyBNYXRNdWxQYWNrZWRQcm9ncmFtKGMuc2hhcGUscC5zaGFwZSxbbixvXSx5LHIpLGg9dGhpcy5jb21waWxlQW5kUnVuKGQsW2MscF0sdGhpcy5tYWtlUGFja2VkVGVuc29yKGQub3V0cHV0U2hhcGUpKTtyZXR1cm4hMT09PUVOVi5nZXQoXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIpJiYoaD10aGlzLnVucGFja1RlbnNvcihoKSksaC5yZXNoYXBlKFsxLGguc2hhcGVbMF0saC5zaGFwZVsxXV0pfXJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obmV3IE1hdE11bFByb2dyYW0obS5zaGFwZSxnLnNoYXBlLHksciksW20sZ10pfSx0LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihkLGUpe2lmKFwiY29tcGxleDY0XCI9PT1kLmR0eXBlKXt2YXIgdD10aGlzLnRleERhdGEuZ2V0KGQuZGF0YUlkKSxyPXRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLG49bmV3IEJpbmFyeU9wQ29tcGxleFByb2dyYW0oQ09NUExFWF9NVUxUSVBMWS5SRUFMLGQuc2hhcGUsZS5zaGFwZSksbz1uZXcgQmluYXJ5T3BDb21wbGV4UHJvZ3JhbShDT01QTEVYX01VTFRJUExZLklNQUcsZC5zaGFwZSxlLnNoYXBlKSxhPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGQsdC5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGQsdC5jb21wbGV4VGVuc29ycy5pbWFnKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsci5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsci5jb21wbGV4VGVuc29ycy5pbWFnKV0saT10aGlzLmNvbXBpbGVBbmRSdW4obixhKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihvLGEpLHU9dGhpcy5jb21wbGV4KGkscyk7cmV0dXJuIGkuZGlzcG9zZSgpLHMuZGlzcG9zZSgpLHV9aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW2QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubXVsdGlwbHkoZCxlKTt2YXIgbD1uZXcgQmluYXJ5T3BQcm9ncmFtKE1VTCxkLnNoYXBlLGUuc2hhcGUpLGM9dGhpcy5tYWtlT3V0cHV0QXJyYXkobC5vdXRwdXRTaGFwZSxkLmR0eXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGwsW2QsZV0sYyl9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbihkLGUsdCxyLG4sbyl7dmFyIGE9W2QsZSx0XSxpPW51bGw7bnVsbCE9byYmKGk9by5zaGFwZSxhLnB1c2gobykpO3ZhciBtPW51bGw7bnVsbCE9biYmKG09bi5zaGFwZSxhLnB1c2gobikpO3ZhciBoPW51bGwsZz1CYXRjaE5vcm1Qcm9ncmFtO0VOVi5nZXQoXCJXRUJHTF9QQUNLX0JBVENITk9STUFMSVpBVElPTlwiKSYmKGg9dGhpcy5tYWtlUGFja2VkVGVuc29yKGQuc2hhcGUpLGc9QmF0Y2hOb3JtUGFja2VkUHJvZ3JhbSk7dmFyIGY9bmV3IGcoZC5zaGFwZSxlLnNoYXBlLHQuc2hhcGUsaSxtLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZixhLGgpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHMsZSx0LHIsbil7dmFyIG89bmV3IExSTlByb2dyYW0ocy5zaGFwZSxlLHQscixuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3NdKX0sdC5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbihwLGUsdCxyLG4sbyxhKXt2YXIgaT1uZXcgTFJOR3JhZFByb2dyYW0oZS5zaGFwZSxyLG4sbyxhKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW2UsdCxwXSl9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgVGlsZVByb2dyYW0oYS5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2FdKX0sdC5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKGEsZSx0KXt2YXIgcj1uZXcgUGFkUHJvZ3JhbShhLnNoYXBlLGUsdCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFthXSl9LHQucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbihhLGUpe3ZhciB0PW5ldyBUcmFuc3Bvc2VQcm9ncmFtKGEuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthXSl9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbihhLGUsdCl7dmFyIHI9bmV3IEdhdGhlclByb2dyYW0oYS5zaGFwZSxlLnNpemUsdCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFthLGVdKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24ocCxlLHQpe2Fzc2VydCg0Pj1wLnJhbmssXCJiYXRjaFRvU3BhY2VORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwiKTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbihhLGUpe3JldHVybiBhKmV9KSxuPWdldFJlc2hhcGVkKHAuc2hhcGUsZSxyKSxvPWdldFBlcm11dGVkKG4ubGVuZ3RoLGUubGVuZ3RoKSxhPWdldFJlc2hhcGVkUGVybXV0ZWQocC5zaGFwZSxlLHIpLGk9Z2V0U2xpY2VCZWdpbkNvb3Jkcyh0LGUubGVuZ3RoKSxzPWdldFNsaWNlU2l6ZShhLHQsZS5sZW5ndGgpO3JldHVybiBwLnJlc2hhcGUobikudHJhbnNwb3NlKG8pLnJlc2hhcGUoYSkuc2xpY2UoaSxzKX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24ocCxlLHQpe2Fzc2VydCg0Pj1wLnJhbmssXCJzcGFjZVRvQmF0Y2hORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwiKTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbihhLGUpe3JldHVybiBhKmV9KSxuPVtbMCwwXV07bi5wdXNoLmFwcGx5KG4sdCk7Zm9yKHZhciBvPTErZS5sZW5ndGg7bzxwLnNoYXBlLmxlbmd0aDsrK28pbi5wdXNoKFswLDBdKTt2YXIgZD1wLnBhZChuKSxpPWdldFJlc2hhcGVkKGQuc2hhcGUsZSxyLCExKSxzPWdldFBlcm11dGVkKGkubGVuZ3RoLGUubGVuZ3RoLCExKSx1PWdldFJlc2hhcGVkUGVybXV0ZWQoZC5zaGFwZSxlLHIsITEpO3JldHVybiBkLnJlc2hhcGUoaSkudHJhbnNwb3NlKHMpLnJlc2hhcGUodSl9LHQucHJvdG90eXBlLnJlZHVjZT1mdW5jdGlvbihwLGUsdCl7dmFyIHI9cC5zaGFwZVswXSxuPXAuc2hhcGVbMV0sbz1jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUobiksYT1uZXcgUmVkdWNlUHJvZ3JhbSh7d2luZG93U2l6ZTpvLGluU2l6ZTpuLGJhdGNoU2l6ZTpyfSxlKSxpPWEub3V0cHV0U2hhcGUscz1pWzBdLGQ9aVsxXSxsPXRoaXMubWFrZU91dHB1dEFycmF5KFtzLGRdLHQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxbcF0sbCksMT09PWwuc2hhcGVbMV0/bDp0aGlzLnJlZHVjZShsLGUsdCl9LHQucHJvdG90eXBlLmFyZ1JlZHVjZT1mdW5jdGlvbihkLGUsdCl7dm9pZCAwPT09dCYmKHQ9bnVsbCk7dmFyIG09ZC5zaGFwZVswXSxoPWQuc2hhcGVbMV07bnVsbCE9dCYmKG09dC5zaGFwZVswXSxoPXQuc2hhcGVbMV0pO3ZhciBnPWNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShoKSxhPW5ldyBBcmdNaW5NYXhQcm9ncmFtKHt3aW5kb3dTaXplOmcsaW5TaXplOmgsYmF0Y2hTaXplOm19LGUsbnVsbD09dCksaT1hLm91dHB1dFNoYXBlLHM9aVswXSx1PWlbMV0sbD10aGlzLm1ha2VPdXRwdXRBcnJheShbcyx1XSxcImludDMyXCIpLGM9W2RdO3JldHVybiBudWxsIT10JiZjLnB1c2godCksdGhpcy5jb21waWxlQW5kUnVuKGEsYyxsKSwxPT09bC5zaGFwZVsxXT9sOnRoaXMuYXJnUmVkdWNlKGQsZSxsKX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHMsZSl7YXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJzdW1cIixlLHMucmFuayk7dmFyIHQ9Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhzLnNoYXBlLGUpLHI9dFswXSxuPXNpemVGcm9tU2hhcGUodFsxXSksbz1zLmFzMkQoLTEsbiksYT1zdW1PdXRUeXBlKHMuZHR5cGUpO3JldHVybiB0aGlzLnJlZHVjZShvLFwic3VtXCIsYSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbihzLGUpe3ZhciB0PWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocy5zaGFwZSxlKSxyPXRbMF0sbj1zaXplRnJvbVNoYXBlKHRbMV0pLG89cy5hczJEKC0xLG4pLGE9c3VtT3V0VHlwZShzLmR0eXBlKTtyZXR1cm4gdGhpcy5yZWR1Y2UobyxcInByb2RcIixhKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24ocCxlLHQpe3ZhciByPTAsZD1nZXRBeGVzUGVybXV0YXRpb24oW3JdLHAucmFuayksbz1wO251bGwhPWQmJihvPXAudHJhbnNwb3NlKGQpLHI9Z2V0SW5uZXJNb3N0QXhlcygxLHAucmFuaylbMF0pO3ZhciBtPWNvbXB1dGVPdXRTaGFwZSQxKG8uc2hhcGUscix0KSxpPXNpemVGcm9tU2hhcGUoW28uc2hhcGVbcl1dKSxzPW8uYXMyRCgtMSxpKSx1PXN1bU91dFR5cGUocC5kdHlwZSksbD10aGlzLnNlZ09wQ29tcHV0ZShzLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsZSx1LHQpLnJlc2hhcGUobSk7cmV0dXJuIG51bGwhPWQmJihsPWwudHJhbnNwb3NlKGdldFVuZG9BeGVzUGVybXV0YXRpb24oZCkpKSxsfSx0LnByb3RvdHlwZS5zZWdPcENvbXB1dGU9ZnVuY3Rpb24obSxlLHQsaCxuKXt2YXIgbz1tLnNoYXBlWzBdLGE9bS5zaGFwZVsxXSxpPXNlZ09wQ29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGEsbikscz1uZXcgU2VnbWVudE9wUHJvZ3JhbSh7d2luZG93U2l6ZTppLGluU2l6ZTphLGJhdGNoU2l6ZTpvLG51bVNlZ21lbnRzOm59LGUpLHU9cy5vdXRwdXRTaGFwZSxsPXVbMF0sYz11WzFdLHA9dGhpcy5tYWtlT3V0cHV0QXJyYXkoW2wsY10saCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLFttLHRdLHApLHAuc2hhcGVbMV09PT1uP3A6KHQ9cmFuZ2UoMCxuKS50aWxlKFthL2ldKSx0aGlzLnNlZ09wQ29tcHV0ZShwLGUsdCxoLG4pKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHMsZSl7dmFyIHQ9W2VdO2Fzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYXJnTWluXCIsdCxzLnJhbmspO3ZhciByPWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocy5zaGFwZSx0KSxuPXJbMF0sbz1zaXplRnJvbVNoYXBlKHJbMV0pLGE9cy5hczJEKC0xLG8pO3JldHVybiB0aGlzLmFyZ1JlZHVjZShhLFwibWluXCIpLnJlc2hhcGUobil9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbihzLGUpe3ZhciB0PVtlXTthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01heFwiLHQscy5yYW5rKTt2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHMuc2hhcGUsdCksbj1yWzBdLG89c2l6ZUZyb21TaGFwZShyWzFdKSxhPXMuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5hcmdSZWR1Y2UoYSxcIm1heFwiKS5yZXNoYXBlKG4pfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24oYSxlLHQscil7aWYoZSE9PWEucmFuay0xKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGN1bXN1bSBzaGFkZXIgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIrKGEucmFuay0xKStcIiBidXQgZ290IGF4aXM9XCIrZSk7dmFyIG49bmV3IEN1bVN1bVByb2dyYW0oYS5zaGFwZSx0LHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbYV0pfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbihhLGUpe3ZhciB0PW5ldyBCaW5hcnlPcFByb2dyYW0oRVFVQUwsYS5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSxyKX0sdC5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKE5PVF9FUVVBTCxhLnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthLGVdLHIpfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKGEsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW2EsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubGVzcyhhLGUpO3ZhciB0PW5ldyBCaW5hcnlPcFByb2dyYW0oTEVTUyxhLnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthLGVdLHIpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKExFU1NfRVFVQUwsYS5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSxyKX0sdC5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbihhLGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFthLGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmdyZWF0ZXIoYSxlKTt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKEdSRUFURVIsYS5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSxyKX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKGEsZSl7dmFyIHQ9bmV3IEJpbmFyeU9wUHJvZ3JhbShHUkVBVEVSX0VRVUFMLGEuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheSh0Lm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2EsZV0scil9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsTE9HSUNBTF9OT1QpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKGEsZSl7dmFyIHQ9bmV3IEJpbmFyeU9wUHJvZ3JhbShMT0dJQ0FMX0FORCxhLnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthLGVdLHIpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKExPR0lDQUxfT1IsYS5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSxyKX0sdC5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKGEsZSx0KXt2YXIgcj1uZXcgU2VsZWN0UHJvZ3JhbShhLnJhbmssZS5zaGFwZSxlLnJhbmspLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSx1cGNhc3RUeXBlKGUuZHR5cGUsdC5kdHlwZSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbYSxlLHRdLG4pfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbihhKXt3YXJuKFwidGYud2hlcmUoKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLndoZXJlQXN5bmMoKSBpbnN0ZWFkXCIpO3ZhciBlPWEuZGF0YVN5bmMoKTtyZXR1cm4gd2hlcmVJbXBsKGEuc2hhcGUsZSl9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24oYSxlLHQpe3JldHVybiB0b3BrSW1wbChhLmRhdGFTeW5jKCksYS5zaGFwZSxhLmR0eXBlLGUsdCl9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbihzLGUpe2Fzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWluXCIsZSxzLnJhbmspO3ZhciB0PWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocy5zaGFwZSxlKSxyPXRbMF0sbj1zaXplRnJvbVNoYXBlKHRbMV0pLG89cy5hczJEKC0xLG4pO3JldHVybiB0aGlzLnJlZHVjZShvLFwibWluXCIsby5kdHlwZSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbihhLGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFthLGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1pbmltdW0oYSxlKTt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKE1JTixhLnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSl9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbihhLGUpe3ZhciB0PW5ldyBCaW5hcnlPcFByb2dyYW0oTU9ELGEuc2hhcGUsZS5zaGFwZSkscj10LmdldEN1c3RvbVNldHVwRnVuYygpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSxudWxsLHIpfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24ocyxlKXthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1heFwiLGUscy5yYW5rKTt2YXIgdD1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHMuc2hhcGUsZSkscj10WzBdLG49c2l6ZUZyb21TaGFwZSh0WzFdKSxvPXMuYXMyRCgtMSxuKTtyZXR1cm4gdGhpcy5yZWR1Y2UobyxcIm1heFwiLG8uZHR5cGUpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24oYSxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbYSxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tYXhpbXVtKGEsZSk7dmFyIHQ9bmV3IEJpbmFyeU9wUHJvZ3JhbShNQVgsYS5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2EsZV0pfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24ocyxlKXthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFsbFwiLGUscy5yYW5rKTt2YXIgdD1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHMuc2hhcGUsZSkscj10WzBdLG49c2l6ZUZyb21TaGFwZSh0WzFdKSxvPXMuYXMyRCgtMSxuKTtyZXR1cm4gdGhpcy5yZWR1Y2UobyxcImFsbFwiLG8uZHR5cGUpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbihzLGUpe2Fzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYW55XCIsZSxzLnJhbmspO3ZhciB0PWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocy5zaGFwZSxlKSxyPXRbMF0sbj1zaXplRnJvbVNoYXBlKHRbMV0pLG89cy5hczJEKC0xLG4pO3JldHVybiB0aGlzLnJlZHVjZShvLFwiYW55XCIsby5kdHlwZSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKFNRVUFSRURfRElGRkVSRU5DRSxhLnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSl9LHQucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKERJVixhLnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5vdXRwdXRTaGFwZSxcImZsb2F0MzJcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthLGVdLHIpfSx0LnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbihhLGUpe3ZhciB0PW5ldyBCaW5hcnlPcFByb2dyYW0oSU5UX0RJVixhLnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5vdXRwdXRTaGFwZSxcImludDMyXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSxyKX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEsZSl7aWYoXCJjb21wbGV4NjRcIj09PWEuZHR5cGUmJlwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXJldHVybiB0aGlzLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcChhLGUsQUREKTt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKEFERCxhLnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5vdXRwdXRTaGFwZSx1cGNhc3RUeXBlKGEuZHR5cGUsZS5kdHlwZSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSxyKX0sdC5wcm90b3R5cGUuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wPWZ1bmN0aW9uKHAsZSx0KXt2YXIgcj10aGlzLG49dGhpcy50ZXhEYXRhLmdldChwLmRhdGFJZCksbz10aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxhPVtbbi5jb21wbGV4VGVuc29ycy5yZWFsLG8uY29tcGxleFRlbnNvcnMucmVhbF0sW24uY29tcGxleFRlbnNvcnMuaW1hZyxvLmNvbXBsZXhUZW5zb3JzLmltYWddXS5tYXAoZnVuY3Rpb24obil7dmFyIG89blswXSxhPW5bMV0saT1uZXcgQmluYXJ5T3BQcm9ncmFtKHQscC5zaGFwZSxlLnNoYXBlKSxzPXIubWFrZU91dHB1dEFycmF5KGkub3V0cHV0U2hhcGUsdXBjYXN0VHlwZShvLmR0eXBlLGEuZHR5cGUpKSxkPXIubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUocCxvKSxsPXIubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoZSxhKTtyZXR1cm4gci5jb21waWxlQW5kUnVuKGksW2QsbF0scyl9KSxpPWFbMF0scz1hWzFdLGQ9dGhpcy5jb21wbGV4KGkscyk7cmV0dXJuIGkuZGlzcG9zZSgpLHMuZGlzcG9zZSgpLGR9LHQucHJvdG90eXBlLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlPWZ1bmN0aW9uKGEsZSl7cmV0dXJue2RhdGFJZDplLmRhdGFJZCxkdHlwZTplLmR0eXBlLHNoYXBlOmEuc2hhcGV9fSx0LnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKGEpe2Zvcih2YXIgZT1hWzBdLG49MTtuPGEubGVuZ3RoO24rKyllPXRoaXMuYWRkKGUsYVtuXSk7cmV0dXJuIGV9LHQucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKGEsZSl7aWYoXCJjb21wbGV4NjRcIj09PWEuZHR5cGUmJlwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXJldHVybiB0aGlzLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcChhLGUsU1VCKTtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbYSxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zdWJ0cmFjdChhLGUpO3ZhciB0PW5ldyBCaW5hcnlPcFByb2dyYW0oU1VCLGEuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheSh0Lm91dHB1dFNoYXBlLHVwY2FzdFR5cGUoYS5kdHlwZSxlLmR0eXBlKSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthLGVdLHIpfSx0LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKFBPVyxhLnNoYXBlLGUuc2hhcGUpLHI9dC5nZXRDdXN0b21TZXR1cEZ1bmMoKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsdXBjYXN0VHlwZShhLmR0eXBlLGUuZHR5cGUpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2EsZV0sbixyKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxDRUlMKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsRkxPT1IpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKGEpe3ZhciBlPW5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLFNJR04pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxST1VORCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFthXSl9LHQucHJvdG90eXBlLmV4cD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxFWFApO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxFWFBNMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFthXSl9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxMT0cpLHQ9ZS5nZXRDdXN0b21TZXR1cEZ1bmMoKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdLG51bGwsdCl9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKGEpe3ZhciBlPW5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLExPRzFQKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxTUVJUKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsUlNRUlQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsU1FVQVJFKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxSRUNJUFJPQ0FMKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxSRUxVKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKGEpe3ZhciBlPW5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLEVMVSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFthXSl9LHQucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbihhLGUpe3ZhciB0PW5ldyBCaW5hcnlPcFByb2dyYW0oRUxVX0RFUixhLnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odCxbYSxlXSl9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsU0VMVSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFthXSl9LHQucHJvdG90eXBlLmludD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxUT19JTlQpLHQ9dGhpcy5tYWtlT3V0cHV0QXJyYXkoZS5vdXRwdXRTaGFwZSxcImludDMyXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0sdCl9LHQucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24oYSxlLHQpe3ZhciByPW5ldyBDbGlwUHJvZ3JhbShhLnNoYXBlLGUsdCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFthXSl9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxBQlMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKGEpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQoYS5kYXRhSWQpLHQ9bmV3IENvbXBsZXhBYnNQcm9ncmFtKGEuc2hhcGUpLHI9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoYSxlLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoYSxlLmNvbXBsZXhUZW5zb3JzLmltYWcpXTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQscil9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsU0lHTU9JRCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFthXSl9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKGEpe3ZhciBlPW5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLFNPRlRQTFVTKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKGEpe3ZhciBlPW5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLFNJTik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFthXSl9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxDT1MpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS50YW49ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsVEFOKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxBU0lOKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxBQ09TKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxBVEFOKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uZXcgQmluYXJ5T3BQcm9ncmFtKEFUQU4yLGEuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthLGVdKX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxTSU5IKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxDT1NIKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUudGFuaD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxUQU5IKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsQVNJTkgpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxBQ09TSCksdD1lLmdldEN1c3RvbVNldHVwRnVuYygpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0sbnVsbCx0KX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24oYSl7dmFyIGU9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsQVRBTkgpLHQ9ZS5nZXRDdXN0b21TZXR1cEZ1bmMoKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdLG51bGwsdCl9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSxFUkYpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbYV0pfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKGEsZSl7dmFyIHQ9bmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsU1RFUChlKSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthXSl9LHQucHJvdG90eXBlLmNvbnYyZFdpdGhJbTJSb3c9ZnVuY3Rpb24oeSxlLHQpe3ZhciByPXQuZmlsdGVyV2lkdGgsbj10LmZpbHRlckhlaWdodCxvPXQuaW5DaGFubmVscyxhPXQub3V0V2lkdGgsaT10Lm91dEhlaWdodCxzPXIqbipvLHU9aSphLGw9W3MsdV0sYz15LnNxdWVlemUoWzBdKSxwPWUucmVzaGFwZShbcywtMV0pLGQ9bmV3IEltMkNvbFByb2dyYW0obCxjLnNoYXBlLHQpLGg9dGhpcy5jb21waWxlQW5kUnVuKGQsW2NdLHRoaXMubWFrZVBhY2tlZFRlbnNvcihsKSksZj1uZXcgTWF0TXVsUGFja2VkUHJvZ3JhbShoLnNoYXBlLHAuc2hhcGUsW3UsdC5vdXRDaGFubmVsc10sITAsITEpLG09dGhpcy5jb21waWxlQW5kUnVuKGYsW2gscF0sdGhpcy5tYWtlUGFja2VkVGVuc29yKGYub3V0cHV0U2hhcGUpKTtyZXR1cm4hMT09PUVOVi5nZXQoXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIpJiYobT10aGlzLnVucGFja1RlbnNvcihtKSksbS5yZXNoYXBlKFsxLGksYSx0Lm91dENoYW5uZWxzXSl9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbihhLGUsdCl7aWYoRU5WLmdldChcIldFQkdMX0NPTlZfSU0yQ09MXCIpJiYxPT09YS5zaGFwZVswXSlyZXR1cm4gdGhpcy5jb252MmRXaXRoSW0yUm93KGEsZSx0KTt2YXIgcj1uZXcgQ29udjJEUHJvZ3JhbSh0KTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2EsZV0pfSx0LnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbihhLGUsdCl7dmFyIHI9bmV3IENvbnYyRERlcklucHV0UHJvZ3JhbSh0KTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2EsZV0pfSx0LnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24oYSxlLHQpe3ZhciByPW5ldyBDb252MkREZXJGaWx0ZXJQcm9ncmFtKHQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbYSxlXSl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbihhLGUsdCl7dmFyIHI9bmV3IERlcHRod2lzZUNvbnYyRFByb2dyYW0odCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFthLGVdKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24oYSxlLHQpe3ZhciByPW5ldyBEZXB0aHdpc2VDb252MkREZXJJbnB1dFByb2dyYW0odCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFthLGVdKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKGEsZSx0KXt2YXIgcj1uZXcgRGVwdGh3aXNlQ29udjJERGVyRmlsdGVyUHJvZ3JhbSh0KTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW2EsZV0pfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKGEsZSl7dmFyIHQ9bmV3IFBvb2wyRFByb2dyYW0oZSxcIm1heFwiLCExKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsYS5kdHlwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih0LFthXSxyKX0sdC5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbihhLGUpe3ZhciB0PW5ldyBQb29sMkRQcm9ncmFtKGUsXCJhdmdcIiwhMSkscj10aGlzLm1ha2VPdXRwdXRBcnJheSh0Lm91dHB1dFNoYXBlLFwiZmxvYXQzMlwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHQsW2FdLHIpfSx0LnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24ocCxlLHQscil7dmFyIG49bmV3IFBvb2wyRFByb2dyYW0ocixcIm1heFwiLCEwKSxvPXRoaXMuY29tcGlsZUFuZFJ1bihuLFtlXSksYT1uZXcgTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtKHIpLGk9dGhpcy5tYWtlT3V0cHV0QXJyYXkoYS5vdXRwdXRTaGFwZSxlLmR0eXBlKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihhLFtwLG9dLGkpO3JldHVybiBvLmRpc3Bvc2UoKSxzfSx0LnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24oYSxlLHQpe3ZhciByPW5ldyBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW0odCksbj10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLGUuZHR5cGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbYV0sbil9LHQucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gY2FzdFRlbnNvcihhLGUsdGhpcyl9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChhLmRhdGFJZCkuaXNQYWNrZWQmJiFpc1Jlc2hhcGVGcmVlKGEuc2hhcGUsZSk/dGhpcy5wYWNrZWRSZXNoYXBlKGEsZSk6cmVzaGFwZVRlbnNvcihhLGUpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbihhLGUsdCxyKXt2YXIgbj1uZXcgUmVzaXplQmlsaW5lYXJQcm9ncmFtKGEuc2hhcGUsZSx0LHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbYV0pfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKGEsZSx0KXt2YXIgcj1uZXcgUmVzaXplQmlsaW5lYXJCYWNrcHJvcFByb2dyYW0oYSxlLHQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbYV0pfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24oYSxlLHQscil7dmFyIG49bmV3IFJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW0oYS5zaGFwZSxlLHQscik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFthXSl9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKGEsZSx0KXt2YXIgcj1uZXcgUmVzaXplTmVhcmVzdE5laWdib3JCYWNrcHJvcFByb2dyYW0oYSxlLHQpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbYV0pfSx0LnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbihwLGUsdCxyKXt2YXIgbj1lP3A6c29mdG1heChwKSxvPW4uc2hhcGVbMF0sYT1uLnNoYXBlWzFdLGk9bmV3IE11bHRpbm9taWFsUHJvZ3JhbShvLGEsdCkscz10aGlzLm1ha2VPdXRwdXRBcnJheShpLm91dHB1dFNoYXBlLFwiaW50MzJcIiksZD1pLmdldEN1c3RvbVNldHVwRnVuYyhyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW25dLHMsZCl9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbihhLGUsdCxyKXt2YXIgbj1uZXcgT25lSG90UHJvZ3JhbShhLnNpemUsZSx0LHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbYV0pfSx0LnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbihhLGUsdCxyLG4pe3JldHVybiB3YXJuKFwidGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkXCIpLG5vbk1heFN1cHByZXNzaW9uSW1wbChhLmRhdGFTeW5jKCksZS5kYXRhU3luYygpLHQscixuKX0sdC5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbihzLGUsdCxyLG4sbyl7dmFyIGE9bmV3IENyb3BBbmRSZXNpemVQcm9ncmFtKHMuc2hhcGUsZS5zaGFwZSxyLG4sbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFtzLGUsdF0pfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24ocCxlLHQpe2Fzc2VydCgxPGUsXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIitlKTt2YXIgcj1wLnNoYXBlWzBdLG49KFwiTkhXQ1wiPT09dD9wLnNoYXBlWzFdOnAuc2hhcGVbMl0pKmUsbz0oXCJOSFdDXCI9PT10P3Auc2hhcGVbMl06cC5zaGFwZVszXSkqZSxhPShcIk5IV0NcIj09PXQ/cC5zaGFwZVszXTpwLnNoYXBlWzFdKS8oZSplKSxpPW5ldyBEZXB0aFRvU3BhY2VQcm9ncmFtKFwiTkhXQ1wiPT09dD9bcixuLG8sYV06W3IsYSxuLG9dLGUsdCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihpLFtwXSl9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGEsZSx0KXtyZXR1cm4gc3BsaXQoYSxlLHQpfSx0LnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24obCxlLHQpe3ZhciByPWNhbGN1bGF0ZVNoYXBlcyhlLGwsdCksbj1yLnNsaWNlUmFuayxvPXIubnVtVXBkYXRlcyxhPXIuc2xpY2VTaXplLGk9ci5zdHJpZGVzLHM9ci5vdXRwdXRTaXplLHU9bC5yZXNoYXBlKFtvLG5dKSxjPWUucmVzaGFwZShbbyxhXSk7aWYoMD09PXMpcmV0dXJuIHJlc2hhcGVUZW5zb3IodGVuc29yKFtdKSx0KTt2YXIgcD1zY2FsYXIoMCksZD1uZXcgU2NhdHRlclByb2dyYW0obyxuLHUucmFuayxjLnJhbmssaSxbcy9hLGFdKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGQsW2MsdSxwXSkucmVzaGFwZSh0KX0sdC5wcm90b3R5cGUuc3BhcnNlVG9EZW5zZT1mdW5jdGlvbihwLGUsdCxyKXt2YXIgbj1jYWxjdWxhdGVTaGFwZXMoZSxwLHQpLG89bi5zbGljZVJhbmssYT1uLm51bVVwZGF0ZXMsaT1uLnN0cmlkZXMscz1uLm91dHB1dFNpemUsZD1uZXcgU2NhdHRlclByb2dyYW0oYSxvLHAucmFuayxlLnJhbmssaSxbcywxXSwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihkLFtlLHAscl0pLnJlc2hhcGUodCl9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITEpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEltcGwodCwhMCl9LHQucHJvdG90eXBlLmZmdEltcGw9ZnVuY3Rpb24ocCxlKXt2YXIgdD10aGlzLnRleERhdGEuZ2V0KHAuZGF0YUlkKSxyPW5ldyBGRlRQcm9ncmFtKENPTVBMRVhfRkZULlJFQUwscC5zaGFwZSxlKSxuPW5ldyBGRlRQcm9ncmFtKENPTVBMRVhfRkZULklNQUcscC5zaGFwZSxlKSxvPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHAsdC5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHAsdC5jb21wbGV4VGVuc29ycy5pbWFnKV0sYT10aGlzLmNvbXBpbGVBbmRSdW4ocixvKSxpPXRoaXMuY29tcGlsZUFuZFJ1bihuLG8pLHM9dGhpcy5jb21wbGV4KGEsaSkuYXMyRChwLnNoYXBlWzBdLHAuc2hhcGVbMV0pO3JldHVybiBhLmRpc3Bvc2UoKSxpLmRpc3Bvc2UoKSxzfSx0LnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbihkLGUpe3ZhciB0PWUuc2hhcGUscj10W3QubGVuZ3RoLTFdLG49cHJlcGFyZUFuZFZhbGlkYXRlKGQsZSksbz1uWzBdLGE9blsxXSxpPW5bMl0scz1uWzNdLHU9ZS5yZXNoYXBlKFthLHJdKSxsPWQucmVzaGFwZShbZC5zaXplL2ksaV0pLGM9bmV3IEdhdGhlck5EUHJvZ3JhbShyLHMsW2EsaV0pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYyxbbCx1XSkucmVzaGFwZShvKX0sdC5wcm90b3R5cGUubWFrZU91dHB1dEFycmF5PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIFRlbnNvci5tYWtlKGEse30sZSl9LHQucHJvdG90eXBlLm1ha2VQYWNrZWRUZW5zb3I9ZnVuY3Rpb24oYSl7dmFyIGU9VGVuc29yLm1ha2UoYSx7fSk7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLmlzUGFja2VkPSEwLGV9LHQucHJvdG90eXBlLnVucGFja1RlbnNvcj1mdW5jdGlvbihhKXt2YXIgZT1uZXcgVW5wYWNrUHJvZ3JhbShhLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW2FdKX0sdC5wcm90b3R5cGUuZ2V0QmF0Y2hEaW09ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9Miksc2l6ZUZyb21TaGFwZShhLnNsaWNlKDAsYS5sZW5ndGgtZSkpfSx0LnByb3RvdHlwZS5nZXRSb3dzQ29scz1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblsxPHQubGVuZ3RoP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sdC5wcm90b3R5cGUucGFja2VkUmVzaGFwZT1mdW5jdGlvbihhLGUpe3ZhciB0PWEucmVzaGFwZShbdGhpcy5nZXRCYXRjaERpbShhLnNoYXBlKV0uY29uY2F0KHRoaXMuZ2V0Um93c0NvbHMoYS5zaGFwZSkpKSxyPVt0aGlzLmdldEJhdGNoRGltKGUpXS5jb25jYXQodGhpcy5nZXRSb3dzQ29scyhlKSksbj1uZXcgUmVzaGFwZVBhY2tlZFByb2dyYW0ocix0LnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdLHRoaXMubWFrZVBhY2tlZFRlbnNvcihyKSkucmVzaGFwZShlKX0sdC5wcm90b3R5cGUuY29tcGlsZUFuZFJ1bj1mdW5jdGlvbih5LGUsdCxiLG4pe3ZhciB4PXRoaXM7aWYodm9pZCAwPT09biYmKG49ITApLG51bGw9PXQmJih0PXRoaXMubWFrZU91dHB1dEFycmF5KHkub3V0cHV0U2hhcGUsZVswXS5kdHlwZSkpLDA9PT10LnNpemUpcmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLnZhbHVlcz1nZXRUeXBlZEFycmF5RnJvbURUeXBlKHQuZHR5cGUsMCksdDt2YXIgYT1lLm1hcChmdW5jdGlvbihlKXtpZihcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJHUEdQVVByb2dyYW0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgaW5wdXQuIEZvciBjb21wbGV4NjQgZHR5cGVzLCBwbGVhc2Ugc2VwYXJhdGUgdGhlIHByb2dyYW0gaW50byByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMuXCIpO3ZhciBhPXgudGV4RGF0YS5nZXQoZS5kYXRhSWQpO2lmKG51bGw9PWEudGV4dHVyZSYmKGEuaXNQYWNrZWR8fCF5LnVzZXNQYWNrZWRUZXh0dXJlcykmJnNpemVGcm9tU2hhcGUoZS5zaGFwZSk8PUVOVi5nZXQoXCJXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNXCIpKXJldHVybntzaGFwZTplLnNoYXBlLHRleERhdGE6bnVsbCxpc1VuaWZvcm06ITAsdW5pZm9ybVZhbHVlczp4LnJlYWRTeW5jKGUuZGF0YUlkKX07aWYoYS5pc1BhY2tlZCE9PSEheS51c2VzUGFja2VkVGV4dHVyZXMpe3ZhciBzLGk7YS5pc1BhY2tlZD8ocz1uZXcgVW5wYWNrUHJvZ3JhbShlLnNoYXBlKSxpPXguY29tcGlsZUFuZFJ1bihzLFtlXSkpOihzPW5ldyBQYWNrUHJvZ3JhbShlLnNoYXBlKSxpPXguY29tcGlsZUFuZFJ1bihzLFtlXSx4Lm1ha2VQYWNrZWRUZW5zb3IoZS5zaGFwZSkpKSxhPXgudGV4RGF0YS5nZXQoaS5kYXRhSWQpLGU9aX1yZXR1cm4geC51cGxvYWRUb0dQVShlLmRhdGFJZCkse3NoYXBlOmUuc2hhcGUsdGV4RGF0YTphLGlzVW5pZm9ybTohMX19KTt0aGlzLnVwbG9hZFRvR1BVKHQuZGF0YUlkKTt2YXIgaT17c2hhcGU6dC5zaGFwZSx0ZXhEYXRhOnRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLGlzVW5pZm9ybTohMX0sdT1tYWtlU2hhZGVyS2V5KHksYSxpKSxsPXRoaXMuZ2V0QW5kU2F2ZUJpbmFyeSh1LGZ1bmN0aW9uKCl7cmV0dXJuIGNvbXBpbGVQcm9ncmFtKHguZ3BncHUseSxhLGkpfSksYz1udWxsIT10aGlzLmFjdGl2ZVRpbWVycyxwO2lmKGMmJihwPXRoaXMuc3RhcnRUaW1lcigpKSxydW5Qcm9ncmFtKGwsYSxpLGIpLEVOVi5nZXQoXCJXRUJHTF9QQUdJTkdfRU5BQkxFRFwiKSYmbiYmdGhpcy5udW1CeXRlc0luR1BVPnRoaXMuTlVNX0JZVEVTX0JFRk9SRV9QQUdJTkcpZm9yKHZhciBOPXRoaXMubnVtQnl0ZXNJbkdQVS10aGlzLk5VTV9CWVRFU19CRUZPUkVfUEFHSU5HOzA8TiYmMDx0aGlzLmxydURhdGFHUFUubGVuZ3RoOyl7dmFyIEk9dGhpcy5scnVEYXRhR1BVLnNoaWZ0KCksaD10aGlzLnRleERhdGEuZ2V0KEkpLGY9aC5zaGFwZSxtPWguZHR5cGU7Ti09dGhpcy5jb21wdXRlQnl0ZXMoZixtKSx0aGlzLnJlYWQoSSl9cmV0dXJuIGMmJihwPXRoaXMuZW5kVGltZXIocCksdGhpcy5hY3RpdmVUaW1lcnMucHVzaCh7bmFtZTp5LmNvbnN0cnVjdG9yLm5hbWUscXVlcnk6dGhpcy5nZXRRdWVyeVRpbWUocCl9KSksdH0sdC5wcm90b3R5cGUuZ2V0QW5kU2F2ZUJpbmFyeT1mdW5jdGlvbihhLGUpe3JldHVybiBhIGluIHRoaXMuYmluYXJ5Q2FjaGV8fCh0aGlzLmJpbmFyeUNhY2hlW2FdPWUoKSksdGhpcy5iaW5hcnlDYWNoZVthXX0sdC5wcm90b3R5cGUuZ2V0VGV4dHVyZU1hbmFnZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcn0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2lmKCF0aGlzLmRpc3Bvc2VkKXtmb3IodmFyIHQgaW4gdGhpcy5iaW5hcnlDYWNoZSl0aGlzLmdwZ3B1LmRlbGV0ZVByb2dyYW0odGhpcy5iaW5hcnlDYWNoZVt0XS53ZWJHTFByb2dyYW0pO3RoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpLHRoaXMuY2FudmFzLnJlbW92ZSgpLG51bGwhPXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dCYmdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy5yZW1vdmUoKSx0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkmJnRoaXMuZ3BncHUuZGlzcG9zZSgpLHRoaXMuZGlzcG9zZWQ9ITB9fSx0LnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gMDx0LmFicyhzY2FsYXIoMWUtOCkpLmdldCgpPzMyOjE2fSl9LHQucHJvdG90eXBlLnVwbG9hZFRvR1BVPWZ1bmN0aW9uKG0pe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQobSksdD1lLnNoYXBlLHI9ZS52YWx1ZXMsbj1lLnRleHR1cmUsbz1lLmR0eXBlLGE9ZS51c2FnZSxpPWUuaXNQYWNrZWQ7aWYobnVsbD09bil7dmFyIHM9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnMsbDtzJiYobD1wZXJmb3JtYW5jZS5ub3coKSk7dmFyIGc9Z2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSh0LGkpO2UudGV4U2hhcGU9Zzt2YXIgYz10aGlzLmFjcXVpcmVUZXh0dXJlKG0sZyxhLGkpO2lmKGUudGV4dHVyZT1jLG51bGwhPXIpe2lmKGkpe3ZhciBwPXNpemVGcm9tU2hhcGUodC5zbGljZSgwLHQubGVuZ3RoLTIpKSxkPTE8dC5sZW5ndGg/dFt0Lmxlbmd0aC0yXToxLGg9dFt0Lmxlbmd0aC0xXTt0aGlzLmdwZ3B1LnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShjLHAsZCxoLHR5cGVkQXJyYXlUb0Zsb2F0MzIocixvKSl9ZWxzZSB0aGlzLmdwZ3B1LnVwbG9hZE1hdHJpeFRvVGV4dHVyZShjLGdbMF0sZ1sxXSx0eXBlZEFycmF5VG9GbG9hdDMyKHIsbykpO2UudmFsdWVzPW51bGwscyYmKHRoaXMudXBsb2FkV2FpdE1zKz1wZXJmb3JtYW5jZS5ub3coKS1sKX19ZWxzZSBFTlYuZ2V0KFwiV0VCR0xfUEFHSU5HX0VOQUJMRURcIikmJjA8PXRoaXMubHJ1RGF0YUdQVS5pbmRleE9mKG0pJiYodGhpcy5scnVEYXRhR1BVLnNwbGljZSh0aGlzLmxydURhdGFHUFUuaW5kZXhPZihtKSwxKSx0aGlzLmxydURhdGFHUFUucHVzaChtKSl9LHQucHJvdG90eXBlLmNvbnZlcnRBbmRDYWNoZU9uQ1BVPWZ1bmN0aW9uKHAsZSl7dmFyIHQ9dGhpcy5kZWxheWVkU3RvcmFnZSxyPXRoaXMudGV4RGF0YS5nZXQocCksbj1yLnRleHR1cmUsbz1yLnRleFNoYXBlLGE9ci5kdHlwZSxpPXIudXNhZ2Uscz1yLmlzUGFja2VkO3JldHVybiB0JiZudWxsIT1uJiYodGhpcy5yZWxlYXNlVGV4dHVyZShwLG4sbyxpLHMpLHIudGV4dHVyZT1udWxsLHIudGV4U2hhcGU9bnVsbCksci51c2FnZT1UZXh0dXJlVXNhZ2UuVVBMT0FELG51bGwhPWUmJihyLnZhbHVlcz1mbG9hdDMyVG9UeXBlZEFycmF5KGUsYSkpLHIudmFsdWVzfSx0LnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZT1mdW5jdGlvbihwLGUsdCxyLG4pe3ZhciBvPXRoaXMudGV4RGF0YS5nZXQocCksYT1vLnNoYXBlLGk9by5kdHlwZTtpZihFTlYuZ2V0KFwiV0VCR0xfUEFHSU5HX0VOQUJMRURcIikpe3ZhciBzPXRoaXMubHJ1RGF0YUdQVS5pbmRleE9mKHApOzA8PXMmJnRoaXMubHJ1RGF0YUdQVS5zcGxpY2UocywxKX10aGlzLm51bUJ5dGVzSW5HUFUtPXRoaXMuY29tcHV0ZUJ5dGVzKGEsaSksdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShlLHQscixuKX0sdC5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmU9ZnVuY3Rpb24ocyxlLHQscil7dmFyIG49dGhpcy50ZXhEYXRhLmdldChzKSxvPW4uc2hhcGUsYT1uLmR0eXBlO3JldHVybiBFTlYuZ2V0KFwiV0VCR0xfUEFHSU5HX0VOQUJMRURcIikmJnRoaXMubHJ1RGF0YUdQVS5wdXNoKHMpLHRoaXMubnVtQnl0ZXNJbkdQVSs9dGhpcy5jb21wdXRlQnl0ZXMobyxhKSx0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKGUsdCxyKX0sdC5wcm90b3R5cGUuY29tcHV0ZUJ5dGVzPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHNpemVGcm9tU2hhcGUoYSkqYnl0ZXNQZXJFbGVtZW50KGUpfSx0fSgpO0VOVi5nZXQoXCJJU19CUk9XU0VSXCIpJiZFTlYucmVnaXN0ZXJCYWNrZW5kKFwid2ViZ2xcIixmdW5jdGlvbigpe3JldHVybiBuZXcgTWF0aEJhY2tlbmRXZWJHTH0sMixzZXRUZW5zb3JUcmFja2VyKTt2YXIgYWJzPW9wKHthYnNfOmFic199KSxhY29zPW9wKHthY29zXzphY29zX30pLGFjb3NoPW9wKHthY29zaF86YWNvc2hffSksYXNpbj1vcCh7YXNpbl86YXNpbl99KSxhc2luaD1vcCh7YXNpbmhfOmFzaW5oX30pLGF0YW49b3Aoe2F0YW5fOmF0YW5ffSksYXRhbmg9b3Aoe2F0YW5oXzphdGFuaF99KSxjZWlsPW9wKHtjZWlsXzpjZWlsX30pLGNsaXBCeVZhbHVlPW9wKHtjbGlwQnlWYWx1ZV86Y2xpcEJ5VmFsdWVffSksY29zPW9wKHtjb3NfOmNvc199KSxjb3NoPW9wKHtjb3NoXzpjb3NoX30pLGVyZj1vcCh7ZXJmXzplcmZffSksZXhwPW9wKHtleHBfOmV4cF99KSxleHBtMT1vcCh7ZXhwbTFfOmV4cG0xX30pLGZsb29yPW9wKHtmbG9vcl86Zmxvb3JffSksbG9nJDE9b3Aoe2xvZ186bG9nX30pLGxvZzFwPW9wKHtsb2cxcF86bG9nMXBffSksbG9nU2lnbW9pZD1vcCh7bG9nU2lnbW9pZF86bG9nU2lnbW9pZF99KSxuZWc9b3Aoe25lZ186bmVnX30pLHJlY2lwcm9jYWw9b3Aoe3JlY2lwcm9jYWxfOnJlY2lwcm9jYWxffSkscm91bmQ9b3Aoe3JvdW5kXzpyb3VuZF99KSxyc3FydD1vcCh7cnNxcnRfOnJzcXJ0X30pLHNpZ21vaWQ9b3Aoe3NpZ21vaWRfOnNpZ21vaWRffSksc2lnbj1vcCh7c2lnbl86c2lnbl99KSxzaW49b3Aoe3Npbl86c2luX30pLHNpbmg9b3Aoe3NpbmhfOnNpbmhffSksc29mdHBsdXM9b3Aoe3NvZnRwbHVzXzpzb2Z0cGx1c199KSxzcXJ0PW9wKHtzcXJ0XzpzcXJ0X30pLHNxdWFyZT1vcCh7c3F1YXJlXzpzcXVhcmVffSksc3RlcD1vcCh7c3RlcF86c3RlcF99KSx0YW49b3Aoe3Rhbl86dGFuX30pLHRhbmgkMT1vcCh7dGFuaF86dGFuaF99KSxiYXRjaE5vcm1hbGl6YXRpb24yZD1vcCh7YmF0Y2hOb3JtYWxpemF0aW9uMmRfOmJhdGNoTm9ybWFsaXphdGlvbjJkX30pLGJhdGNoTm9ybWFsaXphdGlvbjNkPW9wKHtiYXRjaE5vcm1hbGl6YXRpb24zZF86YmF0Y2hOb3JtYWxpemF0aW9uM2RffSksYmF0Y2hOb3JtYWxpemF0aW9uNGQ9b3Aoe2JhdGNoTm9ybWFsaXphdGlvbjRkXzpiYXRjaE5vcm1hbGl6YXRpb240ZF99KSxiYXRjaE5vcm1hbGl6YXRpb249b3Aoe2JhdGNoTm9ybWFsaXphdGlvbl86YmF0Y2hOb3JtYWxpemF0aW9uX30pLG1hdE11bD1vcCh7bWF0TXVsXzptYXRNdWxffSksZG90PW9wKHtkb3RfOmRvdF99KSxvdXRlclByb2R1Y3Q9b3Aoe291dGVyUHJvZHVjdF86b3V0ZXJQcm9kdWN0X30pLGNvbnYxZD1vcCh7Y29udjFkXzpjb252MWRffSksY29udjJkPW9wKHtjb252MmRfOmNvbnYyZF99KSxjb252MmREZXJGaWx0ZXI9b3Aoe2NvbnYyZERlckZpbHRlcl86Y29udjJkRGVyRmlsdGVyX30pLGRlcHRod2lzZUNvbnYyZD1vcCh7ZGVwdGh3aXNlQ29udjJkXzpkZXB0aHdpc2VDb252MmRffSksc2VwYXJhYmxlQ29udjJkPW9wKHtzZXBhcmFibGVDb252MmRfOnNlcGFyYWJsZUNvbnYyZF99KSxjb252MmRUcmFuc3Bvc2U9b3Aoe2NvbnYyZFRyYW5zcG9zZV86Y29udjJkVHJhbnNwb3NlX30pLHJldmVyc2U9b3Aoe3JldmVyc2VfOnJldmVyc2VffSkscmV2ZXJzZTFkPW9wKHtyZXZlcnNlMWRfOnJldmVyc2UxZF99KSxyZXZlcnNlMmQ9b3Aoe3JldmVyc2UyZF86cmV2ZXJzZTJkX30pLHJldmVyc2UzZD1vcCh7cmV2ZXJzZTNkXzpyZXZlcnNlM2RffSkscmV2ZXJzZTRkPW9wKHtyZXZlcnNlNGRfOnJldmVyc2U0ZF99KSxtYXhQb29sPW9wKHttYXhQb29sXzptYXhQb29sX30pLGF2Z1Bvb2w9b3Aoe2F2Z1Bvb2xfOmF2Z1Bvb2xffSkscG9vbD1vcCh7cG9vbF86cG9vbF99KSxzbGljZT1vcCh7c2xpY2VfOnNsaWNlX30pLHNsaWNlMWQ9b3Aoe3NsaWNlMWRfOnNsaWNlMWRffSksc2xpY2UyZD1vcCh7c2xpY2UyZF86c2xpY2UyZF99KSxzbGljZTNkPW9wKHtzbGljZTNkXzpzbGljZTNkX30pLHNsaWNlNGQ9b3Aoe3NsaWNlNGRfOnNsaWNlNGRffSksYWxsPW9wKHthbGxfOmFsbF99KSxhbnk9b3Aoe2FueV86YW55X30pLGFyZ01heD1vcCh7YXJnTWF4XzphcmdNYXhffSksYXJnTWluPW9wKHthcmdNaW5fOmFyZ01pbl99KSxsb2dTdW1FeHA9b3Aoe2xvZ1N1bUV4cF86bG9nU3VtRXhwX30pLG1heD1vcCh7bWF4XzptYXhffSksbWVhbj1vcCh7bWVhbl86bWVhbl99KSxtaW49b3Aoe21pbl86bWluX30pLG1vbWVudHM9b3Aoe21vbWVudHNfOm1vbWVudHNffSksc3VtJDE9b3Aoe3N1bV86c3VtX30pLHByb2Q9b3Aoe3Byb2RfOnByb2RffSksZXF1YWw9b3Aoe2VxdWFsXzplcXVhbF99KSxlcXVhbFN0cmljdD1vcCh7ZXF1YWxTdHJpY3RfOmVxdWFsU3RyaWN0X30pLGdyZWF0ZXI9b3Aoe2dyZWF0ZXJfOmdyZWF0ZXJffSksZ3JlYXRlckVxdWFsPW9wKHtncmVhdGVyRXF1YWxfOmdyZWF0ZXJFcXVhbF99KSxncmVhdGVyRXF1YWxTdHJpY3Q9b3Aoe2dyZWF0ZXJFcXVhbFN0cmljdF86Z3JlYXRlckVxdWFsU3RyaWN0X30pLGdyZWF0ZXJTdHJpY3Q9b3Aoe2dyZWF0ZXJTdHJpY3RfOmdyZWF0ZXJTdHJpY3RffSksbGVzcz1vcCh7bGVzc186bGVzc199KSxsZXNzRXF1YWw9b3Aoe2xlc3NFcXVhbF86bGVzc0VxdWFsX30pLGxlc3NFcXVhbFN0cmljdD1vcCh7bGVzc0VxdWFsU3RyaWN0XzpsZXNzRXF1YWxTdHJpY3RffSksbGVzc1N0cmljdD1vcCh7bGVzc1N0cmljdF86bGVzc1N0cmljdF99KSxub3RFcXVhbD1vcCh7bm90RXF1YWxfOm5vdEVxdWFsX30pLG5vdEVxdWFsU3RyaWN0PW9wKHtub3RFcXVhbFN0cmljdF86bm90RXF1YWxTdHJpY3RffSksYWRkPW9wKHthZGRfOmFkZF99KSxhZGROPW9wKHthZGROXzphZGROX30pLGFkZFN0cmljdD1vcCh7YWRkU3RyaWN0XzphZGRTdHJpY3RffSksYXRhbjI9b3Aoe2F0YW4yXzphdGFuMl99KSxkaXY9b3Aoe2Rpdl86ZGl2X30pLGRpdlN0cmljdD1vcCh7ZGl2U3RyaWN0XzpkaXZTdHJpY3RffSksZmxvb3JEaXY9b3Aoe2Zsb29yRGl2XzpmbG9vckRpdl99KSxtYXhpbXVtPW9wKHttYXhpbXVtXzptYXhpbXVtX30pLG1heGltdW1TdHJpY3Q9b3Aoe21heGltdW1TdHJpY3RfOm1heGltdW1TdHJpY3RffSksbWluaW11bT1vcCh7bWluaW11bV86bWluaW11bV99KSxtaW5pbXVtU3RyaWN0PW9wKHttaW5pbXVtU3RyaWN0XzptaW5pbXVtU3RyaWN0X30pLG1vZD1vcCh7bW9kXzptb2RffSksbW9kU3RyaWN0PW9wKHttb2RTdHJpY3RfOm1vZFN0cmljdF99KSxtdWw9b3Aoe211bF86bXVsX30pLG11bFN0cmljdD1vcCh7bXVsU3RyaWN0XzptdWxTdHJpY3RffSkscG93PW9wKHtwb3dfOnBvd199KSxwb3dTdHJpY3Q9b3Aoe3Bvd1N0cmljdF86cG93U3RyaWN0X30pLHNxdWFyZWREaWZmZXJlbmNlPW9wKHtzcXVhcmVkRGlmZmVyZW5jZV86c3F1YXJlZERpZmZlcmVuY2VffSksc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q9b3Aoe3NxdWFyZWREaWZmZXJlbmNlU3RyaWN0XzpzcXVhcmVkRGlmZmVyZW5jZVN0cmljdF99KSxzdWI9b3Aoe3N1Yl86c3ViX30pLHN1YlN0cmljdD1vcCh7c3ViU3RyaWN0XzpzdWJTdHJpY3RffSksbG9naWNhbEFuZD1vcCh7bG9naWNhbEFuZF86bG9naWNhbEFuZF99KSxsb2dpY2FsTm90PW9wKHtsb2dpY2FsTm90Xzpsb2dpY2FsTm90X30pLGxvZ2ljYWxPcj1vcCh7bG9naWNhbE9yXzpsb2dpY2FsT3JffSksbG9naWNhbFhvcj1vcCh7bG9naWNhbFhvcl86bG9naWNhbFhvcl99KSx3aGVyZT1vcCh7d2hlcmVfOndoZXJlX30pLHdoZXJlQXN5bmM9d2hlcmVBc3luY18sZWx1PW9wKHtlbHVfOmVsdV99KSxsZWFreVJlbHU9b3Aoe2xlYWt5UmVsdV86bGVha3lSZWx1X30pLHByZWx1PW9wKHtwcmVsdV86cHJlbHVffSkscmVsdT1vcCh7cmVsdV86cmVsdV99KSxzZWx1PW9wKHtzZWx1XzpzZWx1X30pLHRyYW5zcG9zZT1vcCh7dHJhbnNwb3NlXzp0cmFuc3Bvc2VffSksbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb249b3Aoe2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXzpsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbl99KSxub3JtPW9wKHtub3JtXzpub3JtX30pLGdhdGhlcj1vcCh7Z2F0aGVyXzpnYXRoZXJffSksdW5zb3J0ZWRTZWdtZW50U3VtPW9wKHt1bnNvcnRlZFNlZ21lbnRTdW1fOnVuc29ydGVkU2VnbWVudFN1bV99KSxiYXNpY0xTVE1DZWxsPW9wKHtiYXNpY0xTVE1DZWxsXzpiYXNpY0xTVE1DZWxsX30pLG11bHRpUk5OQ2VsbD1vcCh7bXVsdGlSTk5DZWxsXzptdWx0aVJOTkNlbGxffSksbW92aW5nQXZlcmFnZT1vcCh7bW92aW5nQXZlcmFnZV86bW92aW5nQXZlcmFnZV99KSxzdHJpZGVkU2xpY2U9b3Aoe3N0cmlkZWRTbGljZV86c3RyaWRlZFNsaWNlX30pLHRvcGs9b3Aoe3RvcGtfOnRvcGtffSksc2NhdHRlck5EPW9wKHtzY2F0dGVyTkRfOnNjYXR0ZXJORF99KSxmZnQ9b3Aoe2ZmdF86ZmZ0X30pLGlmZnQ9b3Aoe2lmZnRfOmlmZnRffSkscmZmdD1vcCh7cmZmdF86cmZmdF99KSxzcGVjdHJhbF9vcHM9T2JqZWN0LmZyZWV6ZSh7ZmZ0OmZmdCxpZmZ0OmlmZnQscmZmdDpyZmZ0fSksc3BhcnNlVG9EZW5zZT1vcCh7c3BhcnNlVG9EZW5zZV86c3BhcnNlVG9EZW5zZV99KSxnYXRoZXJORD1vcCh7Z2F0aGVyTkRfOmdhdGhlck5EX30pLFJlZHVjdGlvbjshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0Lk1FQU49MV09XCJNRUFOXCIsdFt0LlNVTT0yXT1cIlNVTVwiLHRbdC5TVU1fQllfTk9OWkVST19XRUlHSFRTPTNdPVwiU1VNX0JZX05PTlpFUk9fV0VJR0hUU1wifShSZWR1Y3Rpb258fChSZWR1Y3Rpb249e30pKTt2YXIgYWJzb2x1dGVEaWZmZXJlbmNlPW9wKHthYnNvbHV0ZURpZmZlcmVuY2VfOmFic29sdXRlRGlmZmVyZW5jZV99KSxjb21wdXRlV2VpZ2h0ZWRMb3NzPW9wKHtjb21wdXRlV2VpZ2h0ZWRMb3NzXzpjb21wdXRlV2VpZ2h0ZWRMb3NzX30pLGNvc2luZURpc3RhbmNlPW9wKHtjb3NpbmVEaXN0YW5jZV86Y29zaW5lRGlzdGFuY2VffSksaGluZ2VMb3NzPW9wKHtoaW5nZUxvc3NfOmhpbmdlTG9zc199KSxodWJlckxvc3M9b3Aoe2h1YmVyTG9zc186aHViZXJMb3NzX30pLGxvZ0xvc3M9b3Aoe2xvZ0xvc3NfOmxvZ0xvc3NffSksbWVhblNxdWFyZWRFcnJvcj1vcCh7bWVhblNxdWFyZWRFcnJvcl86bWVhblNxdWFyZWRFcnJvcl99KSxzaWdtb2lkQ3Jvc3NFbnRyb3B5PW9wKHtzaWdtb2lkQ3Jvc3NFbnRyb3B5XzpzaWdtb2lkQ3Jvc3NFbnRyb3B5X30pLHNvZnRtYXhDcm9zc0VudHJvcHk9b3Aoe3NvZnRtYXhDcm9zc0VudHJvcHlfOnNvZnRtYXhDcm9zc0VudHJvcHlffSksbG9zc19vcHM9T2JqZWN0LmZyZWV6ZSh7Z2V0IFJlZHVjdGlvbigpe3JldHVybiBSZWR1Y3Rpb259LGFic29sdXRlRGlmZmVyZW5jZTphYnNvbHV0ZURpZmZlcmVuY2UsY29tcHV0ZVdlaWdodGVkTG9zczpjb21wdXRlV2VpZ2h0ZWRMb3NzLGNvc2luZURpc3RhbmNlOmNvc2luZURpc3RhbmNlLGhpbmdlTG9zczpoaW5nZUxvc3MsaHViZXJMb3NzOmh1YmVyTG9zcyxsb2dMb3NzOmxvZ0xvc3MsbWVhblNxdWFyZWRFcnJvcjptZWFuU3F1YXJlZEVycm9yLHNpZ21vaWRDcm9zc0VudHJvcHk6c2lnbW9pZENyb3NzRW50cm9weSxzb2Z0bWF4Q3Jvc3NFbnRyb3B5OnNvZnRtYXhDcm9zc0VudHJvcHl9KSxncmFtU2NobWlkdD1vcCh7Z3JhbVNjaG1pZHRfOmdyYW1TY2htaWR0X30pLHFyPW9wKHtxcl86cXJffSksbGluYWxnX29wcz1PYmplY3QuZnJlZXplKHtncmFtU2NobWlkdDpncmFtU2NobWlkdCxxcjpxcn0pLHJlc2l6ZUJpbGluZWFyPW9wKHtyZXNpemVCaWxpbmVhcl86cmVzaXplQmlsaW5lYXJffSkscmVzaXplTmVhcmVzdE5laWdoYm9yPW9wKHtyZXNpemVOZWFyZXN0TmVpZ2hib3JfOnJlc2l6ZU5lYXJlc3ROZWlnaGJvcl99KSxub25NYXhTdXBwcmVzc2lvbj1vcCh7bm9uTWF4U3VwcHJlc3Npb25fOm5vbk1heFN1cHByZXNzaW9uX30pLG5vbk1heFN1cHByZXNzaW9uQXN5bmM9bm9uTWF4U3VwcHJlc3Npb25Bc3luY18sY3JvcEFuZFJlc2l6ZT1jcm9wQW5kUmVzaXplXyxpbWFnZV9vcHM9T2JqZWN0LmZyZWV6ZSh7cmVzaXplQmlsaW5lYXI6cmVzaXplQmlsaW5lYXIscmVzaXplTmVhcmVzdE5laWdoYm9yOnJlc2l6ZU5lYXJlc3ROZWlnaGJvcixub25NYXhTdXBwcmVzc2lvbjpub25NYXhTdXBwcmVzc2lvbixub25NYXhTdXBwcmVzc2lvbkFzeW5jOm5vbk1heFN1cHByZXNzaW9uQXN5bmMsY3JvcEFuZFJlc2l6ZTpjcm9wQW5kUmVzaXplfSksb3BzPU9iamVjdC5mcmVlemUoe2ltYWdlOmltYWdlX29wcyxsaW5hbGc6bGluYWxnX29wcyxsb3NzZXM6bG9zc19vcHMsc3BlY3RyYWw6c3BlY3RyYWxfb3BzLG9wOm9wLGJhdGNoTm9ybWFsaXphdGlvbjJkOmJhdGNoTm9ybWFsaXphdGlvbjJkLGJhdGNoTm9ybWFsaXphdGlvbjNkOmJhdGNoTm9ybWFsaXphdGlvbjNkLGJhdGNoTm9ybWFsaXphdGlvbjRkOmJhdGNoTm9ybWFsaXphdGlvbjRkLGJhdGNoTm9ybWFsaXphdGlvbjpiYXRjaE5vcm1hbGl6YXRpb24sY29tcGxleDpjb21wbGV4LHJlYWw6cmVhbCxpbWFnOmltYWcsY29uY2F0OmNvbmNhdCxjb25jYXQxZDpjb25jYXQxZCxjb25jYXQyZDpjb25jYXQyZCxjb25jYXQzZDpjb25jYXQzZCxjb25jYXQ0ZDpjb25jYXQ0ZCxzcGxpdDpzcGxpdCQxLGNvbnYxZDpjb252MWQsY29udjJkOmNvbnYyZCxjb252MmREZXJGaWx0ZXI6Y29udjJkRGVyRmlsdGVyLGRlcHRod2lzZUNvbnYyZDpkZXB0aHdpc2VDb252MmQsc2VwYXJhYmxlQ29udjJkOnNlcGFyYWJsZUNvbnYyZCxjb252MmRUcmFuc3Bvc2U6Y29udjJkVHJhbnNwb3NlLG1hdE11bDptYXRNdWwsZG90OmRvdCxvdXRlclByb2R1Y3Q6b3V0ZXJQcm9kdWN0LHJldmVyc2U6cmV2ZXJzZSxyZXZlcnNlMWQ6cmV2ZXJzZTFkLHJldmVyc2UyZDpyZXZlcnNlMmQscmV2ZXJzZTNkOnJldmVyc2UzZCxyZXZlcnNlNGQ6cmV2ZXJzZTRkLG1heFBvb2w6bWF4UG9vbCxhdmdQb29sOmF2Z1Bvb2wscG9vbDpwb29sLHNsaWNlOnNsaWNlLHNsaWNlMWQ6c2xpY2UxZCxzbGljZTJkOnNsaWNlMmQsc2xpY2UzZDpzbGljZTNkLHNsaWNlNGQ6c2xpY2U0ZCxhYnM6YWJzLGFjb3M6YWNvcyxhY29zaDphY29zaCxhc2luOmFzaW4sYXNpbmg6YXNpbmgsYXRhbjphdGFuLGF0YW5oOmF0YW5oLGNlaWw6Y2VpbCxjbGlwQnlWYWx1ZTpjbGlwQnlWYWx1ZSxjb3M6Y29zLGNvc2g6Y29zaCxlcmY6ZXJmLGV4cDpleHAsZXhwbTE6ZXhwbTEsZmxvb3I6Zmxvb3IsbG9nOmxvZyQxLGxvZzFwOmxvZzFwLGxvZ1NpZ21vaWQ6bG9nU2lnbW9pZCxuZWc6bmVnLHJlY2lwcm9jYWw6cmVjaXByb2NhbCxyb3VuZDpyb3VuZCxyc3FydDpyc3FydCxzaWdtb2lkOnNpZ21vaWQsc2lnbjpzaWduLHNpbjpzaW4sc2luaDpzaW5oLHNvZnRwbHVzOnNvZnRwbHVzLHNxcnQ6c3FydCxzcXVhcmU6c3F1YXJlLHN0ZXA6c3RlcCx0YW46dGFuLHRhbmg6dGFuaCQxLGFsbDphbGwsYW55OmFueSxhcmdNYXg6YXJnTWF4LGFyZ01pbjphcmdNaW4sbG9nU3VtRXhwOmxvZ1N1bUV4cCxtYXg6bWF4LG1lYW46bWVhbixtaW46bWluLG1vbWVudHM6bW9tZW50cyxzdW06c3VtJDEscHJvZDpwcm9kLGVxdWFsOmVxdWFsLGVxdWFsU3RyaWN0OmVxdWFsU3RyaWN0LGdyZWF0ZXI6Z3JlYXRlcixncmVhdGVyRXF1YWw6Z3JlYXRlckVxdWFsLGdyZWF0ZXJFcXVhbFN0cmljdDpncmVhdGVyRXF1YWxTdHJpY3QsZ3JlYXRlclN0cmljdDpncmVhdGVyU3RyaWN0LGxlc3M6bGVzcyxsZXNzRXF1YWw6bGVzc0VxdWFsLGxlc3NFcXVhbFN0cmljdDpsZXNzRXF1YWxTdHJpY3QsbGVzc1N0cmljdDpsZXNzU3RyaWN0LG5vdEVxdWFsOm5vdEVxdWFsLG5vdEVxdWFsU3RyaWN0Om5vdEVxdWFsU3RyaWN0LGFkZDphZGQsYWRkTjphZGROLGFkZFN0cmljdDphZGRTdHJpY3QsYXRhbjI6YXRhbjIsZGl2OmRpdixkaXZTdHJpY3Q6ZGl2U3RyaWN0LGZsb29yRGl2OmZsb29yRGl2LG1heGltdW06bWF4aW11bSxtYXhpbXVtU3RyaWN0Om1heGltdW1TdHJpY3QsbWluaW11bTptaW5pbXVtLG1pbmltdW1TdHJpY3Q6bWluaW11bVN0cmljdCxtb2Q6bW9kLG1vZFN0cmljdDptb2RTdHJpY3QsbXVsOm11bCxtdWxTdHJpY3Q6bXVsU3RyaWN0LHBvdzpwb3cscG93U3RyaWN0OnBvd1N0cmljdCxzcXVhcmVkRGlmZmVyZW5jZTpzcXVhcmVkRGlmZmVyZW5jZSxzcXVhcmVkRGlmZmVyZW5jZVN0cmljdDpzcXVhcmVkRGlmZmVyZW5jZVN0cmljdCxzdWI6c3ViLHN1YlN0cmljdDpzdWJTdHJpY3QsZWx1OmVsdSxsZWFreVJlbHU6bGVha3lSZWx1LHByZWx1OnByZWx1LHJlbHU6cmVsdSxzZWx1OnNlbHUsbG9naWNhbEFuZDpsb2dpY2FsQW5kLGxvZ2ljYWxOb3Q6bG9naWNhbE5vdCxsb2dpY2FsT3I6bG9naWNhbE9yLGxvZ2ljYWxYb3I6bG9naWNhbFhvcix3aGVyZTp3aGVyZSx3aGVyZUFzeW5jOndoZXJlQXN5bmMsYnVmZmVyOmJ1ZmZlcix0b1BpeGVsczp0b1BpeGVscyxwcmludDpwcmludCxiYXRjaFRvU3BhY2VORDpiYXRjaFRvU3BhY2VORCxjYXN0OmNhc3QsY2xvbmU6Y2xvbmUsY3Vtc3VtOmN1bXN1bSxkZXB0aFRvU3BhY2U6ZGVwdGhUb1NwYWNlLGV4cGFuZERpbXM6ZXhwYW5kRGltcyxleWU6ZXllLGZyb21QaXhlbHM6ZnJvbVBpeGVscyxtdWx0aW5vbWlhbDptdWx0aW5vbWlhbCxvbmVIb3Q6b25lSG90LHBhZDpwYWQscGFkMWQ6cGFkMWQscGFkMmQ6cGFkMmQscGFkM2Q6cGFkM2QscGFkNGQ6cGFkNGQscmFuZDpyYW5kLHJhbmRvbU5vcm1hbDpyYW5kb21Ob3JtYWwscmFuZG9tVW5pZm9ybTpyYW5kb21Vbmlmb3JtLHJlc2hhcGU6cmVzaGFwZSxzcGFjZVRvQmF0Y2hORDpzcGFjZVRvQmF0Y2hORCxzcXVlZXplOnNxdWVlemUsc3RhY2s6c3RhY2ssdGlsZTp0aWxlLHRydW5jYXRlZE5vcm1hbDp0cnVuY2F0ZWROb3JtYWwsdW5zdGFjazp1bnN0YWNrLHNldGRpZmYxZEFzeW5jOnNldGRpZmYxZEFzeW5jLGZpbGw6ZmlsbCxsaW5zcGFjZTpsaW5zcGFjZSxvbmVzOm9uZXMkMSxyYW5nZTpyYW5nZSxzY2FsYXI6c2NhbGFyLHRlbnNvcjp0ZW5zb3IsdGVuc29yMWQ6dGVuc29yMWQsdGVuc29yMmQ6dGVuc29yMmQsdGVuc29yM2Q6dGVuc29yM2QsdGVuc29yNGQ6dGVuc29yNGQsdGVuc29yNWQ6dGVuc29yNWQsdGVuc29yNmQ6dGVuc29yNmQsemVyb3M6emVyb3Msb25lc0xpa2U6b25lc0xpa2UsemVyb3NMaWtlOnplcm9zTGlrZSx0cmFuc3Bvc2U6dHJhbnNwb3NlLHNvZnRtYXg6c29mdG1heCxsb2dTb2Z0bWF4OmxvZ1NvZnRtYXgsbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246bG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24sbm9ybTpub3JtLGdhdGhlcjpnYXRoZXIsdW5zb3J0ZWRTZWdtZW50U3VtOnVuc29ydGVkU2VnbWVudFN1bSxiYXNpY0xTVE1DZWxsOmJhc2ljTFNUTUNlbGwsbXVsdGlSTk5DZWxsOm11bHRpUk5OQ2VsbCxtb3ZpbmdBdmVyYWdlOm1vdmluZ0F2ZXJhZ2Usc3RyaWRlZFNsaWNlOnN0cmlkZWRTbGljZSx0b3BrOnRvcGssc2NhdHRlck5EOnNjYXR0ZXJORCxmZnQ6ZmZ0LGlmZnQ6aWZmdCxyZmZ0OnJmZnQsc3BhcnNlVG9EZW5zZTpzcGFyc2VUb0RlbnNlLGdhdGhlck5EOmdhdGhlck5EfSksTWF0aEJhY2tlbmRDUFU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5ibG9ja1NpemU9NDgsdGhpcy5maXJzdFVzZT0hMCxFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmKHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSl9cmV0dXJuIHQucHJvdG90eXBlLnNldERhdGFNb3Zlcj1mdW5jdGlvbih0KXt0aGlzLmRhdGE9bmV3IERhdGFTdG9yYWdlKHQpfSx0LnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbihhLGUsdCl7aWYodGhpcy5maXJzdFVzZSYmKHRoaXMuZmlyc3RVc2U9ITEsRU5WLmdldChcIklTX05PREVcIikmJndhcm4oXCJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuSGkgdGhlcmUgXFx1RDgzRFxcdURDNEIuIExvb2tzIGxpa2UgeW91IGFyZSBydW5uaW5nIFRlbnNvckZsb3cuanMgaW4gTm9kZS5qcy4gVG8gc3BlZWQgdGhpbmdzIHVwIGRyYW1hdGljYWxseSwgaW5zdGFsbCBvdXIgbm9kZSBiYWNrZW5kLCB3aGljaCBiaW5kcyB0byBUZW5zb3JGbG93IEMrKywgYnkgcnVubmluZyBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUsIG9yIG5wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZS1ncHUgaWYgeW91IGhhdmUgQ1VEQS4gVGhlbiBjYWxsIHJlcXVpcmUoJ0B0ZW5zb3JmbG93L3RmanMtbm9kZScpOyAoLWdwdSBzdWZmaXggZm9yIENVREEpIGF0IHRoZSBzdGFydCBvZiB5b3VyIHByb2dyYW0uIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtbm9kZSBmb3IgbW9yZSBkZXRhaWxzLlxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5cIikpLHRoaXMuZGF0YS5oYXMoYSkpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3RoaXMuZGF0YS5zZXQoYSx7ZHR5cGU6dH0pfSx0LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihhLGUpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiTWF0aEJhY2tlbmRDUFUud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbFwiKTt0aGlzLmRhdGEuZ2V0KGEpLnZhbHVlcz1lfSx0LnByb3RvdHlwZS5mcm9tUGl4ZWxzPWZ1bmN0aW9uKHMsZSl7aWYobnVsbD09cyl0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgcGFzc2VkIHRvIHRmLmZyb21QaXhlbHMoKSBjYW4gbm90IGJlIG51bGxcIik7dmFyIHQscDtpZihFTlYuZ2V0KFwiSVNfTk9ERVwiKSYmbnVsbD09cy5nZXRDb250ZXh0KXRocm93IG5ldyBFcnJvcihcIldoZW4gcnVubmluZyBpbiBub2RlLCBwaXhlbHMgbXVzdCBiZSBhbiBIVE1MQ2FudmFzRWxlbWVudCBsaWtlIHRoZSBvbmUgcmV0dXJuZWQgYnkgdGhlIGBjYW52YXNgIG5wbSBwYWNrYWdlXCIpO2lmKG51bGwhPXMuZ2V0Q29udGV4dCl0PXMuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAscy53aWR0aCxzLmhlaWdodCkuZGF0YTtlbHNlIGlmKHMgaW5zdGFuY2VvZiBJbWFnZURhdGEpdD1zLmRhdGE7ZWxzZXtpZighKHMgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50fHxzIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5mcm9tUGl4ZWxzKCkgbXVzdCBiZSBlaXRoZXIgYW4gSFRNTFZpZGVvRWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQgb3IgSW1hZ2VEYXRhLCBidXQgd2FzIFwiK3MuY29uc3RydWN0b3IubmFtZSk7aWYobnVsbD09dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlYWQgcGl4ZWxzIGZyb20gSFRNTEltYWdlRWxlbWVudCBvdXRzaWRlIHRoZSBicm93c2VyLlwiKTt0aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLndpZHRoPXMud2lkdGgsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy5oZWlnaHQ9cy5oZWlnaHQsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShzLDAsMCxzLndpZHRoLHMuaGVpZ2h0KSx0PXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwwLHMud2lkdGgscy5oZWlnaHQpLmRhdGF9aWYoND09PWUpcD1uZXcgSW50MzJBcnJheSh0KTtlbHNle3ZhciBsPXMud2lkdGgqcy5oZWlnaHQ7cD1uZXcgSW50MzJBcnJheShsKmUpO2Zvcih2YXIgbz0wO288bDtvKyspZm9yKHZhciBkPTA7ZDxlOysrZClwW28qZStkXT10WzQqbytkXX1yZXR1cm4gdGVuc29yM2QocCxbcy5oZWlnaHQscy53aWR0aCxlXSxcImludDMyXCIpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm5bMix0aGlzLnJlYWRTeW5jKHQpXX0pfSl9LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKGEpe3ZhciBlPXRoaXMuZGF0YS5nZXQoYSksdD1lLmR0eXBlLHI9ZS5jb21wbGV4VGVuc29ycztyZXR1cm5cImNvbXBsZXg2NFwiPT09dD9tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKHIucmVhbC5kYXRhU3luYygpLHIuaW1hZy5kYXRhU3luYygpKTp0aGlzLmRhdGEuZ2V0KGEpLnZhbHVlc30sdC5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24oYSl7aWYodGhpcy5kYXRhLmhhcyhhKSl7dmFyIGU9dGhpcy5kYXRhLmdldChhKS5jb21wbGV4VGVuc29ycztudWxsIT1lJiYoZS5yZWFsLmRpc3Bvc2UoKSxlLmltYWcuZGlzcG9zZSgpKSx0aGlzLmRhdGEuZGVsZXRlKGEpfX0sdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbihhKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGU9bm93KCksYSgpLFsyLHtrZXJuZWxNczpub3coKS1lfV19KX0pfSx0LnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm57dW5yZWxpYWJsZTohMH19LHQucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24oYSxlKXt2YXIgdD1UZW5zb3IubWFrZShhLnNoYXBlLHt9LFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpFTlYuZW5naW5lLmtlZXAoYS5jbG9uZSgpKSxpbWFnOkVOVi5lbmdpbmUua2VlcChlLmNsb25lKCkpfSx0fSx0LnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmNsb25lKCl9LHQucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLmltYWcuY2xvbmUoKX0sdC5wcm90b3R5cGUuYXNzZXJ0Tm90Q29tcGxleD1mdW5jdGlvbihhLG4pe0FycmF5LmlzQXJyYXkoYSl8fChhPVthXSksYS5mb3JFYWNoKGZ1bmN0aW9uKHQpe251bGwhPXQmJmFzc2VydChcImNvbXBsZXg2NFwiIT09dC5kdHlwZSxuK1wiIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IHRlbnNvcnMuXCIpfSl9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHMscCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgocyxcInNsaWNlXCIpO2Zvcih2YXIgdD1idWZmZXIoZSxzLmR0eXBlKSxuPTA7bjx0LnNpemU7KytuKXt2YXIgcj10LmluZGV4VG9Mb2MobiksYT1yLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiB0K3BbZV19KTt0LnNldC5hcHBseSh0LFtzLmdldC5hcHBseShzLGEpXS5jb25jYXQocikpfXJldHVybiB0LnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbihiLGUsdCxyLG4sbyxhLGkscyl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGIsXCJzdHJpZGVkU2xpY2VcIik7dmFyIHU9Z2V0U3RyaWRlZFNsaWNlZEluZm8oYi5zaGFwZSxlLHQscixuLG8sYSxpLHMpLGw9dVswXSxjPXVbMV0scD11WzJdLGQ9Yy5maWx0ZXIoZnVuY3Rpb24oYSxlKXtyZXR1cm4tMT09PXAuaW5kZXhPZihlKX0pO2lmKGQuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gMD09PXR9KSlyZXR1cm4gdGVuc29yKFtdLGQpO2Zvcih2YXIgaD1idWZmZXIoYyxiLmR0eXBlKSxmPTA7ZjxoLnNpemU7ZisrKXtmb3IodmFyIHg9aC5pbmRleFRvTG9jKGYpLGc9QXJyYXkoeC5sZW5ndGgpLE49MDtOPGcubGVuZ3RoO04rKylnW05dPXhbTl0qcltOXStsW05dO2guc2V0LmFwcGx5KGgsW2IuZ2V0LmFwcGx5KGIsZyldLmNvbmNhdCh4KSl9cmV0dXJuIGgudG9UZW5zb3IoKS5yZXNoYXBlKGQpfSx0LnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHMsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHMsXCJyZXZlcnNlXCIpO2Zvcih2YXIgdD1idWZmZXIocy5zaGFwZSxzLmR0eXBlKSxyPXMuYnVmZmVyKCksbj1mdW5jdGlvbihuKXt2YXIgbz10LmluZGV4VG9Mb2MobiksYT1vLnNsaWNlKCk7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBhW2VdPXMuc2hhcGVbZV0tMS1hW2VdfSksdC5zZXQuYXBwbHkodCxbci5nZXQuYXBwbHkocixhKV0uY29uY2F0KG8pKX0sbz0wO288dC5zaXplO28rKyluKG8pO3JldHVybiB0LnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbihwLGwpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChwLFwiY29uY2F0XCIpO3ZhciBlPXAubWFwKGZ1bmN0aW9uKHQpe3ZhciBlPXNpemVGcm9tU2hhcGUodC5zaGFwZS5zbGljZShsKSk7cmV0dXJuIHQuYXMyRCgtMSxlKX0pLGQ9Y29tcHV0ZU91dFNoYXBlKGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksMSksbj1idWZmZXIoZCxwWzBdLmR0eXBlKS52YWx1ZXM7aWYoMT09PWVbMF0uc2hhcGVbMF0pe3ZhciB0PTA7ZS5mb3JFYWNoKGZ1bmN0aW9uKGEpe24uc2V0KGEuZGF0YVN5bmMoKSx0KSx0Kz1hLnNpemV9KX1lbHNle3ZhciBvPTA7ZS5mb3JFYWNoKGZ1bmN0aW9uKGkpe2Zvcih2YXIgZT1pLmRhdGFTeW5jKCksdD0wLHA9MDtwPGkuc2hhcGVbMF07KytwKWZvcih2YXIgbD1wKmRbMV0rbyxzPTA7czxpLnNoYXBlWzFdOysrcyluW2wrc109ZVt0KytdO28rPWkuc2hhcGVbMV19KX12YXIgcj1jb21wdXRlT3V0U2hhcGUocC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSxsKTtyZXR1cm4gdGVuc29yKG4scixwWzBdLmR0eXBlKX0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIm5lZ1wiKSx0aGlzLm11bHRpcGx5KHNjYWxhcigtMSksdCl9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhLGUpe3JldHVyblwiY29tcGxleDY0XCI9PT1hLmR0eXBlfHxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKGEuY2FzdChcImNvbXBsZXg2NFwiKSxlLmNhc3QoXCJjb21wbGV4NjRcIiksZnVuY3Rpb24oYSxlLHQscil7cmV0dXJue3JlYWw6YSt0LGltYWc6ZStyfX0pOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLGUsdXBjYXN0VHlwZShhLmR0eXBlLGUuZHR5cGUpLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGErZX0pfSx0LnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKHMpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChzLFwiYWRkTlwiKTtmb3IodmFyIGU9cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGF0YVN5bmMoKX0pLHQ9YnVmZmVyKHNbMF0uc2hhcGUsc1swXS5kdHlwZSkscj10LnZhbHVlcyxuPTA7bjxzLmxlbmd0aDtuKyspZm9yKHZhciBwPWVbbl0sYT0wO2E8ci5sZW5ndGg7YSsrKXJbYV0rPXBbYV07cmV0dXJuIHQudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24oYSxlKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09YS5kdHlwZXx8XCJjb21wbGV4NjRcIj09PWUuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcChhLmNhc3QoXCJjb21wbGV4NjRcIiksZS5jYXN0KFwiY29tcGxleDY0XCIpLGZ1bmN0aW9uKGEsZSx0LHIpe3JldHVybntyZWFsOmEtdCxpbWFnOmUtcn19KTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLHVwY2FzdFR5cGUoYS5kdHlwZSxlLmR0eXBlKSxmdW5jdGlvbihhLGUpe3JldHVybiBhLWV9KX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcInBvd1wiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLGEuZHR5cGUsZnVuY3Rpb24oYSxlKXtyZXR1cm4gX01hdGhwb3coYSxlKX0pfSx0LnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbihELGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW0QsZV0sXCJtYXRNdWxcIik7Zm9yKHZhciBuPXQ/RC5zaGFwZVsxXTpELnNoYXBlWzJdLG89dD9ELnNoYXBlWzJdOkQuc2hhcGVbMV0sYT1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSxpPUQuc2hhcGVbMF0scz1ELmRhdGFTeW5jKCksdT1lLmRhdGFTeW5jKCksbD10P1tELnN0cmlkZXNbMF0sMSxELnN0cmlkZXNbMV1dOltELnN0cmlkZXNbMF0sRC5zdHJpZGVzWzFdLDFdLGM9bFswXSxwPWxbMV0sZD1sWzJdLGg9cj9bMSxlLnN0cmlkZXNbMV0sZS5zdHJpZGVzWzBdXTpbZS5zdHJpZGVzWzFdLDEsZS5zdHJpZGVzWzBdXSxmPWhbMF0sbT1oWzFdLGc9aFsyXSx2PW8qYSx5PW5ldyBGbG9hdDMyQXJyYXkoaSp2KSx4PXRoaXMuYmxvY2tTaXplLFQ9MDtUPGk7VCsrKWZvcih2YXIgUD0wO1A8bztQKz14KWZvcih2YXIgTz0wO088YTtPKz14KWZvcih2YXIgTD0wO0w8bjtMKz14KWZvcih2YXIgej1fTWF0aG1pbihQK3gsbyksQz1fTWF0aG1pbihPK3gsYSksXz1fTWF0aG1pbihMK3gsbiksQT1QO0E8ejtBKyspZm9yKHZhciBNPU87TTxDO00rKyl7Zm9yKHZhciBGPTAsQj1MO0I8XztCKyspRis9c1tUKmMrQSpwK0IqZF0qdVtCKmYrTSptK1QqZ107eVtUKnYrKEEqYStNKV0rPUZ9cmV0dXJuIHRlbnNvcjNkKHksW2ksbyxhXSl9LHQucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKGEsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PWEuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AoYS5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSxmdW5jdGlvbihhLGUsdCxyKXtyZXR1cm57cmVhbDphKnQtZSpyLGltYWc6YSpyK2UqdH19KTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLHVwY2FzdFR5cGUoYS5kdHlwZSxlLmR0eXBlKSxmdW5jdGlvbihhLGUpe3JldHVybiBhKmV9KX0sdC5wcm90b3R5cGUucmVhbERpdmlkZT1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW2EsZV0sXCJyZWFsRGl2aWRlXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLGUsXCJmbG9hdDMyXCIsZnVuY3Rpb24oYSxlKXtyZXR1cm4gYS9lfSl9LHQucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcImZsb29yRGl2XCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLGUsXCJpbnQzMlwiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIF9NYXRoZmxvb3IoYS9lKX0pfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24obSxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgobSxcInN1bVwiKSxhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcInN1bVwiLGUsbS5yYW5rKTtmb3IodmFyIHQ9Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhtLnNoYXBlLGUpLHI9dFswXSxuPXRbMV0sbz16ZXJvcyhyLHVwY2FzdFR5cGUobS5kdHlwZSxcImludDMyXCIpKSxhPXNpemVGcm9tU2hhcGUobiksaT1vLmRhdGFTeW5jKCkscz1tLmRhdGFTeW5jKCksdT0wO3U8aS5sZW5ndGg7Kyt1KXtmb3IodmFyIGg9dSphLGM9MCxnPTA7ZzxhOysrZyljKz1zW2grZ107aVt1XT1jfXJldHVybiBvfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKG0sZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KG0sXCJzdW1cIik7Zm9yKHZhciB0PWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobS5zaGFwZSxlKSxyPXRbMF0sbj10WzFdLG89emVyb3Mocix1cGNhc3RUeXBlKG0uZHR5cGUsXCJpbnQzMlwiKSksYT1zaXplRnJvbVNoYXBlKG4pLGk9by5kYXRhU3luYygpLHM9bS5kYXRhU3luYygpLHU9MDt1PGkubGVuZ3RoOysrdSl7Zm9yKHZhciBoPXUqYSxjPTEsZz0wO2c8YTsrK2cpYyo9c1toK2ddO2lbdV09Y31yZXR1cm4gb30sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHAsZSxsKXt0aGlzLmFzc2VydE5vdENvbXBsZXgocCxcInVuc29ydGVkU2VnbWVudFN1bVwiKTtmb3IodmFyIHI9W10sbj1wLnJhbmstZS5yYW5rLG89MDtvPG47KytvKWU9ZS5leHBhbmREaW1zKG8rMSk7Zm9yKG89MDtvPGw7KytvKXt2YXIgZD1zY2FsYXIobyxcImludDMyXCIpLGk9ZXF1YWwoZCxlKS5hc1R5cGUoXCJmbG9hdDMyXCIpLm11bChwKS5zdW0oMCk7ci5wdXNoKGkpfXJldHVybiBzdGFjayhyKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKGcsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGcsXCJhcmdNaW5cIik7dmFyIHQ9W2VdO2Fzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYXJnTWluXCIsdCxnLnJhbmspO2Zvcih2YXIgcj1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGcuc2hhcGUsdCksbj1yWzBdLG89clsxXSxhPXplcm9zKG4sXCJpbnQzMlwiKSxpPXNpemVGcm9tU2hhcGUobykscz1hLmRhdGFTeW5jKCksdT1nLmRhdGFTeW5jKCksbD0wO2w8cy5sZW5ndGg7KytsKXtmb3IodmFyIHk9bCppLHA9dVt5XSxiPTAseD0wLE47eDxpOysreClOPXVbeSt4XSxOPHAmJihwPU4sYj14KTtzW2xdPWJ9cmV0dXJuIGF9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbihnLGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChnLFwiYXJnTWF4XCIpO3ZhciB0PVtlXTthc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01heFwiLHQsZy5yYW5rKTtmb3IodmFyIHI9Y29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhnLnNoYXBlLHQpLG49clswXSxvPXJbMV0sYT16ZXJvcyhuLFwiaW50MzJcIiksaT1zaXplRnJvbVNoYXBlKG8pLHM9YS5kYXRhU3luYygpLHU9Zy5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciB5PWwqaSxwPXVbeV0sYj0wLHg9MCxOO3g8aTsrK3gpTj11W3kreF0sTj5wJiYocD1OLGI9eCk7c1tsXT1ifXJldHVybiBhfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24obSxlLHQscil7aWYodGhpcy5hc3NlcnROb3RDb21wbGV4KG0sXCJjdW1zdW1cIiksZSE9PW0ucmFuay0xKXRocm93IG5ldyBFcnJvcihcImJhY2tlbmQuY3Vtc3VtIGluIENQVSBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz1cIisobS5yYW5rLTEpK1wiIGJ1dCBnb3QgYXhpcz1cIitlKTtmb3IodmFyIG49dXBjYXN0VHlwZShtLmR0eXBlLFwiaW50MzJcIiksbz16ZXJvcyhtLnNoYXBlLG4pLGE9by5kYXRhU3luYygpLGk9bS5kYXRhU3luYygpLHM9bS5zaGFwZVttLnJhbmstMV0sdT1yP2Z1bmN0aW9uKGEsZSl7cmV0dXJuIGErcy1lLTF9OmZ1bmN0aW9uKGEsZSl7cmV0dXJuIGErZX0sbD0wO2w8aS5sZW5ndGg7bCs9cylmb3IodmFyIGc9MCxmO2c8cztnKyspaWYoZj11KGwsZyksMD09ZylhW2ZdPXQ/MDppW2ZdO2Vsc2V7dmFyIHk9dShsLGctMSk7YVtmXT10P2lbeV0rYVt5XTppW2ZdK2FbeV19cmV0dXJuIG99LHQucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcImVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLGUsXCJib29sXCIsZnVuY3Rpb24oYSxlKXtyZXR1cm4gYT09PWU/MTowfSl9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcIm5vdEVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLGUsXCJib29sXCIsZnVuY3Rpb24oYSxlKXtyZXR1cm4gYT09PWU/MDoxfSl9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFthLGVdLFwibGVzc1wiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLFwiYm9vbFwiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGE8ZT8xOjB9KX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcImxlc3NFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLFwiYm9vbFwiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGE8PWU/MTowfSl9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFthLGVdLFwiZ3JlYXRlclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLFwiYm9vbFwiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGE+ZT8xOjB9KX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcImdyZWF0ZXJFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLFwiYm9vbFwiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGE+PWU/MTowfSl9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJsb2dpY2FsTm90XCIpO2Zvcih2YXIgZT1hLmRhdGFTeW5jKCksdD1uZXcgSW50MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXRbcl09ZVtyXT8wOjE7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczp0fSxcImJvb2xcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFthLGVdLFwibG9naWNhbEFuZFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLFwiYm9vbFwiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGEmJmV9KX0sdC5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcImxvZ2ljYWxPclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLFwiYm9vbFwiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGF8fGV9KX0sdC5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKGQsZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2QsZSx0XSxcInNlbGVjdFwiKTtmb3IodmFyIHI9ZC5kYXRhU3luYygpLG49ZS5kYXRhU3luYygpLG89dC5kYXRhU3luYygpLGE9emVyb3MoZS5zaGFwZSx1cGNhc3RUeXBlKGUuZHR5cGUsdC5kdHlwZSkpLGk9YS5kYXRhU3luYygpLHM9MCxtPTA9PT1kLnJhbmt8fDE8ZC5yYW5rfHwxPT09ZS5yYW5rPzE6ZS5zaGFwZVsxXSxsPTA7bDxyLmxlbmd0aDtsKyspZm9yKHZhciBoPTA7aDxtO2grKylpW3MrK109MT09PXJbbF0/bltsXTpvW2xdO3JldHVybiBhfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2FdLFwid2hlcmVcIik7dmFyIGU9YS5kYXRhU3luYygpO3JldHVybiB3aGVyZUltcGwoYS5zaGFwZSxlKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbihhLGUsdCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwidG9wa1wiKSx0b3BrSW1wbChhLmRhdGFTeW5jKCksYS5zaGFwZSxhLmR0eXBlLGUsdCl9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbihtLGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChtLFwibWluXCIpLGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWluXCIsZSxtLnJhbmspO2Zvcih2YXIgdD1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKG0uc2hhcGUsZSkscj10WzBdLG49dFsxXSxvPXplcm9zKHIsbS5kdHlwZSksYT1zaXplRnJvbVNoYXBlKG4pLGk9by5kYXRhU3luYygpLHM9bS5kYXRhU3luYygpLHU9MDt1PGkubGVuZ3RoOysrdSl7Zm9yKHZhciBnPXUqYSxjPXNbZ10sZj0wLHk7ZjxhOysrZil5PXNbZytmXSx5PGMmJihjPXkpO2lbdV09Y31yZXR1cm4gb30sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW2EsZV0sXCJtaW5pbXVtXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLGUsYS5kdHlwZSxmdW5jdGlvbihhLGUpe3JldHVybiBfTWF0aG1pbihhLGUpfSl9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW2EsZV0sXCJtb2RcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsZSxhLmR0eXBlLGZ1bmN0aW9uKGEsZSl7dmFyIHQ9YSVlO3JldHVybiAwPmEmJjA+ZXx8MDw9YSYmMDw9ZT90Oih0K2UpJWV9KX0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKG0sZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KG0sXCJtYXhcIiksYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJtYXhcIixlLG0ucmFuayk7Zm9yKHZhciB0PWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobS5zaGFwZSxlKSxyPXRbMF0sbj10WzFdLG89emVyb3MocixtLmR0eXBlKSxhPXNpemVGcm9tU2hhcGUobiksaT1vLmRhdGFTeW5jKCkscz1tLmRhdGFTeW5jKCksdT0wO3U8aS5sZW5ndGg7Kyt1KXtmb3IodmFyIGc9dSphLGM9c1tnXSxmPTAseTtmPGE7KytmKXk9c1tnK2ZdLHk+YyYmKGM9eSk7aVt1XT1jfXJldHVybiBvfSx0LnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcIm1heGltdW1cIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsZSxhLmR0eXBlLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIF9NYXRobWF4KGEsZSl9KX0sdC5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKG0sZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KG0sXCJhbGxcIiksYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhbGxcIixlLG0ucmFuayk7Zm9yKHZhciB0PWNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobS5zaGFwZSxlKSxyPXRbMF0sbj10WzFdLG89emVyb3MocixtLmR0eXBlKSxhPXNpemVGcm9tU2hhcGUobiksaT1vLmRhdGFTeW5jKCkscz1tLmRhdGFTeW5jKCksdT0wO3U8aS5sZW5ndGg7Kyt1KXtmb3IodmFyIGc9dSphLGM9c1tnXSxmPTAseTtmPGE7KytmKXk9c1tnK2ZdLGM9YyYmeTtpW3VdPWN9cmV0dXJuIG99LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbihtLGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChtLFwiYW55XCIpLGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYW55XCIsZSxtLnJhbmspO2Zvcih2YXIgdD1jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKG0uc2hhcGUsZSkscj10WzBdLG49dFsxXSxvPXplcm9zKHIsbS5kdHlwZSksYT1zaXplRnJvbVNoYXBlKG4pLGk9by5kYXRhU3luYygpLHM9bS5kYXRhU3luYygpLHU9MDt1PGkubGVuZ3RoOysrdSl7Zm9yKHZhciBnPXUqYSxjPXNbZ10sZj0wLHk7ZjxhOysrZil5PXNbZytmXSxjPWN8fHk7aVt1XT1jfXJldHVybiBvfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbihhLGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW2EsZV0sXCJzcXVhcmVkRGlmZmVyZW5jZVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSxlLGEuZHR5cGUsZnVuY3Rpb24oYSxlKXt2YXIgdD1hLWU7cmV0dXJuIHQqdH0pfSx0LnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwiY2VpbFwiKTtmb3IodmFyIGU9YS5kYXRhU3luYygpLHQ9bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXRbcl09X01hdGhjZWlsKGVbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcImZsb29yXCIpO2Zvcih2YXIgZT1hLmRhdGFTeW5jKCksdD1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpdFtyXT1fTWF0aGZsb29yKGVbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwieFwiKTtmb3IodmFyIGU9YS5kYXRhU3luYygpLHQ9bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXRbcl09MD5lW3JdPy0xOjA8ZVtyXT8xOjA7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczp0fSl9LHQucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwicm91bmRcIik7Zm9yKHZhciBlPWEuZGF0YVN5bmMoKSx0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MCxzO3I8ZS5sZW5ndGg7KytyKXM9X01hdGhmbG9vcihlW3JdKSx0W3JdPS41PmVbcl0tcz9fTWF0aGZsb29yKGVbcl0pOi41PGVbcl0tcz9fTWF0aGNlaWwoZVtyXSk6MD09cyUyP3M6cysxO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJleHBcIik7Zm9yKHZhciBlPWEuZGF0YVN5bmMoKSx0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil0W3JdPV9NYXRoZXhwKGVbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcImV4cG0xXCIpO2Zvcih2YXIgZT1hLmRhdGFTeW5jKCksdD1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpdFtyXT1NYXRoLmV4cG0xKGVbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJsb2dcIik7Zm9yKHZhciBlPWEuZGF0YVN5bmMoKSx0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MCxzO3I8ZS5sZW5ndGg7KytyKXM9ZVtyXSx0W3JdPV9NYXRobG9nKHMpO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbihhKXt2YXIgZT1NYXRoLmxvZzFwO3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwibG9nMXBcIik7Zm9yKHZhciBzPWEuZGF0YVN5bmMoKSx0PW5ldyBGbG9hdDMyQXJyYXkocy5sZW5ndGgpLHI9MCxpO3I8cy5sZW5ndGg7KytyKWk9c1tyXSx0W3JdPWUoaSk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczp0fSl9LHQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJzcXJ0XCIpO2Zvcih2YXIgZT1hLmRhdGFTeW5jKCksdD1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTAscztyPGUubGVuZ3RoOysrcilzPWVbcl0sdFtyXT1fTWF0aHNxcnQocyk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczp0fSl9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwicnNxcnRcIik7Zm9yKHZhciBlPWEuZGF0YVN5bmMoKSx0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MCxzO3I8ZS5sZW5ndGg7KytyKXM9ZVtyXSx0W3JdPTEvX01hdGhzcXJ0KHMpO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJzcXVhcmVcIik7Zm9yKHZhciBlPWEuZGF0YVN5bmMoKSx0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MCxzO3I8ZS5sZW5ndGg7KytyKXM9ZVtyXSx0W3JdPXMqcztyZXR1cm4gVGVuc29yLm1ha2UoYS5zaGFwZSx7dmFsdWVzOnR9KX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcInJlY2lwcm9jYWxcIik7Zm9yKHZhciBlPWEuZGF0YVN5bmMoKSx0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil0W3JdPTEvZVtyXTtyZXR1cm4gVGVuc29yLm1ha2UoYS5zaGFwZSx7dmFsdWVzOnR9KX0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcInJlbHVcIik7Zm9yKHZhciBlPXplcm9zKGEuc2hhcGUsYS5kdHlwZSksdD1lLmRhdGFTeW5jKCkscj1hLmRhdGFTeW5jKCksbj0wO248ci5sZW5ndGg7KytuKXRbbl09X01hdGhtYXgoMCxyW25dKTtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwiZWx1XCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSksdD1hLmRhdGFTeW5jKCkscj0wLHM7cjx0Lmxlbmd0aDsrK3Ipcz10W3JdLGVbcl09MDw9cz9zOl9NYXRoZXhwKHMpLTE7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbihzLGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbcyxlXSxcImVsdURlclwiKTtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG49cy5kYXRhU3luYygpLG89MCxwO288ci5sZW5ndGg7KytvKXA9cltvXSx0W29dPTE8PXA/bltvXTpuW29dKihwKzEpO3JldHVybiBUZW5zb3IubWFrZShlLnNoYXBlLHt2YWx1ZXM6dH0pfSx0LnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic2VsdVwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MCxvO3I8bi5sZW5ndGg7KytyKW89bltyXSxlW3JdPTA8PW8/U0VMVV9TQ0FMRSpvOlNFTFVfU0NBTEVBTFBIQSooX01hdGhleHAobyktMSk7cmV0dXJuIFRlbnNvci5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24ocyxlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChzLFwiY2xpcFwiKTtmb3IodmFyIHI9bmV3IEZsb2F0MzJBcnJheShzLnNpemUpLG49cy5kYXRhU3luYygpLG89MCxwO288bi5sZW5ndGg7KytvKXA9bltvXSxyW29dPXA+dD90OnA8ZT9lOnA7cmV0dXJuIFRlbnNvci5tYWtlKHMuc2hhcGUse3ZhbHVlczpyfSl9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbihhKXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheShhLnNpemUpLHQ9YS5kYXRhU3luYygpLHI9MDtyPHQubGVuZ3RoOysrcillW3JdPV9NYXRoYWJzKHRbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHMpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHMuc2l6ZSksdD1zLmRhdGFTeW5jKCkscj0wO3I8cy5zaXplOysrcil7dmFyIGk9dFsyKnJdLG89dFsyKnIrMV07ZVtyXT1fTWF0aHNxcnQoaSppK28qbyl9cmV0dXJuIFRlbnNvci5tYWtlKHMuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmludD1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcImludFwiKTtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkoYS5zaXplKSx0PWEuZGF0YVN5bmMoKSxyPTA7cjx0Lmxlbmd0aDsrK3IpZVtyXT10W3JdO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6ZX0sXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcInNpZ21vaWRcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkoYS5zaXplKSx0PWEuZGF0YVN5bmMoKSxyPTA7cjx0Lmxlbmd0aDsrK3IpZVtyXT0xLygxK19NYXRoZXhwKC10W3JdKSk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKHApe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChwLFwic29mdHBsdXNcIik7Zm9yKHZhciBlPV9NYXRobG9nKDEuMTkyMDkyODk1NTA3ODEyNWUtNykrMix0PW5ldyBGbG9hdDMyQXJyYXkocC5zaXplKSxyPXAuZGF0YVN5bmMoKSxuPTA7bjxyLmxlbmd0aDsrK24pe3ZhciBsPXJbbl0+LWUsYT1yW25dPGUsaT1fTWF0aGV4cChyW25dKSxzPXZvaWQgMDtzPWE/aTpsP3Jbbl06X01hdGhsb2coMStpKSx0W25dPXN9cmV0dXJuIFRlbnNvci5tYWtlKHAuc2hhcGUse3ZhbHVlczp0fSl9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcInNpblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheShhLnNpemUpLHQ9YS5kYXRhU3luYygpLHI9MDtyPHQubGVuZ3RoOysrcillW3JdPV9NYXRoc2luKHRbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJjb3NcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkoYS5zaXplKSx0PWEuZGF0YVN5bmMoKSxyPTA7cjx0Lmxlbmd0aDsrK3IpZVtyXT1fTWF0aGNvcyh0W3JdKTtyZXR1cm4gVGVuc29yLm1ha2UoYS5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwidGFuXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSksdD1hLmRhdGFTeW5jKCkscj0wO3I8dC5sZW5ndGg7KytyKWVbcl09TWF0aC50YW4odFtyXSk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJhc2luXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSksdD1hLmRhdGFTeW5jKCkscj0wO3I8dC5sZW5ndGg7KytyKWVbcl09TWF0aC5hc2luKHRbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwiYWNvc1wiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheShhLnNpemUpLHQ9YS5kYXRhU3luYygpLHI9MDtyPHQubGVuZ3RoOysrcillW3JdPU1hdGguYWNvcyh0W3JdKTtyZXR1cm4gVGVuc29yLm1ha2UoYS5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcImF0YW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkoYS5zaXplKSx0PWEuZGF0YVN5bmMoKSxyPTA7cjx0Lmxlbmd0aDsrK3IpZVtyXT1NYXRoLmF0YW4odFtyXSk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbYSxlXSxcImF0YW4yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLGUsYS5kdHlwZSxmdW5jdGlvbihhLGUpe3JldHVybiBNYXRoLmF0YW4yKGEsZSl9KX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcInNpbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkoYS5zaXplKSx0PWEuZGF0YVN5bmMoKSxyPTA7cjx0Lmxlbmd0aDsrK3IpZVtyXT1NYXRoLnNpbmgodFtyXSk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSksdD1hLmRhdGFTeW5jKCkscj0wO3I8dC5sZW5ndGg7KytyKWVbcl09TWF0aC5jb3NoKHRbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwidGFuaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheShhLnNpemUpLHQ9YS5kYXRhU3luYygpLHI9MDtyPHQubGVuZ3RoOysrcillW3JdPXRhbmgodFtyXSk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChhLFwiYXNpbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkoYS5zaXplKSx0PWEuZGF0YVN5bmMoKSxyPTA7cjx0Lmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFzaW5oKHRbcl0pO3JldHVybiBUZW5zb3IubWFrZShhLnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcImFjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSksdD1hLmRhdGFTeW5jKCkscj0wO3I8dC5sZW5ndGg7KytyKWVbcl09TWF0aC5hY29zaCh0W3JdKTtyZXR1cm4gVGVuc29yLm1ha2UoYS5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24oYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJhdGFuaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheShhLnNpemUpLHQ9YS5kYXRhU3luYygpLHI9MDtyPHQubGVuZ3RoOysrcillW3JdPU1hdGguYXRhbmgodFtyXSk7cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbihhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYSxcImVyZlwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheShhLnNpemUpLHQ9YS5kYXRhU3luYygpLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dFtuXSxvPTEvKDErRVJGX1Aqcik7ZVtuXT0xLSgoKChFUkZfQTUqbytFUkZfQTQpKm8rRVJGX0EzKSpvK0VSRl9BMikqbytFUkZfQTEpKm8qX01hdGhleHAoLXIqcil9cmV0dXJuIFRlbnNvci5tYWtlKGEuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24ocyxlKXt2b2lkIDA9PT1lJiYoZT0wKSx0aGlzLmFzc2VydE5vdENvbXBsZXgocyxcInN0ZXBcIik7Zm9yKHZhciBpPW5ldyBGbG9hdDMyQXJyYXkocy5zaXplKSxyPXMuZGF0YVN5bmMoKSxuPTAscDtuPHIubGVuZ3RoOysrbilwPXJbbl0saVtuXT1pc05hTihwKT9OYU46MDxwPzE6ZTtyZXR1cm4gVGVuc29yLm1ha2Uocy5zaGFwZSx7dmFsdWVzOml9KX0sdC5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKFAsZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW1AsZV0sXCJjb252MmRcIik7Zm9yKHZhciByPXQuZmlsdGVySGVpZ2h0LG49dC5maWx0ZXJXaWR0aCxvPXQuZGlsYXRpb25IZWlnaHQsYT10LmRpbGF0aW9uV2lkdGgsaT10LnBhZEluZm8ubGVmdCxzPXQucGFkSW5mby50b3AsdT1idWZmZXIodC5vdXRTaGFwZSxQLmR0eXBlKSxsPVAuZGF0YVN5bmMoKSxjPWUuZGF0YVN5bmMoKSxwPXUudmFsdWVzLGQ9MDtkPHQuYmF0Y2hTaXplOysrZClmb3IodmFyIE89ZCpQLnN0cmlkZXNbMF0sZj1kKnUuc3RyaWRlc1swXSxtPTA7bTx0Lm91dEhlaWdodDsrK20pZm9yKHZhciBMPWYrbSp1LnN0cmlkZXNbMV0sdj1tKnQuc3RyaWRlSGVpZ2h0LWkseT0wLHo7eTxyO3krKylpZih6PXYreSpvLCEoMD56fHx6Pj10LmluSGVpZ2h0KSlmb3IodmFyIEY9eSplLnN0cmlkZXNbMF0sRT1PK3oqUC5zdHJpZGVzWzFdLHc9MDt3PHQub3V0V2lkdGg7Kyt3KWZvcih2YXIgQj1MK3cqdC5vdXRDaGFubmVscyxiPXcqdC5zdHJpZGVXaWR0aC1zLEM9MCxWO0M8bjtDKyspaWYoVj1iK0MqYSwhKDA+Vnx8Vj49dC5pbldpZHRoKSlmb3IodmFyIFU9RitDKmUuc3RyaWRlc1sxXSxOPUUrVip0LmluQ2hhbm5lbHMsUj1VLFc9MDtXPHQuaW5DaGFubmVsczsrK1cpe2Zvcih2YXIgRz1sW04rV10sRD0wO0Q8dC5vdXRDaGFubmVsczsrK0QpcFtCK0RdKz1HKmNbUitEXTtSKz10Lm91dENoYW5uZWxzfXJldHVybiB1LnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbnYyZERlcklucHV0PWZ1bmN0aW9uKGosZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2osZV0sXCJjb252MmREZXJJbnB1dFwiKTtmb3IodmFyIHI9YnVmZmVyKHQuaW5TaGFwZSxcImZsb2F0MzJcIiksbj1yLnZhbHVlcyxvPXIuc3RyaWRlcyxhPW9bMF0saT1vWzFdLHM9b1syXSx1PWouZGF0YVN5bmMoKSxsPWouc3RyaWRlcyxjPWxbMF0scD1sWzFdLGQ9bFsyXSxoPWUuZGF0YVN5bmMoKSxmPWUuc3RyaWRlcyxtPWZbMF0sZz1mWzFdLHY9ZlsyXSx5PXQuYmF0Y2hTaXplLHg9dC5maWx0ZXJIZWlnaHQsVD10LmZpbHRlcldpZHRoLEU9dC5pbkNoYW5uZWxzLHc9dC5pbkhlaWdodCxTPXQuaW5XaWR0aCxiPXQub3V0Q2hhbm5lbHMsQz10Lm91dEhlaWdodCxfPXQub3V0V2lkdGgsQT10LnN0cmlkZUhlaWdodCxOPXQuc3RyaWRlV2lkdGgsUj14LTEtdC5wYWRJbmZvLnRvcCxJPVQtMS10LnBhZEluZm8ubGVmdCxrPTA7azx5Oysraylmb3IodmFyIFk9MDtZPEU7KytZKWZvcih2YXIgWj0wO1o8dzsrK1opZm9yKHZhciBRPVotUixQPV9NYXRobWF4KDAsX01hdGhjZWlsKFEvQSkpLEY9X01hdGhtaW4oQywoeCtRKS9BKSxMPTA7TDxTOysrTCl7Zm9yKHZhciBKPUwtSSxVPV9NYXRobWF4KDAsX01hdGhjZWlsKEovTikpLHo9X01hdGhtaW4oXywoVCtKKS9OKSxWPTAsZWU9UDtlZTxGOysrZWUpZm9yKHZhciB0ZT1lZSpBLVEsVz1VO1c8ejsrK1cpZm9yKHZhciBhZT1jKmsrcCplZStkKlcsJD1tKih4LTEtdGUpK2cqKFQtMS0oVypOLUopKSt2KlksWD0wO1g8YjsrK1gpVis9dVthZStYXSpoWyQrWF07blthKmsraSpaK3MqTCtZXT1WfXJldHVybiByLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbihiLGUsdCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtiLGVdLFwiY29udjJkRGVyRmlsdGVyXCIpO2Zvcih2YXIgcj10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgsbz10LmZpbHRlckhlaWdodCxhPXQuZmlsdGVyV2lkdGgsaT1idWZmZXIodC5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIikscz10LnBhZEluZm8ubGVmdCx1PXQucGFkSW5mby50b3AsbD0wO2w8bzsrK2wpZm9yKHZhciBOPV9NYXRobWF4KDAsX01hdGhjZWlsKCh1LWwpL3IpKSxwPV9NYXRobWluKHQub3V0SGVpZ2h0LCh0LmluSGVpZ2h0K3UtbCkvciksZD0wO2Q8YTsrK2QpZm9yKHZhciBJPV9NYXRobWF4KDAsX01hdGhjZWlsKChzLWQpL24pKSxmPV9NYXRobWluKHQub3V0V2lkdGgsKHQuaW5XaWR0aCtzLWQpL24pLG09MDttPHQuaW5DaGFubmVsczsrK20pZm9yKHZhciBDPTA7Qzx0Lm91dENoYW5uZWxzOysrQyl7Zm9yKHZhciBrPTAsUj0wO1I8dC5iYXRjaFNpemU7KytSKWZvcih2YXIgRD1OO0Q8cDsrK0QpZm9yKHZhciBQPWwrRCpyLXUsRT1JLEE7RTxmOysrRSlBPWQrRSpuLXMsays9Yi5nZXQoUixQLEEsbSkqZS5nZXQoUixELEUsQyk7aS5zZXQoayxsLGQsbSxDKX1yZXR1cm4gaS50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24oTCxlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbTCxlXSxcImRlcHRod2lzZUNvbnYyRFwiKTtmb3IodmFyIHI9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLG89dC5kaWxhdGlvbkhlaWdodCxhPXQuZGlsYXRpb25XaWR0aCxpPXQucGFkSW5mby5sZWZ0LHM9dC5wYWRJbmZvLnRvcCx1PXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzLGw9YnVmZmVyKHQub3V0U2hhcGUsTC5kdHlwZSksYz1MLmRhdGFTeW5jKCkscD1lLmRhdGFTeW5jKCksZD1sLnZhbHVlcyxoPTA7aDx0LmJhdGNoU2l6ZTsrK2gpZm9yKHZhciB6PWgqTC5zdHJpZGVzWzBdLG09aCpsLnN0cmlkZXNbMF0sZz0wO2c8dC5vdXRIZWlnaHQ7KytnKWZvcih2YXIgRj1tK2cqbC5zdHJpZGVzWzFdLHk9Zyp0LnN0cmlkZUhlaWdodC1pLHg9MCxCO3g8cjsrK3gpaWYoQj15K3gqbywhKDA+Qnx8Qj49dC5pbkhlaWdodCkpZm9yKHZhciBWPXgqZS5zdHJpZGVzWzBdLHc9eitCKkwuc3RyaWRlc1sxXSxTPTA7Uzx0Lm91dFdpZHRoOysrUylmb3IodmFyIFU9RitTKmwuc3RyaWRlc1syXSxDPVMqdC5zdHJpZGVXaWR0aC1zLF89MCxXO188bjsrK18paWYoVz1DK18qYSwhKDA+V3x8Vz49dC5pbldpZHRoKSlmb3IodmFyIEc9VitfKmUuc3RyaWRlc1sxXSxSPXcrVyp0LmluQ2hhbm5lbHMsST1VLHE9RyxIPTA7SDx0LmluQ2hhbm5lbHM7KytIKXtmb3IodmFyIGo9Y1tSK0hdLE89MDtPPHU7KytPKWRbSStPXSs9aipwW3ErT107SSs9dSxxKz11fXJldHVybiBsLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKFksZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW1ksZV0sXCJkZXB0aHdpc2VDb252MkREZXJJbnB1dFwiKTtmb3IodmFyIHI9YnVmZmVyKHQuaW5TaGFwZSxcImZsb2F0MzJcIiksbj1yLnZhbHVlcyxvPXIuc3RyaWRlcyxhPW9bMF0saT1vWzFdLHM9b1syXSx1PVkuZGF0YVN5bmMoKSxsPVkuc3RyaWRlcyxjPWxbMF0scD1sWzFdLGQ9bFsyXSxoPWUuZGF0YVN5bmMoKSxmPWUuc3RyaWRlcyxtPWZbMF0sZz1mWzFdLHY9ZlsyXSx5PXQuYmF0Y2hTaXplLHg9dC5maWx0ZXJIZWlnaHQsVD10LmZpbHRlcldpZHRoLEU9dC5pbkNoYW5uZWxzLHc9dC5pbkhlaWdodCxTPXQuaW5XaWR0aCxiPXQub3V0Q2hhbm5lbHMsQz10Lm91dEhlaWdodCxfPXQub3V0V2lkdGgsQT10LnN0cmlkZUhlaWdodCxOPXQuc3RyaWRlV2lkdGgsUj14LTEtdC5wYWRJbmZvLnRvcCxJPVQtMS10LnBhZEluZm8ubGVmdCxrPWIvRSxEPTA7RDx5OysrRClmb3IodmFyIFo9MDtaPEU7KytaKWZvcih2YXIgUT0wO1E8dzsrK1EpZm9yKHZhciBKPVEtUixGPV9NYXRobWF4KDAsX01hdGhjZWlsKEovQSkpLEw9X01hdGhtaW4oQywoeCtKKS9BKSxCPTA7QjxTOysrQil7Zm9yKHZhciBlZT1CLUksej1fTWF0aG1heCgwLF9NYXRoY2VpbChlZS9OKSksVj1fTWF0aG1pbihfLChUK2VlKS9OKSxIPTAsdGU9Rjt0ZTxMOysrdGUpZm9yKHZhciBhZT10ZSpBLUoscT16O3E8VjsrK3EpZm9yKHZhciBuZT1jKkQrcCp0ZStkKnEsWD1tKih4LTEtYWUpK2cqKFQtMS0ocSpOLWVlKSkrdipaLEs9MDtLPGs7KytLKUgrPXVbbmUrKFoqaytLKV0qaFtYK0tdO25bYSpEK2kqUStzKkIrWl09SH1yZXR1cm4gci50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24oTixlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbTixlXSxcImRlcHRod2lzZUNvbnYyRERlckZpbHRlclwiKTtmb3IodmFyIHI9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLG89dC5maWx0ZXJIZWlnaHQsYT10LmZpbHRlcldpZHRoLGk9YnVmZmVyKHQuZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLHM9dC5wYWRJbmZvLmxlZnQsdT10LnBhZEluZm8udG9wLGw9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHMsYz0wO2M8bzsrK2MpZm9yKHZhciBJPV9NYXRobWF4KDAsX01hdGhjZWlsKCh1LWMpL3IpKSxkPV9NYXRobWluKHQub3V0SGVpZ2h0LCh0LmluSGVpZ2h0K3UtYykvciksaD0wO2g8YTsrK2gpZm9yKHZhciBrPV9NYXRobWF4KDAsX01hdGhjZWlsKChzLWgpL24pKSxtPV9NYXRobWluKHQub3V0V2lkdGgsKHQuaW5XaWR0aCtzLWgpL24pLGc9MDtnPHQub3V0Q2hhbm5lbHM7KytnKXtmb3IodmFyIFI9TWF0aC50cnVuYyhnL2wpLHk9ZyVsLHg9MCxEPTA7RDx0LmJhdGNoU2l6ZTsrK0QpZm9yKHZhciBQPUk7UDxkOysrUClmb3IodmFyIEE9YytQKnItdSxTPWssXztTPG07KytTKV89aCtTKm4tcyx4Kz1OLmdldChELEEsXyxSKSplLmdldChELFAsUyxnKTtpLnNldCh4LGMsaCxSLHkpfXJldHVybiBpLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24ocCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgocCxcInRpbGVcIik7Zm9yKHZhciB0PUFycmF5KHAucmFuaykscj0wO3I8dC5sZW5ndGg7cisrKXRbcl09cC5zaGFwZVtyXSplW3JdO3ZhciBkPWJ1ZmZlcih0LHAuZHR5cGUpLG89cC5idWZmZXIoKTtmb3Iocj0wO3I8ZC52YWx1ZXMubGVuZ3RoOysrcil7Zm9yKHZhciBhPWQuaW5kZXhUb0xvYyhyKSxpPUFycmF5KHAucmFuaykscz0wO3M8aS5sZW5ndGg7cysrKWlbc109YVtzXSVwLnNoYXBlW3NdO3ZhciBjPW8ubG9jVG9JbmRleChpKTtkLnZhbHVlc1tyXT1vLnZhbHVlc1tjXX1yZXR1cm4gZC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24ocCxlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChwLFwicGFkXCIpO3ZhciByPWUubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbMF0rcC5zaGFwZVt0XStlWzFdfSksbj1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pLG89cC5idWZmZXIoKSxhPWJ1ZmZlcihyLHAuZHR5cGUpOzAhPT10JiZhLnZhbHVlcy5maWxsKHQpO2Zvcih2YXIgaT0wO2k8cC5zaXplO2krKyl7dmFyIGQ9by5pbmRleFRvTG9jKGkpLHU9ZC5tYXAoZnVuY3Rpb24oYSxlKXtyZXR1cm4gYStuW2VdfSk7YS5zZXQuYXBwbHkoYSxbcC5nZXQuYXBwbHkocCxkKV0uY29uY2F0KHUpKX1yZXR1cm4gYS50b1RlbnNvcigpfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24ocCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgocCxcInRyYW5zcG9zZVwiKTtmb3IodmFyIHQ9QXJyYXkocC5yYW5rKSxyPTA7cjx0Lmxlbmd0aDtyKyspdFtyXT1wLnNoYXBlW2Vbcl1dO3ZhciBkPXAuZGF0YVN5bmMoKSxvPWJ1ZmZlcih0LHAuZHR5cGUpLGE9cC5idWZmZXIoKTtmb3Iocj0wO3I8cC5zaXplOysrcil7Zm9yKHZhciBpPWEuaW5kZXhUb0xvYyhyKSxzPUFycmF5KGkubGVuZ3RoKSx1PTA7dTxzLmxlbmd0aDt1Kyspc1t1XT1pW2VbdV1dO3ZhciBtPW8ubG9jVG9JbmRleChzKTtvLnZhbHVlc1ttXT1kW3JdfXJldHVybiBvLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbihwLGUsdCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtwLGVdLFwiZ2F0aGVyXCIpO3ZhciByPXAuc2hhcGUuc2xpY2UoKSxuPWUuZGF0YVN5bmMoKTtyW3RdPW4ubGVuZ3RoO2Zvcih2YXIgbz1idWZmZXIocixwLmR0eXBlKSxhPXAuYnVmZmVyKCksaT0wO2k8by5zaXplOysraSl7dmFyIGQ9by5pbmRleFRvTG9jKGkpLHU9ZC5zbGljZSgpO3VbdF09bltkW3RdXTt2YXIgbD1hLmxvY1RvSW5kZXgodSk7by52YWx1ZXNbaV09YS52YWx1ZXNbbF19cmV0dXJuIG8udG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24ocCxlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbcF0sXCJiYXRjaFRvU3BhY2VORFwiKTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbihhLGUpe3JldHVybiBhKmV9KSxuPWdldFJlc2hhcGVkKHAuc2hhcGUsZSxyKSxvPWdldFBlcm11dGVkKG4ubGVuZ3RoLGUubGVuZ3RoKSxhPWdldFJlc2hhcGVkUGVybXV0ZWQocC5zaGFwZSxlLHIpLGk9Z2V0U2xpY2VCZWdpbkNvb3Jkcyh0LGUubGVuZ3RoKSxzPWdldFNsaWNlU2l6ZShhLHQsZS5sZW5ndGgpO3JldHVybiBwLnJlc2hhcGUobikudHJhbnNwb3NlKG8pLnJlc2hhcGUoYSkuc2xpY2UoaSxzKX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24ocCxlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbcF0sXCJzcGFjZVRvQmF0Y2hORFwiKTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbihhLGUpe3JldHVybiBhKmV9KSxuPVtbMCwwXV07bi5wdXNoLmFwcGx5KG4sdCk7Zm9yKHZhciBvPTErZS5sZW5ndGg7bzxwLnNoYXBlLmxlbmd0aDsrK28pbi5wdXNoKFswLDBdKTt2YXIgZD1wLnBhZChuKSxpPWdldFJlc2hhcGVkKGQuc2hhcGUsZSxyLCExKSxzPWdldFBlcm11dGVkKGkubGVuZ3RoLGUubGVuZ3RoLCExKSx1PWdldFJlc2hhcGVkUGVybXV0ZWQoZC5zaGFwZSxlLHIsITEpO3JldHVybiBkLnJlc2hhcGUoaSkudHJhbnNwb3NlKHMpLnJlc2hhcGUodSl9LHQucHJvdG90eXBlLnBvb2w9ZnVuY3Rpb24oeixlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh6LFwicG9vbFwiKTtmb3IodmFyIHI9ZS5zdHJpZGVIZWlnaHQsbj1lLnN0cmlkZVdpZHRoLG89ZS5kaWxhdGlvbkhlaWdodCxhPWUuZGlsYXRpb25XaWR0aCxpPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHM9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCx1PWUucGFkSW5mby50b3AsbD1lLnBhZEluZm8ubGVmdCxjPVwibWF4XCI9PT10P19OdW1iZXJORUdBVElWRV9JTkZJTklUWTpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkscD16LmRhdGFTeW5jKCksZD1idWZmZXIoZS5vdXRTaGFwZSx6LmR0eXBlKSxoPWQudmFsdWVzLGY9ZS5vdXRTaGFwZVsxXSplLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10sbT1lLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10sZz1lLm91dFNoYXBlWzNdLHY9MDt2PGUuYmF0Y2hTaXplOysrdilmb3IodmFyIEI9dipmLHg9dip6LnN0cmlkZXNbMF0sVD0wO1Q8ZS5pbkNoYW5uZWxzOysrVClmb3IodmFyIFY9MDtWPGUub3V0SGVpZ2h0OysrVilmb3IodmFyIFU9VipyLXUsUz1fTWF0aG1heCgwLFUpLGI9X01hdGhtaW4oZS5pbkhlaWdodCxpK1UpLEM9QitWKm0sXz0wO188ZS5vdXRXaWR0aDsrK18pe2Zvcih2YXIgVz1fKm4tbCxOPV9NYXRobWF4KDAsVyksUj1fTWF0aG1pbihlLmluV2lkdGgscytXKSxJPWMsRz0wLHE9MCxIPVM7SDxiO0grPW8pe2Zvcih2YXIgaj14K0gqei5zdHJpZGVzWzFdLFA9TiwkO1A8UjtQKz1hKSQ9cFtqK1Aqei5zdHJpZGVzWzJdK1RdLFwibWF4XCI9PT10JiYkPkk/ST0kOlwiYXZnXCI9PXQmJihHKz0kLHErKyk7aWYoaXNOYU4oSSkpYnJlYWt9aFtDK18qZytUXT1cImF2Z1wiPT09dD9HL3E6SX1yZXR1cm4gZC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMucG9vbChhLGUsXCJtYXhcIil9LHQucHJvdG90eXBlLm1heFBvb2xQb3NpdGlvbnM9ZnVuY3Rpb24oTixlKXtmb3IodmFyIHQ9YnVmZmVyKGUub3V0U2hhcGUsXCJpbnQzMlwiKSxyPWUuc3RyaWRlSGVpZ2h0LG49ZS5zdHJpZGVXaWR0aCxvPWUuZGlsYXRpb25IZWlnaHQsYT1lLmRpbGF0aW9uV2lkdGgsaT1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxzPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsdT1lLnBhZEluZm8udG9wLGw9ZS5wYWRJbmZvLmxlZnQsYz0wO2M8ZS5iYXRjaFNpemU7KytjKWZvcih2YXIgST0wO0k8ZS5pbkNoYW5uZWxzOysrSSlmb3IodmFyIGs9MDtrPGUub3V0SGVpZ2h0Oysrayl7Zm9yKHZhciBSPWsqci11LGY9UjswPmY7KWYrPW87Zm9yKHZhciBEPV9NYXRobWluKGUuaW5IZWlnaHQsaStSKSxnPTA7ZzxlLm91dFdpZHRoOysrZyl7Zm9yKHZhciBQPWcqbi1sLHk9UDswPnk7KXkrPWE7Zm9yKHZhciBPPV9NYXRobWluKGUuaW5XaWR0aCxzK1ApLFQ9X051bWJlck5FR0FUSVZFX0lORklOSVRZLEw9LTEsej1mO3o8RDt6Kz1vKWZvcih2YXIgTT16LVIsYj15O2I8TztiKz1hKXt2YXIgRj1iLVAsXz1OLmdldChjLHosYixJKTtfPlQmJihUPV8sTD1NKnMrRil9dC5zZXQoTCxjLGssZyxJKX19cmV0dXJuIHQudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKE4sZSx0LHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSx0XSxcIm1heFBvb2xCYWNrcHJvcFwiKTtmb3IodmFyIG49dGhpcy5tYXhQb29sUG9zaXRpb25zKGUsciksbz1yLnN0cmlkZUhlaWdodCxhPXIuc3RyaWRlV2lkdGgsaT1yLmRpbGF0aW9uSGVpZ2h0LHM9ci5kaWxhdGlvbldpZHRoLHU9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbD1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9bC0xLXIucGFkSW5mby5sZWZ0LHA9dS0xLXIucGFkSW5mby50b3AsZD1idWZmZXIoZS5zaGFwZSxcImZsb2F0MzJcIiksaD0wO2g8ci5iYXRjaFNpemU7KytoKWZvcih2YXIgST0wO0k8ci5pbkNoYW5uZWxzOysrSSlmb3IodmFyIGs9MDtrPHIuaW5IZWlnaHQ7KytrKWZvcih2YXIgUj0wO1I8ci5pbldpZHRoOysrUil7Zm9yKHZhciBEPWstcCx5PVItYyx4PTAsUD0wLEE7UDx1O1ArPWkpaWYoQT0oRCtQKS9vLCEoMD5BfHxBPj1yLm91dEhlaWdodHx8X01hdGhmbG9vcihBKSE9PUEpKWZvcih2YXIgXz0wLE87XzxsO18rPXMpaWYoTz0oeStfKS9hLCEoMD5PfHxPPj1yLm91dFdpZHRofHxfTWF0aGZsb29yKE8pIT09Tykpe3ZhciBMPXUqbC0xLW4uZ2V0KGgsQSxPLEkpPT09UCpsK18/MTowOzAhPUwmJih4Kz1OLmdldChoLEEsTyxJKSpMKX1kLnNldCh4LGgsayxSLEkpfXJldHVybiBkLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbihmLGUsdCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtmLGVdLFwiYXZnUG9vbEJhY2twcm9wXCIpO2Zvcih2YXIgcj10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgsbz10LmZpbHRlckhlaWdodCxhPXQuZmlsdGVyV2lkdGgsaT10LmRpbGF0aW9uSGVpZ2h0LHM9dC5kaWxhdGlvbldpZHRoLHU9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbD10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9bC0xLXQucGFkSW5mby5sZWZ0LHA9dS0xLXQucGFkSW5mby50b3AsZD1idWZmZXIoZS5zaGFwZSxcImZsb2F0MzJcIiksaD0wO2g8dC5iYXRjaFNpemU7KytoKWZvcih2YXIgTj0wO048dC5pbkNoYW5uZWxzOysrTilmb3IodmFyIEk9MDtJPHQuaW5IZWlnaHQ7KytJKWZvcih2YXIgaz0wO2s8dC5pbldpZHRoOysrayl7Zm9yKHZhciBSPUktcCx4PWstYyxUPTAsRD0wLFA7RDx1O0QrPWkpaWYoUD0oUitEKS9yLCEoMD5QfHxQPj10Lm91dEhlaWdodHx8X01hdGhmbG9vcihQKSE9PVApKWZvcih2YXIgQT0wLF87QTxsO0ErPXMpXz0oeCtBKS9uLDA+X3x8Xz49dC5vdXRXaWR0aHx8X01hdGhmbG9vcihfKSE9PV98fChUKz1mLmdldChoLFAsXyxOKSk7ZC5zZXQoVCooMS8obyphKSksaCxJLGssTil9cmV0dXJuIGQudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbihhLGUpe3JldHVybiBjYXN0VGVuc29yKGEsZSx0aGlzKX0sdC5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbihhLGUpe3JldHVybiByZXNoYXBlVGVuc29yKGEsZSl9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJhdmdQb29sXCIpLHRoaXMucG9vbChhLGUsXCJhdmdcIikudG9GbG9hdCgpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbihULGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoVCxcInJlc2l6ZUJpbGluZWFyXCIpO2Zvcih2YXIgbj1ULnNoYXBlLG89blswXSxhPW5bMV0saT1uWzJdLHM9blszXSx1PVQuZGF0YVN5bmMoKSxsPW5ldyBGbG9hdDMyQXJyYXkoc2l6ZUZyb21TaGFwZShbbyxlLHQsc10pKSxjPVtyJiYxPGU/YS0xOmEsciYmMTx0P2ktMTppXSxwPVtyJiYxPGU/ZS0xOmUsciYmMTx0P3QtMTp0XSxkPTAsej1jWzBdL3BbMF0sZj1jWzFdL3BbMV0sbT0wO208bzttKyspZm9yKHZhciBCPTA7QjxlO0IrKylmb3IodmFyIFY9eipCLHk9X01hdGhmbG9vcihWKSx4PV9NYXRobWluKGEtMSxfTWF0aGNlaWwoVikpLEU9bSpULnN0cmlkZXNbMF0reSpULnN0cmlkZXNbMV0sdz1tKlQuc3RyaWRlc1swXSt4KlQuc3RyaWRlc1sxXSxTPTA7Uzx0O1MrKylmb3IodmFyIFU9ZipTLEM9X01hdGhmbG9vcihVKSxfPVUtQyxBPV9NYXRobWluKGktMSxfTWF0aGNlaWwoVSkpLE49RStDKlQuc3RyaWRlc1syXSxSPXcrQypULnN0cmlkZXNbMl0sST1FKyArQSpULnN0cmlkZXNbMl0saz13K0EqVC5zdHJpZGVzWzJdLEQ9MDtEPHM7RCsrKXt2YXIgVz11W04rRF0sTz11W1IrRF0sUD1XKyh1W0krRF0tVykqXyxGPVArKE8rKHVbaytEXS1PKSpfLVApKihWLXkpO2xbZCsrXT1GfXJldHVybiB0ZW5zb3IobCxbbyxlLHQsc10pfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHosZSx0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3osZV0sXCJyZXNpemVCaWxpbmVhckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG49clswXSxvPXJbMV0sYT1yWzJdLGk9clszXSxzPXouc2hhcGUsdT1zWzFdLGw9c1syXSxjPW5ldyBGbG9hdDMyQXJyYXkobipvKmEqaSkscD1bdCYmMTx1P28tMTpvLHQmJjE8bD9hLTE6YV0sZD1bdCYmMTx1P3UtMTp1LHQmJjE8bD9sLTE6bF0saD1wWzBdL2RbMF0sZj1wWzFdL2RbMV0sbT16LmRhdGFTeW5jKCksZz0wLEI9MDtCPG47QisrKWZvcih2YXIgVj1CKmUuc3RyaWRlc1swXSx4PTA7eDx1O3grKylmb3IodmFyIFU9eCpoLEU9X01hdGhmbG9vcihVKSx3PV9NYXRobWluKF9NYXRoY2VpbChVKSxvLTEpLFM9VitFKmUuc3RyaWRlc1sxXSxiPVYrdyplLnN0cmlkZXNbMV0sQz1VLUUsXz0xLUMsQT0wO0E8bDtBKyspZm9yKHZhciBXPUEqZixSPV9NYXRoZmxvb3IoVyksST1fTWF0aG1pbihfTWF0aGNlaWwoVyksYS0xKSxrPVctUixEPTEtayxNPVMrUiplLnN0cmlkZXNbMl0sTz1TK0kqZS5zdHJpZGVzWzJdLFA9YitSKmUuc3RyaWRlc1syXSxGPWIrSSplLnN0cmlkZXNbMl0sTD0wLHE7TDxpO0wrKylxPW1bZysrXSxjW00rTF0rPXEqKF8qRCksY1tPK0xdKz1xKihfKmspLGNbUCtMXSs9cSooQypEKSxjW0YrTF0rPXEqKEMqayk7cmV0dXJuIHRlbnNvcjRkKGMsW24sYSxvLGldLGUuZHR5cGUpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24oTixlLHQscil7dGhpcy5hc3NlcnROb3RDb21wbGV4KE4sXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7Zm9yKHZhciBuPU4uc2hhcGUsbz1uWzBdLGE9blsxXSxpPW5bMl0scz1uWzNdLHU9Ti5kYXRhU3luYygpLGw9bmV3IEZsb2F0MzJBcnJheShvKmUqdCpzKSxjPVtyJiYxPGU/YS0xOmEsciYmMTx0P2ktMTppXSxwPVtyJiYxPGU/ZS0xOmUsciYmMTx0P3QtMTp0XSxkPWNbMF0vcFswXSxoPWNbMV0vcFsxXSxmPTAsST0wO0k8bztJKyspZm9yKHZhciBrPUkqTi5zdHJpZGVzWzBdLHY9MDt2PGU7disrKWZvcih2YXIgUj1kKnYseD1rK19NYXRobWluKGEtMSxyP19NYXRocm91bmQoUik6X01hdGhmbG9vcihSKSkqTi5zdHJpZGVzWzFdLFQ9MDtUPHQ7VCsrKWZvcih2YXIgRD1oKlQsdz14K19NYXRobWluKGktMSxyP19NYXRocm91bmQoRCk6X01hdGhmbG9vcihEKSkqTi5zdHJpZGVzWzJdLFM9MCxQO1M8cztTKyspUD11W3crU10sbFtmKytdPVA7cmV0dXJuIHRlbnNvcihsLFtvLGUsdCxzXSxOLmR0eXBlKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24oVixlLHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbVixlXSxcInJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG49clswXSxvPXJbMV0sYT1yWzJdLGk9clszXSxzPVYuc2hhcGUsdT1zWzFdLGw9c1syXSxjPW5ldyBGbG9hdDMyQXJyYXkobipvKmEqaSkscD1WLmRhdGFTeW5jKCksZD1bdCYmMTx1P28tMTpvLHQmJjE8bD9hLTE6YV0saD1bdCYmMTx1P3UtMTp1LHQmJjE8bD9sLTE6bF0sZj1kWzBdL2hbMF0sbT1kWzFdL2hbMV0sZz0xL2Ysdj0xL20seT0yKl9NYXRoY2VpbChnKSsyLHg9MipfTWF0aGNlaWwodikrMixUPTA7VDxuO1QrKylmb3IodmFyIFc9VCplLnN0cmlkZXNbMF0sdz0wO3c8bzt3KyspZm9yKHZhciBHPVcrdyplLnN0cmlkZXNbMV0sYj1fTWF0aGZsb29yKHcqZyksQz1fTWF0aGZsb29yKGIteS8yKSxfPTA7XzxhO18rKylmb3IodmFyIHE9RytfKmUuc3RyaWRlc1syXSxOPV9NYXRoZmxvb3IoXyp2KSxSPV9NYXRoZmxvb3IoTi14LzIpLEk9MDtJPGk7SSsrKXtmb3IodmFyIEg9MCxqPTAsJDtqPHk7aisrKWlmKCQ9aitDLCEoMD4kfHwkPj11KSl7dmFyIEs9VyskKlYuc3RyaWRlc1sxXSxQPSQqZjtpZih3PT09X01hdGhtaW4oby0xLHQ/X01hdGhyb3VuZChQKTpfTWF0aGZsb29yKFApKSlmb3IodmFyIEY9MCxYO0Y8eDtGKyspaWYoWD1GK1IsISgwPlh8fFg+PWwpKXt2YXIgWT1LK1gqVi5zdHJpZGVzWzJdLFU9WCptO189PT1fTWF0aG1pbihhLTEsdD9fTWF0aHJvdW5kKFUpOl9NYXRoZmxvb3IoVSkpJiYoSCs9cFtZK0ldKX19Y1txK0ldPUh9cmV0dXJuIHRlbnNvcjRkKGMsZS5zaGFwZSxlLmR0eXBlKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKGIsZSx0LHIsbixvKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2IsZSx0LG4sb10sXCJiYXRjaE5vcm1hbGl6YXRpb25cIik7Zm9yKHZhciBhPWIuZGF0YVN5bmMoKSxpPWUuZGF0YVN5bmMoKSxzPXQuZGF0YVN5bmMoKSx1PW4/bi5kYXRhU3luYygpOm5ldyBGbG9hdDMyQXJyYXkoWzFdKSxsPW8/by5kYXRhU3luYygpOm5ldyBGbG9hdDMyQXJyYXkoWzBdKSxjPW5ldyBGbG9hdDMyQXJyYXkoYS5sZW5ndGgpLHA9bC5sZW5ndGgsZD11Lmxlbmd0aCxoPXMubGVuZ3RoLGY9aS5sZW5ndGgsbT0wLE49MCxJPTAsUz0wLEM9MDtDPGEubGVuZ3RoOysrQyljW0NdPWxbbSsrXSsoYVtDXS1pW04rK10pKnVbSSsrXS9fTWF0aHNxcnQoc1tTKytdK3IpLG0+PXAmJihtPTApLE4+PWYmJihOPTApLEk+PWQmJihJPTApLFM+PWgmJihTPTApO3JldHVybiB0ZW5zb3I0ZChjLGIuc2hhcGUpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKG0sZyxlLHQsbil7ZnVuY3Rpb24gcih0KXtmb3IodmFyIGU9dCVjLHI9dC1lK19NYXRobWF4KDAsZS1nKSxzPXQtZStfTWF0aG1pbihlK2csYSksbz0wLHA7cjw9cztyKyspcD1pW3JdLG8rPXAqcDtyZXR1cm4gb310aGlzLmFzc2VydE5vdENvbXBsZXgobSxcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNERcIik7Zm9yKHZhciBjPW0uc2hhcGVbM10sYT1jLTEsaT1tLmRhdGFTeW5jKCksbz1zaXplRnJvbVNoYXBlKG0uc2hhcGUpLHM9bmV3IEZsb2F0MzJBcnJheShvKSxsPTA7bDxvO2wrKyl7dmFyIHU9cihsKSxkPWlbbF0qX01hdGhwb3coZSt0KnUsLW4pO3NbbF09ZH1yZXR1cm4gdGVuc29yNGQocyxtLnNoYXBlKX0sdC5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbihiLGUsdCxyLG4sbyxhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYixcIkxSTkdyYWRcIik7Zm9yKHZhciBpPWIuc2hhcGVbM10scz1iLmRhdGFTeW5jKCksdT1lLmRhdGFTeW5jKCksbD10LmRhdGFTeW5jKCksYz1uZXcgRmxvYXQzMkFycmF5KHNpemVGcm9tU2hhcGUoYi5zaGFwZSkpLHA9c2l6ZUZyb21TaGFwZShiLnNoYXBlKSxkPTA7ZDxwO2QrKyl7Zm9yKHZhciBOPWQlaSxmPWQtTitfTWF0aG1heCgwLE4tciksbT1kLU4rX01hdGhtaW4oaSxOK3IrMSksZz0wLEk9ZjtJPG07SSsrKWcrPV9NYXRocG93KHVbSV0sMik7Zm9yKGc9bypnK24sST1mO0k8bTtJKyspe3ZhciBTPS0yKm8qYSp1W0ldKmxbZF0vZztkPT09SSYmKFMrPV9NYXRocG93KGcsLWEpKSxTKj1zW2RdLGNbSV0rPVN9fXJldHVybiB0ZW5zb3I0ZChjLGIuc2hhcGUpfSx0LnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbihiLGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoYixcIm11bHRpbm9taWFsXCIpO2Zvcih2YXIgbj1lP2I6c29mdG1heChiKSxvPW4uc2hhcGVbMF0sYT1uLnNoYXBlWzFdLGk9emVyb3MoW28sdF0sXCJpbnQzMlwiKSxzPWkuZGF0YVN5bmMoKSx1PW4uZGF0YVN5bmMoKSxsPTA7bDxvOysrbCl7dmFyIHg9bCphLHA9bmV3IEZsb2F0MzJBcnJheShhLTEpO3BbMF09dVt4XTtmb3IodmFyIGQ9MTtkPHAubGVuZ3RoOysrZClwW2RdPXBbZC0xXSt1W3grZF07Zm9yKHZhciBOPXNlZWRyYW5kb21fMShyLnRvU3RyaW5nKCkpLGY9bCp0LG09MCxJO208dDsrK20pe0k9TigpLHNbZittXT1wLmxlbmd0aDtmb3IodmFyIFM9MDtTPHAubGVuZ3RoO1MrKylpZihJPHBbU10pe3NbZittXT1TO2JyZWFrfX19cmV0dXJuIGl9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbihzLGUsdCxyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgocyxcIm9uZUhvdFwiKTt2YXIgbj1uZXcgRmxvYXQzMkFycmF5KHMuc2l6ZSplKTtuLmZpbGwocik7Zm9yKHZhciBvPTA7bzxzLnNpemU7KytvKTA8PXMuZ2V0KG8pJiZzLmdldChvKTxlJiYobltvKmUrcy5nZXQobyldPXQpO3JldHVybiB0ZW5zb3IyZChuLFtzLnNpemUsZV0sXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24oYSxlLHQscixuKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KGEsXCJub25NYXhTdXBwcmVzc2lvblwiKSxub25NYXhTdXBwcmVzc2lvbkltcGwoYS5kYXRhU3luYygpLGUuZGF0YVN5bmMoKSx0LHIsbil9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXtpZigxIT09dC5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5mZnQoKSBvbiBDUFUgb25seSBzdXBwb3J0cyB2ZWN0b3JzLlwiKTtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITEpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe2lmKDEhPT10LnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcInRmLmlmZnQoKSBvbiBDUFUgb25seSBzdXBwb3J0cyB2ZWN0b3JzLlwiKTtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITApfSx0LnByb3RvdHlwZS5mZnRJbXBsPWZ1bmN0aW9uKHMsZSl7dmFyIHQ9cy5hczFEKCkscj10LnNpemU7aWYodGhpcy5pc0V4cG9uZW50T2YyKHIpKXt2YXIgbj10aGlzLmZmdFJhZGl4Mih0LHIsZSkuYXMyRChzLnNoYXBlWzBdLHMuc2hhcGVbMV0pO3JldHVybiBlJiYobj1jb21wbGV4KHJlYWwobikuZGl2KHNjYWxhcihyKSksaW1hZyhuKS5kaXYoc2NhbGFyKHIpKSkpLG59dmFyIHA9cy5kYXRhU3luYygpLGE9c3BsaXRSZWFsQW5kSW1hZ0FycmF5cyh0aGlzLmZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bChwLHIsZSkpO3JldHVybiBjb21wbGV4KGEucmVhbCxhLmltYWcpLmFzMkQocy5zaGFwZVswXSxzLnNoYXBlWzFdKX0sdC5wcm90b3R5cGUuaXNFeHBvbmVudE9mMj1mdW5jdGlvbih0KXtyZXR1cm4gMD09KHQmdC0xKX0sdC5wcm90b3R5cGUuZmZ0UmFkaXgyPWZ1bmN0aW9uKG0sZSx0KXtpZigxPT09ZSlyZXR1cm4gbTt2YXIgcj1tLmRhdGFTeW5jKCksbj1lLzIsbz1jb21wbGV4V2l0aEV2ZW5JbmRleChyKSxhPWNvbXBsZXgoby5yZWFsLG8uaW1hZykuYXMxRCgpLGc9Y29tcGxleFdpdGhPZGRJbmRleChyKSxzPWNvbXBsZXgoZy5yZWFsLGcuaW1hZykuYXMxRCgpO2E9dGhpcy5mZnRSYWRpeDIoYSxuLHQpLHM9dGhpcy5mZnRSYWRpeDIocyxuLHQpO3ZhciB5PWV4cG9uZW50cyhlLHQpLGw9Y29tcGxleCh5LnJlYWwseS5pbWFnKS5tdWwocyksYz1hLmFkZChsKSxwPWEuc3ViKGwpLGQ9cmVhbChjKS5jb25jYXQocmVhbChwKSksaD1pbWFnKGMpLmNvbmNhdChpbWFnKHApKTtyZXR1cm4gY29tcGxleChkLGgpLmFzMUQoKX0sdC5wcm90b3R5cGUuZm91cmllclRyYW5zZm9ybUJ5TWF0bXVsPWZ1bmN0aW9uKHAsZSx0KXtmb3IodmFyIHI9bmV3IEZsb2F0MzJBcnJheSgyKmUpLG49MDtuPGU7bisrKXtmb3IodmFyIGQ9MCxjPTAsbT0wO208ZTttKyspe3ZhciBoPWV4cG9uZW50KG4qbSxlLHQpLHU9Z2V0Q29tcGxleFdpdGhJbmRleChwLG0pO2QrPXUucmVhbCpoLnJlYWwtdS5pbWFnKmguaW1hZyxjKz11LnJlYWwqaC5pbWFnK3UuaW1hZypoLnJlYWx9dCYmKGQvPWUsYy89ZSksYXNzaWduVG9UeXBlZEFycmF5KHIsZCxjLG4pfXJldHVybiByfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24oYixlLHQpe2Fzc2VydChcIk5IV0NcIj09PXQsXCJPbmx5IE5IV0MgZGF0YUZvcm1hdCBzdXBwb3J0ZWQgb24gQ1BVIGZvciBkZXB0aFRvU3BhY2UuIEdvdCBcIit0KSxhc3NlcnQoMTxlLFwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrZSk7Zm9yKHZhciByPWIuc2hhcGVbMF0sbj1iLnNoYXBlWzFdLG89Yi5zaGFwZVsyXSxhPWIuc2hhcGVbM10saT1uKmUscz1vKmUsdT1hLyhlKmUpLGw9Yi5kYXRhU3luYygpLGM9bmV3IEZsb2F0MzJBcnJheShyKmkqcyp1KSxwPTAsTj0wO048cjsrK04pZm9yKHZhciBJPTA7STxpOysrSSlmb3IodmFyIFM9X01hdGhmbG9vcihJL2UpLG09SSVlLGc9MDtnPHM7KytnKWZvcih2YXIgQz1fTWF0aGZsb29yKGcvZSkseT0obSplK2clZSkqdSx4PTAsazt4PHU7Kyt4KWs9eCt5K2EqKEMrbyooUytuKk4pKSxjW3ArK109bFtrXTtyZXR1cm4gdGVuc29yNGQoYyxbcixpLHMsdV0pfSx0LnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeU9wPWZ1bmN0aW9uKHksZSx0LGIpe3ZhciBuPWFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHkuc2hhcGUsZS5zaGFwZSkseD1idWZmZXIobix0KSxhPXkuZGF0YVN5bmMoKSxpPWUuZGF0YVN5bmMoKSxzPWdldEJyb2FkY2FzdERpbXMoeS5zaGFwZSxuKSx1PWdldEJyb2FkY2FzdERpbXMoZS5zaGFwZSxuKSxsPXgudmFsdWVzO2lmKDA9PT1zLmxlbmd0aCt1Lmxlbmd0aClmb3IodmFyIHI9MDtyPGwubGVuZ3RoOysrcilsW3JdPWIoYVtyJWEubGVuZ3RoXSxpW3IlaS5sZW5ndGhdKTtlbHNle3ZhciBjPXkuYnVmZmVyKCksZD1lLmJ1ZmZlcigpLG89ZnVuY3Rpb24odCl7dmFyIG49eC5pbmRleFRvTG9jKHQpLHI9bi5zbGljZSgteS5yYW5rKTtzLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHJbdF09MH0pO3ZhciBvPWMubG9jVG9JbmRleChyKSxwPW4uc2xpY2UoLWUucmFuayk7dS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBwW3RdPTB9KTt2YXIgbT1kLmxvY1RvSW5kZXgocCk7bFt0XT1iKGFbb10saVttXSl9O2ZvcihyPTA7cjxsLmxlbmd0aDsrK3IpbyhyKX1yZXR1cm4geC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcD1mdW5jdGlvbihiLGUsdCl7dmFyIHI9YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYi5zaGFwZSxlLnNoYXBlKSx4PWJ1ZmZlcihyLFwiZmxvYXQzMlwiKSxuPWJ1ZmZlcihyLFwiZmxvYXQzMlwiKSxvPWIuZGF0YVN5bmMoKSxpPWUuZGF0YVN5bmMoKSxzPWdldEJyb2FkY2FzdERpbXMoYi5zaGFwZSxyKSx1PWdldEJyb2FkY2FzdERpbXMoZS5zaGFwZSxyKSxsPXgudmFsdWVzLGM9bi52YWx1ZXM7aWYoMD09PXMubGVuZ3RoK3UubGVuZ3RoKWZvcih2YXIgYT0wO2E8bC5sZW5ndGg7YSsrKXt2YXIgcD1hJW8ubGVuZ3RoLGg9YSVpLmxlbmd0aCxmPXQob1syKnBdLG9bMipwKzFdLGlbMipoXSxpWzIqaCsxXSk7bFthXT1mLnJlYWwsY1thXT1mLmltYWd9ZWxzZXt2YXIgTj10aGlzLmRhdGEuZ2V0KGIuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmJ1ZmZlcigpLGc9dGhpcy5kYXRhLmdldChlLmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5idWZmZXIoKSxtPWZ1bmN0aW9uKHIpe3ZhciBuPXguaW5kZXhUb0xvYyhyKSxhPW4uc2xpY2UoLWIucmFuayk7cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBhW3RdPTB9KTt2YXIgcD1OLmxvY1RvSW5kZXgoYSksZD1uLnNsaWNlKC1lLnJhbmspO3UuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZFt0XT0wfSk7dmFyIGg9Zy5sb2NUb0luZGV4KGQpLG09dChvWzIqcF0sb1syKnArMV0saVsyKmhdLGlbMipoKzFdKTtsW3JdPW0ucmVhbCxjW3JdPW0uaW1hZ307Zm9yKGE9MDthPGwubGVuZ3RoO2ErKyltKGEpfXJldHVybiB0aGlzLmNvbXBsZXgoeC50b1RlbnNvcigpLG4udG9UZW5zb3IoKSl9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGEsZSx0KXtyZXR1cm4gc3BsaXQoYSxlLHQpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7fSx0LnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiAzMn0sdC5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbihZLGUsdCxyLG4sbyl7Zm9yKHZhciBhPVkuc2hhcGUsaT1hWzBdLHM9YVsxXSx1PWFbMl0sbD1hWzNdLGM9ZS5zaGFwZVswXSxwPXJbMF0sZD1yWzFdLGg9YnVmZmVyKFtjLHAsZCxsXSksZj1lLmRhdGFTeW5jKCksbT10LmRhdGFTeW5jKCksZz1ZLmRhdGFTeW5jKCksdj1ZLnN0cmlkZXMseT1oLnN0cmlkZXMseD0wO3g8Yzt4Kyspe3ZhciBaPTQqeCxFPWZbWl0sdz1mW1orMV0sUz1mW1orMl0sYj1mW1orM10sQz1tW3hdO2lmKCEoQz49aSkpZm9yKHZhciBfPTE8cD8oUy1FKSoocy0xKS8ocC0xKTowLEE9MTxkPyhiLXcpKih1LTEpLyhkLTEpOjAsTj0wLFE7TjxwO04rKylpZihRPTE8cD9FKihzLTEpK04qXzouNSooRStTKSoocy0xKSwwPlF8fFE+cy0xKWZvcih2YXIgSj0wO0o8ZDtKKyspZm9yKHZhciBlZT0wLHRlO2VlPGw7ZWUrKyl0ZT1lZStKKnlbMl0rTip5WzFdK3gqeVswXSxoLnZhbHVlc1t0ZV09bztlbHNlIGlmKFwiYmlsaW5lYXJcIj09PW4pe3ZhciBhZT1fTWF0aGZsb29yKFEpLE89X01hdGhjZWlsKFEpLFA9US1hZTtmb3IoSj0wO0o8ZDtKKyspaWYoMD4oVz0xPGQ/dyoodS0xKStKKkE6LjUqKHcrYikqKHUtMSkpfHxXPnUtMSlmb3IoZWU9MDtlZTxsO2VlKyspdGU9ZWUrSip5WzJdK04qeVsxXSt4KnlbMF0saC52YWx1ZXNbdGVdPW87ZWxzZXt2YXIgRj1fTWF0aGZsb29yKFcpLEw9X01hdGhjZWlsKFcpLEI9Vy1GO2ZvcihlZT0wO2VlPGw7ZWUrKyl7dmFyIFU9Z1t0ZT1lZStGKnZbMl0rYWUqdlsxXStDKnZbMF1dLHo9Z1t0ZT1lZStMKnZbMl0rYWUqdlsxXStDKnZbMF1dLFY9Z1t0ZT1lZStGKnZbMl0rTyp2WzFdK0MqdlswXV0sSD1VKyh6LVUpKkIsRz1WKyhnW3RlPWVlK0wqdlsyXStPKnZbMV0rQyp2WzBdXS1WKSpCO3RlPWVlK0oqeVsyXStOKnlbMV0reCp5WzBdLGgudmFsdWVzW3RlXT1IKyhHLUgpKlB9fX1lbHNlIGZvcihKPTA7SjxkOysrSil7dmFyIFc7aWYoMD4oVz0xPGQ/dyoodS0xKStKKkE6LjUqKHcrYikqKHUtMSkpfHxXPnUtMSlmb3IoZWU9MDtlZTxsO2VlKyspdGU9ZWUrSip5WzJdK04qeVsxXSt4KnlbMF0saC52YWx1ZXNbdGVdPW87ZWxzZXt2YXIgbmU9X01hdGhyb3VuZChXKSwkPV9NYXRocm91bmQoUSk7Zm9yKGVlPTA7ZWU8bDtlZSsrKXt2YXIgWD1lZStuZSp2WzJdKyQqdlsxXStDKnZbMF0sSz1lZStKKnlbMl0rTip5WzFdK3gqeVswXTtoLnZhbHVlc1tLXT1nW1hdfX19fXJldHVybiBoLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24ocCxlLHQscil7dmFyIG49Y2FsY3VsYXRlU2hhcGVzKGUscCx0KSxvPW4uc2xpY2VSYW5rLGE9bi5udW1VcGRhdGVzLGk9bi5zbGljZVNpemUscz1uLnN0cmlkZXMsZD1uLm91dHB1dFNpemU7cmV0dXJuIHRoaXMuc2NhdHRlcihwLGUsdCxkLGksYSxvLHMsciwhMSl9LHQucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKHksZSl7dmFyIHQ9ZS5zaGFwZSxyPXRbdC5sZW5ndGgtMV0sbj1wcmVwYXJlQW5kVmFsaWRhdGUoeSxlKSxvPW5bMF0sYT1uWzFdLGk9blsyXSxzPW5bM107aWYoMD09PWEpcmV0dXJuIHRlbnNvcihbXSxvLHkuZHR5cGUpO2Zvcih2YXIgdT1uZXcgVGVuc29yQnVmZmVyKFthLGldLHkuZHR5cGUpLGw9ZS5kYXRhU3luYygpLGM9eS5kYXRhU3luYygpLHA9MDtwPGE7cCsrKXtmb3IodmFyIGI9W10saD0wLHg9MCxOO3g8cjt4KyspTj1sW3Aqcit4XSxoKz1OKnNbeF0sYi5wdXNoKE4pO2lmKDA+aHx8aD49eS5zaXplL2kpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiAgZG9lcyBub3QgaW5kZXggaW50byBcIit5LnNoYXBlKTtmb3IodmFyIEk9MDtJPGk7SSsrKXUudmFsdWVzW3AqaStJXT1jW2gqaStJXX1yZXR1cm4gdS50b1RlbnNvcigpLnJlc2hhcGUobyl9LHQucHJvdG90eXBlLnNjYXR0ZXJORD1mdW5jdGlvbihwLGUsdCl7dmFyIHI9Y2FsY3VsYXRlU2hhcGVzKGUscCx0KSxuPXIuc2xpY2VSYW5rLG89ci5udW1VcGRhdGVzLGE9ci5zbGljZVNpemUsaT1yLnN0cmlkZXMscz1yLm91dHB1dFNpemUsZD1zY2FsYXIoMCk7cmV0dXJuIHRoaXMuc2NhdHRlcihwLGUsdCxzLGEsbyxuLGksZCwhMCl9LHQucHJvdG90eXBlLnNjYXR0ZXI9ZnVuY3Rpb24oYyxlLHQscixuLG8sYSxpLHMsdSl7dmFyIGw9Yy5kYXRhU3luYygpLHA9ZS5kYXRhU3luYygpO2lmKDA9PT1yKXJldHVybiB0ZW5zb3IoW10sdCxlLmR0eXBlKTt2YXIgZD1uZXcgVGVuc29yQnVmZmVyKFtyL24sbl0sZS5kdHlwZSk7ZC52YWx1ZXMuZmlsbChzLmRhdGFTeW5jKClbMF0pO2Zvcih2YXIgaD0wO2g8bztoKyspe2Zvcih2YXIgYj1bXSxtPTAsTj0wLEk7TjxhO04rKylJPWxbaCphK05dLGIucHVzaChJKSxtKz1JKmlbTl07aWYoMD5tfHxtPj1yL24pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiAgZG9lcyBub3QgaW5kZXggaW50byBcIit0KTtmb3IodmFyIFM9MDtTPG47UysrKXU/ZC52YWx1ZXNbbSpuK1NdKz1wW2gqbitTXTpkLnZhbHVlc1ttKm4rU109MD09PWUucmFuaz9wWzBdOnBbaCpuK1NdfXJldHVybiBkLnRvVGVuc29yKCkucmVzaGFwZSh0KX0sdH0oKTtFTlYucmVnaXN0ZXJCYWNrZW5kKFwiY3B1XCIsZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE1hdGhCYWNrZW5kQ1BVfSwxLHNldFRlbnNvclRyYWNrZXIpO3ZhciBkZWxheUNhbGxiYWNrPVwidW5kZWZpbmVkXCI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/c2V0SW1tZWRpYXRlOnJlcXVlc3RBbmltYXRpb25GcmFtZSxEVFlQRV9WQUxVRV9TSVpFX01BUD17ZmxvYXQzMjo0LGludDMyOjQsdWludDE2OjIsdWludDg6MSxib29sOjF9LHVzZU5vZGVCdWZmZXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlciYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBCbG9ifHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYXRvYnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGJ0b2EpLElPUm91dGVyUmVnaXN0cnk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dGhpcy5zYXZlUm91dGVycz1bXSx0aGlzLmxvYWRSb3V0ZXJzPVtdfXJldHVybiBhLmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWEuaW5zdGFuY2UmJihhLmluc3RhbmNlPW5ldyBhKSxhLmluc3RhbmNlfSxhLnJlZ2lzdGVyU2F2ZVJvdXRlcj1mdW5jdGlvbihlKXthLmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnMucHVzaChlKX0sYS5yZWdpc3RlckxvYWRSb3V0ZXI9ZnVuY3Rpb24oZSl7YS5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzLnB1c2goZSl9LGEuZ2V0U2F2ZUhhbmRsZXJzPWZ1bmN0aW9uKGUpe3JldHVybiBhLmdldEhhbmRsZXJzKGUsXCJzYXZlXCIpfSxhLmdldExvYWRIYW5kbGVycz1mdW5jdGlvbihlKXtyZXR1cm4gYS5nZXRIYW5kbGVycyhlLFwibG9hZFwiKX0sYS5nZXRIYW5kbGVycz1mdW5jdGlvbihhLGUpe3ZhciBvPVtdO3JldHVybihcImxvYWRcIj09PWU/dGhpcy5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzOnRoaXMuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lKGEpO251bGwhPT10JiZvLnB1c2godCl9KSxvfSxhfSgpLFVSTF9TQ0hFTUVfU1VGRklYPVwiOi8vXCIsTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt0aGlzLm1hbmFnZXJzPXt9fXJldHVybiBhLmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWEuaW5zdGFuY2UmJihhLmluc3RhbmNlPW5ldyBhKSxhLmluc3RhbmNlfSxhLnJlZ2lzdGVyTWFuYWdlcj1mdW5jdGlvbihlLG8pe2Fzc2VydChudWxsIT1lLFwic2NoZW1lIG11c3Qgbm90IGJlIHVuZGVmaW5lZCBvciBudWxsLlwiKSxlLmVuZHNXaXRoKFVSTF9TQ0hFTUVfU1VGRklYKSYmKGU9ZS5zbGljZSgwLGUuaW5kZXhPZihVUkxfU0NIRU1FX1NVRkZJWCkpKSxhc3NlcnQoMDxlLmxlbmd0aCxcInNjaGVtZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuXCIpO3ZhciByPWEuZ2V0SW5zdGFuY2UoKTthc3NlcnQobnVsbD09ci5tYW5hZ2Vyc1tlXSxcIkEgbW9kZWwgc3RvcmUgbWFuYWdlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIHNjaGVtZSAnXCIrZStcIicuXCIpLHIubWFuYWdlcnNbZV09b30sYS5nZXRNYW5hZ2VyPWZ1bmN0aW9uKGEpe3ZhciBlPXRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vyc1thXTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIG1hbmFnZXIgZm9yIHNjaGVtZSAnXCIrYStcIidcIik7cmV0dXJuIGV9LGEuZ2V0U2NoZW1lcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEluc3RhbmNlKCkubWFuYWdlcnMpfSxhfSgpLERBVEFCQVNFX05BTUU9XCJ0ZW5zb3JmbG93anNcIixEQVRBQkFTRV9WRVJTSU9OPTEsTU9ERUxfU1RPUkVfTkFNRT1cIm1vZGVsc19zdG9yZVwiLElORk9fU1RPUkVfTkFNRT1cIm1vZGVsX2luZm9fc3RvcmVcIixCcm93c2VySW5kZXhlZERCPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmluZGV4ZWREQj1nZXRJbmRleGVkREJGYWN0b3J5KCksbnVsbD09dHx8IXQpdGhyb3cgbmV3IEVycm9yKFwiRm9yIEluZGV4ZWREQiwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIik7dGhpcy5tb2RlbFBhdGg9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKCl7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtyZXR1cm5bMix0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoLHQpXX0pfSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCldfSl9KX0sdC5wcm90b3R5cGUuZGF0YWJhc2VBY3Rpb249ZnVuY3Rpb24oYSxtKXt2YXIgaD10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0LGUpe3ZhciBuPWguaW5kZXhlZERCLm9wZW4oREFUQUJBU0VfTkFNRSxEQVRBQkFTRV9WRVJTSU9OKTtuLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBzZXRVcERhdGFiYXNlKG4pfSxuLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciByPW4ucmVzdWx0O2lmKG51bGw9PW0pe3ZhciBhPXIudHJhbnNhY3Rpb24oTU9ERUxfU1RPUkVfTkFNRSxcInJlYWRvbmx5XCIpLG89YS5vYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FKS5nZXQoaC5tb2RlbFBhdGgpO28ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PW8ucmVzdWx0PyhyLmNsb3NlKCksZShuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiK2gubW9kZWxQYXRoK1wiJyBpbiBJbmRleGVkREIuXCIpKSk6dm9pZCB0KG8ucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzKX0sby5vbmVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIHIuY2xvc2UoKSxlKG8uZXJyb3IpfSxhLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gci5jbG9zZSgpfX1lbHNle3ZhciBzPWdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04obSksaT1yLnRyYW5zYWN0aW9uKElORk9fU1RPUkVfTkFNRSxcInJlYWR3cml0ZVwiKSxsPWkub2JqZWN0U3RvcmUoSU5GT19TVE9SRV9OQU1FKSxjPWwucHV0KHttb2RlbFBhdGg6aC5tb2RlbFBhdGgsbW9kZWxBcnRpZmFjdHNJbmZvOnN9KSxkO2Mub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGE9KGQ9ci50cmFuc2FjdGlvbihNT0RFTF9TVE9SRV9OQU1FLFwicmVhZHdyaXRlXCIpKS5vYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FKS5wdXQoe21vZGVsUGF0aDpoLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0czptLG1vZGVsQXJ0aWZhY3RzSW5mbzpzfSk7YS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdCh7bW9kZWxBcnRpZmFjdHNJbmZvOnN9KX0sYS5vbmVycm9yPWZ1bmN0aW9uKCl7dmFyIG49KGw9aS5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpKS5kZWxldGUoaC5tb2RlbFBhdGgpO24ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHIuY2xvc2UoKSxlKGEuZXJyb3IpfSxuLm9uZXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gci5jbG9zZSgpLGUoYS5lcnJvcil9fX0sYy5vbmVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIHIuY2xvc2UoKSxlKGMuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT1kP3IuY2xvc2UoKTpkLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gci5jbG9zZSgpfX19fSxuLm9uZXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gZShuLmVycm9yKX19KX0sdC5VUkxfU0NIRU1FPVwiaW5kZXhlZGRiOi8vXCIsdH0oKSxpbmRleGVkREJSb3V0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIEVOVi5nZXQoXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheSh0KSYmdC5zdGFydHNXaXRoKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRSk/YnJvd3NlckluZGV4ZWREQih0LnNsaWNlKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRS5sZW5ndGgpKTpudWxsfTtJT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyU2F2ZVJvdXRlcihpbmRleGVkREJSb3V0ZXIpLElPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJMb2FkUm91dGVyKGluZGV4ZWREQlJvdXRlcik7dmFyIEJyb3dzZXJJbmRleGVkREJNYW5hZ2VyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuaW5kZXhlZERCPWdldEluZGV4ZWREQkZhY3RvcnkoKX1yZXR1cm4gdC5wcm90b3R5cGUubGlzdE1vZGVscz1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbigpe3JldHVyblsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHMsdCl7dmFyIHI9YS5pbmRleGVkREIub3BlbihEQVRBQkFTRV9OQU1FLERBVEFCQVNFX1ZFUlNJT04pO3Iub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHNldFVwRGF0YWJhc2Uocil9LHIub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIG49ci5yZXN1bHQsZT1uLnRyYW5zYWN0aW9uKElORk9fU1RPUkVfTkFNRSxcInJlYWRvbmx5XCIpLGk9ZS5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpLmdldEFsbCgpO2kub25zdWNjZXNzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXt9LGU9MCxhPWkucmVzdWx0LG47ZTxhLmxlbmd0aDtlKyspbj1hW2VdLHRbbi5tb2RlbFBhdGhdPW4ubW9kZWxBcnRpZmFjdHNJbmZvO3ModCl9LGkub25lcnJvcj1mdW5jdGlvbigpe3JldHVybiBuLmNsb3NlKCksdChpLmVycm9yKX0sZS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4uY2xvc2UoKX19LHIub25lcnJvcj1mdW5jdGlvbigpe3JldHVybiB0KHIuZXJyb3IpfX0pXX0pfSl9LHQucHJvdG90eXBlLnJlbW92ZU1vZGVsPWZ1bmN0aW9uKHApe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbigpe3JldHVybiBwPW1heWJlU3RyaXBTY2hlbWUocCksWzIsbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgbj1lLmluZGV4ZWREQi5vcGVuKERBVEFCQVNFX05BTUUsREFUQUJBU0VfVkVSU0lPTik7bi5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gc2V0VXBEYXRhYmFzZShuKX0sbi5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZT1uLnJlc3VsdCxhPWUudHJhbnNhY3Rpb24oSU5GT19TVE9SRV9OQU1FLFwicmVhZHdyaXRlXCIpLGw9YS5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpLHM9bC5nZXQocCksaTtzLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2lmKG51bGw9PXMucmVzdWx0KXJldHVybiBlLmNsb3NlKCkscihuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiK3ArXCInIGluIEluZGV4ZWREQi5cIikpO3ZhciB0PWwuZGVsZXRlKHApLGE9ZnVuY3Rpb24oKXt2YXIgdD0oaT1lLnRyYW5zYWN0aW9uKE1PREVMX1NUT1JFX05BTUUsXCJyZWFkd3JpdGVcIikpLm9iamVjdFN0b3JlKE1PREVMX1NUT1JFX05BTUUpLmRlbGV0ZShwKTt0Lm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiB0KHMucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mbyl9LHQub25lcnJvcj1mdW5jdGlvbigpe3JldHVybiByKHMuZXJyb3IpfX07dC5vbnN1Y2Nlc3M9YSx0Lm9uZXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gYSgpLGUuY2xvc2UoKSxyKHMuZXJyb3IpfX0scy5vbmVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIGUuY2xvc2UoKSxyKHMuZXJyb3IpfSxhLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT1pP2UuY2xvc2UoKTppLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gZS5jbG9zZSgpfX19LG4ub25lcnJvcj1mdW5jdGlvbigpe3JldHVybiByKG4uZXJyb3IpfX0pXX0pfSl9LHR9KCk7aWYoRU5WLmdldChcIklTX0JST1dTRVJcIikpdHJ5e01vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkucmVnaXN0ZXJNYW5hZ2VyKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRSxuZXcgQnJvd3NlckluZGV4ZWREQk1hbmFnZXIpfWNhdGNoKHQpe312YXIgUEFUSF9TRVBBUkFUT1I9XCIvXCIsUEFUSF9QUkVGSVg9XCJ0ZW5zb3JmbG93anNfbW9kZWxzXCIsSU5GT19TVUZGSVg9XCJpbmZvXCIsTU9ERUxfVE9QT0xPR1lfU1VGRklYPVwibW9kZWxfdG9wb2xvZ3lcIixXRUlHSFRfU1BFQ1NfU1VGRklYPVwid2VpZ2h0X3NwZWNzXCIsV0VJR0hUX0RBVEFfU1VGRklYPVwid2VpZ2h0X2RhdGFcIixCcm93c2VyTG9jYWxTdG9yYWdlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZighRU5WLmdldChcIklTX0JST1dTRVJcIil8fHZvaWQgMD09PXdpbmRvdy5sb2NhbFN0b3JhZ2UpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBsb2NhbCBzdG9yYWdlLlwiKTtpZih0aGlzLkxTPXdpbmRvdy5sb2NhbFN0b3JhZ2UsbnVsbD09dHx8IXQpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGxvY2FsIHN0b3JhZ2UsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPXQsdGhpcy5rZXlzPWdldE1vZGVsS2V5cyh0aGlzLm1vZGVsUGF0aCl9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxzLGkscDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbigpe2lmKGEubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7ZT1KU09OLnN0cmluZ2lmeShhLm1vZGVsVG9wb2xvZ3kpLHM9SlNPTi5zdHJpbmdpZnkoYS53ZWlnaHRTcGVjcyksaT1nZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKGEpO3RyeXtyZXR1cm4gdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy5pbmZvLEpTT04uc3RyaW5naWZ5KGkpKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5LGUpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MscyksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhLGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcoYS53ZWlnaHREYXRhKSksWzIse21vZGVsQXJ0aWZhY3RzSW5mbzppfV19Y2F0Y2godCl7Zm9yKHAgaW4gdGhpcy5rZXlzKXRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXNbcF0pO3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzYXZlIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgdG8gbG9jYWwgc3RvcmFnZTogc2l6ZSBxdW90YSBiZWluZyBleGNlZWRlZCBpcyBhIHBvc3NpYmxlIGNhdXNlIG9mIHRoaXMgZmFpbHVyZTogbW9kZWxUb3BvbG9neUJ5dGVzPVwiK2kubW9kZWxUb3BvbG9neUJ5dGVzK1wiLCB3ZWlnaHRTcGVjc0J5dGVzPVwiK2kud2VpZ2h0U3BlY3NCeXRlcytcIiwgd2VpZ2h0RGF0YUJ5dGVzPVwiK2kud2VpZ2h0RGF0YUJ5dGVzK1wiLlwiKX1yZXR1cm5bMl19KX0pfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYSxzLGkscCxsO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbD09KGE9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLmluZm8pKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlcmUgaXMgbm8gbW9kZWwgd2l0aCBuYW1lICdcIit0aGlzLm1vZGVsUGF0aCtcIidcIik7aWYoXCJKU09OXCIhPT1hLm1vZGVsVG9wb2xvZ3lUeXBlKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2UgZG9lcyBub3Qgc3VwcG9ydCBsb2FkaW5nIG5vbi1KU09OIG1vZGVsIHRvcG9sb2d5IHlldC5cIik7aWYocz17fSxudWxsPT0oaT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHRvcG9sb2d5IG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgaXMgbWlzc2luZy5cIik7aWYocy5tb2RlbFRvcG9sb2d5PWksbnVsbD09KHA9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzKSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB3ZWlnaHQgc3BlY3Mgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBhcmUgbWlzc2luZy5cIik7aWYocy53ZWlnaHRTcGVjcz1wLG51bGw9PShsPXRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSBiaW5hcnkgd2VpZ2h0IHZhbHVlcyBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGFyZSBtaXNzaW5nLlwiKTtyZXR1cm4gcy53ZWlnaHREYXRhPWJhc2U2NFN0cmluZ1RvQXJyYXlCdWZmZXIobCksWzIsc119KX0pfSx0LlVSTF9TQ0hFTUU9XCJsb2NhbHN0b3JhZ2U6Ly9cIix0fSgpLGxvY2FsU3RvcmFnZVJvdXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gRU5WLmdldChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FKT9icm93c2VyTG9jYWxTdG9yYWdlKHQuc2xpY2UoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FLmxlbmd0aCkpOm51bGx9O0lPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGxvY2FsU3RvcmFnZVJvdXRlciksSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIobG9jYWxTdG9yYWdlUm91dGVyKTt2YXIgQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7YXNzZXJ0KEVOVi5nZXQoXCJJU19CUk9XU0VSXCIpLFwiQ3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSB3ZWIgYnJvd3NlclwiKSxhc3NlcnQodm9pZCAwIT09d2luZG93LmxvY2FsU3RvcmFnZSxcIkN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBsb2NhbFN0b3JhZ2VcIiksdGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlfXJldHVybiB0LnByb3RvdHlwZS5saXN0TW9kZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcyxpLHAsbCxkLHU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oKXtmb3Iocz17fSxpPVwidGVuc29yZmxvd2pzX21vZGVscy9cIixwPVwiL2luZm9cIixsPTA7bDx0aGlzLkxTLmxlbmd0aDsrK2wpKGQ9dGhpcy5MUy5rZXkobCkpLnN0YXJ0c1dpdGgoaSkmJmQuZW5kc1dpdGgocCkmJih1PWdldE1vZGVsUGF0aEZyb21LZXkoZCksc1t1XT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShkKSkpO3JldHVyblsyLHNdfSl9KX0sdC5wcm90b3R5cGUucmVtb3ZlTW9kZWw9ZnVuY3Rpb24oYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKCl7aWYoYT1tYXliZVN0cmlwU2NoZW1lJDEoYSksZT1nZXRNb2RlbEtleXMoYSksbnVsbD09dGhpcy5MUy5nZXRJdGVtKGUuaW5mbykpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgYXQgcGF0aCAnXCIrYStcIidcIik7cmV0dXJuIG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0oZS5pbmZvKSksdGhpcy5MUy5yZW1vdmVJdGVtKGUuaW5mbyksdGhpcy5MUy5yZW1vdmVJdGVtKGUudG9wb2xvZ3kpLHRoaXMuTFMucmVtb3ZlSXRlbShlLndlaWdodFNwZWNzKSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS53ZWlnaHREYXRhKSxbMixuXX0pfSl9LHR9KCk7aWYoRU5WLmdldChcIklTX0JST1dTRVJcIikpdHJ5e01vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkucmVnaXN0ZXJNYW5hZ2VyKEJyb3dzZXJMb2NhbFN0b3JhZ2UuVVJMX1NDSEVNRSxuZXcgQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXIpfWNhdGNoKHQpe312YXIgREVGQVVMVF9GSUxFX05BTUVfUFJFRklYPVwibW9kZWxcIixERUZBVUxUX0pTT05fRVhURU5TSU9OX05BTUU9XCIuanNvblwiLERFRkFVTFRfV0VJR0hUX0RBVEFfRVhURU5TSU9OX05BTUU9XCIud2VpZ2h0cy5iaW5cIixCcm93c2VyRG93bmxvYWRzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShlKXtpZighRU5WLmdldChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwidHJpZ2dlckRvd25sb2FkcygpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgYnJvd3Nlci5cIik7ZS5zdGFydHNXaXRoKGEuVVJMX1NDSEVNRSkmJihlPWUuc2xpY2UoYS5VUkxfU0NIRU1FLmxlbmd0aCkpLG51bGwhPWUmJjAhPT1lLmxlbmd0aHx8KGU9XCJtb2RlbFwiKSx0aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZT1lK1wiLmpzb25cIix0aGlzLndlaWdodERhdGFGaWxlTmFtZT1lK1wiLndlaWdodHMuYmluXCJ9cmV0dXJuIGEucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24ocyl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxwLGwsZCx1LGM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oKXtpZihlPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtzLndlaWdodERhdGFdLHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSkscy5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiRG93bmxvYWRUcmlnZ2VyLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVybiBwPVt7cGF0aHM6W1wiLi9cIit0aGlzLndlaWdodERhdGFGaWxlTmFtZV0sd2VpZ2h0czpzLndlaWdodFNwZWNzfV0sbD17bW9kZWxUb3BvbG9neTpzLm1vZGVsVG9wb2xvZ3ksd2VpZ2h0c01hbmlmZXN0OnB9LGQ9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGwpXSx7dHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIn0pKSwodT1udWxsPT10aGlzLmpzb25BbmNob3I/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik6dGhpcy5qc29uQW5jaG9yKS5kb3dubG9hZD10aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZSx1LmhyZWY9ZCx1LmNsaWNrKCksbnVsbCE9cy53ZWlnaHREYXRhJiYoKGM9bnVsbD09dGhpcy53ZWlnaHREYXRhQW5jaG9yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMud2VpZ2h0RGF0YUFuY2hvcikuZG93bmxvYWQ9dGhpcy53ZWlnaHREYXRhRmlsZU5hbWUsYy5ocmVmPWUsYy5jbGljaygpKSxbMix7bW9kZWxBcnRpZmFjdHNJbmZvOmdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04ocyl9XX0pfSl9LGEuVVJMX1NDSEVNRT1cImRvd25sb2FkczovL1wiLGF9KCksQnJvd3NlckZpbGVzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZihudWxsPT10fHwxPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBicm93c2VyRmlsZXMsIGF0IGxlYXN0IDEgZmlsZSBpcyByZXF1aXJlZCwgYnV0IHJlY2VpdmVkIFwiK3QpO3RoaXMuZmlsZXM9dH1yZXR1cm4gdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxyLG07cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gcj10aGlzLmZpbGVzWzBdLG09dGhpcy5maWxlcy5zbGljZSgxKSxbMixuZXcgUHJvbWlzZShmdW5jdGlvbihoLHQpe3ZhciBlPW5ldyBGaWxlUmVhZGVyO2Uub25sb2FkPWZ1bmN0aW9uKGUpe3ZhciBuPUpTT04ucGFyc2UoZS50YXJnZXQucmVzdWx0KSxpPW4ubW9kZWxUb3BvbG9neTtpZihudWxsIT1pKXswPT09bS5sZW5ndGgmJmgoe21vZGVsVG9wb2xvZ3k6aX0pO3ZhciBvPW4ud2VpZ2h0c01hbmlmZXN0O2lmKG51bGwhPW8pe3ZhciBzO3RyeXtzPWEuY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzKG8sbSl9Y2F0Y2goYSl7cmV0dXJuIHZvaWQgdChhKX12YXIgdT1bXSxjPVtdLHA9W107by5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXtjLnB1c2godCkscC5wdXNoKG51bGwpfSksdS5wdXNoLmFwcGx5KHUsdC53ZWlnaHRzKX0pLG8uZm9yRWFjaChmdW5jdGlvbihhKXthLnBhdGhzLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGU9bmV3IEZpbGVSZWFkZXI7ZS5vbmxvYWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQucmVzdWx0LG49Yy5pbmRleE9mKGEpO3Bbbl09dCwtMT09PXAuaW5kZXhPZihudWxsKSYmaCh7bW9kZWxUb3BvbG9neTppLHdlaWdodFNwZWNzOnUsd2VpZ2h0RGF0YTpjb25jYXRlbmF0ZUFycmF5QnVmZmVycyhwKX0pfSxlLm9uZXJyb3I9ZnVuY3Rpb24oKXt0KFwiRmFpbGVkIHRvIHdlaWdodHMgZGF0YSBmcm9tIGZpbGUgb2YgcGF0aCAnXCIrYStcIicuXCIpfSxlLnJlYWRBc0FycmF5QnVmZmVyKHNbYV0pfSl9KX1lbHNlIHQobmV3IEVycm9yKFwid2VpZ2h0TWFuaWZlc3QgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrci5uYW1lKSl9ZWxzZSB0KG5ldyBFcnJvcihcIm1vZGVsVG9wb2xvZ3kgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrci5uYW1lKSl9LGUub25lcnJvcj1mdW5jdGlvbigpe3QoXCJGYWlsZWQgdG8gcmVhZCBtb2RlbCB0b3BvbG9neSBhbmQgd2VpZ2h0cyBtYW5pZmVzdCBKU09OIGZyb20gZmlsZSAnXCIrci5uYW1lK1wiJy4gQnJvd3NlckZpbGVzIHN1cHBvcnRzIGxvYWRpbmcgS2VyYXMtc3R5bGUgdGYuTW9kZWwgYXJ0aWZhY3RzIG9ubHkuXCIpfSxlLnJlYWRBc1RleHQocil9KV19KX0pfSx0LnByb3RvdHlwZS5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXM9ZnVuY3Rpb24ocyxwKXtmb3IodmFyIHQ9W10scj1wLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gYmFzZW5hbWUodC5uYW1lKX0pLG49e30sZT0wLG89cztlPG8ubGVuZ3RoO2UrKylvW2VdLnBhdGhzLmZvckVhY2goZnVuY3Rpb24obyl7dmFyIGU9YmFzZW5hbWUobyk7aWYoLTEhPT10LmluZGV4T2YoZSkpdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGZpbGUgYmFzZW5hbWUgZm91bmQgaW4gd2VpZ2h0cyBtYW5pZmVzdDogJ1wiK2UrXCInXCIpO2lmKHQucHVzaChlKSwtMT09PXIuaW5kZXhPZihlKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgZmlsZSB3aXRoIGJhc2VuYW1lICdcIitlK1wiJyBpcyBub3QgcHJvdmlkZWQuXCIpO25bb109cFtyLmluZGV4T2YoZSldfSk7aWYodC5sZW5ndGghPT1wLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGZpbGVzIGluIHdlaWdodHMgbWFuaWZlc3QgKFwiK3QubGVuZ3RoK1wiKSBhbmQgdGhlIG51bWJlciBvZiB3ZWlnaHQgZmlsZXMgcHJvdmlkZWQgKFwiK3AubGVuZ3RoK1wiKS5cIik7cmV0dXJuIG59LHR9KCksYnJvd3NlckRvd25sb2Fkc1JvdXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gRU5WLmdldChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoQnJvd3NlckRvd25sb2Fkcy5VUkxfU0NIRU1FKT9icm93c2VyRG93bmxvYWRzKHQuc2xpY2UoQnJvd3NlckRvd25sb2Fkcy5VUkxfU0NIRU1FLmxlbmd0aCkpOm51bGx9O0lPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGJyb3dzZXJEb3dubG9hZHNSb3V0ZXIpO3ZhciBCcm93c2VySFRUUFJlcXVlc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEsZSx0KXtpZih0aGlzLndlaWdodFBhdGhQcmVmaXg9dCx0aGlzLkRFRkFVTFRfTUVUSE9EPVwiUE9TVFwiLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl0aHJvdyBuZXcgRXJyb3IoXCJicm93c2VySFRUUFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCBvdXRzaWRlIHRoZSB3ZWIgYnJvd3NlciB3aXRob3V0IGEgZmV0Y2ggcG9seWZpbGwuXCIpO2lmKGFzc2VydChudWxsIT1hJiYwPGEubGVuZ3RoLFwiVVJMIHBhdGggZm9yIGJyb3dzZXJIVFRQUmVxdWVzdCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpLEFycmF5LmlzQXJyYXkoYSkmJmFzc2VydCgyPT09YS5sZW5ndGgsXCJVUkwgcGF0aHMgZm9yIGJyb3dzZXJIVFRQUmVxdWVzdCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMiwgKGFjdHVhbCBsZW5ndGggaXMgXCIrYS5sZW5ndGgrXCIpLlwiKSx0aGlzLnBhdGg9YSxudWxsIT1lJiZudWxsIT1lLmJvZHkpdGhyb3cgbmV3IEVycm9yKFwicmVxdWVzdEluaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBubyBwcmUtZXhpc3RpbmcgYm9keSwgYnV0IGhhcyBvbmUuXCIpO3RoaXMucmVxdWVzdEluaXQ9ZXx8e319cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24ocyl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxpLHAsbDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmlmKHMubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtyZXR1cm4oZT1PYmplY3QuYXNzaWduKHttZXRob2Q6dGhpcy5ERUZBVUxUX01FVEhPRH0sdGhpcy5yZXF1ZXN0SW5pdCkpLmJvZHk9bmV3IEZvcm1EYXRhLGk9W3twYXRoczpbXCIuL21vZGVsLndlaWdodHMuYmluXCJdLHdlaWdodHM6cy53ZWlnaHRTcGVjc31dLHA9e21vZGVsVG9wb2xvZ3k6cy5tb2RlbFRvcG9sb2d5LHdlaWdodHNNYW5pZmVzdDppfSxlLmJvZHkuYXBwZW5kKFwibW9kZWwuanNvblwiLG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShwKV0se3R5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSxcIm1vZGVsLmpzb25cIiksbnVsbCE9cy53ZWlnaHREYXRhJiZlLmJvZHkuYXBwZW5kKFwibW9kZWwud2VpZ2h0cy5iaW5cIixuZXcgQmxvYihbcy53ZWlnaHREYXRhXSx7dHlwZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSksXCJtb2RlbC53ZWlnaHRzLmJpblwiKSxbNCxmZXRjaCh0aGlzLnBhdGgsZSldO2Nhc2UgMTppZigobD10LnNlbnQoKSkub2spcmV0dXJuWzIse21vZGVsQXJ0aWZhY3RzSW5mbzpnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKHMpLHJlc3BvbnNlczpbbF19XTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGZhaWxlZCBkdWUgdG8gSFRUUCByZXNwb25zZSBzdGF0dXMgXCIrbC5zdGF0dXMrXCIuXCIpO319KX0pfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbigpe3JldHVyblsyLEFycmF5LmlzQXJyYXkodGhpcy5wYXRoKT90aGlzLmxvYWRCaW5hcnlNb2RlbCgpOnRoaXMubG9hZEpTT05Nb2RlbCgpXX0pfSl9LHQucHJvdG90eXBlLmxvYWRCaW5hcnlUb3BvbG9neT1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGEsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiBlLnRyeXMucHVzaChbMCwzLCw0XSksWzQsZmV0Y2godGhpcy5wYXRoWzBdLHRoaXMucmVxdWVzdEluaXQpXTtjYXNlIDE6aWYoIShhPWUuc2VudCgpKS5vayl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3QubG9hZCgpIGZhaWxlZCBkdWUgdG8gSFRUUCByZXNwb25zZTogXCIrYS5zdGF0dXNUZXh0KTtyZXR1cm5bNCxhLmFycmF5QnVmZmVyKCldO2Nhc2UgMjpyZXR1cm5bMixlLnNlbnQoKV07Y2FzZSAzOnRocm93IG49ZS5zZW50KCksbmV3IEVycm9yKHRoaXMucGF0aFswXStcIiBub3QgZm91bmQuIFwiK24pO2Nhc2UgNDpyZXR1cm5bMl07fX0pfSl9LHQucHJvdG90eXBlLmxvYWRCaW5hcnlNb2RlbD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHAsbCxkLGMsbSxoLGcsZjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiBwPXRoaXMubG9hZEJpbmFyeVRvcG9sb2d5KCksWzQsZmV0Y2godGhpcy5wYXRoWzFdLHRoaXMucmVxdWVzdEluaXQpXTtjYXNlIDE6aWYoIShsPWUuc2VudCgpKS5vayl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3QubG9hZCgpIGZhaWxlZCBkdWUgdG8gSFRUUCByZXNwb25zZTogXCIrbC5zdGF0dXNUZXh0KTtyZXR1cm5bNCxQcm9taXNlLmFsbChbcCxsXSldO2Nhc2UgMjpyZXR1cm4gZD1lLnNlbnQoKSxjPWRbMF0sWzQsZFsxXS5qc29uKCldO2Nhc2UgMzpyZXR1cm4gbnVsbD09KG09ZS5zZW50KCkpP1szLDVdOls0LHRoaXMubG9hZFdlaWdodHMobSldO2Nhc2UgNDpmPWUuc2VudCgpLGg9ZlswXSxnPWZbMV0sZS5sYWJlbD01O2Nhc2UgNTpyZXR1cm5bMix7bW9kZWxUb3BvbG9neTpjLHdlaWdodFNwZWNzOmgsd2VpZ2h0RGF0YTpnfV07fX0pfSl9LHQucHJvdG90eXBlLmxvYWRKU09OTW9kZWw9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBwLGwsZCxjLG0saCxnLGY7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxmZXRjaCh0aGlzLnBhdGgsdGhpcy5yZXF1ZXN0SW5pdCldO2Nhc2UgMTppZighKHA9ZS5zZW50KCkpLm9rKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJIVFRQUmVxdWVzdC5sb2FkKCkgZmFpbGVkIGR1ZSB0byBIVFRQIHJlc3BvbnNlOiBcIitwLnN0YXR1c1RleHQpO3JldHVybls0LHAuanNvbigpXTtjYXNlIDI6aWYobD1lLnNlbnQoKSxkPWwubW9kZWxUb3BvbG9neSxjPWwud2VpZ2h0c01hbmlmZXN0LG51bGw9PWQmJm51bGw9PWMpdGhyb3cgbmV3IEVycm9yKFwiVGhlIEpTT04gZnJvbSBIVFRQIHBhdGggXCIrdGhpcy5wYXRoK1wiIGNvbnRhaW5zIG5laXRoZXIgbW9kZWwgdG9wb2xvZ3kgb3IgbWFuaWZlc3QgZm9yIHdlaWdodHMuXCIpO3JldHVybiBudWxsPT1jP1szLDRdOihnPWwud2VpZ2h0c01hbmlmZXN0LFs0LHRoaXMubG9hZFdlaWdodHMoZyldKTtjYXNlIDM6Zj1lLnNlbnQoKSxtPWZbMF0saD1mWzFdLGUubGFiZWw9NDtjYXNlIDQ6cmV0dXJuWzIse21vZGVsVG9wb2xvZ3k6ZCx3ZWlnaHRTcGVjczptLHdlaWdodERhdGE6aH1dO319KX0pfSx0LnByb3RvdHlwZS5sb2FkV2VpZ2h0cz1mdW5jdGlvbihtKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLGgsZyxmLHksYix4LE4sSSx2LFMsQztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmZvcihlPUFycmF5LmlzQXJyYXkodGhpcy5wYXRoKT90aGlzLnBhdGhbMV06dGhpcy5wYXRoLGg9cGFyc2VVcmwoZSksZz1oWzBdLGY9aFsxXSx5PXRoaXMud2VpZ2h0UGF0aFByZWZpeHx8ZyxiPVtdLHg9MCxOPW07eDxOLmxlbmd0aDt4KyspST1OW3hdLGIucHVzaC5hcHBseShiLEkud2VpZ2h0cyk7cmV0dXJuIHY9W10sbS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXt2LnB1c2goeSt0K2YpfSl9KSxTPVtiXSxDPWNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzLFs0LGxvYWRXZWlnaHRzQXNBcnJheUJ1ZmZlcih2LHRoaXMucmVxdWVzdEluaXQpXTtjYXNlIDE6cmV0dXJuWzIsUy5jb25jYXQoW0MuYXBwbHkodm9pZCAwLFt0LnNlbnQoKV0pXSldO319KX0pfSx0LlVSTF9TQ0hFTUVfUkVHRVg9L15odHRwcz86XFwvXFwvLyx0fSgpLGh0dHBSZXF1ZXN0Um91dGVyPWZ1bmN0aW9uKHQpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaD9udWxsOihBcnJheS5pc0FycmF5KHQpP3QuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIGlzSFRUUFNjaGVtZSh0KX0pOmlzSFRUUFNjaGVtZSh0KSk/YnJvd3NlckhUVFBSZXF1ZXN0KHQpOm51bGx9O0lPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGh0dHBSZXF1ZXN0Um91dGVyKSxJT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyTG9hZFJvdXRlcihodHRwUmVxdWVzdFJvdXRlcik7dmFyIFBhc3N0aHJvdWdoTG9hZGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChhLGUsdCl7dGhpcy5tb2RlbFRvcG9sb2d5PWEsdGhpcy53ZWlnaHRTcGVjcz1lLHRoaXMud2VpZ2h0RGF0YT10fXJldHVybiB0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbigpe3JldHVybiB0PXt9LG51bGwhPXRoaXMubW9kZWxUb3BvbG9neSYmKHQ9X19hc3NpZ24oe21vZGVsVG9wb2xvZ3k6dGhpcy5tb2RlbFRvcG9sb2d5fSx0KSksbnVsbCE9dGhpcy53ZWlnaHRTcGVjcyYmMDx0aGlzLndlaWdodFNwZWNzLmxlbmd0aCYmKHQ9X19hc3NpZ24oe3dlaWdodFNwZWNzOnRoaXMud2VpZ2h0U3BlY3N9LHQpKSxudWxsIT10aGlzLndlaWdodERhdGEmJjA8dGhpcy53ZWlnaHREYXRhLmJ5dGVMZW5ndGgmJih0PV9fYXNzaWduKHt3ZWlnaHREYXRhOnRoaXMud2VpZ2h0RGF0YX0sdCkpLFsyLHRdfSl9KX0sdH0oKSxQYXNzdGhyb3VnaFNhdmVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnNhdmVIYW5kbGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbigpe3JldHVyblsyLHRoaXMuc2F2ZUhhbmRsZXIodCldfSl9KX0sdH0oKSxyZWdpc3RlclNhdmVSb3V0ZXI9SU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlclNhdmVSb3V0ZXIscmVnaXN0ZXJMb2FkUm91dGVyPUlPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJMb2FkUm91dGVyLGdldFNhdmVIYW5kbGVycz1JT1JvdXRlclJlZ2lzdHJ5LmdldFNhdmVIYW5kbGVycyxnZXRMb2FkSGFuZGxlcnM9SU9Sb3V0ZXJSZWdpc3RyeS5nZXRMb2FkSGFuZGxlcnMsaW89T2JqZWN0LmZyZWV6ZSh7YnJvd3NlckZpbGVzOmJyb3dzZXJGaWxlcyxicm93c2VySFRUUFJlcXVlc3Q6YnJvd3NlckhUVFBSZXF1ZXN0LGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzOmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzLGRlY29kZVdlaWdodHM6ZGVjb2RlV2VpZ2h0cyxlbmNvZGVXZWlnaHRzOmVuY29kZVdlaWdodHMsZnJvbU1lbW9yeTpmcm9tTWVtb3J5LGdldExvYWRIYW5kbGVyczpnZXRMb2FkSGFuZGxlcnMsZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTjpnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OLGdldFNhdmVIYW5kbGVyczpnZXRTYXZlSGFuZGxlcnMsbG9hZFdlaWdodHM6bG9hZFdlaWdodHMscmVnaXN0ZXJMb2FkUm91dGVyOnJlZ2lzdGVyTG9hZFJvdXRlcixyZWdpc3RlclNhdmVSb3V0ZXI6cmVnaXN0ZXJTYXZlUm91dGVyLHdpdGhTYXZlSGFuZGxlcjp3aXRoU2F2ZUhhbmRsZXIsY29weU1vZGVsOmNvcHlNb2RlbCxsaXN0TW9kZWxzOmxpc3RNb2RlbHMsbW92ZU1vZGVsOm1vdmVNb2RlbCxyZW1vdmVNb2RlbDpyZW1vdmVNb2RlbH0pLGNvbmZ1c2lvbk1hdHJpeD1vcCh7Y29uZnVzaW9uTWF0cml4Xzpjb25mdXNpb25NYXRyaXhffSksbWF0aD1PYmplY3QuZnJlZXplKHtjb25mdXNpb25NYXRyaXg6Y29uZnVzaW9uTWF0cml4fSksU2VyaWFsaXphYmxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lfSx0LmZyb21Db25maWc9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gbmV3IGEoZSl9LHR9KCksU2VyaWFsaXphdGlvbk1hcD1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt0aGlzLmNsYXNzTmFtZU1hcD17fX1yZXR1cm4gYS5nZXRNYXA9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09YS5pbnN0YW5jZSYmKGEuaW5zdGFuY2U9bmV3IGEpLGEuaW5zdGFuY2V9LGEucmVnaXN0ZXI9ZnVuY3Rpb24oZSl7YS5nZXRNYXAoKS5jbGFzc05hbWVNYXBbZS5jbGFzc05hbWVdPVtlLGUuZnJvbUNvbmZpZ119LGF9KCksc2VyaWFsaXphdGlvbj1PYmplY3QuZnJlZXplKHtTZXJpYWxpemFibGU6U2VyaWFsaXphYmxlLFNlcmlhbGl6YXRpb25NYXA6U2VyaWFsaXphdGlvbk1hcCxyZWdpc3RlckNsYXNzOnJlZ2lzdGVyQ2xhc3N9KSxXRUJHTF9FTlZTPXtIQVNfV0VCR0w6ITB9LE5PREVfRU5WUz17SVNfTk9ERTohMH0sQ0hST01FX0VOVlM9e0lTX0NIUk9NRTohMH0sQlJPV1NFUl9FTlZTPXtJU19CUk9XU0VSOiEwfSxDUFVfRU5WUz17SEFTX1dFQkdMOiExfSxCUk9XU0VSX0NQVV9FTlZTPXtCQUNLRU5EOlwidGVzdC1jcHVcIn0sQUxMX0VOVlM9e30sdGVzdF91dGlsPU9iamVjdC5mcmVlemUoe1dFQkdMX0VOVlM6V0VCR0xfRU5WUyxOT0RFX0VOVlM6Tk9ERV9FTlZTLENIUk9NRV9FTlZTOkNIUk9NRV9FTlZTLEJST1dTRVJfRU5WUzpCUk9XU0VSX0VOVlMsQ1BVX0VOVlM6Q1BVX0VOVlMsQlJPV1NFUl9DUFVfRU5WUzpCUk9XU0VSX0NQVV9FTlZTLEFMTF9FTlZTOkFMTF9FTlZTLGV4cGVjdEFycmF5c0Nsb3NlOmV4cGVjdEFycmF5c0Nsb3NlLGV4cGVjdFByb21pc2VUb0ZhaWw6ZXhwZWN0UHJvbWlzZVRvRmFpbCxleHBlY3RBcnJheXNFcXVhbDpleHBlY3RBcnJheXNFcXVhbCxleHBlY3ROdW1iZXJzQ2xvc2U6ZXhwZWN0TnVtYmVyc0Nsb3NlLGV4cGVjdFZhbHVlc0luUmFuZ2U6ZXhwZWN0VmFsdWVzSW5SYW5nZSxleHBlY3RBcnJheUJ1ZmZlcnNFcXVhbDpleHBlY3RBcnJheUJ1ZmZlcnNFcXVhbH0pLHdlYmdsPU9iamVjdC5mcmVlemUoe2dwZ3B1X3V0aWw6Z3BncHVfdXRpbCx3ZWJnbF91dGlsOndlYmdsX3V0aWwsTWF0aEJhY2tlbmRXZWJHTDpNYXRoQmFja2VuZFdlYkdMLEdQR1BVQ29udGV4dDpHUEdQVUNvbnRleHR9KSxPcHRpbWl6ZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09YSYmYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyhlLGEpLGUucHJvdG90eXBlLm1pbmltaXplPWZ1bmN0aW9uKHMsZSxpKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHI9dGhpcy5jb21wdXRlR3JhZGllbnRzKHMsaSksbj1yLnZhbHVlLG89ci5ncmFkcztyZXR1cm4gdGhpcy5hcHBseUdyYWRpZW50cyhvKSxPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBvW3RdLmRpc3Bvc2UoKX0pLGU/bjoobi5kaXNwb3NlKCksbnVsbCl9LGUucHJvdG90eXBlLmNvbXB1dGVHcmFkaWVudHM9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdmFyaWFibGVHcmFkcyhhLGUpfSxlfShTZXJpYWxpemFibGUpLEFkYWRlbHRhT3B0aW1pemVyPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSx0LHIpe3ZvaWQgMD09PXImJihyPW51bGwpO3ZhciBzPWEuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gcy5sZWFybmluZ1JhdGU9ZSxzLnJobz10LHMuZXBzaWxvbj1yLHMuYWNjdW11bGF0ZWRHcmFkcz17fSxzLmFjY3VtdWxhdGVkVXBkYXRlcz17fSxzLmM9a2VlcChzY2FsYXIoLWUpKSxzLnJob1NjYWxhcj1rZWVwKHNjYWxhcih0KSkscy5vbmVNaW51c1Jobz1rZWVwKHNjYWxhcigxLXQpKSxudWxsPT09ciYmKHI9RU5WLmdldChcIkVQU0lMT05cIikpLHMuZXBzaWxvblNjYWxhcj1rZWVwKHNjYWxhcihyKSksc31yZXR1cm4gX19leHRlbmRzKGUsYSksZS5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24ocCl7dmFyIGQ9dGhpcyxlPWZ1bmN0aW9uKGMpe3ZhciByPUVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1tjXTtudWxsPT10LmFjY3VtdWxhdGVkR3JhZHNbY10mJnRpZHkoZnVuY3Rpb24oKXtkLmFjY3VtdWxhdGVkR3JhZHNbY109emVyb3NMaWtlKHIpLnZhcmlhYmxlKCExKX0pLG51bGw9PXQuYWNjdW11bGF0ZWRVcGRhdGVzW2NdJiZ0aWR5KGZ1bmN0aW9uKCl7ZC5hY2N1bXVsYXRlZFVwZGF0ZXNbY109emVyb3NMaWtlKHIpLnZhcmlhYmxlKCExKX0pO3ZhciBvPXBbY10sYT10LmFjY3VtdWxhdGVkR3JhZHNbY10saT10LmFjY3VtdWxhdGVkVXBkYXRlc1tjXTt0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9ZC5yaG9TY2FsYXIubXVsKGEpLmFkZChkLm9uZU1pbnVzUmhvLm11bChvLnNxdWFyZSgpKSksZT1pLmFkZChkLmVwc2lsb25TY2FsYXIpLnNxcnQoKS5kaXYoYS5hZGQoZC5lcHNpbG9uU2NhbGFyKS5zcXJ0KCkpLm11bChvKSxuPWQucmhvU2NhbGFyLm11bChpKS5hZGQoZC5vbmVNaW51c1Joby5tdWwoZS5zcXVhcmUoKSkpO2QuYWNjdW11bGF0ZWRHcmFkc1tjXS5hc3NpZ24odCksZC5hY2N1bXVsYXRlZFVwZGF0ZXNbY10uYXNzaWduKG4pO3ZhciBzPWQuYy5tdWwoZSkuYWRkKHIpO3IuYXNzaWduKHMpfSl9LHQ9dGhpcztmb3IodmFyIGEgaW4gcCllKGEpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLmMuZGlzcG9zZSgpLHRoaXMuZXBzaWxvblNjYWxhci5kaXNwb3NlKCksdGhpcy5yaG9TY2FsYXIuZGlzcG9zZSgpLHRoaXMub25lTWludXNSaG8uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzJiYoT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGEuYWNjdW11bGF0ZWRVcGRhdGVzW2VdLmRpc3Bvc2UoKX0pLE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRHcmFkcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gYS5hY2N1bXVsYXRlZEdyYWRzW2VdLmRpc3Bvc2UoKX0pKX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxyaG86dGhpcy5yaG8sZXBzaWxvbjp0aGlzLmVwc2lsb259fSxlLmZyb21Db25maWc9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gbmV3IGEoZS5sZWFybmluZ1JhdGUsZS5yaG8sZS5lcHNpbG9uKX0sZS5jbGFzc05hbWU9XCJBZGFkZWx0YU9wdGltaXplclwiLGV9KE9wdGltaXplcik7cmVnaXN0ZXJDbGFzcyhBZGFkZWx0YU9wdGltaXplcik7dmFyIEFkYWdyYWRPcHRpbWl6ZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlLHQpe3ZvaWQgMD09PXQmJih0PS4xKTt2YXIgbz1hLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG8ubGVhcm5pbmdSYXRlPWUsby5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZT10LG8uYWNjdW11bGF0ZWRHcmFkcz17fSxvLmM9a2VlcChzY2FsYXIoLWUpKSxvLmVwc2lsb249a2VlcChzY2FsYXIoRU5WLmdldChcIkVQU0lMT05cIikpKSxvfXJldHVybiBfX2V4dGVuZHMoZSxhKSxlLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbihzKXt2YXIgcD10aGlzLGU9ZnVuY3Rpb24obCl7dmFyIHI9RU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW2xdO251bGw9PXQuYWNjdW11bGF0ZWRHcmFkc1tsXSYmdGlkeShmdW5jdGlvbigpe3AuYWNjdW11bGF0ZWRHcmFkc1tsXT1maWxsKHIuc2hhcGUscC5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSkudmFyaWFibGUoITEpfSk7dmFyIG89c1tsXSxhPXQuYWNjdW11bGF0ZWRHcmFkc1tsXTt0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9YS5hZGQoby5zcXVhcmUoKSk7cC5hY2N1bXVsYXRlZEdyYWRzW2xdLmFzc2lnbih0KTt2YXIgZT1wLmMubXVsKG8uZGl2KHQuYWRkKHAuZXBzaWxvbikuc3FydCgpKSkuYWRkKHIpO3IuYXNzaWduKGUpfSl9LHQ9dGhpcztmb3IodmFyIGEgaW4gcyllKGEpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLmVwc2lsb24uZGlzcG9zZSgpLHRoaXMuYy5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEdyYWRzJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkR3JhZHMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGEuYWNjdW11bGF0ZWRHcmFkc1tlXS5kaXNwb3NlKCl9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxpbml0aWFsQWNjdW11bGF0b3JWYWx1ZTp0aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlfX0sZS5mcm9tQ29uZmlnPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIG5ldyBhKGUubGVhcm5pbmdSYXRlLGUuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpfSxlLmNsYXNzTmFtZT1cIkFkYWdyYWRPcHRpbWl6ZXJcIixlfShPcHRpbWl6ZXIpO3JlZ2lzdGVyQ2xhc3MoQWRhZ3JhZE9wdGltaXplcik7dmFyIEFkYW1PcHRpbWl6ZXI9ZnVuY3Rpb24ocyl7ZnVuY3Rpb24gZShlLHQscixuKXt2b2lkIDA9PT1uJiYobj1udWxsKTt2YXIgaT1zLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkubGVhcm5pbmdSYXRlPWUsaS5iZXRhMT10LGkuYmV0YTI9cixpLmVwc2lsb249bixpLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9e30saS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudD17fSxpLmM9a2VlcChzY2FsYXIoLWUpKSxpLmJldGExU2NhbGFyPWtlZXAoc2NhbGFyKHQpKSxpLmJldGEyU2NhbGFyPWtlZXAoc2NhbGFyKHIpKSx0aWR5KGZ1bmN0aW9uKCl7aS5hY2NCZXRhMT1zY2FsYXIodCkudmFyaWFibGUoKSxpLmFjY0JldGEyPXNjYWxhcihyKS52YXJpYWJsZSgpfSksaS5vbmVNaW51c0JldGExPWtlZXAoc2NhbGFyKDEtdCkpLGkub25lTWludXNCZXRhMj1rZWVwKHNjYWxhcigxLXIpKSxpLm9uZT1rZWVwKHNjYWxhcigxKSksbnVsbD09PW4mJihuPUVOVi5nZXQoXCJFUFNJTE9OXCIpKSxpLmVwc1NjYWxhcj1rZWVwKHNjYWxhcihuKSksaX1yZXR1cm4gX19leHRlbmRzKGUscyksZS5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24obSl7dmFyIGU9dGhpczt0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9ZS5vbmUuc3ViKGUuYWNjQmV0YTEpLHI9ZS5vbmUuc3ViKGUuYWNjQmV0YTIpO2Zvcih2YXIgbiBpbiBtKXt2YXIgbz1FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W25dKXt2YXIgYT0hMTtlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbbl09emVyb3NMaWtlKG8pLnZhcmlhYmxlKGEpfW51bGw9PWUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbbl0mJihhPSExLGUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbbl09emVyb3NMaWtlKG8pLnZhcmlhYmxlKGEpKTt2YXIgZz1tW25dLHM9ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W25dLHU9ZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtuXSxsPWUuYmV0YTFTY2FsYXIubXVsKHMpLmFkZChlLm9uZU1pbnVzQmV0YTEubXVsKGcpKSxjPWUuYmV0YTJTY2FsYXIubXVsKHUpLmFkZChlLm9uZU1pbnVzQmV0YTIubXVsKGcuc3F1YXJlKCkpKSxwPWwuZGl2KHQpLGQ9Yy5kaXYocik7ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W25dLmFzc2lnbihsKSxlLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W25dLmFzc2lnbihjKTt2YXIgaD1lLmMubXVsKHAuZGl2KGUuZXBzU2NhbGFyLmFkZChkLnNxcnQoKSkpKS5hZGQobyk7by5hc3NpZ24oaCl9ZS5hY2NCZXRhMS5hc3NpZ24oZS5hY2NCZXRhMS5tdWwoZS5iZXRhMVNjYWxhcikpLGUuYWNjQmV0YTIuYXNzaWduKGUuYWNjQmV0YTIubXVsKGUuYmV0YTJTY2FsYXIpKX0pfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLmMuZGlzcG9zZSgpLHRoaXMuZXBzU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLmJldGExU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLmJldGEyU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLmFjY0JldGExLmRpc3Bvc2UoKSx0aGlzLmFjY0JldGEyLmRpc3Bvc2UoKSx0aGlzLm9uZU1pbnVzQmV0YTEuZGlzcG9zZSgpLHRoaXMub25lTWludXNCZXRhMi5kaXNwb3NlKCksdGhpcy5vbmUuZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBhLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbZV0uZGlzcG9zZSgpfSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gYS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtlXS5kaXNwb3NlKCl9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxiZXRhMTp0aGlzLmJldGExLGJldGEyOnRoaXMuYmV0YTIsZXBzaWxvbjp0aGlzLmVwc2lsb259fSxlLmZyb21Db25maWc9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gbmV3IGEoZS5sZWFybmluZ1JhdGUsZS5iZXRhMSxlLmJldGEyLGUuZXBzaWxvbil9LGUuY2xhc3NOYW1lPVwiQWRhbU9wdGltaXplclwiLGV9KE9wdGltaXplcik7cmVnaXN0ZXJDbGFzcyhBZGFtT3B0aW1pemVyKTt2YXIgQWRhbWF4T3B0aW1pemVyPWZ1bmN0aW9uKHMpe2Z1bmN0aW9uIGUoZSx0LHIsbixwKXt2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1wJiYocD0wKTt2YXIgbD1zLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGwubGVhcm5pbmdSYXRlPWUsbC5iZXRhMT10LGwuYmV0YTI9cixsLmVwc2lsb249bixsLmRlY2F5PXAsbC5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PXt9LGwuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm09e30sbC5jPWtlZXAoc2NhbGFyKC1lKSksbC5iZXRhMVNjYWxhcj1rZWVwKHNjYWxhcih0KSksbC5iZXRhMlNjYWxhcj1rZWVwKHNjYWxhcihyKSksbC5kZWNheVNjYWxhcj1rZWVwKHNjYWxhcihwKSksdGlkeShmdW5jdGlvbigpe2wuaXRlcmF0aW9uPXNjYWxhcigwKS52YXJpYWJsZSgpLGwuYWNjQmV0YTE9c2NhbGFyKHQpLnZhcmlhYmxlKCl9KSxsLm9uZU1pbnVzQmV0YTE9a2VlcChzY2FsYXIoMS10KSksbC5vbmU9a2VlcChzY2FsYXIoMSkpLG51bGw9PT1uJiYobj1FTlYuZ2V0KFwiRVBTSUxPTlwiKSksbC5lcHNTY2FsYXI9a2VlcChzY2FsYXIobikpLGx9cmV0dXJuIF9fZXh0ZW5kcyhlLHMpLGUucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKG0pe3ZhciBlPXRoaXM7dGlkeShmdW5jdGlvbigpe3ZhciB0PWUub25lLnN1YihlLmFjY0JldGExKSxyPWUuYy5kaXYoZS5vbmUuYWRkKGUuZGVjYXlTY2FsYXIubXVsKGUuaXRlcmF0aW9uKSkpO2Zvcih2YXIgbiBpbiBtKXt2YXIgbz1FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W25dKXt2YXIgYT0hMTtlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbbl09emVyb3NMaWtlKG8pLnZhcmlhYmxlKGEpfW51bGw9PWUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bbl0mJihhPSExLGUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bbl09emVyb3NMaWtlKG8pLnZhcmlhYmxlKGEpKTt2YXIgZz1tW25dLHM9ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W25dLHU9ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtuXSxsPWUuYmV0YTFTY2FsYXIubXVsKHMpLmFkZChlLm9uZU1pbnVzQmV0YTEubXVsKGcpKSxjPWUuYmV0YTJTY2FsYXIubXVsKHUpLHA9Zy5hYnMoKSxkPWMubWF4aW11bShwKTtlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbbl0uYXNzaWduKGwpLGUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bbl0uYXNzaWduKGQpO3ZhciBoPXIuZGl2KHQpLm11bChsLmRpdihlLmVwc1NjYWxhci5hZGQoZCkpKS5hZGQobyk7by5hc3NpZ24oaCl9ZS5pdGVyYXRpb24uYXNzaWduKGUuaXRlcmF0aW9uLmFkZChlLm9uZSkpLGUuYWNjQmV0YTEuYXNzaWduKGUuYWNjQmV0YTEubXVsKGUuYmV0YTFTY2FsYXIpKX0pfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLmMuZGlzcG9zZSgpLHRoaXMuZXBzU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLmFjY0JldGExLmRpc3Bvc2UoKSx0aGlzLmJldGExU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLmJldGEyU2NhbGFyLmRpc3Bvc2UoKSx0aGlzLm9uZU1pbnVzQmV0YTEuZGlzcG9zZSgpLHRoaXMuZGVjYXlTY2FsYXIuZGlzcG9zZSgpLHRoaXMuaXRlcmF0aW9uLmRpc3Bvc2UoKSx0aGlzLm9uZS5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50JiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGEuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtlXS5kaXNwb3NlKCl9KSxudWxsIT10aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBhLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW2VdLmRpc3Bvc2UoKX0pfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbixkZWNheTp0aGlzLmRlY2F5fX0sZS5mcm9tQ29uZmlnPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIG5ldyBhKGUubGVhcm5pbmdSYXRlLGUuYmV0YTEsZS5iZXRhMixlLmVwc2lsb24sZS5kZWNheSl9LGUuY2xhc3NOYW1lPVwiQWRhbWF4T3B0aW1pemVyXCIsZX0oT3B0aW1pemVyKTtyZWdpc3RlckNsYXNzKEFkYW1heE9wdGltaXplcik7dmFyIFNHRE9wdGltaXplcj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gdC5sZWFybmluZ1JhdGU9ZSx0LnNldExlYXJuaW5nUmF0ZShlKSx0fXJldHVybiBfX2V4dGVuZHMoZSxhKSxlLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbihhKXt2YXIgcj10aGlzO09iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9YVtlXSxuPUVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1tlXTt0aWR5KGZ1bmN0aW9uKCl7dmFyIGE9ci5jLm11bCh0KS5hZGQobik7bi5hc3NpZ24oYSl9KX0pfSxlLnByb3RvdHlwZS5zZXRMZWFybmluZ1JhdGU9ZnVuY3Rpb24odCl7dGhpcy5sZWFybmluZ1JhdGU9dCxudWxsIT10aGlzLmMmJnRoaXMuYy5kaXNwb3NlKCksdGhpcy5jPWtlZXAoc2NhbGFyKC10KSl9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmMuZGlzcG9zZSgpfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlfX0sZS5mcm9tQ29uZmlnPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIG5ldyBhKGUubGVhcm5pbmdSYXRlKX0sZS5jbGFzc05hbWU9XCJTR0RPcHRpbWl6ZXJcIixlfShPcHRpbWl6ZXIpO3JlZ2lzdGVyQ2xhc3MoU0dET3B0aW1pemVyKTt2YXIgTW9tZW50dW1PcHRpbWl6ZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlLHQscil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBzPWEuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiBzLmxlYXJuaW5nUmF0ZT1lLHMubW9tZW50dW09dCxzLnVzZU5lc3Rlcm92PXIscy5tPXNjYWxhcihzLm1vbWVudHVtKSxzLmFjY3VtdWxhdGlvbnM9e30sc31yZXR1cm4gX19leHRlbmRzKGUsYSksZS5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24ocyl7dmFyIHA9dGhpcyxlPWZ1bmN0aW9uKGwpe3ZhciByPUVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1tsXTtudWxsPT10LmFjY3VtdWxhdGlvbnNbbF0mJnRpZHkoZnVuY3Rpb24oKXtwLmFjY3VtdWxhdGlvbnNbbF09emVyb3NMaWtlKHIpLnZhcmlhYmxlKCExKX0pO3ZhciBvPXQuYWNjdW11bGF0aW9uc1tsXSxhPXNbbF07dGlkeShmdW5jdGlvbigpe3ZhciB0PXAubS5tdWwobykuYWRkKGEpLG47bj1wLnVzZU5lc3Rlcm92P3AuYy5tdWwoYS5hZGQodC5tdWwocC5tKSkpLmFkZChyKTpwLmMubXVsKHQpLmFkZChyKSxwLmFjY3VtdWxhdGlvbnNbbF0uYXNzaWduKHQpLHIuYXNzaWduKG4pfSl9LHQ9dGhpcztmb3IodmFyIGEgaW4gcyllKGEpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7aWYoYS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMubS5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRpb25zKWZvcih2YXIgZSBpbiB0aGlzLmFjY3VtdWxhdGlvbnMpdGhpcy5hY2N1bXVsYXRpb25zW2VdLmRpc3Bvc2UoKX0sZS5wcm90b3R5cGUuc2V0TW9tZW50dW09ZnVuY3Rpb24odCl7dGhpcy5tb21lbnR1bT10fSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLG1vbWVudHVtOnRoaXMubW9tZW50dW0sdXNlTmVzdGVyb3Y6dGhpcy51c2VOZXN0ZXJvdn19LGUuZnJvbUNvbmZpZz1mdW5jdGlvbihhLGUpe3JldHVybiBuZXcgYShlLmxlYXJuaW5nUmF0ZSxlLm1vbWVudHVtLGUudXNlTmVzdGVyb3YpfSxlLmNsYXNzTmFtZT1cIk1vbWVudHVtT3B0aW1pemVyXCIsZX0oU0dET3B0aW1pemVyKTtyZWdpc3RlckNsYXNzKE1vbWVudHVtT3B0aW1pemVyKTt2YXIgUk1TUHJvcE9wdGltaXplcj1mdW5jdGlvbihzKXtmdW5jdGlvbiBlKGUsdCxwLGwsZCl7dm9pZCAwPT09dCYmKHQ9LjkpLHZvaWQgMD09PXAmJihwPTApLHZvaWQgMD09PWwmJihsPW51bGwpLHZvaWQgMD09PWQmJihkPSExKTt2YXIgdT1zLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHUubGVhcm5pbmdSYXRlPWUsdS5kZWNheT10LHUubW9tZW50dW09cCx1LmVwc2lsb249bCx1LmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9e30sdS5hY2N1bXVsYXRlZE1lYW5HcmFkcz17fSx1LmFjY3VtdWxhdGVkTW9tZW50cz17fSx1LmM9a2VlcChzY2FsYXIoZSkpLHUuZGVjYXlTY2FsYXI9a2VlcChzY2FsYXIodCkpLHUubW9tZW50dW1TY2FsYXI9a2VlcChzY2FsYXIocCkpLHUub25lTWludXNEZWNheT1rZWVwKHNjYWxhcigxLXQpKSx1LmNlbnRlcmVkPWQsbnVsbD09PWwmJihsPUVOVi5nZXQoXCJFUFNJTE9OXCIpKSx1LmVwc2lsb25TY2FsYXI9a2VlcChzY2FsYXIobCkpLHV9cmV0dXJuIF9fZXh0ZW5kcyhlLHMpLGUucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHApe3ZhciBkPXRoaXMsZT1mdW5jdGlvbihtKXt2YXIgcj1FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbbV07bnVsbD09dC5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW21dJiZ0aWR5KGZ1bmN0aW9uKCl7ZC5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW21dPXplcm9zTGlrZShyKS52YXJpYWJsZSghMSl9KSxudWxsPT10LmFjY3VtdWxhdGVkTWVhbkdyYWRzW21dJiZ0LmNlbnRlcmVkJiZ0aWR5KGZ1bmN0aW9uKCl7ZC5hY2N1bXVsYXRlZE1lYW5HcmFkc1ttXT16ZXJvc0xpa2UocikudmFyaWFibGUoITEpfSksbnVsbD09dC5hY2N1bXVsYXRlZE1vbWVudHNbbV0mJnRpZHkoZnVuY3Rpb24oKXtkLmFjY3VtdWxhdGVkTW9tZW50c1ttXT16ZXJvc0xpa2UocikudmFyaWFibGUoITEpfSk7dmFyIG89dC5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW21dLGE9dC5hY2N1bXVsYXRlZE1lYW5HcmFkc1ttXSxpPXQuYWNjdW11bGF0ZWRNb21lbnRzW21dLHM9cFttXTt0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9ZC5kZWNheVNjYWxhci5tdWwobykuYWRkKGQub25lTWludXNEZWNheS5tdWwocy5zcXVhcmUoKSkpO2lmKGQuY2VudGVyZWQpe3ZhciBlPWQuZGVjYXlTY2FsYXIubXVsKGEpLmFkZChkLm9uZU1pbnVzRGVjYXkubXVsKHMpKSxuPWQubW9tZW50dW1TY2FsYXIubXVsKGkpLmFkZChkLmMubXVsKHMpLmRpdih0LnN1YihlLnNxdWFyZSgpLmFkZChkLmVwc2lsb25TY2FsYXIpKS5zcXJ0KCkpKTtkLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbV0uYXNzaWduKHQpLGQuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbV0uYXNzaWduKGUpLGQuYWNjdW11bGF0ZWRNb21lbnRzW21dLmFzc2lnbihuKTt2YXIgdT1yLnN1YihuKTtyLmFzc2lnbih1KX1lbHNle3ZhciBoPWQuZGVjYXlTY2FsYXIubXVsKG8pLmFkZChkLm9uZU1pbnVzRGVjYXkubXVsKHMuc3F1YXJlKCkpKTtuPWQubW9tZW50dW1TY2FsYXIubXVsKGkpLmFkZChkLmMubXVsKHMpLmRpdihoLmFkZChkLmVwc2lsb25TY2FsYXIpLnNxcnQoKSkpLGQuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1ttXS5hc3NpZ24oaCksZC5hY2N1bXVsYXRlZE1vbWVudHNbbV0uYXNzaWduKG4pLHU9ci5zdWIobiksci5hc3NpZ24odSl9fSl9LHQ9dGhpcztmb3IodmFyIGEgaW4gcCllKGEpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLmMuZGlzcG9zZSgpLHRoaXMuZXBzaWxvblNjYWxhci5kaXNwb3NlKCksdGhpcy5kZWNheVNjYWxhci5kaXNwb3NlKCksdGhpcy5tb21lbnR1bVNjYWxhci5kaXNwb3NlKCksdGhpcy5vbmVNaW51c0RlY2F5LmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gYS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW2VdLmRpc3Bvc2UoKX0pLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMmJnRoaXMuY2VudGVyZWQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGEuYWNjdW11bGF0ZWRNZWFuR3JhZHNbZV0uZGlzcG9zZSgpfSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1vbWVudHMmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBhLmFjY3VtdWxhdGVkTW9tZW50c1tlXS5kaXNwb3NlKCl9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxkZWNheTp0aGlzLmRlY2F5LG1vbWVudHVtOnRoaXMubW9tZW50dW0sZXBzaWxvbjp0aGlzLmVwc2lsb24sY2VudGVyZWQ6dGhpcy5jZW50ZXJlZH19LGUuZnJvbUNvbmZpZz1mdW5jdGlvbihhLGUpe3JldHVybiBuZXcgYShlLmxlYXJuaW5nUmF0ZSxlLmRlY2F5LGUubW9tZW50dW0sZS5lcHNpbG9uLGUuY2VudGVyZWQpfSxlLmNsYXNzTmFtZT1cIlJNU1Byb3BPcHRpbWl6ZXJcIixlfShPcHRpbWl6ZXIpO3JlZ2lzdGVyQ2xhc3MoUk1TUHJvcE9wdGltaXplcik7dmFyIE9wdGltaXplckNvbnN0cnVjdG9ycz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQuc2dkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgU0dET3B0aW1pemVyKHQpfSx0Lm1vbWVudHVtPWZ1bmN0aW9uKGEsZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLG5ldyBNb21lbnR1bU9wdGltaXplcihhLGUsdCl9LHQucm1zcHJvcD1mdW5jdGlvbihhLGUscyxpLHApe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09cyYmKHM9MCksdm9pZCAwPT09aSYmKGk9bnVsbCksdm9pZCAwPT09cCYmKHA9ITEpLG5ldyBSTVNQcm9wT3B0aW1pemVyKGEsZSxzLGkscCl9LHQuYWRhbT1mdW5jdGlvbihhLG8scyxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9LjAwMSksdm9pZCAwPT09byYmKG89LjkpLHZvaWQgMD09PXMmJihzPS45OTkpLHZvaWQgMD09PWkmJihpPW51bGwpLG5ldyBBZGFtT3B0aW1pemVyKGEsbyxzLGkpfSx0LmFkYWRlbHRhPWZ1bmN0aW9uKGEsbixvKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9LjAwMSksdm9pZCAwPT09biYmKG49Ljk1KSx2b2lkIDA9PT1vJiYobz1udWxsKSxuZXcgQWRhZGVsdGFPcHRpbWl6ZXIoYSxuLG8pfSx0LmFkYW1heD1mdW5jdGlvbihhLHMsaSxwLGwpe3JldHVybiB2b2lkIDA9PT1hJiYoYT0uMDAyKSx2b2lkIDA9PT1zJiYocz0uOSksdm9pZCAwPT09aSYmKGk9Ljk5OSksdm9pZCAwPT09cCYmKHA9bnVsbCksdm9pZCAwPT09bCYmKGw9MCksbmV3IEFkYW1heE9wdGltaXplcihhLHMsaSxwLGwpfSx0LmFkYWdyYWQ9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LjEpLG5ldyBBZGFncmFkT3B0aW1pemVyKGEsZSl9LHR9KCksdHJhaW49e3NnZDpPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuc2dkLG1vbWVudHVtOk9wdGltaXplckNvbnN0cnVjdG9ycy5tb21lbnR1bSxhZGFkZWx0YTpPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZGVsdGEsYWRhZ3JhZDpPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZ3JhZCxybXNwcm9wOk9wdGltaXplckNvbnN0cnVjdG9ycy5ybXNwcm9wLGFkYW1heDpPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhbWF4LGFkYW06T3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYW19LHNldEJhY2tlbmQ9RW52aXJvbm1lbnQuc2V0QmFja2VuZCxnZXRCYWNrZW5kPUVudmlyb25tZW50LmdldEJhY2tlbmQ7c2V0T3BIYW5kbGVyKG9wcyk7LyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAqXG4gICAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgKlxuICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqL3ZhciBleHRlbmRTdGF0aWNzJDE9ZnVuY3Rpb24oYSxlKXtyZXR1cm4oZXh0ZW5kU3RhdGljcyQxPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihhLGUpe2EuX19wcm90b19fPWV9fHxmdW5jdGlvbihhLGUpe2Zvcih2YXIgdCBpbiBlKWUuaGFzT3duUHJvcGVydHkodCkmJihhW3RdPWVbdF0pfSkoYSxlKX0sX19hc3NpZ24kMT1mdW5jdGlvbigpe3JldHVybihfX2Fzc2lnbiQxPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGEpe2Zvcih2YXIgZT0xLG89YXJndW1lbnRzLmxlbmd0aCxyO2U8bztlKyspZm9yKHZhciBzIGluIHI9YXJndW1lbnRzW2VdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLHMpJiYoYVtzXT1yW3NdKTtyZXR1cm4gYX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sX2Vwc2lsb249RU5WLmdldChcIkVQU0lMT05cIiksX25leHRVbmlxdWVUZW5zb3JJZD0wLF91aWRQcmVmaXhlcz17fSxzY2FsYXJDYWNoZT17ZmxvYXQzMjp7fSxpbnQzMjp7fX0sREVGQVVMVF9EVFlQRT1cImZsb2F0MzJcIixBdHRyaWJ1dGVFcnJvcj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKHQpe3ZhciBuPWEuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YobixlLnByb3RvdHlwZSksbn1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlfShFcnJvciksUnVudGltZUVycm9yPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUodCl7dmFyIG49YS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihuLGUucHJvdG90eXBlKSxufXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGV9KEVycm9yKSxWYWx1ZUVycm9yPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUodCl7dmFyIG49YS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihuLGUucHJvdG90eXBlKSxufXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGV9KEVycm9yKSxOb3RJbXBsZW1lbnRlZEVycm9yPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUodCl7dmFyIG49YS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihuLGUucHJvdG90eXBlKSxufXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGV9KEVycm9yKSxBc3NlcnRpb25FcnJvcj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKHQpe3ZhciBuPWEuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YobixlLnByb3RvdHlwZSksbn1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlfShFcnJvciksSW5kZXhFcnJvcj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKHQpe3ZhciBuPWEuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YobixlLnByb3RvdHlwZSksbn1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlfShFcnJvciksX0dMT0JBTF9DVVNUT01fT0JKRUNUUz17fSxDb25zdHJhaW50PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt9fSxlfShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksTWF4Tm9ybT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gdC5kZWZhdWx0TWF4VmFsdWU9Mix0LmRlZmF1bHRBeGlzPTAsdC5tYXhWYWx1ZT1udWxsPT1lLm1heFZhbHVlP3QuZGVmYXVsdE1heFZhbHVlOmUubWF4VmFsdWUsdC5heGlzPW51bGw9PWUuYXhpcz90LmRlZmF1bHRBeGlzOmUuYXhpcyx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEpe3ZhciBlPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1jYWxjTDJOb3JtcyhhLGUuYXhpcyksbj1jbGlwQnlWYWx1ZSh0LDAsZS5tYXhWYWx1ZSk7cmV0dXJuIG11bChhLGRpdihuLGFkZChnZXRTY2FsYXIoZXBzaWxvbigpKSx0KSkpfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttYXhWYWx1ZTp0aGlzLm1heFZhbHVlLGF4aXM6dGhpcy5heGlzfX0sZS5jbGFzc05hbWU9XCJNYXhOb3JtXCIsZX0oQ29uc3RyYWludCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heE5vcm0pO3ZhciBVbml0Tm9ybT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gdC5kZWZhdWx0QXhpcz0wLHQuYXhpcz1udWxsPT1lLmF4aXM/dC5kZWZhdWx0QXhpczplLmF4aXMsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGRpdihhLGFkZChnZXRTY2FsYXIoZXBzaWxvbigpKSxjYWxjTDJOb3JtcyhhLGUuYXhpcykpKX0pfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57YXhpczp0aGlzLmF4aXN9fSxlLmNsYXNzTmFtZT1cIlVuaXROb3JtXCIsZX0oQ29uc3RyYWludCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFVuaXROb3JtKTt2YXIgTm9uTmVnPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQpe3JldHVybiByZWx1KHQpfSxlLmNsYXNzTmFtZT1cIk5vbk5lZ1wiLGV9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhOb25OZWcpO3ZhciBNaW5NYXhOb3JtPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiB0LmRlZmF1bHRNaW5WYWx1ZT0wLHQuZGVmYXVsdE1heFZhbHVlPTEsdC5kZWZhdWx0UmF0ZT0xLHQuZGVmYXVsdEF4aXM9MCx0Lm1pblZhbHVlPW51bGw9PWUubWluVmFsdWU/dC5kZWZhdWx0TWluVmFsdWU6ZS5taW5WYWx1ZSx0Lm1heFZhbHVlPW51bGw9PWUubWF4VmFsdWU/dC5kZWZhdWx0TWF4VmFsdWU6ZS5tYXhWYWx1ZSx0LnJhdGU9bnVsbD09ZS5yYXRlP3QuZGVmYXVsdFJhdGU6ZS5yYXRlLHQuYXhpcz1udWxsPT1lLmF4aXM/dC5kZWZhdWx0QXhpczplLmF4aXMsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Y2FsY0wyTm9ybXMoYSxlLmF4aXMpLG49YWRkKG11bChnZXRTY2FsYXIoZS5yYXRlKSxjbGlwQnlWYWx1ZSh0LGUubWluVmFsdWUsZS5tYXhWYWx1ZSkpLG11bChnZXRTY2FsYXIoMS1lLnJhdGUpLHQpKTtyZXR1cm4gbXVsKGEsZGl2KG4sYWRkKGdldFNjYWxhcihlcHNpbG9uKCkpLHQpKSl9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21pblZhbHVlOnRoaXMubWluVmFsdWUsbWF4VmFsdWU6dGhpcy5tYXhWYWx1ZSxyYXRlOnRoaXMucmF0ZSxheGlzOnRoaXMuYXhpc319LGUuY2xhc3NOYW1lPVwiTWluTWF4Tm9ybVwiLGV9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNaW5NYXhOb3JtKTt2YXIgQ09OU1RSQUlOVF9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA9e21heE5vcm06XCJNYXhOb3JtXCIsbWluTWF4Tm9ybTpcIk1pbk1heE5vcm1cIixub25OZWc6XCJOb25OZWdcIix1bml0Tm9ybTpcIlVuaXROb3JtXCJ9LGV4cG9ydHNfY29uc3RyYWludHM9T2JqZWN0LmZyZWV6ZSh7bWF4Tm9ybTptYXhOb3JtLHVuaXROb3JtOnVuaXROb3JtLG5vbk5lZzpub25OZWcsbWluTWF4Tm9ybTptaW5NYXhOb3JtfSksbmFtZU1hcD1uZXcgTWFwLFZBTElEX0RBVEFfRk9STUFUX1ZBTFVFUz1bXCJjaGFubmVsc0ZpcnN0XCIsXCJjaGFubmVsc0xhc3RcIl0sVkFMSURfUEFERElOR19NT0RFX1ZBTFVFUz1bXCJ2YWxpZFwiLFwic2FtZVwiLFwiY2F1c2FsXCJdLFZBTElEX1BPT0xfTU9ERV9WQUxVRVM9W1wibWF4XCIsXCJhdmdcIl0sX25hbWVTY29wZVN0YWNrPVtdLF9uYW1lU2NvcGVEaXZpZGVyPVwiL1wiLHRlbnNvck5hbWVSZWdleD1uZXcgUmVnRXhwKC9eW0EtWmEtel1bLUEtWmEtejAtOVxcLl9cXC9dKiQvKSxWQUxJRF9GQU5fTU9ERV9WQUxVRVM9W1wiZmFuSW5cIixcImZhbk91dFwiLFwiZmFuQXZnXCJdLFZBTElEX0RJU1RSSUJVVElPTl9WQUxVRVM9W1wibm9ybWFsXCIsXCJ1bmlmb3JtXCJdLEluaXRpYWxpemVyPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmZyb21Db25maWdVc2VzQ3VzdG9tT2JqZWN0cz1mdW5jdGlvbigpe3JldHVybiExfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57fX0sZX0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpLFplcm9zPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHplcm9zKGEsZSl9LGUuY2xhc3NOYW1lPVwiWmVyb3NcIixlfShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFplcm9zKTt2YXIgT25lcz1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT1hJiZhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhLGUpe3JldHVybiBvbmVzJDEoYSxlKX0sZS5jbGFzc05hbWU9XCJPbmVzXCIsZX0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhPbmVzKTt2YXIgQ29uc3RhbnQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyl8fHRoaXM7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudCBvZiB0eXBlIENvbnN0YW50Q29uZmlnIGJ1dCBnb3QgXCIrZSk7aWYodm9pZCAwPT09ZS52YWx1ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbmZpZyBtdXN0IGhhdmUgdmFsdWUgc2V0IGJ1dCBnb3QgXCIrZSk7cmV0dXJuIHQudmFsdWU9ZS52YWx1ZSx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEsZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBtdWwoc2NhbGFyKHQudmFsdWUpLG9uZXMkMShhLGUpKX0pfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57dmFsdWU6dGhpcy52YWx1ZX19LGUuY2xhc3NOYW1lPVwiQ29uc3RhbnRcIixlfShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnN0YW50KTt2YXIgUmFuZG9tVW5pZm9ybT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gdC5ERUZBVUxUX01JTlZBTD0tLjA1LHQuREVGQVVMVF9NQVhWQUw9LjA1LHQubWludmFsPWUubWludmFsfHx0LkRFRkFVTFRfTUlOVkFMLHQubWF4dmFsPWUubWF4dmFsfHx0LkRFRkFVTFRfTUFYVkFMLHQuc2VlZD1lLnNlZWQsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhLGUpe3JldHVybiByYW5kb21Vbmlmb3JtKGEsdGhpcy5taW52YWwsdGhpcy5tYXh2YWwsZSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttaW52YWw6dGhpcy5taW52YWwsbWF4dmFsOnRoaXMubWF4dmFsLHNlZWQ6dGhpcy5zZWVkfX0sZS5jbGFzc05hbWU9XCJSYW5kb21Vbmlmb3JtXCIsZX0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSYW5kb21Vbmlmb3JtKTt2YXIgUmFuZG9tTm9ybWFsPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiB0LkRFRkFVTFRfTUVBTj0wLHQuREVGQVVMVF9TVERERVY9LjA1LHQubWVhbj1lLm1lYW58fHQuREVGQVVMVF9NRUFOLHQuc3RkZGV2PWUuc3RkZGV2fHx0LkRFRkFVTFRfU1REREVWLHQuc2VlZD1lLnNlZWQsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhLGUpe2lmKFwiZmxvYXQzMlwiIT09KGU9ZXx8XCJmbG9hdDMyXCIpJiZcImludDMyXCIhPT1lKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwicmFuZG9tTm9ybWFsIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgXCIrZStcIi5cIik7cmV0dXJuIHJhbmRvbU5vcm1hbCQxKGEsdGhpcy5tZWFuLHRoaXMuc3RkZGV2LGUsdGhpcy5zZWVkKX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21lYW46dGhpcy5tZWFuLHN0ZGRldjp0aGlzLnN0ZGRldixzZWVkOnRoaXMuc2VlZH19LGUuY2xhc3NOYW1lPVwiUmFuZG9tTm9ybWFsXCIsZX0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSYW5kb21Ob3JtYWwpO3ZhciBUcnVuY2F0ZWROb3JtYWw9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHQuREVGQVVMVF9NRUFOPTAsdC5ERUZBVUxUX1NURERFVj0uMDUsdC5tZWFuPWUubWVhbnx8dC5ERUZBVUxUX01FQU4sdC5zdGRkZXY9ZS5zdGRkZXZ8fHQuREVGQVVMVF9TVERERVYsdC5zZWVkPWUuc2VlZCx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEsZSl7aWYoXCJmbG9hdDMyXCIhPT0oZT1lfHxcImZsb2F0MzJcIikmJlwiaW50MzJcIiE9PWUpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJ0cnVuY2F0ZWROb3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBcIitlK1wiLlwiKTtyZXR1cm4gdHJ1bmNhdGVkTm9ybWFsKGEsdGhpcy5tZWFuLHRoaXMuc3RkZGV2LGUsdGhpcy5zZWVkKX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21lYW46dGhpcy5tZWFuLHN0ZGRldjp0aGlzLnN0ZGRldixzZWVkOnRoaXMuc2VlZH19LGUuY2xhc3NOYW1lPVwiVHJ1bmNhdGVkTm9ybWFsXCIsZX0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhUcnVuY2F0ZWROb3JtYWwpO3ZhciBJZGVudGl0eT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gdC5nYWluPW51bGw9PWUuZ2Fpbj9nZXRTY2FsYXIoMSk6c2NhbGFyKGUuZ2FpbiksdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PXQubGVuZ3RofHx0WzBdIT09dFsxXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklkZW50aXR5IG1hdHJpeCBpbml0aWFsaXplciBjYW4gb25seSBiZSB1c2VkIGZvciAyRCBzcXVhcmUgbWF0cmljZXMuXCIpO3JldHVybiBtdWwoZS5nYWluLGV5ZSh0WzBdKSl9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2dhaW46dGhpcy5nYWluLmdldCgpfX0sZS5jbGFzc05hbWU9XCJJZGVudGl0eVwiLGV9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSWRlbnRpdHkpO3ZhciBWYXJpYW5jZVNjYWxpbmc9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyl8fHRoaXM7aWYoMD5lLnNjYWxlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwic2NhbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGZsb2F0LiBHb3Q6IFwiK2Uuc2NhbGUpO3JldHVybiB0LnNjYWxlPW51bGw9PWUuc2NhbGU/MTplLnNjYWxlLHQubW9kZT1lLm1vZGUsY2hlY2tGYW5Nb2RlKHQubW9kZSksdC5kaXN0cmlidXRpb249ZS5kaXN0cmlidXRpb24sY2hlY2tEaXN0cmlidXRpb24odC5kaXN0cmlidXRpb24pLHQuc2VlZD1lLnNlZWQsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihwLGUpe3ZhciBsPWNvbXB1dGVGYW5zKHApLG49bFswXSxyPWxbMV0saT10aGlzLnNjYWxlO2lmKGkvPVwiZmFuSW5cIj09PXRoaXMubW9kZT9fTWF0aG1heCgxLG4pOlwiZmFuT3V0XCI9PT10aGlzLm1vZGU/X01hdGhtYXgoMSxyKTpfTWF0aG1heCgxLChuK3IpLzIpLFwibm9ybWFsXCI9PT10aGlzLmRpc3RyaWJ1dGlvbil7dmFyIGQ9X01hdGhzcXJ0KGkpO2lmKFwiZmxvYXQzMlwiIT09KGU9ZXx8XCJmbG9hdDMyXCIpJiZcImludDMyXCIhPT1lKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKHRoaXMuZ2V0Q2xhc3NOYW1lKCkrXCIgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBcIitlK1wiLlwiKTtyZXR1cm4gdHJ1bmNhdGVkTm9ybWFsKHAsMCxkLGUsdGhpcy5zZWVkKX12YXIgbz1fTWF0aHNxcnQoMyppKTtyZXR1cm4gcmFuZG9tVW5pZm9ybShwLC1vLG8sZSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntzY2FsZTp0aGlzLnNjYWxlLG1vZGU6dGhpcy5tb2RlLGRpc3RyaWJ1dGlvbjp0aGlzLmRpc3RyaWJ1dGlvbixzZWVkOnRoaXMuc2VlZH19LGUuY2xhc3NOYW1lPVwiVmFyaWFuY2VTY2FsaW5nXCIsZX0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhWYXJpYW5jZVNjYWxpbmcpO3ZhciBHbG9yb3RVbmlmb3JtPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGEuY2FsbCh0aGlzLHtzY2FsZToxLG1vZGU6XCJmYW5BdmdcIixkaXN0cmlidXRpb246XCJ1bmlmb3JtXCIsc2VlZDpudWxsPT1lP251bGw6ZS5zZWVkfSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LGUuY2xhc3NOYW1lPVwiR2xvcm90VW5pZm9ybVwiLGV9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb3JvdFVuaWZvcm0pO3ZhciBHbG9yb3ROb3JtYWw9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gYS5jYWxsKHRoaXMse3NjYWxlOjEsbW9kZTpcImZhbkF2Z1wiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6bnVsbD09ZT9udWxsOmUuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSxlLmNsYXNzTmFtZT1cIkdsb3JvdE5vcm1hbFwiLGV9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb3JvdE5vcm1hbCk7dmFyIEhlTm9ybWFsPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGEuY2FsbCh0aGlzLHtzY2FsZToyLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6bnVsbD09ZT9udWxsOmUuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSxlLmNsYXNzTmFtZT1cIkhlTm9ybWFsXCIsZX0oVmFyaWFuY2VTY2FsaW5nKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGVOb3JtYWwpO3ZhciBMZUN1bk5vcm1hbD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3JldHVybiBhLmNhbGwodGhpcyx7c2NhbGU6MSxtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJub3JtYWxcIixzZWVkOm51bGw9PWU/bnVsbDplLnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sZS5jbGFzc05hbWU9XCJMZUN1bk5vcm1hbFwiLGV9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExlQ3VuTm9ybWFsKTt2YXIgT3J0aG9nb25hbD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcztpZih0LkRFRkFVTFRfR0FJTj0xLHQuZ2Fpbj1udWxsPT1lLmdhaW4/dC5ERUZBVUxUX0dBSU46ZS5nYWluLHQuc2VlZD1lLnNlZWQsbnVsbCE9dC5zZWVkKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiUmFuZG9tIHNlZWQgaXMgbm90IGltcGxlbWVudGVkIGZvciBPcnRob2dvbmFsIEluaXRpYWxpemVyIHlldC5cIik7cmV0dXJuIHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7dmFyIGU9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT1hLmxlbmd0aCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBPcnRob2dvbmFsIEluaXRpYWxpemVyIGRvZXMgbm90IHN1cHBvcnQgbm9uLTJEIHNoYXBlcyB5ZXQuXCIpOzJlMzxhWzBdKmFbMV0mJmNvbnNvbGUud2FybihcIk9ydGhvZ29uYWwgaW5pdGlhbGl6ZXIgaXMgYmVpbmcgY2FsbGVkIG9uIGEgbWF0cml4IHdpdGggbW9yZSB0aGFuIDIwMDAgKFwiK2FbMF0qYVsxXStcIikgZWxlbWVudHM6IFNsb3duZXNzIG1heSByZXN1bHQuXCIpO3ZhciBuPXJhbmRvbU5vcm1hbCQxKGFbMF0+YVsxXT9bYVsxXSxhWzBdXTphLDAsMSxcImZsb2F0MzJcIiksdD1saW5hbGdfb3BzLmdyYW1TY2htaWR0KG4pO3JldHVybiBhWzBdPmFbMV0mJih0PXQudHJhbnNwb3NlKCkpLG11bChnZXRTY2FsYXIoZS5nYWluKSx0KX0pfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57Z2Fpbjp0aGlzLmdhaW4sc2VlZDp0aGlzLnNlZWR9fSxlLmNsYXNzTmFtZT1cIk9ydGhvZ29uYWxcIixlfShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE9ydGhvZ29uYWwpO3ZhciBJTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA9e2NvbnN0YW50OlwiQ29uc3RhbnRcIixnbG9yb3ROb3JtYWw6XCJHbG9yb3ROb3JtYWxcIixnbG9yb3RVbmlmb3JtOlwiR2xvcm90VW5pZm9ybVwiLGhlTm9ybWFsOlwiSGVOb3JtYWxcIixpZGVudGl0eTpcIklkZW50aXR5XCIsbGVDdW5Ob3JtYWw6XCJMZUN1bk5vcm1hbFwiLG9uZXM6XCJPbmVzXCIsb3J0aG9nb25hbDpcIk9ydGhvZ29uYWxcIixyYW5kb21Ob3JtYWw6XCJSYW5kb21Ob3JtYWxcIixyYW5kb21Vbmlmb3JtOlwiUmFuZG9tVW5pZm9ybVwiLHRydW5jYXRlZE5vcm1hbDpcIlRydW5jYXRlZE5vcm1hbFwiLHZhcmlhbmNlU2NhbGluZzpcIlZhcmlhbmNlU2NhbGluZ1wiLHplcm9zOlwiWmVyb3NcIn0sZXhwb3J0c19pbml0aWFsaXplcnM9T2JqZWN0LmZyZWV6ZSh7emVyb3M6emVyb3MkMSxvbmVzOm9uZXMkMSQxLGNvbnN0YW50OmNvbnN0YW50LHJhbmRvbVVuaWZvcm06cmFuZG9tVW5pZm9ybSQxLHJhbmRvbU5vcm1hbDpyYW5kb21Ob3JtYWwkMix0cnVuY2F0ZWROb3JtYWw6dHJ1bmNhdGVkTm9ybWFsJDEsaWRlbnRpdHk6aWRlbnRpdHksdmFyaWFuY2VTY2FsaW5nOnZhcmlhbmNlU2NhbGluZyxnbG9yb3RVbmlmb3JtOmdsb3JvdFVuaWZvcm0sZ2xvcm90Tm9ybWFsOmdsb3JvdE5vcm1hbCxoZU5vcm1hbDpoZU5vcm1hbCxsZUN1bk5vcm1hbDpsZUN1bk5vcm1hbCxvcnRob2dvbmFsOm9ydGhvZ29uYWx9KSxERUZBVUxUX1ZBUklBQkxFX05BTUVfUFJFRklYPVwiVmFyaWFibGVcIixMYXllclZhcmlhYmxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChhLGUsbyxzLHApe3ZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSx2b2lkIDA9PT1vJiYobz1ERUZBVUxUX1ZBUklBQkxFX05BTUVfUFJFRklYKSx2b2lkIDA9PT1zJiYocz0hMCksdm9pZCAwPT09cCYmKHA9bnVsbCksdGhpcy5kdHlwZT1udWxsPT1lP1wiZmxvYXQzMlwiOmUsdGhpcy5zaGFwZT1hLnNoYXBlLHRoaXMuaWQ9Z2V0TmV4dFVuaXF1ZVRlbnNvcklkKCksbz1udWxsPT1vP0RFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVg6byx0aGlzLm9yaWdpbmFsTmFtZT1nZXRTY29wZWRUZW5zb3JOYW1lKG8pLHRoaXMubmFtZT1nZXRVbmlxdWVUZW5zb3JOYW1lKHRoaXMub3JpZ2luYWxOYW1lKSx0aGlzLnRyYWluYWJsZT1zLHRoaXMuY29uc3RyYWludD1wLHRoaXMudmFsPXZhcmlhYmxlKGEsdGhpcy50cmFpbmFibGUsdGhpcy5uYW1lLHRoaXMuZHR5cGUpfXJldHVybiB0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSx0aGlzLnZhbH0sdC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSxjaGVja1NoYXBlc01hdGNoKHRoaXMudmFsLHQpLHRoaXMudmFsLmlkIT09dC5pZCYmKHRoaXMudmFsLmFzc2lnbih0KSxudWxsIT10aGlzLmNvbnN0cmFpbnQmJnRoaXMudmFsLmFzc2lnbih0aGlzLmNvbnN0cmFpbnQuYXBwbHkodGhpcy52YWwpKSksdGhpc30sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSx0aGlzLnZhbC5kaXNwb3NlKCl9LHQucHJvdG90eXBlLmFzc2VydE5vdERpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYodGhpcy52YWwuaXNEaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJMYXllcnNWYXJpYWJsZSBcIit0aGlzLm5hbWUrXCIgaXMgYWxyZWFkeSBkaXNwb3NlZC5cIil9LHR9KCksSW5wdXRTcGVjPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMuZHR5cGU9dC5kdHlwZSx0aGlzLnNoYXBlPXQuc2hhcGUsdGhpcy5uZGltPW51bGw9PXQuc2hhcGU/dC5uZGltOnQuc2hhcGUubGVuZ3RoLHRoaXMubWF4TkRpbT10Lm1heE5EaW0sdGhpcy5taW5ORGltPXQubWluTkRpbSx0aGlzLmF4ZXM9dC5heGVzfHx7fX19KCksU3ltYm9saWNUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24ocyxlLHQsbixyLGksYSl7dGhpcy5kdHlwZT1zLHRoaXMuc2hhcGU9ZSx0aGlzLnNvdXJjZUxheWVyPXQsdGhpcy5pbnB1dHM9bix0aGlzLmNhbGxBcmdzPXIsdGhpcy5vdXRwdXRUZW5zb3JJbmRleD1hLHRoaXMuaWQ9Z2V0TmV4dFVuaXF1ZVRlbnNvcklkKCksbnVsbCE9aSYmKHRoaXMub3JpZ2luYWxOYW1lPWdldFNjb3BlZFRlbnNvck5hbWUoaSksdGhpcy5uYW1lPWdldFVuaXF1ZVRlbnNvck5hbWUodGhpcy5vcmlnaW5hbE5hbWUpKSx0aGlzLnJhbms9ZS5sZW5ndGh9fSgpLF9uZXh0Tm9kZUlEPTAsTm9kZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoYSxlKXt0aGlzLmNhbGxBcmdzPWUsdGhpcy5pZD1fbmV4dE5vZGVJRCsrLHRoaXMub3V0Ym91bmRMYXllcj1hLm91dGJvdW5kTGF5ZXIsdGhpcy5pbmJvdW5kTGF5ZXJzPWEuaW5ib3VuZExheWVycyx0aGlzLm5vZGVJbmRpY2VzPWEubm9kZUluZGljZXMsdGhpcy50ZW5zb3JJbmRpY2VzPWEudGVuc29ySW5kaWNlcyx0aGlzLmlucHV0VGVuc29ycz1hLmlucHV0VGVuc29ycyx0aGlzLm91dHB1dFRlbnNvcnM9YS5vdXRwdXRUZW5zb3JzLHRoaXMuaW5wdXRNYXNrcz1hLmlucHV0TWFza3MsdGhpcy5vdXRwdXRNYXNrcz1hLm91dHB1dE1hc2tzLHRoaXMuaW5wdXRTaGFwZXM9YS5pbnB1dFNoYXBlcyx0aGlzLm91dHB1dFNoYXBlcz1hLm91dHB1dFNoYXBlcztmb3IodmFyIHQ9MCxvPWEuaW5ib3VuZExheWVycyxyO3Q8by5sZW5ndGg7dCsrKXI9b1t0XSxudWxsIT1yJiZyLm91dGJvdW5kTm9kZXMucHVzaCh0aGlzKTthLm91dGJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzLnB1c2godGhpcyl9cmV0dXJuIHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxlPTAsbz10aGlzLmluYm91bmRMYXllcnMsbjtlPG8ubGVuZ3RoO2UrKyluPW9bZV0sbnVsbD09bj9hLnB1c2gobnVsbCk6YS5wdXNoKG4ubmFtZSk7cmV0dXJue291dGJvdW5kTGF5ZXI6dGhpcy5vdXRib3VuZExheWVyP3RoaXMub3V0Ym91bmRMYXllci5uYW1lOm51bGwsaW5ib3VuZExheWVyczphLG5vZGVJbmRpY2VzOnRoaXMubm9kZUluZGljZXMsdGVuc29ySW5kaWNlczp0aGlzLnRlbnNvckluZGljZXN9fSx0fSgpLF9uZXh0TGF5ZXJJRD0wLExheWVyPWZ1bmN0aW9uKHApe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9cC5jYWxsKHRoaXMpfHx0aGlzO3QuX2NhbGxIb29rPW51bGwsdC5fYWRkZWRXZWlnaHROYW1lcz1bXSx0Ll9zdGF0ZWZ1bD0hMSx0LmlkPV9uZXh0TGF5ZXJJRCsrLHQuYWN0aXZpdHlSZWd1bGFyaXplcj1udWxsLHQuaW5wdXRTcGVjPW51bGwsdC5zdXBwb3J0c01hc2tpbmc9ITEsdC5fdHJhaW5hYmxlV2VpZ2h0cz1bXSx0Ll9ub25UcmFpbmFibGVXZWlnaHRzPVtdLHQuX2xvc3Nlcz1bXSx0Ll91cGRhdGVzPVtdLHQuX2J1aWx0PSExLHQuaW5ib3VuZE5vZGVzPVtdLHQub3V0Ym91bmROb2Rlcz1bXTt2YXIgbj1lLm5hbWU7aWYoIW4pe3ZhciBsPXQuZ2V0Q2xhc3NOYW1lKCk7bj10b1NuYWtlQ2FzZShsKStcIl9cIitnZXRVaWQobCl9aWYodC5uYW1lPW4sdC50cmFpbmFibGU9bnVsbD09ZS50cmFpbmFibGV8fGUudHJhaW5hYmxlLHQudXBkYXRhYmxlPW51bGw9PWUudXBkYXRhYmxlfHxlLnVwZGF0YWJsZSxudWxsIT1lLmlucHV0U2hhcGV8fG51bGwhPWUuYmF0Y2hJbnB1dFNoYXBlKXt2YXIgaTtpZihudWxsIT1lLmJhdGNoSW5wdXRTaGFwZSlpPWUuYmF0Y2hJbnB1dFNoYXBlO2Vsc2UgaWYobnVsbCE9ZS5pbnB1dFNoYXBlKXt2YXIgZD1udWxsO251bGwhPWUuYmF0Y2hTaXplJiYoZD1lLmJhdGNoU2l6ZSksaT1bZF0uY29uY2F0KGUuaW5wdXRTaGFwZSl9dC5iYXRjaElucHV0U2hhcGU9aTt2YXIgdT1lLmR0eXBlO251bGw9PXUmJih1PWUuaW5wdXREVHlwZSksbnVsbD09dSYmKHU9XCJmbG9hdDMyXCIpLHQuZHR5cGU9dX1yZXR1cm4gdC5pbml0aWFsV2VpZ2h0cz1udWxsPT1lLndlaWdodHM/bnVsbDplLndlaWdodHMsdC5fcmVmQ291bnQ9bnVsbCx0fXJldHVybiBfX2V4dGVuZHMkMShlLHApLGUubm9kZUtleT1mdW5jdGlvbihhLGUpe3JldHVybiBhLm5hbWUrXCJfaWItXCIrZS50b1N0cmluZygpfSxlLnByb3RvdHlwZS5nZXROb2RlQXRJbmRleD1mdW5jdGlvbihhLGUpe2lmKDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBsYXllciBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQgYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgXCIrZStcIi5cIik7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPD1hKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQXNrZWQgdG8gZ2V0IFwiK2UrXCIgYXQgbm9kZSBcIithK1wiLCBidXQgdGhlIGxheWVyIGhhcyBvbmx5IFwiK3RoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCtcIiBpbmJvdW5kIG5vZGVzLlwiKTtyZXR1cm4gdGhpcy5pbmJvdW5kTm9kZXNbYV19LGUucHJvdG90eXBlLmdldElucHV0QXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleCh0LFwiaW5wdXRcIikuaW5wdXRUZW5zb3JzKX0sZS5wcm90b3R5cGUuZ2V0T3V0cHV0QXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleCh0LFwib3V0cHV0XCIpLm91dHB1dFRlbnNvcnMpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpbnB1dFwiLHtnZXQ6ZnVuY3Rpb24oKXtpZigxPHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsIGhlbmNlIHRoZSBub3Rpb24gb2YgXFxcImxheWVyIGlucHV0XFxcIiBpcyBpbGwtZGVmaW5lZC4gVXNlIGBnZXRJbnB1dEF0KG5vZGVJbmRleClgIGluc3RlYWQuXCIpO2lmKDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGlzIG5vdCBjb25uZWN0ZWQsIG5vIGlucHV0IHRvIHJldHVybi5cIik7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleCgwLFwiaW5wdXRcIikuaW5wdXRUZW5zb3JzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJvdXRwdXRcIix7Z2V0OmZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgaGFzIG5vIGluYm91bmQgbm9kZXMuXCIpO2lmKDE8dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZStcIiBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcywgaGVuY2UgdGhlIG5vdGlvbiBvZiBcXFwibGF5ZXIgb3V0cHV0XFxcIiBpcyBpbGwtZGVmaW5lZC4gVXNlIGBnZXRPdXRwdXRBdChub2RlSW5kZXgpYCBpbnN0ZWFkLlwiKTtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KDAsXCJvdXRwdXRcIikub3V0cHV0VGVuc29ycyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibG9zc2VzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sb3NzZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9zc2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG9zc2VzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInVwZGF0ZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VwZGF0ZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiYnVpbHRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1aWx0fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fYnVpbHQ9dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZT90aGlzLl90cmFpbmFibGVXZWlnaHRzOltdfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cz10fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuX25vblRyYWluYWJsZVdlaWdodHM6dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyl9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzPXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwid2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLm5vblRyYWluYWJsZVdlaWdodHMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInN0YXRlZnVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZWZ1bH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5yZXNldFN0YXRlcz1mdW5jdGlvbigpe2lmKCF0aGlzLnN0YXRlZnVsKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIHRoZSByZXNldFN0YXRlcygpIG1ldGhvZCBvZiBhIG5vbi1zdGF0ZWZ1bCBMYXllciBvYmplY3QuXCIpfSxlLnByb3RvdHlwZS5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHk9ZnVuY3Rpb24obSl7aWYobT10b0xpc3QobSksbnVsbCE9dGhpcy5pbnB1dFNwZWMmJjAhPT10aGlzLmlucHV0U3BlYy5sZW5ndGgpe3ZhciBnPXRvTGlzdCh0aGlzLmlucHV0U3BlYyk7aWYobS5sZW5ndGghPT1nLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZStcIiBleHBlY3RzIFwiK2cubGVuZ3RoK1wiIGlucHV0cywgYnV0IGl0IHJlY2VpdmVkIFwiK20ubGVuZ3RoK1wiIGlucHV0IHRlbnNvcnMuIElucHV0IHJlY2VpdmVkOiBcIittKTtmb3IodmFyIHQ9MDt0PG0ubGVuZ3RoO3QrKyl7dmFyIGY9bVt0XSxyPWdbdF07aWYobnVsbCE9cil7dmFyIGk9Zi5yYW5rO2lmKG51bGwhPXIubmRpbSYmaSE9PXIubmRpbSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK3QrXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBuZGltPVwiK3IubmRpbStcIiwgZm91bmQgbmRpbT1cIitpKTtpZihudWxsIT1yLm1heE5EaW0mJmk+ci5tYXhORGltKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrdCtcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIG1heF9uZGltPVwiK3IubWF4TkRpbStcIiwgZm91bmQgbmRpbT1cIitpKTtpZihudWxsIT1yLm1pbk5EaW0mJmk8ci5taW5ORGltKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrdCtcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIG1pbl9uZGltPVwiK3IubWluTkRpbStcIiwgZm91bmQgbmRpbT1cIitpK1wiLlwiKTtpZihudWxsIT1yLmR0eXBlJiZmLmR0eXBlIT09ci5kdHlwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK3QrXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiIDogZXhwZWN0ZWQgZHR5cGU9XCIrci5kdHlwZStcIiwgZm91bmQgZHR5cGU9XCIrZi5kdHlwZStcIi5cIik7aWYoci5heGVzKXt2YXIgYT1mLnNoYXBlO2Zvcih2YXIgbyBpbiByLmF4ZXMpe3ZhciBzPStvLGw9ci5heGVzW29dLHU9MDw9cz9hW3NdOmFbYS5sZW5ndGgrc107aWYobnVsbCE9bCYmLTE9PT1bbCxudWxsXS5pbmRleE9mKHUpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrdCtcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIGF4aXMgXCIrcytcIiBvZiBpbnB1dCBzaGFwZSB0byBoYXZlIHZhbHVlIFwiK2wrXCIgYnV0IGdvdCBzaGFwZSBcIithK1wiLlwiKX19aWYobnVsbCE9ci5zaGFwZSlmb3IodmFyIGM9MDtjPHIuc2hhcGUubGVuZ3RoOysrYyl7dmFyIHk9ci5zaGFwZVtjXSxoPWYuc2hhcGVbY107aWYobnVsbCE9eSYmbnVsbCE9aCYmeSE9PWgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIit0K1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgc2hhcGU9XCIrci5zaGFwZStcIiwgZm91bmQgc2hhcGU9JHt4U2hhcGV9LlwiKX19fX19LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGUucHJvdG90eXBlLmludm9rZUNhbGxIb29rPWZ1bmN0aW9uKGEsZSl7bnVsbCE9dGhpcy5fY2FsbEhvb2smJnRoaXMuX2NhbGxIb29rKGEsZSl9LGUucHJvdG90eXBlLnNldENhbGxIb29rPWZ1bmN0aW9uKHQpe3RoaXMuX2NhbGxIb29rPXR9LGUucHJvdG90eXBlLmNsZWFyQ2FsbEhvb2s9ZnVuY3Rpb24oKXt0aGlzLl9jYWxsSG9vaz1udWxsfSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbih5LGUpe3ZhciBiPXRoaXM7ZT1lfHx7fSx0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7Zm9yKHZhciBuPXRvTGlzdCh5KSxyPSEwLHA9MCxkPW47cDxkLmxlbmd0aDtwKyspaWYoIShkW3BdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcikpe3I9ITE7YnJlYWt9Zm9yKHZhciB4PSEwLG89MCxjPW47bzxjLmxlbmd0aDtvKyspaWYoY1tvXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3Ipe3g9ITE7YnJlYWt9aWYocj09eCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFyZ3VtZW50cyB0byBhcHBseSgpIG11c3QgYmUgYWxsIFN5bWJvbGljVGVuc29ycyBvciBhbGwgVGVuc29yc1wiKTtyZXR1cm4gbmFtZVNjb3BlKHRoaXMubmFtZSxmdW5jdGlvbigpe2lmKCFiLmJ1aWx0KXtiLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eSh5KTtmb3IodmFyIHQ9W10scj0wLHM9dG9MaXN0KHkpLG87cjxzLmxlbmd0aDtyKyspbz1zW3JdLHQucHVzaChvLnNoYXBlKTtiLmJ1aWxkKHNpbmdsZXRvbk9yQXJyYXkodCkpLGIuYnVpbHQ9ITAsYi5pbml0aWFsV2VpZ2h0cyYmYi5zZXRXZWlnaHRzKGIuaW5pdGlhbFdlaWdodHMpLG51bGw9PT1iLl9yZWZDb3VudCYmeCYmKGIuX3JlZkNvdW50PTEpfWlmKGIuYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KHkpLHgpe2Zvcih2YXIgaT1bXSx1PTAsTj10b0xpc3QoZj1iLmNhbGwoeSxlKSkscDt1PE4ubGVuZ3RoO3UrKylwPU5bdV0sLTEhPT1uLmluZGV4T2YocCkmJihwPXAuY2xvbmUoKSksaS5wdXNoKHApO2lmKGY9c2luZ2xldG9uT3JBcnJheShpKSxudWxsIT1iLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIGZ9dmFyIEk9Y29sbGVjdElucHV0U2hhcGUoeSksZD1iLmNvbXB1dGVPdXRwdXRTaGFwZShJKSxmPXZvaWQgMCx2PWd1ZXNzT3V0cHV0RFR5cGUoeSk7aWYoYi53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlKEFycmF5LmlzQXJyYXkoeSk/SVswXTpJKSxmPW51bGwhPWQmJjA8ZC5sZW5ndGgmJkFycmF5LmlzQXJyYXkoZFswXSk/ZC5tYXAoZnVuY3Rpb24odCxhKXtyZXR1cm4gbmV3IFN5bWJvbGljVGVuc29yKHYsdCxiLHRvTGlzdCh5KSxlLGIubmFtZSxhKX0pOm5ldyBTeW1ib2xpY1RlbnNvcih2LGQsYix0b0xpc3QoeSksZSxiLm5hbWUpLGIuYWRkSW5ib3VuZE5vZGUoeSxmLG51bGwsbnVsbCxJLGQsZSksYi5fcmVmQ291bnQrKyxudWxsIT1iLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIGZ9KX0sZS5wcm90b3R5cGUud2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZT1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmJhdGNoSW5wdXRTaGFwZSlpZihhLmxlbmd0aCE9PXRoaXMuYmF0Y2hJbnB1dFNoYXBlLmxlbmd0aCljb25zb2xlLndhcm4oXCJUaGUgcmFuayBvZiB0aGUgaW5wdXQgdGVuc29yIHByb3ZpZGVkIChzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoYSkrXCIpIGRvZXMgbm90IG1hdGNoIHRoYXQgb2YgdGhlIGJhdGNoSW5wdXRTaGFwZSAoXCIrSlNPTi5zdHJpbmdpZnkodGhpcy5iYXRjaElucHV0U2hhcGUpK1wiKSBvZiB0aGUgbGF5ZXIgXCIrdGhpcy5uYW1lKTtlbHNle3ZhciBlPSExO3RoaXMuYmF0Y2hJbnB1dFNoYXBlLmZvckVhY2goZnVuY3Rpb24odCxuKXtudWxsIT10JiZudWxsIT1hW25dJiZhW25dIT09dCYmKGU9ITApfSksZSYmY29uc29sZS53YXJuKFwiVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0ZW5zb3IgKFwiK0pTT04uc3RyaW5naWZ5KGEpK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0YXRpb24gb2YgbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBcIitKU09OLnN0cmluZ2lmeSh0aGlzLmJhdGNoSW5wdXRTaGFwZSkpfX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0U2hhcGVcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5pbmJvdW5kTm9kZXN8fDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiVGhlIGxheWVyIFwiK3RoaXMubmFtZStcIiBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQgYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgb3V0cHV0IHNoYXBlLlwiKTtmb3IodmFyIG89W10sZT0wLHM9dGhpcy5pbmJvdW5kTm9kZXM7ZTxzLmxlbmd0aDtlKyspe3ZhciBuPXNbZV0scj1KU09OLnN0cmluZ2lmeShuLm91dHB1dFNoYXBlcyk7LTE9PT1vLmluZGV4T2YocikmJm8ucHVzaChyKX1pZigxPT09by5sZW5ndGgpe3ZhciBpPXRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcztyZXR1cm4gQXJyYXkuaXNBcnJheShpKSYmQXJyYXkuaXNBcnJheShpWzBdKSYmMT09PWkubGVuZ3RoP2lbMF06aX10aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJUaGUgbGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzIHdpdGggZGlmZmVyZW50IG91dHB1dCBzaGFwZXMuIEhlbmNlIHRoZSBub3Rpb24gb2YgXFxcIm91dHV0IHNoYXBlXFxcIiBpcyBpbGwtZGVmaW5lZCBmb3IgdGhlIGxheWVyLlwiKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5jb3VudFBhcmFtcz1mdW5jdGlvbigpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJZb3UgdHJpZWQgdG8gY2FsbCBjb3VudFBhcmFtcygpIG9uIFwiK3RoaXMubmFtZStcIiwgYnV0IHRoZSBsYXllciBpcyBub3QgYnVpbHQgeWV0LiBCdWlsZCBpdCBmaXJzdCBieSBjYWxsaW5nIGJ1aWxkKGJhdGNoSW5wdXRTaGFwZSkuXCIpO3JldHVybiBjb3VudFBhcmFtc0luV2VpZ2h0cyh0aGlzLndlaWdodHMpfSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbigpe3RoaXMuYnVpbHQ9ITB9LGUucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSxiYXRjaEdldFZhbHVlKHQ/dGhpcy50cmFpbmFibGVXZWlnaHRzOnRoaXMud2VpZ2h0cyl9LGUucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24ocCl7dmFyIGU9dGhpczt0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9ZS53ZWlnaHRzO2lmKHQubGVuZ3RoIT09cC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJZb3UgY2FsbGVkIHNldFdlaWdodHMod2VpZ2h0cykgb24gbGF5ZXIgXFxcIlwiK2UubmFtZStcIlxcXCIgd2l0aCBhIHdlaWdodCBsaXN0IG9mIGxlbmd0aCBcIitwLmxlbmd0aCtcIiwgYnV0IHRoZSBsYXllciB3YXMgZXhwZWN0aW5nIFwiK3QubGVuZ3RoK1wiIHdlaWdodHMuIFByb3ZpZGVkIHdlaWdodHM6IFwiK3ArXCIuLi5cIik7aWYoMCE9PXQubGVuZ3RoKXtmb3IodmFyIG49W10scj1iYXRjaEdldFZhbHVlKHQpLGk9MDtpPHIubGVuZ3RoOysraSl7dmFyIGQ9cltpXSxvPXRbaV0scz1wW2ldO2lmKCF1dGlsLmFycmF5c0VxdWFsKGQuc2hhcGUscy5zaGFwZSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllciB3ZWlnaHQgc2hhcGUgXCIrZC5zaGFwZStcIiBub3QgY29tcGF0aWJsZSB3aXRoIHByb3ZpZGVkIHdlaWdodCBzaGFwZSBcIitzLnNoYXBlKTtuLnB1c2goW28sc10pfWJhdGNoU2V0VmFsdWUobil9fSl9LGUucHJvdG90eXBlLmFkZFdlaWdodD1mdW5jdGlvbihwLGUsdCxsLHIsaSxkKXtpZigtMSE9PXRoaXMuX2FkZGVkV2VpZ2h0TmFtZXMuaW5kZXhPZihwKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgbmFtZSBcIitwK1wiIGZvciBsYXllciBcIit0aGlzLm5hbWUpO3RoaXMuX2FkZGVkV2VpZ2h0TmFtZXMucHVzaChwKSxudWxsPT10JiYodD1cImZsb2F0MzJcIik7dmFyIG89bmV3IExheWVyVmFyaWFibGUobC5hcHBseShlLHQpLHQscCxpLGQpO3JldHVybiBudWxsIT1yJiZ0aGlzLmFkZExvc3MoZnVuY3Rpb24oKXtyZXR1cm4gci5hcHBseShvLnJlYWQoKSl9KSxudWxsPT1pJiYoaT0hMCksaT90aGlzLl90cmFpbmFibGVXZWlnaHRzLnB1c2gobyk6dGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cy5wdXNoKG8pLG99LGUucHJvdG90eXBlLmFkZExvc3M9ZnVuY3Rpb24oYSl7dmFyIG47bnVsbD09YXx8QXJyYXkuaXNBcnJheShhKSYmMD09PWEubGVuZ3RofHwoYT10b0xpc3QoYSksdm9pZCAwIT09dGhpcy5fbG9zc2VzJiZudWxsIT09dGhpcy5fbG9zc2VzJiYobj10aGlzLmxvc3NlcykucHVzaC5hcHBseShuLGEpKX0sZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxlLnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihhLGUpe3ZhciB0PXRoaXM7aWYoIXRoaXMuc3VwcG9ydHNNYXNraW5nKXtpZihudWxsIT1lKXtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGRvZXMgbm90IHN1cHBvcnQgbWFza2luZyxidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suXCIpO2UuZm9yRWFjaChmdW5jdGlvbihhKXtpZihudWxsIT1hKXRocm93IG5ldyBUeXBlRXJyb3IoXCJMYXllciBcIit0Lm5hbWUrXCIgZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLGJ1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay5cIil9KX1yZXR1cm4gbnVsbH1yZXR1cm4gZX0sZS5wcm90b3R5cGUuYWRkSW5ib3VuZE5vZGU9ZnVuY3Rpb24obSxlLGcseSxiLHgsTil7dm9pZCAwPT09TiYmKE49bnVsbCk7dmFyIEk9dG9MaXN0KG0pO2U9dG9MaXN0KGUpLGc9dG9MaXN0KGcpLHk9dG9MaXN0KHkpLGI9bm9ybWFsaXplU2hhcGVMaXN0KGIpLHg9bm9ybWFsaXplU2hhcGVMaXN0KHgpO2Zvcih2YXIgcz1bXSxsPVtdLHU9W10sYz0wLHY9SSxoO2M8di5sZW5ndGg7YysrKWg9dltjXSxzLnB1c2goaC5zb3VyY2VMYXllciksbC5wdXNoKGgubm9kZUluZGV4KSx1LnB1c2goaC50ZW5zb3JJbmRleCk7bmV3IE5vZGUoe291dGJvdW5kTGF5ZXI6dGhpcyxpbmJvdW5kTGF5ZXJzOnMsbm9kZUluZGljZXM6bCx0ZW5zb3JJbmRpY2VzOnUsaW5wdXRUZW5zb3JzOkksb3V0cHV0VGVuc29yczplLGlucHV0TWFza3M6ZyxvdXRwdXRNYXNrczp5LGlucHV0U2hhcGVzOmIsb3V0cHV0U2hhcGVzOnh9LE4pO2Zvcih2YXIgUz0wO1M8ZS5sZW5ndGg7UysrKWVbU10uc291cmNlTGF5ZXI9dGhpcyxlW1NdLm5vZGVJbmRleD10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgtMSxlW1NdLnRlbnNvckluZGV4PVN9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtuYW1lOnRoaXMubmFtZSx0cmFpbmFibGU6dGhpcy50cmFpbmFibGV9O3JldHVybiBudWxsIT10aGlzLmJhdGNoSW5wdXRTaGFwZSYmKHQuYmF0Y2hJbnB1dFNoYXBlPXRoaXMuYmF0Y2hJbnB1dFNoYXBlKSxudWxsIT10aGlzLmR0eXBlJiYodC5kdHlwZT10aGlzLmR0eXBlKSx0fSxlLnByb3RvdHlwZS5kaXNwb3NlV2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndlaWdodHMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5kaXNwb3NlKCl9KSx0aGlzLndlaWdodHMubGVuZ3RofSxlLnByb3RvdHlwZS5hc3NlcnROb3REaXNwb3NlZD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLl9yZWZDb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJMYXllciAnXCIrdGhpcy5uYW1lK1wiJyBpcyBhbHJlYWR5IGRpc3Bvc2VkLlwiKX0sZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXNwb3NlIExheWVyIFwiK3RoaXMubmFtZStcIiBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiBidWlsdCB5ZXQuXCIpO2lmKG51bGw9PT10aGlzLl9yZWZDb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGlzcG9zZSBMYXllciBcIit0aGlzLm5hbWUrXCIgYmVjYXVzZSBpdCBoYXMgbm90IGJlZW4gdXNlZCB5ZXQuXCIpO3RoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTt2YXIgdD0wO3JldHVybiAwPT0tLXRoaXMuX3JlZkNvdW50JiYodD10aGlzLmRpc3Bvc2VXZWlnaHRzKCkpLHtyZWZDb3VudEFmdGVyRGlzcG9zZTp0aGlzLl9yZWZDb3VudCxudW1EaXNwb3NlZFZhcmlhYmxlczp0fX0sZX0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpLElucHV0TGF5ZXI9ZnVuY3Rpb24obyl7ZnVuY3Rpb24gZShlKXt2YXIgdD1vLmNhbGwodGhpcyx7ZHR5cGU6ZS5kdHlwZSxuYW1lOm51bGw9PWUubmFtZT9nZXRVaWQoXCJpbnB1dFwiKS50b1N0cmluZygpOmUubmFtZX0pfHx0aGlzO2lmKG51bGw9PWUuYmF0Y2hTaXplJiYoZS5iYXRjaFNpemU9bnVsbCksbnVsbD09ZS5zcGFyc2UmJihlLnNwYXJzZT0hMSksdC50cmFpbmFibGU9ITEsdC5idWlsdD0hMCx0LnNwYXJzZT1lLnNwYXJzZSxudWxsIT1lLmlucHV0U2hhcGUmJm51bGwhPWUuYmF0Y2hJbnB1dFNoYXBlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiT25seSBwcm92aWRlIHRoZSBpbnB1dFNoYXBlIE9SIGJhdGNoSW5wdXRTaGFwZSBhcmd1bWVudCB0byBpbnB1dExheWVyLCBub3QgYm90aCBhdCB0aGUgc2FtZSB0aW1lLlwiKTt2YXIgbj1lLmJhdGNoSW5wdXRTaGFwZTtpZihudWxsPT1uKXtpZihudWxsPT1lLmlucHV0U2hhcGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbiBJbnB1dExheWVyIHNob3VsZCBiZSBwYXNzZWQgZWl0aGVyIGEgYGJhdGNoSW5wdXRTaGFwZWAgb3IgYW4gYGlucHV0U2hhcGVgLlwiKTtuPVtlLmJhdGNoU2l6ZV0uY29uY2F0KGUuaW5wdXRTaGFwZSl9ZWxzZSBpZihudWxsIT1lLmJhdGNoU2l6ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJhdGNoU2l6ZSBpZiBiYXRjaElucHV0U2hhcGUgaXNzcGVjaWZpZWQgd2hlbiBjcmVhdGluZyBhbiBJbnB1dExheWVyLlwiKTt2YXIgcz1lLmR0eXBlfHxcImZsb2F0MzJcIjt0LmJhdGNoSW5wdXRTaGFwZT1uLHQuZHR5cGU9cyx0LmlucHV0U3BlYz1be3NoYXBlOm59XTt2YXIgaT1uZXcgU3ltYm9saWNUZW5zb3IodC5kdHlwZSx0LmJhdGNoSW5wdXRTaGFwZSx0LFtdLHt9LHQubmFtZSk7cmV0dXJuIGkubm9kZUluZGV4PTAsaS50ZW5zb3JJbmRleD0wLG5ldyBOb2RlKHtvdXRib3VuZExheWVyOnQsaW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczpbaV0sb3V0cHV0VGVuc29yczpbaV0saW5wdXRNYXNrczpbbnVsbF0sb3V0cHV0TWFza3M6W251bGxdLGlucHV0U2hhcGVzOltuXSxvdXRwdXRTaGFwZXM6W25dfSksdH1yZXR1cm4gX19leHRlbmRzJDEoZSxvKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbigpe3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IHBhc3MgYW55IGlucHV0IHRvIGFuIElucHV0TGF5ZXIncyBhcHBseSgpIG1ldGhvZC4gSW5wdXRMYXllciBuYW1lOiBcIit0aGlzLm5hbWUpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJue3JlZkNvdW50QWZ0ZXJEaXNwb3NlOnRoaXMuX3JlZkNvdW50LG51bURpc3Bvc2VkVmFyaWFibGVzOjB9fSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57YmF0Y2hJbnB1dFNoYXBlOnRoaXMuYmF0Y2hJbnB1dFNoYXBlLGR0eXBlOnRoaXMuZHR5cGUsc3BhcnNlOnRoaXMuc3BhcnNlLG5hbWU6dGhpcy5uYW1lfX0sZS5jbGFzc05hbWU9XCJJbnB1dExheWVyXCIsZX0oTGF5ZXIpLE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSW5wdXRMYXllciksZnVuY3Rpb24odCl7dFt0LlNJTEVOVD0wXT1cIlNJTEVOVFwiLHRbdC5WRVJCT1NFPTFdPVwiVkVSQk9TRVwifShNb2RlbExvZ2dpbmdWZXJib3NpdHl8fChNb2RlbExvZ2dpbmdWZXJib3NpdHk9e30pKTt2YXIgQmFzZUNhbGxiYWNrPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMudmFsaWRhdGlvbkRhdGE9bnVsbH1yZXR1cm4gdC5wcm90b3R5cGUuc2V0UGFyYW1zPWZ1bmN0aW9uKHQpe3RoaXMucGFyYW1zPXR9LHQucHJvdG90eXBlLm9uRXBvY2hCZWdpbj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuWzJdfSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuWzJdfSl9KX0sdC5wcm90b3R5cGUub25CYXRjaEJlZ2luPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm5bMl19KX0pfSx0LnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm5bMl19KX0pfSx0LnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbigpe3JldHVyblsyXX0pfSl9LHQucHJvdG90eXBlLm9uVHJhaW5FbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbigpe3JldHVyblsyXX0pfSl9LHQucHJvdG90eXBlLnNldE1vZGVsPWZ1bmN0aW9uKCl7fSx0fSgpLENhbGxiYWNrTGlzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoYSxuKXt2b2lkIDA9PT1uJiYobj0xMCksbnVsbD09YSYmKGE9W10pLHRoaXMuY2FsbGJhY2tzPWEsdGhpcy5xdWV1ZUxlbmd0aD1ufXJldHVybiB0LnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24odCl7dGhpcy5jYWxsYmFja3MucHVzaCh0KX0sdC5wcm90b3R5cGUuc2V0UGFyYW1zPWZ1bmN0aW9uKGEpe2Zvcih2YXIgZT0wLHI9dGhpcy5jYWxsYmFja3M7ZTxyLmxlbmd0aDtlKyspcltlXS5zZXRQYXJhbXMoYSl9LHQucHJvdG90eXBlLnNldE1vZGVsPWZ1bmN0aW9uKGEpe2Zvcih2YXIgZT0wLHI9dGhpcy5jYWxsYmFja3M7ZTxyLmxlbmd0aDtlKyspcltlXS5zZXRNb2RlbChhKX0sdC5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LG87cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOm51bGw9PWUmJihlPXt9KSx0PTAsbz10aGlzLmNhbGxiYWNrcyxuLmxhYmVsPTE7Y2FzZSAxOnJldHVybiB0PG8ubGVuZ3RoP1s0LG9bdF0ub25FcG9jaEJlZ2luKGEsZSldOlszLDRdO2Nhc2UgMjpuLnNlbnQoKSxuLmxhYmVsPTM7Y2FzZSAzOnJldHVybiB0KyssWzMsMV07Y2FzZSA0OnJldHVyblsyXTt9fSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihhLGUpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxvO3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpudWxsPT1lJiYoZT17fSksdD0wLG89dGhpcy5jYWxsYmFja3Msbi5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gdDxvLmxlbmd0aD9bNCxvW3RdLm9uRXBvY2hFbmQoYSxlKV06WzMsNF07Y2FzZSAyOm4uc2VudCgpLG4ubGFiZWw9MztjYXNlIDM6cmV0dXJuIHQrKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdO319KX0pfSx0LnByb3RvdHlwZS5vbkJhdGNoQmVnaW49ZnVuY3Rpb24oYSxlKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsbztyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6bnVsbD09ZSYmKGU9e30pLHQ9MCxvPXRoaXMuY2FsbGJhY2tzLG4ubGFiZWw9MTtjYXNlIDE6cmV0dXJuIHQ8by5sZW5ndGg/WzQsb1t0XS5vbkJhdGNoQmVnaW4oYSxlKV06WzMsNF07Y2FzZSAyOm4uc2VudCgpLG4ubGFiZWw9MztjYXNlIDM6cmV0dXJuIHQrKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdO319KX0pfSx0LnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LG87cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT1lJiYoZT17fSksWzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3MoZSldO2Nhc2UgMTpuLnNlbnQoKSx0PTAsbz10aGlzLmNhbGxiYWNrcyxuLmxhYmVsPTI7Y2FzZSAyOnJldHVybiB0PG8ubGVuZ3RoP1s0LG9bdF0ub25CYXRjaEVuZChhLGUpXTpbMyw1XTtjYXNlIDM6bi5zZW50KCksbi5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gdCsrLFszLDJdO2Nhc2UgNTpyZXR1cm5bMl07fX0pfSl9LHQucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbihhKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbztyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6bnVsbD09YSYmKGE9e30pLGU9MCxvPXRoaXMuY2FsbGJhY2tzLHQubGFiZWw9MTtjYXNlIDE6cmV0dXJuIGU8by5sZW5ndGg/WzQsb1tlXS5vblRyYWluQmVnaW4oYSldOlszLDRdO2Nhc2UgMjp0LnNlbnQoKSx0LmxhYmVsPTM7Y2FzZSAzOnJldHVybiBlKyssWzMsMV07Y2FzZSA0OnJldHVyblsyXTt9fSl9KX0sdC5wcm90b3R5cGUub25UcmFpbkVuZD1mdW5jdGlvbihhKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbztyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6bnVsbD09YSYmKGE9e30pLGU9MCxvPXRoaXMuY2FsbGJhY2tzLHQubGFiZWw9MTtjYXNlIDE6cmV0dXJuIGU8by5sZW5ndGg/WzQsb1tlXS5vblRyYWluRW5kKGEpXTpbMyw0XTtjYXNlIDI6dC5zZW50KCksdC5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gZSsrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl07fX0pfSl9LHR9KCksTW9kZWxUcmFpbmluZ1lpZWxkZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKHQpe3RoaXMueWllbGRFdmVyeT10LHRoaXMuYmF0Y2hDb3VudD0wLHRoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXM9W10sdGhpcy5hdXRvWWllbGRFdmVyeUJhdGNoZXM9bnVsbCx0aGlzLmJhdGNoU3RhcnRNaWxsaXM9dXRpbC5ub3coKX1yZXR1cm4gYS5wcm90b3R5cGUucmVzb2x2ZU9uZVRlbnNvckluTG9ncz1mdW5jdGlvbihzKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbyxwLGwsZDtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6Zm9yKG8gaW4gZT1bXSxzKWUucHVzaChvKTtwPTAsdC5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gcDxlLmxlbmd0aD8obD1lW3BdLFwibnVtYmVyXCI9PXR5cGVvZihkPXNbbF0pP1szLDNdOls0LGQuZGF0YSgpXSk6WzMsNF07Y2FzZSAyOnJldHVybiB0LnNlbnQoKSxbMyw0XTtjYXNlIDM6cmV0dXJuIHArKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdO319KX0pfSxhLnByb3RvdHlwZS5tYXliZVlpZWxkT25CYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsbztyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuXCJhdXRvXCI9PT10aGlzLnlpZWxkRXZlcnk/KHRoaXMuYmF0Y2hDb3VudCsrLG51bGw9PXRoaXMuYXV0b1lpZWxkRXZlcnlCYXRjaGVzP1s0LHRoaXMucmVzb2x2ZU9uZVRlbnNvckluTG9ncyhlKV06WzMsM10pOlszLDddO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksdD11dGlsLm5vdygpLFs0LG5leHRGcmFtZSgpXTtjYXNlIDI6cmV0dXJuIG4uc2VudCgpLHRoaXMuYmF0Y2hDb3VudD5hLlNLSVBfRklSU1RfQkFUQ0hFUyYmKHRoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXMucHVzaCh0LXRoaXMuYmF0Y2hTdGFydE1pbGxpcyksdGhpcy5iYXRjaER1cmF0aW9uc01pbGxpcy5sZW5ndGg+PWEuREVDSVNJT05fQkFUQ0hfQ09VTlQmJihvPXRoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXMucmVkdWNlKGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGErZX0pL3RoaXMuYmF0Y2hEdXJhdGlvbnNNaWxsaXMubGVuZ3RoLHRoaXMuYXV0b1lpZWxkRXZlcnlCYXRjaGVzPV9NYXRocm91bmQoYS5USFJFU0hPTERfTUlMTElTL28pLDE+dGhpcy5hdXRvWWllbGRFdmVyeUJhdGNoZXMmJih0aGlzLmF1dG9ZaWVsZEV2ZXJ5QmF0Y2hlcz0xKSkpLHRoaXMuYmF0Y2hTdGFydE1pbGxpcz11dGlsLm5vdygpLHRoaXMubGFzdFlpZWxkQmF0Y2hDb3VudD10aGlzLmJhdGNoQ291bnQsWzMsNl07Y2FzZSAzOnJldHVybiB0aGlzLmJhdGNoQ291bnQtdGhpcy5sYXN0WWllbGRCYXRjaENvdW50Pj10aGlzLmF1dG9ZaWVsZEV2ZXJ5QmF0Y2hlcz9bNCxuZXh0RnJhbWUoKV06WzMsNl07Y2FzZSA0OnJldHVybiBuLnNlbnQoKSxbNCx0aGlzLnJlc29sdmVPbmVUZW5zb3JJbkxvZ3MoZSldO2Nhc2UgNTpuLnNlbnQoKSx0aGlzLmxhc3RZaWVsZEJhdGNoQ291bnQ9dGhpcy5iYXRjaENvdW50LG4ubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzMsOV07Y2FzZSA3OnJldHVyblwiYmF0Y2hcIj09PXRoaXMueWllbGRFdmVyeT9bNCxuZXh0RnJhbWUoKV06WzMsOV07Y2FzZSA4Om4uc2VudCgpLG4ubGFiZWw9OTtjYXNlIDk6cmV0dXJuWzJdO319KX0pfSxhLnByb3RvdHlwZS5tYXliZVlpZWxkT25FcG9jaD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuXCJlcG9jaFwiPT09dGhpcy55aWVsZEV2ZXJ5P1s0LG5leHRGcmFtZSgpXTpbMywyXTtjYXNlIDE6dC5zZW50KCksdC5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMl07fX0pfSl9LGEuU0tJUF9GSVJTVF9CQVRDSEVTPTEsYS5ERUNJU0lPTl9CQVRDSF9DT1VOVD0yLGEuVEhSRVNIT0xEX01JTExJUz0xNixhfSgpLEJhc2VMb2dnZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHQueWllbGRFdmVyeT1lfHxcImF1dG9cIix0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXV0b1lpZWxkZXI9bmV3IE1vZGVsVHJhaW5pbmdZaWVsZGVyKHRoaXMueWllbGRFdmVyeSksWzJdfSl9KX0sZS5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWVuPTAsdGhpcy50b3RhbHM9e30sWzJdfSl9KX0sZS5wcm90b3R5cGUub25CYXRjaEVuZD1mdW5jdGlvbihhLHMpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzLGEscCxsLGQ7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuYXV0b1lpZWxkZXIubWF5YmVZaWVsZE9uQmF0Y2gocyldO2Nhc2UgMTpmb3IoZCBpbiBlLnNlbnQoKSxudWxsPT1zJiYocz17fSksYT1udWxsPT1zLnNpemU/MDpzLnNpemUsdGhpcy5zZWVuKz1hLHA9ZnVuY3Rpb24oZSl7dmFyIG49c1tlXTtpZihcIm51bWJlclwiPT10eXBlb2YgbilsLnRvdGFscy5oYXNPd25Qcm9wZXJ0eShlKXx8KGwudG90YWxzW2VdPTApLGwudG90YWxzW2VdKz1uKmE7ZWxzZXt2YXIgcjtlIGluIGwudG90YWxzP3I9bC50b3RhbHNbZV06bC50b3RhbHNbZV09Z2V0U2NhbGFyKDApLGwudG90YWxzW2VdPXRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gYWRkKHQudG90YWxzW2VdLG11bChuLGdldFNjYWxhcihhKSkpfSksbnVsbCE9ciYmci5kaXNwb3NlKCl9fSxsPXRoaXMscylwKGQpO3JldHVyblsyXTt9fSl9KX0sZS5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihhLHApe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzLG8scyxsLGQsdTtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5hdXRvWWllbGRlci5tYXliZVlpZWxkT25FcG9jaCgpXTtjYXNlIDE6aWYoZS5zZW50KCksbnVsbCE9cClmb3Iobz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09cy50b3RhbHNbYV0/XCJjb250aW51ZVwiOnZvaWQoXCJudW1iZXJcIj09dHlwZW9mIHMudG90YWxzW2FdP3BbYV09cy50b3RhbHNbYV0vcy5zZWVuOnRpZHkoZnVuY3Rpb24oKXtwW2FdPW11bChkaXYoZ2V0U2NhbGFyKDEpLGdldFNjYWxhcih0LnNlZW4pKSx0LnRvdGFsc1thXSksdC50b3RhbHNbYV0uZGlzcG9zZSgpLGtlZXAocFthXSl9KSl9LHM9dGhpcyxsPTAsZD10aGlzLnBhcmFtcy5tZXRyaWNzO2w8ZC5sZW5ndGg7bCsrKXU9ZFtsXSxvKHUpO3JldHVyblsyXTt9fSl9KX0sZX0oQmFzZUNhbGxiYWNrKSxIaXN0b3J5PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXBvY2g9W10sdGhpcy5oaXN0b3J5PXt9LFsyXX0pfSl9LGUucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbigpe2Zvcih0IGluIG51bGw9PWUmJihlPXt9KSx0aGlzLmVwb2NoLnB1c2goYSksZSludWxsPT10aGlzLmhpc3RvcnlbdF0mJih0aGlzLmhpc3RvcnlbdF09W10pLHRoaXMuaGlzdG9yeVt0XS5wdXNoKGVbdF0pO3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLnN5bmNEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBwLGQsYyx1LG0saCxnLGYseTtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6Zm9yKHUgaW4gcD1bXSxkPVtdLGM9W10sdGhpcy5oaXN0b3J5KWZvcihtPXRoaXMuaGlzdG9yeVt1XSxoPTA7aDxtLmxlbmd0aDsrK2gpXCJudW1iZXJcIiE9dHlwZW9mIG1baF0mJihnPW1baF0scC5wdXNoKGcuZGF0YSgpKSxkLnB1c2godSksYy5wdXNoKGgpKTtyZXR1cm5bNCxQcm9taXNlLmFsbChwKV07Y2FzZSAxOmZvcihmPWUuc2VudCgpLHk9MDt5PGYubGVuZ3RoOysreSl0aGlzLmhpc3RvcnlbZFt5XV1bY1t5XV0uZGlzcG9zZSgpLHRoaXMuaGlzdG9yeVtkW3ldXVtjW3ldXT1mW3ldWzBdO3JldHVyblsyXTt9fSl9KX0sZX0oQmFzZUNhbGxiYWNrKSxDdXN0b21DYWxsYmFjaz1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gdC50cmFpbkJlZ2luPWUub25UcmFpbkJlZ2luLHQudHJhaW5FbmQ9ZS5vblRyYWluRW5kLHQuZXBvY2hCZWdpbj1lLm9uRXBvY2hCZWdpbix0LmVwb2NoRW5kPWUub25FcG9jaEVuZCx0LmJhdGNoQmVnaW49ZS5vbkJhdGNoQmVnaW4sdC5iYXRjaEVuZD1lLm9uQmF0Y2hFbmQsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5vbkVwb2NoQmVnaW49ZnVuY3Rpb24oYSxlKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT10aGlzLmVwb2NoQmVnaW4/WzMsM106WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3MoZSldO2Nhc2UgMTpyZXR1cm4gdC5zZW50KCksWzQsdGhpcy5lcG9jaEJlZ2luKGEsZSldO2Nhc2UgMjp0LnNlbnQoKSx0LmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXTt9fSl9KX0sZS5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihhLGUpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMuZXBvY2hFbmQ/WzMsM106WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3MoZSldO2Nhc2UgMTpyZXR1cm4gdC5zZW50KCksWzQsdGhpcy5lcG9jaEVuZChhLGUpXTtjYXNlIDI6dC5zZW50KCksdC5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl07fX0pfSl9LGUucHJvdG90eXBlLm9uQmF0Y2hCZWdpbj1mdW5jdGlvbihhLGUpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMuYmF0Y2hCZWdpbj9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyhlKV07Y2FzZSAxOnJldHVybiB0LnNlbnQoKSxbNCx0aGlzLmJhdGNoQmVnaW4oYSxlKV07Y2FzZSAyOnQuc2VudCgpLHQubGFiZWw9MztjYXNlIDM6cmV0dXJuWzJdO319KX0pfSxlLnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09dGhpcy5iYXRjaEVuZD9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyhlKV07Y2FzZSAxOnJldHVybiB0LnNlbnQoKSxbNCx0aGlzLmJhdGNoRW5kKGEsZSldO2Nhc2UgMjp0LnNlbnQoKSx0LmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXTt9fSl9KX0sZS5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGEpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMudHJhaW5CZWdpbj9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyhhKV07Y2FzZSAxOnJldHVybiBlLnNlbnQoKSxbNCx0aGlzLnRyYWluQmVnaW4oYSldO2Nhc2UgMjplLnNlbnQoKSxlLmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXTt9fSl9KX0sZS5wcm90b3R5cGUub25UcmFpbkVuZD1mdW5jdGlvbihhKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT10aGlzLnRyYWluRW5kP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKGEpXTtjYXNlIDE6cmV0dXJuIGUuc2VudCgpLFs0LHRoaXMudHJhaW5FbmQoYSldO2Nhc2UgMjplLnNlbnQoKSxlLmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXTt9fSl9KX0sZX0oQmFzZUNhbGxiYWNrKSxDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7fXJldHVybiBhLnJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3Rvcj1mdW5jdGlvbihlLHQpe3V0aWwuYXNzZXJ0KDA8PWUmJl9OdW1iZXJpc0ludGVnZXIoZSksXCJWZXJib3NpdHkgbGV2ZWwgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlciA+PSAwLCBidXQgZ290IFwiK2UpLGEuY2hlY2tGb3JEdXBsaWNhdGUodCksbnVsbD09YS5jb25zdHJ1Y3RvcnNbZV0mJihhLmNvbnN0cnVjdG9yc1tlXT1bXSksYS5jb25zdHJ1Y3RvcnNbZV0ucHVzaCh0KX0sYS5jaGVja0ZvckR1cGxpY2F0ZT1mdW5jdGlvbihyKXtmb3IodmFyIGUgaW4gYS5jb25zdHJ1Y3RvcnMpYS5jb25zdHJ1Y3RvcnNbK2VdLmZvckVhY2goZnVuY3Rpb24odCl7aWYodD09PXIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEdXBsaWNhdGUgY2FsbGJhY2sgY29uc3RydWN0b3IuXCIpfSl9LGEuY2xlYXI9ZnVuY3Rpb24oKXthLmNvbnN0cnVjdG9ycz17fX0sYS5jcmVhdGVDYWxsYmFja3M9ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGEuY29uc3RydWN0b3JzKXt2YXIgcj0rbjtlPj1yJiZ0LnB1c2guYXBwbHkodCxhLmNvbnN0cnVjdG9yc1tyXSl9cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdH0pfSxhLmNvbnN0cnVjdG9ycz17fSxhfSgpLG1zZSQxPW1lYW5TcXVhcmVkRXJyb3IkMSxNU0UkMT1tZWFuU3F1YXJlZEVycm9yJDEsbWFlJDE9bWVhbkFic29sdXRlRXJyb3IsTUFFJDE9bWVhbkFic29sdXRlRXJyb3IsbWFwZSQxPW1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcixNQVBFJDE9bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDE9Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHksY29zaW5lJDE9Y29zaW5lUHJveGltaXR5LHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDE9c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHksdmVyc2lvbiQxPVwiMC44LjVcIixDb250YWluZXI9ZnVuY3Rpb24oYWUpe2Z1bmN0aW9uIHgoZSl7dmFyIHQ9YWUuY2FsbCh0aGlzLHt9KXx8dGhpcztpZih0LmNvbnRhaW5lck5vZGVzPW5ldyBTZXQsdC5uYW1lPWUubmFtZSxudWxsPT10Lm5hbWUpe3ZhciBuPXQuZ2V0Q2xhc3NOYW1lKCkudG9Mb3dlckNhc2UoKTt0Lm5hbWU9Z2V0VWlkKG4pfWlmKHQuc3VwcG9ydHNNYXNraW5nPSExLHQudHJhaW5hYmxlPSEwLHQudXBkYXRhYmxlPSEwLHQuaW5wdXRzPUFycmF5LmlzQXJyYXkoZS5pbnB1dHMpP2UuaW5wdXRzLnNsaWNlKCk6W2UuaW5wdXRzXSx0Lm91dHB1dHM9QXJyYXkuaXNBcnJheShlLm91dHB1dHMpP2Uub3V0cHV0cy5zbGljZSgpOltlLm91dHB1dHNdLHVuaXF1ZSh0LmlucHV0cykubGVuZ3RoIT09dC5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGxpc3Qgb2YgaW5wdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgcmVkdW5kYW50LiBBbGwgaW5wdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogXCIrdC5pbnB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk7dW5pcXVlKHQub3V0cHV0cykubGVuZ3RoIT09dC5vdXRwdXRzLmxlbmd0aCYmY29uc29sZS53YXJuKFwiVGhlIGxpc3Qgb2Ygb3V0cHV0cyBwYXNzZWQgdG8gdGhlIG1vZGVsIGlzIHJlZHVuZGFudC4gQWxsIG91dHB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiBcIit0Lm91dHB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSksdC5pbnB1dExheWVycz1bXSx0LmlucHV0TGF5ZXJzTm9kZUluZGljZXM9W10sdC5pbnB1dExheWVyc1RlbnNvckluZGljZXM9W10sdC5vdXRwdXRMYXllcnM9W10sdC5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcz1bXSx0Lm91dHB1dExheWVyc1RlbnNvckluZGljZXM9W10sdC5sYXllcnM9W107Zm9yKHZhciByPTAsaT10Lm91dHB1dHM7cjxpLmxlbmd0aDtyKyspe3ZhciBvPShDPWlbcl0pLnNvdXJjZUxheWVyLG9lPUMubm9kZUluZGV4LHNlPUMudGVuc29ySW5kZXg7dC5vdXRwdXRMYXllcnMucHVzaChvKSx0Lm91dHB1dExheWVyc05vZGVJbmRpY2VzLnB1c2gob2UpLHQub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcy5wdXNoKHNlKX1mb3IodmFyIHBlPTAsbGU9dC5pbnB1dHM7cGU8bGUubGVuZ3RoO3BlKyspbz0oQz1sZVtwZV0pLnNvdXJjZUxheWVyLG9lPUMubm9kZUluZGV4LHNlPUMudGVuc29ySW5kZXgsYXNzZXJ0JDEoMD09PW9lLFwiaW5wdXQgbGF5ZXIgaGFzID4xIG5vZGVzXCIpLGFzc2VydCQxKDA9PT1zZSxcImlucHV0IGxheWVyIGhhcyA+MSB0ZW5zb3JzXCIpLHQuaW5wdXRMYXllcnMucHVzaChvKSx0LmlucHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaChvZSksdC5pbnB1dExheWVyc1RlbnNvckluZGljZXMucHVzaChzZSk7dC5pbnB1dE5hbWVzPVtdLHQub3V0cHV0TmFtZXM9W10sdC5mZWVkSW5wdXRTaGFwZXM9W10sdC5mZWVkSW5wdXROYW1lcz1bXSx0LmZlZWRPdXRwdXROYW1lcz1bXTtmb3IodmFyIHA9MDtwPHQuaW5wdXRMYXllcnMubGVuZ3RoO3ArKyl7aWYoISgobz10LmlucHV0TGF5ZXJzW3BdKWluc3RhbmNlb2YgSW5wdXRMYXllcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklucHV0IGxheWVycyB0byBhIE1vZGVsIG11c3QgYmUgSW5wdXRMYXllciBvYmplY3RzLiBSZWNlaXZlZCBpbnB1dHM6IFwiK2UuaW5wdXRzK1wiLiBJbnB1dCBcIitwK1wiICgwLWJhc2VkKSBvcmlnaW5hdGVzIGZyb20gbGF5ZXIgdHlwZSBcIitvLmdldENsYXNzTmFtZSgpK1wiLlwiKTt0LmlucHV0TmFtZXMucHVzaChvLm5hbWUpLHQuZmVlZElucHV0U2hhcGVzLnB1c2goby5iYXRjaElucHV0U2hhcGUpLHQuZmVlZElucHV0TmFtZXMucHVzaChvLm5hbWUpfWZvcih2YXIgZGU9MCx1ZT10Lm91dHB1dExheWVycztkZTx1ZS5sZW5ndGg7ZGUrKylvPXVlW2RlXSx0Lm91dHB1dE5hbWVzLnB1c2goby5uYW1lKTt0LmludGVybmFsSW5wdXRTaGFwZXM9dC5pbnB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksdC5pbnRlcm5hbE91dHB1dFNoYXBlcz10Lm91dHB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSk7Zm9yKHZhciBmPXt9LGc9e30sbT17fSx5PXt9LHY9e30sYj1bXSx3PWZ1bmN0aW9uKHIsZSxuLGksbSxnKXtudWxsIT1pJiZudWxsIT1tJiZudWxsIT1nfHwoaT1yLnNvdXJjZUxheWVyLG09ci5ub2RlSW5kZXgsZz1yLnRlbnNvckluZGV4KTt2YXIgeT1pLmluYm91bmROb2Rlc1ttXTtpZigtMSE9PW4uaW5kZXhPZih5KSl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIHRlbnNvciBcIityLm5hbWUrXCIgYXQgbGF5ZXIgXFxcIlwiK2kubmFtZStcIlxcXCIgaXMgcGFydCBvZiBhIGN5Y2xlLlwiKTtpZigtMT09PWUuaW5kZXhPZih5KSl7dC5jb250YWluZXJOb2Rlcy5hZGQoeC5ub2RlS2V5KGksbSkpLChpLmlkIGluIHYpfHwodltpLmlkXT1PYmplY3Qua2V5cyh2KS5sZW5ndGgpLC0xPT09bi5pbmRleE9mKHkpJiZuLnB1c2goeSk7Zm9yKHZhciBsPXkuaW5ib3VuZExheWVycy5sZW5ndGgsdT0wO3U8bDt1Kyspe3ZhciBOPXkuaW5wdXRUZW5zb3JzW3VdLHA9eS5pbmJvdW5kTGF5ZXJzW3VdLGg9eS5ub2RlSW5kaWNlc1t1XSxkPXkudGVuc29ySW5kaWNlc1t1XTt3KE4sZSxuLHAsaCxkKX1mb3IoZS5wdXNoKHkpOzA8PW4uaW5kZXhPZih5KTspbi5zcGxpY2Uobi5pbmRleE9mKHkpLDEpO2IucHVzaCh5KX19LHo9W10sUz1bXSxJPTAsY2U9dC5vdXRwdXRzLEM7STxjZS5sZW5ndGg7SSsrKUM9Y2VbSV0sdyhDLHosUyk7Zm9yKHZhciBtZT0wLGhlPWIuc2xpY2UoKS5yZXZlcnNlKCk7bWU8aGUubGVuZ3RoO21lKyspe2dbKFo9aGVbbWVdKS5pZF09WixaLmlkIGluIGZ8fChmW1ouaWRdPTApO3ZhciBFPWZbWi5pZF0sZ2U9bnVsbD09bVtaLm91dGJvdW5kTGF5ZXIuaWRdPzA6bVtaLm91dGJvdW5kTGF5ZXIuaWRdO2ZvcihFPV9NYXRobWF4KEUsZ2UpLG1bWi5vdXRib3VuZExheWVyLmlkXT1FLHlbWi5vdXRib3VuZExheWVyLmlkXT1aLm91dGJvdW5kTGF5ZXIsZltaLmlkXT1FLHA9MDtwPFouaW5ib3VuZExheWVycy5sZW5ndGg7cCsrKXt2YXIgTD1aLmluYm91bmRMYXllcnNbcF0sZmU9KG9lPVoubm9kZUluZGljZXNbcF0sTC5pbmJvdW5kTm9kZXNbb2VdKSxUPW51bGw9PWZbZmUuaWRdPzA6ZltmZS5pZF07ZltmZS5pZF09X01hdGhtYXgoRSsxLFQpLGdbZmUuaWRdPWZlfX12YXIgRD17fTtmb3IodmFyIE8gaW4gZikoRT1mW09dKWluIER8fChEW0VdPVtdKSxEW0VdLnB1c2goZ1tPXSk7dmFyIFI9e307Zm9yKHZhciBNIGluIG0pKEU9bVtNXSlpbiBSfHwoUltFXT1bXSksUltFXS5wdXNoKHlbTV0pO3ZhciBQPU9iamVjdC5rZXlzKFIpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VJbnQodCwxMCl9KS5zb3J0KHJldmVyc2VOdW1iZXJDb21wYXJlKTt0LmxheWVycz1bXTtmb3IodmFyIHllPTAsYmU9UCxCO3llPGJlLmxlbmd0aDt5ZSsrKXtCPVJbRT1iZVt5ZV1dLEIuc29ydChmdW5jdGlvbihhLGUpe3ZhciB0PXZbYS5pZF0sbj12W2UuaWRdO3JldHVybiB0PG4/LTE6dD5uPzE6MH0pO2Zvcih2YXIgeGU9MCxOZT1CO3hlPE5lLmxlbmd0aDt4ZSsrKW89TmVbeGVdLHQubGF5ZXJzLnB1c2gobyl9dC5sYXllcnNCeURlcHRoPVIsUD1PYmplY3Qua2V5cyhEKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHBhcnNlSW50KHQsMTApfSkuc29ydChyZXZlcnNlTnVtYmVyQ29tcGFyZSk7Zm9yKHZhciBXPXQuaW5wdXRzLnNsaWNlKCksJD1bXSxxPTAsSWU9UDtxPEllLmxlbmd0aDtxKyspZm9yKHZhciBKPTAsdmU9RFtFPUllW3FdXTtKPHZlLmxlbmd0aDtKKyspe3ZhciBaO2lmKG51bGwhPShvPShaPXZlW0pdKS5vdXRib3VuZExheWVyKSl7Zm9yKHZhciBTZT0wLENlPVouaW5wdXRUZW5zb3JzO1NlPENlLmxlbmd0aDtTZSsrKWlmKEM9Q2VbU2VdLC0xPT09Vy5pbmRleE9mKEMpKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJHcmFwaCBkaXNjb25uZWN0ZWQ6IGNhbm5vdCBvYnRhaW4gdmFsdWUgZm9yIHRlbnNvciBcIitDK1wiIGF0IGxheWVyIFxcXCJcIitvLm5hbWUrXCJcXFwiLiBUaGUgZm9sbG93aW5nIHByZXZpb3VzIGxheWVycyB3ZXJlIGFjY2Vzc2VkIHdpdGhvdXQgaXNzdWU6IFwiKyQpO2Zvcih2YXIgWD0wLGtlPVoub3V0cHV0VGVuc29ycztYPGtlLmxlbmd0aDtYKyspQz1rZVtYXSxXLnB1c2goQyk7JC5wdXNoKG8ubmFtZSl9fXQubm9kZXNCeURlcHRoPUQ7Zm9yKHZhciBlZT10LmxheWVycy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pLHRlPWZ1bmN0aW9uKGEpe3ZhciBlPWVlLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZT09PWF9KS5sZW5ndGg7aWYoMSE9PWUpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBuYW1lIFxcXCJcIithK1wiXFxcIiBpcyB1c2VkIFwiK2UrXCIgdGltZXMgaW4gdGhlIG1vZGVsLiBBbGwgbGF5ZXIgbmFtZXMgc2hvdWxkIGJlIHVuaXF1ZS4gTGF5ZXIgbmFtZXM6IFwiK0pTT04uc3RyaW5naWZ5KGVlKSl9LG5lPTAsVGU9ZWU7bmU8VGUubGVuZ3RoO25lKyspdGUoVGVbbmVdKTtyZXR1cm4gdC5vdXRib3VuZE5vZGVzPVtdLHQuaW5ib3VuZE5vZGVzPVtdLG5ldyBOb2RlKHtvdXRib3VuZExheWVyOnQsaW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczp0LmlucHV0cyxvdXRwdXRUZW5zb3JzOnQub3V0cHV0cyxpbnB1dE1hc2tzOnQuaW5wdXRzLm1hcChmdW5jdGlvbigpe3JldHVybiBudWxsfSksb3V0cHV0TWFza3M6dC5vdXRwdXRzLm1hcChmdW5jdGlvbigpe3JldHVybiBudWxsfSksaW5wdXRTaGFwZXM6dC5pbnB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksb3V0cHV0U2hhcGVzOnQub3V0cHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KX0pLHQuYnVpbHQ9ITAsdC5fcmVmQ291bnQ9MSx0fXJldHVybiBfX2V4dGVuZHMkMSh4LGFlKSx4LnByb3RvdHlwZS5hc3NlcnROb3REaXNwb3NlZD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLl9yZWZDb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgJ1wiK3RoaXMubmFtZStcIicgaXMgYWxyZWFkeSBkaXNwb3NlZC5cIil9LHgucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7dmFyIGE9e3JlZkNvdW50QWZ0ZXJEaXNwb3NlOm51bGwsbnVtRGlzcG9zZWRWYXJpYWJsZXM6MH07aWYoMD09LS10aGlzLl9yZWZDb3VudClmb3IodmFyIGU9MCxvPXRoaXMubGF5ZXJzLG47ZTxvLmxlbmd0aDtlKyspbj1vW2VdLGEubnVtRGlzcG9zZWRWYXJpYWJsZXMrPW4uZGlzcG9zZSgpLm51bURpc3Bvc2VkVmFyaWFibGVzO3JldHVybiBhLnJlZkNvdW50QWZ0ZXJEaXNwb3NlPXRoaXMuX3JlZkNvdW50LGF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7aWYoMDx0aGlzLl90cmFpbmFibGVXZWlnaHRzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgY29udGFpbnMgX3RyYWluYWJsZVdlaWdodHMuVGhlIHRyYWluYWJsZSB3ZWlnaHRzIG9mIGEgQ29udGFpbmVyIGFyZSBhIHVuaW9uIG9mIHRoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBpdHMgY29uc2l0dWVudCBMYXllcnMuIEl0cyBvd24gX3RyYWluYWJsZVdlaWdodHMgbXVzdCByZW1haW4gYW4gZW1wdHkgQXJyYXkuXCIpO2lmKCF0aGlzLnRyYWluYWJsZSlyZXR1cm5bXTtmb3IodmFyIGE9W10sbz0wLHM9dGhpcy5sYXllcnMsbjtvPHMubGVuZ3RoO28rKyluPXNbb10sYT1hLmNvbmNhdChuLnRyYWluYWJsZVdlaWdodHMpO3JldHVybiBhfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBzPVtdLGU9MCxwPXRoaXMubGF5ZXJzLG47ZTxwLmxlbmd0aDtlKyspbj1wW2VdLHMucHVzaC5hcHBseShzLG4ubm9uVHJhaW5hYmxlV2VpZ2h0cyk7aWYoIXRoaXMudHJhaW5hYmxlKXtmb3IodmFyIGw9W10saT0wLGQ9dGhpcy5sYXllcnM7aTxkLmxlbmd0aDtpKyspbj1kW2ldLGwucHVzaC5hcHBseShsLG4udHJhaW5hYmxlV2VpZ2h0cyk7cmV0dXJuIGwuY29uY2F0KHMpfXJldHVybiBzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LnByb3RvdHlwZSxcIndlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx4LnByb3RvdHlwZS5sb2FkV2VpZ2h0cz1mdW5jdGlvbihhLGUsbyxzKXt2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09byYmKG89ITEpLHZvaWQgMD09PXMmJihzPSEwKSxvP2xvYWRXZWlnaHRzRnJvbU5hbWVkVGVuc29yTWFwKGEsdGhpcy5sYXllcnMscyk6bG9hZFdlaWdodHNGcm9tSnNvbihhLHRoaXMubGF5ZXJzLGUpfSx4LnByb3RvdHlwZS51cGRhdGVkQ29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRDb25maWcoKTtyZXR1cm57Y2xhc3NOYW1lOnRoaXMuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOnQsa2VyYXNWZXJzaW9uOlwidGZqcy1sYXllcnMgXCIrdmVyc2lvbiQxLGJhY2tlbmQ6XCJUZW5zb3JGbG93LmpzXCJ9fSx4LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oYSxlKXt2b2lkIDA9PT1lJiYoZT0hMCk7dmFyIHI9Y29udmVydFRzVG9QeXRob25pYyh0aGlzLnVwZGF0ZWRDb25maWcoKSk7cmV0dXJuIGU/SlNPTi5zdHJpbmdpZnkocik6cn0seC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihhLG8pe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gYT10b0xpc3QoYSksZT1cIm1hc2tcImluIG8/dG9MaXN0KG8ubWFzayk6cHlMaXN0UmVwZWF0KG51bGwsYS5sZW5ndGgpLHQucnVuSW50ZXJuYWxHcmFwaChhLGUpWzBdfSl9LHgucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGEsbyl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBlO3JldHVybiBhPXRvTGlzdChhKSxlPW51bGw9PW8/cHlMaXN0UmVwZWF0KG51bGwsYS5sZW5ndGgpOnRvTGlzdChvKSx0LnJ1bkludGVybmFsR3JhcGgoYSxlKVsxXX0pfSx4LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oeCl7dmFyIGU9bm9ybWFsaXplU2hhcGVMaXN0KHgpO2lmKGUubGVuZ3RoIT09dGhpcy5pbnB1dExheWVycy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnZhbGlkIGlucHV0U2hhcGUgYXJndW1lbnQgXCIreCtcIjogbW9kZWwgaGFzIFwiK3RoaXMuaW5wdXRMYXllcnMubGVuZ3RoK1wiIHRlbnNvciBpbnB1dHMuXCIpO2Zvcih2YXIgdD17fSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBDPXRoaXMuaW5wdXRMYXllcnNbbl0saz1lW25dO3RbUz1DLm5hbWUrXCJfMF8wXCJdPWt9dmFyIGE9T2JqZWN0LmtleXModGhpcy5ub2Rlc0J5RGVwdGgpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VJbnQodCwxMCl9KS5zb3J0KHJldmVyc2VOdW1iZXJDb21wYXJlKTtpZigxPGEubGVuZ3RoKWZvcih2YXIgbz0wLFQ9YTtvPFQubGVuZ3RoO28rKylmb3IodmFyIGw9VFtvXSx1PTAsRT10aGlzLm5vZGVzQnlEZXB0aFtsXSxwO3U8RS5sZW5ndGg7dSsrKWlmKHA9RVt1XSxDPXAub3V0Ym91bmRMYXllciwtMT09PXRoaXMuaW5wdXRMYXllcnMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkfSkuaW5kZXhPZihDLmlkKSl7Zm9yKHZhciBSPVtdLGQ9MDtkPHAuaW5ib3VuZExheWVycy5sZW5ndGg7ZCsrKXt2YXIgRD1wLmluYm91bmRMYXllcnNbZF0sZz1wLm5vZGVJbmRpY2VzW2RdLG09cC50ZW5zb3JJbmRpY2VzW2RdLFA9dFtTPUQubmFtZStcIl9cIitnK1wiX1wiK21dO1IucHVzaChQKX12YXIgdj1ub3JtYWxpemVTaGFwZUxpc3QoQy5jb21wdXRlT3V0cHV0U2hhcGUoc2luZ2xldG9uT3JBcnJheShSKSkpLGI9Qy5pbmJvdW5kTm9kZXMuaW5kZXhPZihwKTtmb3IoZD0wO2Q8di5sZW5ndGg7ZCsrKXRbUz1DLm5hbWUrXCJfXCIrYitcIl9cIitkXT12W2RdfXZhciBBPVtdLF89W107Zm9yKG49MDtuPHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDtuKyspe0M9dGhpcy5vdXRwdXRMYXllcnNbbl0sYj10aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW25dLG09dGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzW25dO3ZhciBTPUMubmFtZStcIl9cIitiK1wiX1wiK207Xy5wdXNoKFMpfWZvcihuPTA7bjxfLmxlbmd0aDtuKyspe3ZhciBPPV9bbl07YXNzZXJ0JDEoTyBpbiB0KSxBLnB1c2godFtPXSl9cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkoQSl9LHgucHJvdG90eXBlLnJ1bkludGVybmFsR3JhcGg9ZnVuY3Rpb24oUixlKXtudWxsPT1lJiYoZT1weUxpc3RSZXBlYXQobnVsbCxSLmxlbmd0aCkpO2Zvcih2YXIgUD17fSxuPTA7bjx0aGlzLmlucHV0cy5sZW5ndGg7KytuKXt2YXIgTz10aGlzLmlucHV0c1tuXSxNPVJbbl0sRj1lW25dO1BbTy5pZF09W00sRl19Zm9yKHZhciBCPTAsVj1PYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBwYXJzZUludCh0LDEwKX0pLnNvcnQocmV2ZXJzZU51bWJlckNvbXBhcmUpO0I8Vi5sZW5ndGg7QisrKWZvcih2YXIgbD1WW0JdLHU9MCxVPXRoaXMubm9kZXNCeURlcHRoW2xdO3U8VS5sZW5ndGg7dSsrKXtmb3IodmFyIHA9VVt1XSxoPXAub3V0Ym91bmRMYXllcixkPXAuaW5wdXRUZW5zb3JzLGY9cC5vdXRwdXRUZW5zb3JzLGc9W10sbT0wLFc9ZDttPFcubGVuZ3RoO20rKykoTz1XW21dKS5pZCBpbiBQJiZnLnB1c2goUFtPLmlkXSk7aWYoZy5sZW5ndGg9PT1kLmxlbmd0aCl7dmFyIHY9e30sRz12b2lkIDAscT12b2lkIDAsSD12b2lkIDAsaj12b2lkIDA7aWYobnVsbCE9cC5jYWxsQXJncyYmKHY9cC5jYWxsQXJncyksMT09PWcubGVuZ3RoKXt2YXIgJD1nWzBdLE49JFswXSxDPSRbMV07bnVsbD09di5tYXNrJiYodi5tYXNrPUMpLEg9dG9MaXN0KGguY2FsbChOLHYpKSxqPXRvTGlzdChoLmNvbXB1dGVNYXNrKE4sQykpLEc9W05dLHE9W0NdfWVsc2UgRz1nLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pLHE9Zy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMV19KSxudWxsPT12Lm1hc2smJih2Lm1hc2s9cSksSD10b0xpc3QoaC5jYWxsKEcsdikpLGo9dG9MaXN0KGguY29tcHV0ZU1hc2soRyxxKSk7aWYoaC5hY3Rpdml0eVJlZ3VsYXJpemVyKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTW9kZWwgaW52b2NhdGlvbiB3aXRoIGNvbmNyZXRlIFRlbnNvciB2YWx1ZShzKSBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2ZvcihuPTA7bjxmLmxlbmd0aDsrK24pTz1mW25dLE09SFtuXSxGPWpbbl0sUFtPLmlkXT1bTSxGXX19Zm9yKHZhciBBPVtdLF89W10sRT1bXSxrPTAsSz10aGlzLm91dHB1dHM7azxLLmxlbmd0aDtrKyspe2Fzc2VydCQxKChPPUtba10pLmlkIGluIFAsXCJDb3VsZCBub3QgY29tcHV0ZSBvdXRwdXQgXCIrTy5uYW1lK1wiIDogXCIrTy5pZCk7dmFyIHg9UFtPLmlkXSxUPXhbMF07Rj14WzFdLEUucHVzaChULnNoYXBlKSxBLnB1c2goVCksXy5wdXNoKEYpfXJldHVybltBLF8sRV19LHgucHJvdG90eXBlLmJ1aWxkTm9kZUNvbnZlcnNpb25NYXA9ZnVuY3Rpb24oKXtmb3IodmFyIGU9e30sdD0wLHI9dGhpcy5sYXllcnMsYSxwO3Q8ci5sZW5ndGg7dCsrKXtwPXJbdF0sYT1wIGluc3RhbmNlb2YgeD8xOjA7Zm9yKHZhciBkPTAsdTtkPHAuaW5ib3VuZE5vZGVzLmxlbmd0aDtkKyspdT14Lm5vZGVLZXkocCxkKSx0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyh1KSYmKGVbdV09YSxhKz0xKX1yZXR1cm4gZX0seC5wcm90b3R5cGUuZ2V0TGF5ZXI9ZnVuY3Rpb24oYSxlKXtpZihudWxsIT1lKXtpZih0aGlzLmxheWVycy5sZW5ndGg8PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXYXMgYXNrZWQgdG8gcmV0cmlldmUgbGF5ZXIgYXQgaW5kZXggXCIrZStcIiwgYnV0IG1vZGVsIG9ubHkgaGFzIFwiK3RoaXMubGF5ZXJzLmxlbmd0aCtcIiBsYXllcihzKS5cIik7cmV0dXJuIHRoaXMubGF5ZXJzW2VdfWlmKG51bGw9PWEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJQcm92aWRlIGVpdGhlciBhIGxheWVyIG5hbWUgb3IgbGF5ZXIgaW5kZXhcIik7Zm9yKHZhciB0PTAsbz10aGlzLmxheWVycyxyO3Q8by5sZW5ndGg7dCsrKWlmKHI9b1t0XSxyLm5hbWU9PT1hKXJldHVybiByO3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiTm8gc3VjaCBsYXllcjogXCIrYSl9LHgucHJvdG90eXBlLmNhbGN1bGF0ZUxvc3Nlcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sbj0wLHA9dC5sYXllcnM7bjxwLmxlbmd0aDtuKyspZm9yKHZhciBpPXBbbl0sYT0wLGw7YTxpLmluYm91bmROb2Rlcy5sZW5ndGg7KythKWw9eC5ub2RlS2V5KGksYSksdC5jb250YWluZXJOb2Rlcy5oYXMobCkmJmUucHVzaC5hcHBseShlLGkuY2FsY3VsYXRlTG9zc2VzKCkpO3JldHVybiBlfSl9LHgucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgdD17bmFtZTp0aGlzLm5hbWV9LGU9dGhpcy5idWlsZE5vZGVDb252ZXJzaW9uTWFwKHRoaXMubGF5ZXJzKSxuPVtdLHI9MCxOPXRoaXMubGF5ZXJzO3I8Ti5sZW5ndGg7cisrKXtmb3IodmFyIGE9KHY9TltyXSkuZ2V0Q2xhc3NOYW1lKCksbz12LmdldENvbmZpZygpLHM9W10sbD0wO2w8di5pbmJvdW5kTm9kZXMubGVuZ3RoO2wrKyl7dmFyIEk9di5pbmJvdW5kTm9kZXNbbF0sYz14Lm5vZGVLZXkodixsKSxTPXt9O2lmKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKGMpKXtpZihJLmNhbGxBcmdzKXRyeXtKU09OLnN0cmluZ2lmeShJLmNhbGxBcmdzKSxTPUkuY2FsbEFyZ3N9Y2F0Y2godCl7Y29uc29sZS53YXJuKFwiTGF5ZXIgXCIrdi5uYW1lK1wiIHdhcyBwYXNzZWQgbm9uLXNlcmlhbGl6YWJsZSBrZXl3b3JkIGFyZ3VtZW50czogXCIrSS5jYWxsQXJncytcIi4gVGhleSB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VyaWFsaXplZCBtb2RlbCAoYW5kIHRodXMgd2lsbCBiZSBtaXNzaW5nIGF0IGRlc2VyaWFsaXphdGlvbiB0aW1lKS5cIiksUz17fX1pZigwPEkuaW5ib3VuZExheWVycy5sZW5ndGgpe2Zvcih2YXIgQz1bXSxkPTA7ZDxJLmluYm91bmRMYXllcnMubGVuZ3RoO2QrKyl7dmFyIGs9SS5pbmJvdW5kTGF5ZXJzW2RdLGc9SS5ub2RlSW5kaWNlc1tkXSxUPUkudGVuc29ySW5kaWNlc1tkXTtudWxsPT0oRD1lW3gubm9kZUtleShrLGcpXSkmJihEPTApLEMucHVzaChbay5uYW1lLEQsVCxTXSl9cy5wdXNoKEMpfX19bi5wdXNoKHtuYW1lOnYubmFtZSxjbGFzc05hbWU6YSxjb25maWc6byxpbmJvdW5kTm9kZXM6c30pfXQubGF5ZXJzPW47dmFyIEU9W107Zm9yKGQ9MDtkPHRoaXMuaW5wdXRMYXllcnMubGVuZ3RoO2QrKyl7dmFyIHY9dGhpcy5pbnB1dExheWVyc1tkXTtnPXRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlc1tkXSxjPXgubm9kZUtleSh2LGcpLHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKGMpJiYobnVsbCE9PShEPWVbY10pJiZ2b2lkIDAhPT1EfHwoRD0wKSxUPXRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzW2RdLEUucHVzaChbdi5uYW1lLEQsVF0pKX10LmlucHV0TGF5ZXJzPUU7dmFyIFI9W107Zm9yKGQ9MDtkPHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDtkKyspaWYodj10aGlzLm91dHB1dExheWVyc1tkXSxnPXRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbZF0sYz14Lm5vZGVLZXkodixnKSx0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhjKSl7dmFyIEQ7bnVsbCE9PShEPWVbY10pJiZ2b2lkIDAhPT1EfHwoRD0wKSxUPXRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tkXSxSLnB1c2goW3YubmFtZSxELFRdKX1yZXR1cm4gdC5vdXRwdXRMYXllcnM9Uix0fSx4LmZyb21Db25maWc9ZnVuY3Rpb24oeCxrKXtmdW5jdGlvbiBUKG4sZSl7bi5uYW1lIGluIGE/YVtuLm5hbWVdLnB1c2goZSk6YVtuLm5hbWVdPVtlXX1mdW5jdGlvbiBlKG4sZSl7Zm9yKHZhciB0PVtdLGE9MCxtPWUsczthPG0ubGVuZ3RoO2ErKyl7dmFyIGc9bVthXSxsPWdbMF0sdT1nWzFdLGM9Z1syXTtpZigzPT09Zy5sZW5ndGgpcz17fTtlbHNle2lmKDQhPT1nLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkltcHJvcGVybHkgZm9ybWF0dGVkIG1vZGVsIGNvbmZpZyBmb3IgbGF5ZXIgXCIrSlNPTi5zdHJpbmdpZnkobikrXCI6IFwiK0pTT04uc3RyaW5naWZ5KGcpKTtzPWdbM119aWYoIShsIGluIGkpKXJldHVybiB2b2lkIFQobixlKTt2YXIgcD1pW2xdO2lmKHAuaW5ib3VuZE5vZGVzLmxlbmd0aDw9dSlyZXR1cm4gdm9pZCBUKG4sZSk7dmFyIGg9cC5pbmJvdW5kTm9kZXNbdV07dC5wdXNoKGgub3V0cHV0VGVuc29yc1tjXSl9MDx0Lmxlbmd0aCYmbi5hcHBseShzaW5nbGV0b25PckFycmF5KHQpLHMpfWZ1bmN0aW9uIHQodCl7dmFyIGU9dC5uYW1lLG49ZGVzZXJpYWxpemUodCxudWxsPT1rLmN1c3RvbU9iamVjdHM/e306ay5jdXN0b21PYmplY3RzKTtpW2VdPW47Zm9yKHZhciBhPTAscj10LmluYm91bmROb2RlcyxzO2E8ci5sZW5ndGg7YSsrKXtpZihzPXJbYV0sIShzIGluc3RhbmNlb2YgQXJyYXkpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29ycnVwdGVkIGNvbmZpZ3VyYXRpb24sIGV4cGVjdGVkIGFycmF5IGZvciBub2RlRGF0YTogXCIrcyk7VChuLHMpfX1mb3IodmFyIGk9e30sYT17fSxuPWsubmFtZSxyPWsubGF5ZXJzLG89MCxzPXI7bzxzLmxlbmd0aDtvKyspdChoPXNbb10pO2Zvcig7IWlzT2JqZWN0RW1wdHkoYSk7KWZvcih2YXIgbD0wLGM9cixoO2w8Yy5sZW5ndGg7bCsrKWlmKGg9Y1tsXSwoQT1pW2gubmFtZV0pLm5hbWUgaW4gYSl7dmFyIEU9YVtBLm5hbWVdO2RlbGV0ZSBhW0EubmFtZV07Zm9yKHZhciBmPTAsUj1FO2Y8Ui5sZW5ndGg7ZisrKWUoQSxSW2ZdKX1mb3IodmFyIG09W10seT1bXSx2PTAsRD1rLmlucHV0TGF5ZXJzO3Y8RC5sZW5ndGg7disrKXt2YXIgdz0oaD1EW3ZdKVswXSxQPWhbMV0sTz1oWzJdO2Fzc2VydCQxKHcgaW4gaSk7dmFyIEw9KEE9aVt3XSkuaW5ib3VuZE5vZGVzW1BdLm91dHB1dFRlbnNvcnM7bS5wdXNoKExbT10pfWZvcih2YXIgTT0wLEY9ay5vdXRwdXRMYXllcnM7TTxGLmxlbmd0aDtNKyspe3c9KGg9RltNXSlbMF0sUD1oWzFdLE89aFsyXSxhc3NlcnQkMSh3IGluIGkpO3ZhciBBO0w9KEE9aVt3XSkuaW5ib3VuZE5vZGVzW1BdLm91dHB1dFRlbnNvcnMseS5wdXNoKExbT10pfXJldHVybiBuZXcgeCh7aW5wdXRzOm0sb3V0cHV0czp5LG5hbWU6bn0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoeC5wcm90b3R5cGUsXCJzdGF0ZWZ1bFwiLHtnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9zdGF0ZWZ1bCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgaGFzIF9zdGF0ZWZ1bCA9IHRydWUuIFRoZSBzdGF0ZWZ1bG5lc3Mgb2YgYSBDb250YWluZXIgaXMgZGV0ZXJtaW5lZCBieSB0aGUgTGF5ZXJzIGl0IGNvbnRhaW5zLiBJdHMgX3N0YXRlZnVsIHByb3BlcnR5IG11c3QgcmVtYWluIHRoZSBkZWZhdWx0IGZhbHNlLlwiKTtmb3IodmFyIGE9MCxuPXRoaXMubGF5ZXJzO2E8bi5sZW5ndGg7YSsrKWlmKG5bYV0uc3RhdGVmdWwpcmV0dXJuITA7cmV0dXJuITF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSkseC5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RpZHkoZnVuY3Rpb24oKXt0LmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Quc3RhdGVmdWwmJnQucmVzZXRTdGF0ZXMoKX0pfSl9LHh9KExheWVyKSxGZWVkRGljdD1mdW5jdGlvbigpe2Z1bmN0aW9uIG8oZSl7aWYodGhpcy5pZDJWYWx1ZT17fSxlIGluc3RhbmNlb2Ygbylmb3IodmFyIHQgaW4gZS5pZDJWYWx1ZSl0aGlzLmlkMlZhbHVlW3RdPWUuaWQyVmFsdWVbdF07ZWxzZXtpZihudWxsPT1lKXJldHVybjtmb3IodmFyIG49MCxzPWUsaTtuPHMubGVuZ3RoO24rKylpPXNbbl0sdGhpcy5hZGQoaS5rZXksaS52YWx1ZSl9fXJldHVybiBvLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSxlKXtpZihudWxsIT10aGlzLmlkMlZhbHVlW2EuaWRdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHVwbGljYXRlIGtleTogbmFtZT1cIithLm5hbWUrXCIsIGlkPVwiK2EuaWQpO3JldHVybiB0aGlzLmlkMlZhbHVlW2EuaWRdPWFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGEsZSksdGhpc30sby5wcm90b3R5cGUuYWRkRmVlZD1mdW5jdGlvbih0KXt0aGlzLmFkZCh0LmtleSx0LnZhbHVlKX0sby5wcm90b3R5cGUuaGFzS2V5PWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10aGlzLmlkMlZhbHVlW3QuaWRdfSxvLnByb3RvdHlwZS5nZXRWYWx1ZT1mdW5jdGlvbih0KXtpZihudWxsPT10aGlzLmlkMlZhbHVlW3QuaWRdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTm9uZXhpc3RlbnQga2V5OiBcIitKU09OLnN0cmluZ2lmeSh0KSk7cmV0dXJuIHRoaXMuaWQyVmFsdWVbdC5pZF19LG99KCksREVGQVVMVF9WQUxJREFUSU9OX0JBVENIX1NJWkU9MzIsTW9kZWw9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gdC5pc1RyYWluaW5nPSExLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbihhLGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9Y29uc29sZS5sb2cpLCF0aGlzLmJ1aWx0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhpcyBtb2RlbCBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQsIHRodXMgaXRzIHdlaWdodHMgaGF2ZSBub3QgYmVlbiBjcmVhdGVkIHlldC4gU28gbm8gc3VtbWFyeSBjYW4gYmUgZGlzcGxheWVkLiBCdWlsZCB0aGUgbW9kZWwgZmlyc3QgKGUuZy4sIGJ5IGNhbGxpbmcgaXQgb24gc29tZSB0ZXN0IGRhdGEpLlwiKTtwcmludFN1bW1hcnkodGhpcyxhLGUsdCl9LGUucHJvdG90eXBlLmNvbXBpbGU9ZnVuY3Rpb24oZCl7dmFyIG09dGhpcztpZihudWxsPT1kLmxvc3MmJihkLmxvc3M9W10pLHRoaXMubG9zcz1kLmxvc3MsXCJzdHJpbmdcIj09dHlwZW9mIGQub3B0aW1pemVyKXRoaXMub3B0aW1pemVyPWdldE9wdGltaXplcihkLm9wdGltaXplcik7ZWxzZXtpZighKGQub3B0aW1pemVyIGluc3RhbmNlb2YgT3B0aW1pemVyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVzZXItZGVmaW5lZCBvcHRpbWl6ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB0Zi5PcHRpbWl6ZXIuXCIpO3RoaXMub3B0aW1pemVyPWQub3B0aW1pemVyfXZhciBlPVtdO2lmKCEoQXJyYXkuaXNBcnJheShkLmxvc3MpfHxcInN0cmluZ1wiPT10eXBlb2YgZC5sb3NzfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLmxvc3MpKXtmb3IodmFyIHQgaW4gZC5sb3NzPWQubG9zcyxkLmxvc3MpaWYoLTE9PT10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YodCkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIGVudHJ5IGluIGxvc3MgZGljdGlvbmFyeTogXFxcIlwiK3QrXCJcXFwiLiBPbmx5IGV4cGVjdCB0aGUgZm9sbG93aW5nIGtleXM6IFwiK3RoaXMub3V0cHV0TmFtZXMpO2Zvcih2YXIgYSBpbiB0aGlzLm91dHB1dE5hbWVzKW51bGw9PWQubG9zc1thXSYmY29uc29sZS53YXJuKFwiT3V0cHV0IFxcXCJcIithK1wiXFxcIiBpcyBtaXNzaW5nIGZyb20gbG9zcyBkaWN0aW9uYXJ5LiBXZSBhc3N1bWUgdGhpcyB3YXMgZG9uZSBvbiBwdXJwb3NlLCBhbmQgd2Ugd2lsbCBub3QgYmUgZXhwZWN0aW5nIGRhdGEgdG8gYmUgcGFzc2VkIHRvIFwiK2ErXCIgZHVyaW5nIHRyYWluaW5nXCIpLGUucHVzaChnZXQoZC5sb3NzW2FdKSl9ZWxzZSBpZihBcnJheS5pc0FycmF5KGQubG9zcykpe2lmKGQubG9zcy5sZW5ndGghPT10aGlzLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiV2hlbiBwYXNzaW5nIGFuIEFycmF5IGFzIGxvc3MsIGl0IHNob3VsZCBoYXZlIG9uZSBlbnRyeSBwZXIgbW9kZWwgb3V0cHV0LiBUaGUgbW9kZWwgaGFzIFwiK3RoaXMub3V0cHV0cy5sZW5ndGgrXCIgb3V0cHV0KHMpLCBidXQgeW91IHBhc3NlZCBsb3NzPVwiK2QubG9zcytcIi5cIik7dmFyIG89ZC5sb3NzO2U9by5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGdldCh0KX0pfWVsc2V7dmFyIHI9Z2V0KGQubG9zcyk7dGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbigpe2UucHVzaChyKX0pfXRoaXMubG9zc0Z1bmN0aW9ucz1lLHRoaXMuZmVlZE91dHB1dE5hbWVzPVtdLHRoaXMuZmVlZE91dHB1dFNoYXBlcz1bXSx0aGlzLmZlZWRMb3NzRm5zPVtdO2Zvcih2YXIgaT0wO2k8dGhpcy5vdXRwdXRzLmxlbmd0aDsrK2kpe3ZhciBoPXRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbaV0sbD10aGlzLm91dHB1dE5hbWVzW2ldO3RoaXMuZmVlZE91dHB1dE5hbWVzLnB1c2gobCksdGhpcy5mZWVkT3V0cHV0U2hhcGVzLnB1c2goaCksdGhpcy5mZWVkTG9zc0Zucy5wdXNoKHRoaXMubG9zc0Z1bmN0aW9uc1tpXSl9dmFyIHU9W107dGhpcy5tZXRyaWNzPWQubWV0cmljcyx0aGlzLm1ldHJpY3NOYW1lcz1bXCJsb3NzXCJdLHRoaXMubWV0cmljc1RlbnNvcnM9W10sbmFtZVNjb3BlKFwibG9zc1wiLGZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxtLm91dHB1dHMubGVuZ3RoOysrdClpZigtMT09PXUuaW5kZXhPZih0KSl7dmFyIGE9bS5sb3NzRnVuY3Rpb25zW3RdOzE8bS5vdXRwdXRzLmxlbmd0aCYmKG0ubWV0cmljc1RlbnNvcnMucHVzaChbYSx0XSksbS5tZXRyaWNzTmFtZXMucHVzaChtLm91dHB1dE5hbWVzW3RdK1wiX2xvc3NcIikpfX0pO3ZhciBjPWNvbGxlY3RNZXRyaWNzKGQubWV0cmljcyx0aGlzLm91dHB1dE5hbWVzKTtuYW1lU2NvcGUoXCJtZXRyaWNcIixmdW5jdGlvbigpe2Zvcih2YXIgdD1mdW5jdGlvbih0KXtyZXR1cm4tMT09PXUuaW5kZXhPZih0KT92b2lkIWZ1bmN0aW9uKGUpe2Zvcih2YXIgbj1mdW5jdGlvbihlKXtpZigtMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIixcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihlKSl7dmFyIGE9bS5pbnRlcm5hbE91dHB1dFNoYXBlc1t0XTsxPT09YVthLmxlbmd0aC0xXXx8bS5sb3NzRnVuY3Rpb25zW3RdPT09YmluYXJ5Q3Jvc3NlbnRyb3B5Py0xPT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKGUpPy0xIT09W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKGUpJiYobD1iaW5hcnlDcm9zc2VudHJvcHkkMSk6bD1iaW5hcnlBY2N1cmFjeTptLmxvc3NGdW5jdGlvbnNbdF09PT1zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weT8tMT09PVtcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihlKT8tMSE9PVtcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihlKSYmKGw9c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMSk6bD1zcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5Oi0xPT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKGUpPy0xIT09W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKGUpJiYobD1jYXRlZ29yaWNhbENyb3NzZW50cm9weSQxKTpsPWNhdGVnb3JpY2FsQWNjdXJhY3k7dmFyIG47LTE9PT1bXCJhY2N1cmFjeVwiLFwiYWNjXCJdLmluZGV4T2YoZSk/LTEhPT1bXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YoZSkmJihuPVwiY2VcIik6bj1cImFjY1wiLHU9bCxkPVwiXCIrbn1lbHNle3ZhciByPWdldCQxKGUpO3U9cixkPVwiXCIrZX12YXIgbztuYW1lU2NvcGUoZCxmdW5jdGlvbigpe289dX0pLGZ1bmN0aW9uKHQsZSxhKXsxPG0ub3V0cHV0TmFtZXMubGVuZ3RoJiYoZT1tLm91dHB1dE5hbWVzW3RdK1wiX1wiK2UpLG0ubWV0cmljc05hbWVzLnB1c2goZSksbS5tZXRyaWNzVGVuc29ycy5wdXNoKFthLHRdKX0odCxkLG8pfSxvPTAscD1lLGQsbCx1O288cC5sZW5ndGg7bysrKW4ocFtvXSl9KGNbdF0pOlwiY29udGludWVcIn0sZT0wO2U8bS5vdXRwdXRzLmxlbmd0aDsrK2UpdChlKX0pLHRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cz10aGlzLnRyYWluYWJsZVdlaWdodHN9LGUucHJvdG90eXBlLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzJiZ0aGlzLnRyYWluYWJsZVdlaWdodHMubGVuZ3RoIT09dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLmxlbmd0aCYmY29uc29sZS53YXJuKFwiRGlzY3JlcGFuY3kgYmV0d2VlbiB0cmFpbmFibGV3ZWlnaHRzIGFuZCBjb2xsZWN0ZWQgdHJhaW5hYmxlIHdlaWdodHMuIERpZCB5b3Ugc2V0IGBtb2RlbC50cmFpbmFibGVgIHdpdGhvdXQgY2FsbGluZyBgbW9kZWwuY29tcGlsZSgpYCBhZnRlcndhcmRzP1wiKX0sZS5wcm90b3R5cGUuZXZhbHVhdGU9ZnVuY3Rpb24ocyxlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTt2YXIgcD1udWxsPT10LmJhdGNoU2l6ZT8zMjp0LmJhdGNoU2l6ZTtjaGVja0JhdGNoU2l6ZShwKTt2YXIgcj10aGlzLnN0YW5kYXJkaXplVXNlckRhdGEocyxlLCEwLHApO3RyeXt2YXIgaT1yWzBdLmNvbmNhdChyWzFdKTt0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKTt2YXIgYT10aGlzLnRlc3RGdW5jdGlvbjtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLnRlc3RMb29wKGEsaSxwLHQudmVyYm9zZSx0LnN0ZXBzKSl9ZmluYWxseXtkaXNwb3NlTmV3VGVuc29ycyhyWzBdLHMpLGRpc3Bvc2VOZXdUZW5zb3JzKHJbMV0sZSl9fSxlLnByb3RvdHlwZS5ldmFsdWF0ZURhdGFzZXQ9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gX19hd2FpdGVyJDEodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbigpe3JldHVybiB0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKSxbMixldmFsdWF0ZURhdGFzZXQodGhpcyxhLGUpXX0pfSl9LGUucHJvdG90eXBlLmNoZWNrTnVtU2FtcGxlcz1mdW5jdGlvbihhLGUsdCxuKXt2YXIgbztpZighKHZvaWQgMD09PW4mJihuPVwic3RlcHNcIiksbnVsbCE9dCkpe2lmKG51bGw9PWEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFaXRoZXIgdGhlIGlucHV0IGRhdGEgc2hvdWxkIGhhdmUgYSBkZWZpbmVkIHNoYXBlLCBvciBcIituK1wiIHNob3VkIGJlIHNwZWNpZmllZC5cIik7bz1BcnJheS5pc0FycmF5KGEpP2FbMF0uc2hhcGVbMF06YS5zaGFwZVswXX1lbHNlIGlmKG89bnVsbCxudWxsIT1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWYgXCIrbitcIiBpcyBzZXQsIGJhdGNoU2l6ZSBtdXN0IGJlIG51bGwgb3IgdW5kZWZpbmVkLkdvdCBiYXRjaFNpemUgPSBcIitlKTtyZXR1cm4gb30sZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihkLG0pe2lmKEFycmF5LmlzQXJyYXkobSkmJjA9PT1tLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImBvdXRwdXRzYCBpcyBhbiBlbXB0eSBBcnJheSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuXCIpO3ZhciB0PUFycmF5LmlzQXJyYXkobSksbj10P206W21dLHI9dGhpcy5yZXRyaWV2ZVN5bWJvbGljVGVuc29ycyhuKSxpPW5ldyBGZWVkRGljdDtpZihkIGluc3RhbmNlb2YgVGVuc29yJiYoZD1bZF0pLEFycmF5LmlzQXJyYXkoZCkpe2lmKGQubGVuZ3RoIT09dGhpcy5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIG51bWJlciBvZiBpbnB1dHMgcHJvdmlkZWQgKFwiK2QubGVuZ3RoK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyBvZiB0aGlzIG1vZGVsIChcIit0aGlzLmlucHV0cy5sZW5ndGgrXCIpLlwiKTtmb3IodmFyIGE9MDthPHRoaXMuaW5wdXRzLmxlbmd0aDsrK2EpaS5hZGQodGhpcy5pbnB1dHNbYV0sZFthXSl9ZWxzZSBmb3IodmFyIGg9MCxnPXRoaXMuaW5wdXRzO2g8Zy5sZW5ndGg7aCsrKXt2YXIgbD1nW2hdLHU9ZFtsLm5hbWVdO2lmKG51bGw9PXUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJObyB2YWx1ZSBpcyBwcm92aWRlZCBmb3IgdGhlIG1vZGVsJ3MgaW5wdXQgXCIrbC5uYW1lKTtpLmFkZChsLHUpfXZhciBjPWV4ZWN1dGUocixpKTtyZXR1cm4gdD9jOmNbMF19LGUucHJvdG90eXBlLnJldHJpZXZlU3ltYm9saWNUZW5zb3JzPWZ1bmN0aW9uKHApe2Zvcih2YXIgZT1weUxpc3RSZXBlYXQobnVsbCxwLmxlbmd0aCksdD1wLmxlbmd0aCxkPTAsbT10aGlzLmxheWVycztkPG0ubGVuZ3RoO2QrKyl7Zm9yKHZhciBpPW1bZF0sYT1BcnJheS5pc0FycmF5KGkub3V0cHV0KT9pLm91dHB1dDpbaS5vdXRwdXRdLG89YS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pLHM9MCxoO3M8cC5sZW5ndGgmJihoPW8uaW5kZXhPZihwW3NdKSwtMSE9PWgmJihlW3NdPWFbaF0sdC0tKSwwIT09dCk7KytzKTtpZigwPT09dClicmVha31pZigwPHQpe3ZhciBnPVtdO3Rocm93IGUuZm9yRWFjaChmdW5jdGlvbihlLHQpe251bGw9PWUmJmcucHVzaChwW3RdKX0pLG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IGZpbmQgU3ltYm9saWNUZW5zb3JzIGZvciBvdXRwdXQgbmFtZShzKTogXCIrSlNPTi5zdHJpbmdpZnkoZykpfXJldHVybiBlfSxlLnByb3RvdHlwZS5wcmVkaWN0TG9vcD1mdW5jdGlvbihwLGUsZCl7dmFyIGM9dGhpcztyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MzIpLHZvaWQgMD09PWQmJihkPSExKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Yy5jaGVja051bVNhbXBsZXMocCk7aWYoZCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlZlcmJvc2UgcHJlZGljdExvb3AoKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtmb3IodmFyIHI9bWFrZUJhdGNoZXModCxlKSxhPVtdLG49ZnVuY3Rpb24oZSl7dmFyIHQ9dGlkeShmdW5jdGlvbigpe3ZhciB0PXJbZV1bMF0sYT1yW2VdWzFdLG49c2xpY2VBcnJheXMocCx0LGEpLG89W107aWYoQXJyYXkuaXNBcnJheShuKSlmb3IodmFyIHM9MDtzPG4ubGVuZ3RoOysrcylvLnB1c2goe2tleTpjLmlucHV0c1tzXSx2YWx1ZTpuW3NdfSk7ZWxzZSBvLnB1c2goe2tleTpjLmlucHV0c1swXSx2YWx1ZTpufSk7dmFyIGk9bmV3IEZlZWREaWN0KG8pO3JldHVybiBleGVjdXRlKGMub3V0cHV0cyxpKX0pO2lmKDA9PT1lKWZvcih2YXIgbj0wLG89dCxzO248by5sZW5ndGg7bisrKXM9b1tuXSxhLnB1c2gocyk7ZWxzZSBmb3IodmFyIGQ9MDtkPHQubGVuZ3RoOysrZClhW2RdPWNvbmNhdEFsb25nRmlyc3RBeGlzKGFbZF0sdFtkXSl9LG89MDtvPHIubGVuZ3RoOysrbyluKG8pO3JldHVybiBzaW5nbGV0b25PckFycmF5KGEpfSl9LGUucHJvdG90eXBlLnByZWRpY3Q9ZnVuY3Rpb24oYSxlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIG89ZW5zdXJlVGVuc29yc1JhbmsyT3JIaWdoZXIoYSk7Y2hlY2tJbnB1dERhdGEobyx0aGlzLmlucHV0TmFtZXMsdGhpcy5mZWVkSW5wdXRTaGFwZXMsITEpO3RyeXt2YXIgbj1udWxsPT1lLmJhdGNoU2l6ZT8zMjplLmJhdGNoU2l6ZTtyZXR1cm4gY2hlY2tCYXRjaFNpemUobiksdGhpcy5wcmVkaWN0TG9vcChvLG4pfWZpbmFsbHl7ZGlzcG9zZU5ld1RlbnNvcnMobyxhKX19LGUucHJvdG90eXBlLnByZWRpY3RPbkJhdGNoPWZ1bmN0aW9uKHQpe3JldHVybiBjaGVja0lucHV0RGF0YSh0LHRoaXMuaW5wdXROYW1lcyx0aGlzLmZlZWRJbnB1dFNoYXBlcywhMCksdGhpcy5wcmVkaWN0TG9vcCh0LHQuc2hhcGVbMF0pfSxlLnByb3RvdHlwZS5zdGFuZGFyZGl6ZVVzZXJEYXRhPWZ1bmN0aW9uKHMscCxsLGQpe2lmKHZvaWQgMD09PWwmJihsPSEwKSxudWxsPT10aGlzLm9wdGltaXplcil0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiWW91IG11c3QgY29tcGlsZSBhIG1vZGVsIGJlZm9yZSB0cmFpbmluZy90ZXN0aW5nLiBVc2UgTW9kZWwuY29tcGlsZShtb2RlbENvbXBpbGVDb25maWcpLlwiKTtmb3IodmFyIHI9W10saT0wLHU7aTx0aGlzLmZlZWRPdXRwdXRTaGFwZXMubGVuZ3RoOysraSl1PXRoaXMuZmVlZE91dHB1dFNoYXBlc1tpXSx0aGlzLmZlZWRMb3NzRm5zW2ldPT09c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk/ci5wdXNoKHUuc2xpY2UoMCx1Lmxlbmd0aC0xKS5jb25jYXQoWzFdKSk6ci5wdXNoKHUpO2lmKGNoZWNrQXJyYXlMZW5ndGhzKHM9c3RhbmRhcmRpemVJbnB1dERhdGEocyx0aGlzLmZlZWRJbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCExLFwiaW5wdXRcIikscD1zdGFuZGFyZGl6ZUlucHV0RGF0YShwLHRoaXMuZmVlZE91dHB1dE5hbWVzLHIsITEsXCJ0YXJnZXRcIiksbnVsbCksY2hlY2tMb3NzQW5kVGFyZ2V0Q29tcGF0aWJpbGl0eShwLHRoaXMuZmVlZExvc3NGbnMsdGhpcy5mZWVkT3V0cHV0U2hhcGVzKSx0aGlzLnN0YXRlZnVsJiZudWxsIT1kJiYwPGQmJjAhPXNbMF0uc2hhcGVbMF0lZCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkluIGEgc3RhdGVmdWwgbmV0d29yaywgeW91IHNob3VsZCBvbmx5IHBhc3MgaW5wdXRzIHdpdGggYSBudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IGlzIGRpdmlzaWJsZSBieSB0aGUgYmF0Y2ggc2l6ZSBcIitkK1wiLiBGb3VuZDogXCIrc1swXS5zaGFwZVswXStcIiBzYW1wbGUocykuXCIpO3JldHVybltzLHAsbnVsbF19LGUucHJvdG90eXBlLnRlc3RMb29wPWZ1bmN0aW9uKG8sZSx0LG4sYil7dmFyIGk9dGhpcztyZXR1cm4gdm9pZCAwPT09biYmKG49MCksdGlkeShmdW5jdGlvbigpe3ZhciBhPWkuY2hlY2tOdW1TYW1wbGVzKGUsdCxiLFwic3RlcHNcIikscj1bXTtpZigwPG4pdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7aWYobnVsbCE9Yil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInN0ZXBzIG1vZGUgaW4gdGVzdExvb3AoKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO2Zvcih2YXIgcz1tYWtlQmF0Y2hlcyhhLHQpLGw9dGVuc29yMWQocmFuZ2UkMSgwLGEpKSx1PTA7dTxzLmxlbmd0aDsrK3Upe3ZhciB4PXNbdV1bMF0scD1zW3VdWzFdLGg9c2xpY2VBbG9uZ0ZpcnN0QXhpcyhsLHgscC14KSxkPXNsaWNlQXJyYXlzQnlJbmRpY2VzKGUsaCksZj1vKGQpO2lmKDA9PXUpZm9yKHZhciBnPTA7ZzxmLmxlbmd0aDsrK2cpci5wdXNoKGdldFNjYWxhcigwKSk7Zm9yKGc9MDtnPGYubGVuZ3RoOysrZyl7dmFyIE49ZltnXTtyW2ddPWFkZChyW2ddLG11bChnZXRTY2FsYXIocC14KSxOKSl9fWZvcihnPTA7ZzxyLmxlbmd0aDsrK2cpcltnXT1kaXYocltnXSxnZXRTY2FsYXIoYSkpO3JldHVybiByfSl9LGUucHJvdG90eXBlLmdldERlZHVwZWRNZXRyaWNzTmFtZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5tZXRyaWNzTmFtZXMsZT1bXSx0PTA7dDxhLmxlbmd0aDsrK3Qpe3ZhciBvPWFbdF0scj1vOzE8Y291bnQoYSxvKSYmKHIrPVwiX1wiK2NvdW50KGEuc2xpY2UoMCx0KSxvKSksZS5wdXNoKHIpfXJldHVybiBlfSxlLnByb3RvdHlwZS5tYWtlVHJhaW5GdW5jdGlvbj1mdW5jdGlvbigpe3ZhciBkPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBvPWUuc2xpY2UoMCxkLmlucHV0cy5sZW5ndGgpLHQ9ZS5zbGljZShkLmlucHV0cy5sZW5ndGgsZC5pbnB1dHMubGVuZ3RoK2Qub3V0cHV0cy5sZW5ndGgpLG49W10scj1kLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWQoKX0pO3JldHVybltkLm9wdGltaXplci5taW5pbWl6ZShmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSxyPTA7cjxkLmlucHV0cy5sZW5ndGg7KytyKWUucHVzaCh7a2V5OmQuaW5wdXRzW3JdLHZhbHVlOm9bcl19KTt2YXIgaT1uZXcgRmVlZERpY3QoZSkscz1leGVjdXRlKGQub3V0cHV0cyxpLHt0cmFpbmluZzohMH0pLGw7Zm9yKHI9MDtyPGQubG9zc0Z1bmN0aW9ucy5sZW5ndGg7KytyKXt2YXIgbT0oMCxkLmxvc3NGdW5jdGlvbnNbcl0pKHRbcl0sc1tyXSk7bWVhbihtKSxsPTA9PXI/bTphZGQobCxtKX1mb3Iocj0wO3I8ZC5tZXRyaWNzVGVuc29ycy5sZW5ndGg7KytyKXt2YXIgdT1kLm1ldHJpY3NUZW5zb3JzW3JdWzBdLGM9ZC5tZXRyaWNzVGVuc29yc1tyXVsxXSxwPW1lYW4odSh0W2NdLHNbY10pKTtrZWVwKHApLG4ucHVzaChwKX1yZXR1cm4gbD1tZWFuKGwpLGQuY2FsY3VsYXRlTG9zc2VzKCkuZm9yRWFjaChmdW5jdGlvbih0KXtsPWFkZChsLHQpfSksbH0sITAscildLmNvbmNhdChuKX19LGUucHJvdG90eXBlLm1ha2VUZXN0RnVuY3Rpb249ZnVuY3Rpb24oKXt2YXIgbT10aGlzO3RoaXMudGVzdEZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLHI9ZS5zbGljZSgwLG0uaW5wdXRzLmxlbmd0aCksaT1lLnNsaWNlKG0uaW5wdXRzLmxlbmd0aCxtLmlucHV0cy5sZW5ndGgrbS5vdXRwdXRzLmxlbmd0aCksYT1bXSxvPTAsZztvPG0uaW5wdXRzLmxlbmd0aDsrK28pYS5wdXNoKHtrZXk6bS5pbnB1dHNbb10sdmFsdWU6cltvXX0pO3ZhciB5PW5ldyBGZWVkRGljdChhKSxsPWV4ZWN1dGUobS5vdXRwdXRzLHkpO2ZvcihvPTA7bzxtLmxvc3NGdW5jdGlvbnMubGVuZ3RoOysrbyl7dmFyIHU9bS5sb3NzRnVuY3Rpb25zW29dLGM9bWVhbih1KGlbb10sbFtvXSkpO2c9MD09bz9jOmFkZChnLGMpLHQucHVzaChnKX1mb3Iobz0wO288bS5tZXRyaWNzVGVuc29ycy5sZW5ndGg7KytvKXt2YXIgcD1tLm1ldHJpY3NUZW5zb3JzW29dWzBdLGg9bS5tZXRyaWNzVGVuc29yc1tvXVsxXSxkPW1lYW4ocChpW2hdLGxbaF0pKTt0LnB1c2goZCl9cmV0dXJuIHR9KX19LGUucHJvdG90eXBlLmZpdD1mdW5jdGlvbihhLGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuWzIsZml0VGVuc29ycyh0aGlzLGEsZSx0KV19KX0pfSxlLnByb3RvdHlwZS5maXREYXRhc2V0PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm5bMixmaXREYXRhc2V0KHRoaXMsYSxlKV19KX0pfSxlLnByb3RvdHlwZS5nZXROYW1lZFdlaWdodHM9ZnVuY3Rpb24obyl7Zm9yKHZhciBlPXt9LHQ9bnVsbCE9byYmby50cmFpbmFibGVPbmx5LG49dD90aGlzLnRyYWluYWJsZVdlaWdodHM6dGhpcy53ZWlnaHRzLHI9dGhpcy5nZXRXZWlnaHRzKHQpLHM9MDtzPG4ubGVuZ3RoOysrcyl0JiYhbltzXS50cmFpbmFibGV8fChlW25bc10ub3JpZ2luYWxOYW1lXT1yW3NdKTtyZXR1cm4gZX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwic3RvcFRyYWluaW5nXCIse3NldDpmdW5jdGlvbih0KXt0aGlzLnN0b3BUcmFpbmluZ189dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHAsbCl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQsZCx1LGM7cmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcyxmdW5jdGlvbihhKXtzd2l0Y2goYS5sYWJlbCl7Y2FzZSAwOmlmKFwic3RyaW5nXCI9PXR5cGVvZiBwKXtpZigwPT09KGU9aW8uZ2V0U2F2ZUhhbmRsZXJzKHApKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICdcIitwK1wiJ1wiKTtpZigxPGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIrZS5sZW5ndGgrXCIpIHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnXCIrcCtcIidcIik7cD1lWzBdfWlmKG51bGw9PXAuc2F2ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk1vZGVsLnNhdmUoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYHNhdmVgIGF0dHJpYnV0ZSBkZWZpbmVkLlwiKTtyZXR1cm5bNCxpby5lbmNvZGVXZWlnaHRzKHRoaXMuZ2V0TmFtZWRXZWlnaHRzKGwpKV07Y2FzZSAxOnJldHVybiB0PWEuc2VudCgpLGQ9ITEsdT1udWxsLGM9dGhpcy50b0pTT04odSxkKSxbMixwLnNhdmUoe21vZGVsVG9wb2xvZ3k6Yyx3ZWlnaHREYXRhOnQuZGF0YSx3ZWlnaHRTcGVjczp0LnNwZWNzfSldO319KX0pfSxlLmNsYXNzTmFtZT1cIk1vZGVsXCIsZX0oQ29udGFpbmVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTW9kZWwpO3ZhciBTZXF1ZW50aWFsPWZ1bmN0aW9uKG8pe2Z1bmN0aW9uIHAoZSl7dmFyIHM9by5jYWxsKHRoaXMse2lucHV0czpbXSxvdXRwdXRzOltdfSl8fHRoaXM7aWYoZT1lfHx7fSxzLnRyYWluYWJsZT0hMCxzLl91cGRhdGFibGU9ITAscy5idWlsdD0hMSxzLm5hbWU9bnVsbD09ZS5uYW1lP2dldFVpZChcInNlcXVlbnRpYWxfXCIpOmUubmFtZSxudWxsIT1lLmxheWVycylmb3IodmFyIG49MCxwPWUubGF5ZXJzLGk7bjxwLmxlbmd0aDtuKyspaT1wW25dLHMuYWRkKGkpO3JldHVybiBzfXJldHVybiBfX2V4dGVuZHMkMShwLG8pLHAucHJvdG90eXBlLmNoZWNrU2hhcGU9ZnVuY3Rpb24odCl7aWYodC5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXS5zaGFwZS5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiAwPnR9KSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBhZGRpbmcgbGF5ZXIgXCIrdC5uYW1lK1wiIHdpdGggaW5wdXQgc2hhcGUgW1wiK3QuaW5ib3VuZE5vZGVzWzBdLmlucHV0VGVuc29yc1swXS5zaGFwZStcIl1cIil9LHAucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXt2YXIgZT10IGluc3RhbmNlb2YgcHx8dCBpbnN0YW5jZW9mIE1vZGVsLHI7aWYoZSl7aWYoMSE9PShyPXQpLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO2lmKDEhPT1yLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBpbnB1dCB0ZW5zb3IuIEZvciBtdWx0aS1pbnB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpfWlmKDA9PT10aGlzLm91dHB1dHMubGVuZ3RoKXtpZigwPT09dC5pbmJvdW5kTm9kZXMubGVuZ3RoKXtpZihudWxsPT10LmJhdGNoSW5wdXRTaGFwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBmaXJzdCBsYXllciBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgbXVzdCBnZXQgYW4gYGlucHV0U2hhcGVgIG9yIGBiYXRjaElucHV0U2hhcGVgIGFyZ3VtZW50LlwiKTt2YXIgbz1JbnB1dCh7YmF0Y2hTaGFwZTp0LmJhdGNoSW5wdXRTaGFwZSxkdHlwZTp0LmR0eXBlLG5hbWU6dC5uYW1lK1wiX2lucHV0XCJ9KTt0LmFwcGx5KG8pfWlmKGUpdGhpcy5vdXRwdXRzPXIub3V0cHV0cyx0aGlzLmlucHV0cz1yLmlucHV0cztlbHNle2lmKDEhPT10LmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGxheWVyIGFkZGVkIHRvIGEgU2VxdWVudGlhbCBtb2RlbCBtdXN0IG5vdCBhbHJlYWR5IGJlIGNvbm5lY3RlZCBzb21ld2hlcmUgZWxzZS4gTW9kZWwgcmVjZWl2ZWQgbGF5ZXIgXCIrdC5uYW1lK1wiIHdoaWNoIGhhcyBcIit0LmluYm91bmROb2Rlcy5sZW5ndGgrXCIgcHJlLWV4aXN0aW5nIGluYm91bmQgY29ubmVjdGlvbnMuXCIpO2lmKDEhPT10LmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuIEZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKTt0aGlzLmNoZWNrU2hhcGUodCksdGhpcy5vdXRwdXRzPVt0LmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdXSx0aGlzLmlucHV0cz1nZXRTb3VyY2VJbnB1dHModGhpcy5vdXRwdXRzWzBdKX10aGlzLmluYm91bmROb2Rlcz1bXSxuZXcgTm9kZSh7b3V0Ym91bmRMYXllcjp0aGlzLGluYm91bmRMYXllcnM6W10sbm9kZUluZGljZXM6W10sdGVuc29ySW5kaWNlczpbXSxpbnB1dFRlbnNvcnM6dGhpcy5pbnB1dHMsb3V0cHV0VGVuc29yczp0aGlzLm91dHB1dHMsaW5wdXRNYXNrczpweUxpc3RSZXBlYXQobnVsbCx0aGlzLmlucHV0cy5sZW5ndGgpLG91dHB1dE1hc2tzOltudWxsXSxpbnB1dFNoYXBlczp0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSxvdXRwdXRTaGFwZXM6dGhpcy5vdXRwdXRzWzBdLnNoYXBlfSl9ZWxzZXt2YXIgcz10LmFwcGx5KHRoaXMub3V0cHV0c1swXSk7aWYoQXJyYXkuaXNBcnJheShzKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO3RoaXMuY2hlY2tTaGFwZSh0KSx0aGlzLm91dHB1dHM9W3NdLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnM9dGhpcy5vdXRwdXRzLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcz1bdGhpcy5vdXRwdXRzWzBdLnNoYXBlXX10aGlzLmxheWVycy5wdXNoKHQpLHRoaXMuYnVpbHQ9ITF9LHAucHJvdG90eXBlLnBvcD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLmxheWVycy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZXJlIGFyZSBubyBsYXllcnMgaW4gdGhlIG1vZGVsLlwiKTtpZih0aGlzLmxheWVycy5wb3AoKSwwPT09dGhpcy5sYXllcnMubGVuZ3RoKXRoaXMub3V0cHV0cz1bXSx0aGlzLmluYm91bmROb2Rlcz1bXSx0aGlzLm91dGJvdW5kTm9kZXM9W107ZWxzZXt2YXIgdD10aGlzLmxheWVycy5sZW5ndGgtMTt0aGlzLmxheWVyc1t0XS5vdXRib3VuZE5vZGVzPVtdLHRoaXMub3V0cHV0cz1bdGhpcy5sYXllcnNbdF0ub3V0cHV0XSx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzPXRoaXMub3V0cHV0cyx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXM9W3RoaXMub3V0cHV0c1swXS5zaGFwZV19fSxwLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLmNhbGwoYSxlKX0scC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24odCl7aWYoZ2V0RXhhY3RseU9uZVNoYXBlKHQpLDA9PT10aGlzLmlucHV0cy5sZW5ndGh8fDA9PT10aGlzLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTZXF1ZW50aWFsIG1vZGVsIGNhbm5vdCBiZSBidWlsdDogbW9kZWwgaXMgZW1wdHkuIEFkZCBzb21lIGxheWVycyBmaXJzdC5cIik7dGhpcy5tb2RlbD1uZXcgTW9kZWwoe2lucHV0czp0aGlzLmlucHV0cyxvdXRwdXRzOnRoaXMub3V0cHV0c1swXSxuYW1lOnRoaXMubmFtZStcIl9tb2RlbFwifSksdGhpcy5tb2RlbC50cmFpbmFibGU9dGhpcy50cmFpbmFibGUsdGhpcy5tb2RlbC51cGRhdGFibGU9dGhpcy51cGRhdGFibGUsdGhpcy5zdXBwb3J0c01hc2tpbmc9dGhpcy5tb2RlbC5zdXBwb3J0c01hc2tpbmcsdGhpcy5pbnB1dExheWVycz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzLHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzTm9kZUluZGljZXMsdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXM9dGhpcy5tb2RlbC5pbnB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5vdXRwdXRMYXllcnM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnMsdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc05vZGVJbmRpY2VzLHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5ub2Rlc0J5RGVwdGg9dGhpcy5tb2RlbC5ub2Rlc0J5RGVwdGgsdGhpcy5jb250YWluZXJOb2Rlcz10aGlzLm1vZGVsLmNvbnRhaW5lck5vZGVzLHRoaXMub3V0cHV0TmFtZXM9dGhpcy5tb2RlbC5vdXRwdXROYW1lcyx0aGlzLmlucHV0TmFtZXM9dGhpcy5tb2RlbC5pbnB1dE5hbWVzLHRoaXMuYnVpbHQ9ITB9LHAucHJvdG90eXBlLmNvdW50UGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbHR8fHRoaXMuYnVpbGQoKSxvLnByb3RvdHlwZS5jb3VudFBhcmFtcy5jYWxsKHRoaXMpfSxwLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKGUsdCxhKXt2b2lkIDA9PT1hJiYoYT1jb25zb2xlLmxvZyksdGhpcy5idWlsdHx8dGhpcy5idWlsZCgpLG8ucHJvdG90eXBlLnN1bW1hcnkuY2FsbCh0aGlzLGUsdCxhKX0scC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtudWxsPT10aGlzLm1vZGVsJiZ0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5zZXRXZWlnaHRzKHQpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkocC5wcm90b3R5cGUsXCJ1cGRhdGFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VwZGF0YWJsZX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuYnVpbHQmJih0aGlzLm1vZGVsLnVwZGF0YWJsZT10KSx0aGlzLl91cGRhdGFibGU9dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxwLnByb3RvdHlwZS5ldmFsdWF0ZT1mdW5jdGlvbihhLGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9e30pLCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVybiB0aGlzLm1vZGVsLmV2YWx1YXRlKGEsZSx0KX0scC5wcm90b3R5cGUuZXZhbHVhdGVEYXRhc2V0PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm5bMix0aGlzLm1vZGVsLmV2YWx1YXRlRGF0YXNldChhLGUpXX0pfSl9LHAucHJvdG90eXBlLnByZWRpY3Q9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3QoYSxlKX0scC5wcm90b3R5cGUucHJlZGljdE9uQmF0Y2g9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3RPbkJhdGNoKHQpfSxwLnByb3RvdHlwZS5jb21waWxlPWZ1bmN0aW9uKHQpe3RoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLmNvbXBpbGUodCksdGhpcy5vcHRpbWl6ZXI9dGhpcy5tb2RlbC5vcHRpbWl6ZXIsdGhpcy5sb3NzPXRoaXMubW9kZWwubG9zcyx0aGlzLm1ldHJpY3M9dGhpcy5tb2RlbC5tZXRyaWNzLHRoaXMubWV0cmljc1RlbnNvcnM9dGhpcy5tb2RlbC5tZXRyaWNzVGVuc29ycyx0aGlzLm1ldHJpY3NOYW1lcz10aGlzLm1vZGVsLm1ldHJpY3NOYW1lc30scC5wcm90b3R5cGUuZml0PWZ1bmN0aW9uKGEsZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLF9fYXdhaXRlciQxKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsZnVuY3Rpb24oKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm5bMix0aGlzLm1vZGVsLmZpdChhLGUsdCldfSl9KX0scC5wcm90b3R5cGUuZml0RGF0YXNldD1mdW5jdGlvbihhLGUpe3JldHVybiBfX2F3YWl0ZXIkMSh0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLGZ1bmN0aW9uKCl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuWzIsdGhpcy5tb2RlbC5maXREYXRhc2V0KGEsZSldfSl9KX0scC5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7dmFyIG49e30sZDtpZihlIGluc3RhbmNlb2YgQXJyYXkpe2lmKG51bGw9PWVbMF0uY2xhc3NOYW1lfHxcIk1lcmdlXCI9PT1lWzBdLmNsYXNzTmFtZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxlZ2FjeSBzZXJpYWxpemF0aW9uIGZvcm1hdCBub3Qgc3VwcG9ydGVkIHlldC5cIik7ZD1lfWVsc2UgdXRpbC5hc3NlcnQobnVsbCE9ZS5sYXllcnMsXCJXaGVuIHRoZSBjb25maWcgZGF0YSBmb3IgYSBTZXF1ZW50aWFsIG1vZGVsIGlzIG5vdCBhbiBBcnJheSwgaXQgbXVzdCBiZSBhbiBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgJ2xheWVycycgZmllbGQuXCIpLGQ9ZS5sYXllcnMsZGVsZXRlIGUubGF5ZXJzLG49ZTt2YXIgdT1uZXcgdChuKTtpZighKHUgaW5zdGFuY2VvZiBwKSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlNlcXVlbnRpYWwuZnJvbUNvbmZpZyBjYWxsZWQgb24gbm9uLVNlcXVlbnRpYWwgaW5wdXQ6IFwiK3UpO2Zvcih2YXIgYT0wLGM9ZCxzO2E8Yy5sZW5ndGg7YSsrKXM9ZGVzZXJpYWxpemUoY1thXSksdS5hZGQocyk7cmV0dXJuIHV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLnByb3RvdHlwZSxcInN0b3BUcmFpbmluZ1wiLHtzZXQ6ZnVuY3Rpb24odCl7dGhpcy5tb2RlbC5zdG9wVHJhaW5pbmc9dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxwLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIGE9W10sZT0wLG89dGhpcy5sYXllcnMsbjtlPG8ubGVuZ3RoO2UrKyluPW9bZV0sYS5wdXNoKHtjbGFzc05hbWU6bi5nZXRDbGFzc05hbWUoKSxjb25maWc6bi5nZXRDb25maWcoKX0pO3JldHVybiBhfSxwLmNsYXNzTmFtZT1cIlNlcXVlbnRpYWxcIixwfShNb2RlbCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNlcXVlbnRpYWwpO3ZhciBBY3RpdmF0aW9uPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt9fSxlfShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksRWx1PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTEpLGVsdSQxKGEsZSl9LGUuY2xhc3NOYW1lPVwiZWx1XCIsZX0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEVsdSk7dmFyIFNlbHU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09YSYmYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24odCl7cmV0dXJuIHNlbHUodCl9LGUuY2xhc3NOYW1lPVwic2VsdVwiLGV9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTZWx1KTt2YXIgUmVsdT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT1hJiZhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbih0KXtyZXR1cm4gcmVsdSh0KX0sZS5jbGFzc05hbWU9XCJyZWx1XCIsZX0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlbHUpO3ZhciBSZWx1Nj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT1hJiZhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbih0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBtaW5pbXVtKGdldFNjYWxhcig2KSxyZWx1KHQpKX0pfSxlLmNsYXNzTmFtZT1cInJlbHU2XCIsZX0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlbHU2KTt2YXIgTGluZWFyPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQpe3JldHVybiB0fSxlLmNsYXNzTmFtZT1cImxpbmVhclwiLGV9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMaW5lYXIpO3ZhciBTaWdtb2lkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQpe3JldHVybiBzaWdtb2lkKHQpfSxlLmNsYXNzTmFtZT1cInNpZ21vaWRcIixlfShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2lnbW9pZCk7dmFyIEhhcmRTaWdtb2lkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQpe3JldHVybiBoYXJkU2lnbW9pZCh0KX0sZS5jbGFzc05hbWU9XCJoYXJkU2lnbW9pZFwiLGV9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhIYXJkU2lnbW9pZCk7dmFyIFNvZnRwbHVzPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQpe3JldHVybiBzb2Z0cGx1cyh0KX0sZS5jbGFzc05hbWU9XCJzb2Z0cGx1c1wiLGV9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0cGx1cyk7dmFyIFNvZnRzaWduPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQpe3JldHVybiBzb2Z0c2lnbih0KX0sZS5jbGFzc05hbWU9XCJzb2Z0c2lnblwiLGV9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0c2lnbik7dmFyIFRhbmg9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09YSYmYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24odCl7cmV0dXJuIHRhbmgkMSh0KX0sZS5jbGFzc05hbWU9XCJ0YW5oXCIsZX0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFRhbmgpO3ZhciBTb2Z0bWF4PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPS0xKSxzb2Z0bWF4KGEsZSl9LGUuY2xhc3NOYW1lPVwic29mdG1heFwiLGV9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0bWF4KTt2YXIgUmVMVT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzLG51bGw9PWU/e306ZSl8fHRoaXM7cmV0dXJuIHQuc3VwcG9ydHNNYXNraW5nPSEwLG51bGwhPWUmJih0Lm1heFZhbHVlPWUubWF4VmFsdWUpLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbih0KXt0PWdldEV4YWN0bHlPbmVUZW5zb3IodCk7dmFyIGE9cmVsdSh0KTtyZXR1cm4gbnVsbCE9dGhpcy5tYXhWYWx1ZSYmKGE9Y2xpcEJ5VmFsdWUoYSwwLHRoaXMubWF4VmFsdWUpKSxhfSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXttYXhWYWx1ZTp0aGlzLm1heFZhbHVlfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJSZUxVXCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZUxVKTt2YXIgTGVha3lSZUxVPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9YS5jYWxsKHRoaXMsbnVsbD09ZT97fTplKXx8dGhpcztyZXR1cm4gci5ERUZBVUxUX0FMUEhBPS4zLG51bGw9PWUmJihlPXt9KSxyLmFscGhhPW51bGw9PWUuYWxwaGE/ci5ERUZBVUxUX0FMUEhBOmUuYWxwaGEscn1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQpe3ZhciBlPWdldEV4YWN0bHlPbmVUZW5zb3IodCk7cmV0dXJuIGxlYWt5UmVsdShlLHRoaXMuYWxwaGEpfSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXthbHBoYTp0aGlzLmFscGhhfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJMZWFreVJlTFVcIixlfShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExlYWt5UmVMVSk7dmFyIEVMVSQxPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9YS5jYWxsKHRoaXMsbnVsbD09ZT97fTplKXx8dGhpcztpZihyLkRFRkFVTFRfQUxQSEE9MSxudWxsPT1lJiYoZT17fSksbnVsbCE9ZS5hbHBoYSYmZS5hbHBoYSE9PXIuREVGQVVMVF9BTFBIQSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IGFscGhhIHZhbHVlIChcIitlLmFscGhhK1wiKSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBFTFUgbGF5ZXIgeWV0LlwiKTtyZXR1cm4gci5hbHBoYT1udWxsPT1lLmFscGhhP3IuREVGQVVMVF9BTFBIQTplLmFscGhhLHJ9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbih0KXt2YXIgZT1nZXRFeGFjdGx5T25lVGVuc29yKHQpO3JldHVybiBlbHUoZSl9LGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2FscGhhOnRoaXMuYWxwaGF9LHQ9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmNsYXNzTmFtZT1cIkVMVVwiLGV9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRUxVJDEpO3ZhciBUaHJlc2hvbGRlZFJlTFU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgcj1hLmNhbGwodGhpcyxudWxsPT1lP3t9OmUpfHx0aGlzO3JldHVybiByLkRFRkFVTFRfVEhFVEE9MSxudWxsPT1lJiYoZT17fSksci50aGV0YT1udWxsPT1lLnRoZXRhP3IuREVGQVVMVF9USEVUQTplLnRoZXRhLHIudGhldGFUZW5zb3I9Z2V0U2NhbGFyKHIudGhldGEpLHJ9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbih0KXt2YXIgZT1nZXRFeGFjdGx5T25lVGVuc29yKHQpO3JldHVybiBlLm11bChjYXN0JDEoZS5ncmVhdGVyKHRoaXMudGhldGFUZW5zb3IpLFwiZmxvYXQzMlwiKSl9LGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e3RoZXRhOnRoaXMudGhldGF9LHQ9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmNsYXNzTmFtZT1cIlRocmVzaG9sZGVkUmVMVVwiLGV9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGhyZXNob2xkZWRSZUxVKTt2YXIgU29mdG1heCQxPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9YS5jYWxsKHRoaXMsbnVsbD09ZT97fTplKXx8dGhpcztyZXR1cm4gci5ERUZBVUxUX0FYSVM9MSxudWxsPT1lJiYoZT17fSksci5zb2Z0bWF4PW5ldyBTb2Z0bWF4KCkuYXBwbHksci5heGlzPW51bGw9PWUuYXhpcz9yLkRFRkFVTFRfQVhJUzplLmF4aXMscn1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQpe3ZhciBlPWdldEV4YWN0bHlPbmVUZW5zb3IodCk7cmV0dXJuIHRoaXMuc29mdG1heChlLHRoaXMuYXhpcyl9LGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2F4aXM6dGhpcy5heGlzfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJTb2Z0bWF4XCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0bWF4JDEpO3ZhciBSZWd1bGFyaXplcj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT1hJiZhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlfShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksTDFMMj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzKXx8dGhpcyxuPW51bGw9PWV8fG51bGw9PWUubDE/LjAxOmUubDEscj1udWxsPT1lfHxudWxsPT1lLmwyPy4wMTplLmwyO3JldHVybiB0Lmhhc0wxPTAhPT1uLHQuaGFzTDI9MCE9PXIsdC5sMT1nZXRTY2FsYXIobiksdC5sMj1nZXRTY2FsYXIociksdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9emVyb3MoWzFdKTtyZXR1cm4gZS5oYXNMMSYmKHQ9YWRkKHQsc3VtJDEobXVsKGUubDEsYWJzKGEpKSkpKSxlLmhhc0wyJiYodD1hZGQodCxzdW0kMShtdWwoZS5sMixzcXVhcmUkMShhKSkpKSksdC5hc1NjYWxhcigpfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsMTp0aGlzLmwxLmRhdGFTeW5jKClbMF0sbDI6dGhpcy5sMi5kYXRhU3luYygpWzBdfX0sZS5mcm9tQ29uZmlnPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIG5ldyBhKHtsMTplLmwxLGwyOmUubDJ9KX0sZS5jbGFzc05hbWU9XCJMMUwyXCIsZX0oUmVndWxhcml6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMMUwyKTt2YXIgUkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQPXtsMWwyOlwiTDFMMlwifSxCYXNlQ29udj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKHQsbil7dmFyIHI9YS5jYWxsKHRoaXMsbil8fHRoaXM7aWYoci5iaWFzPW51bGwsci5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLHIuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixlLnZlcmlmeUNvbmZpZyhuKSxyLnJhbms9dCwxIT09ci5yYW5rJiYyIT09ci5yYW5rKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiQ29udm9sdXRpb24gbGF5ZXIgZm9yIHJhbmsgb3RoZXIgdGhhbiAxIG9yIDIgKFwiK3IucmFuaytcIikgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7aWYoci5rZXJuZWxTaXplPW5vcm1hbGl6ZUFycmF5KG4ua2VybmVsU2l6ZSx0LFwia2VybmVsU2l6ZVwiKSxyLnN0cmlkZXM9bm9ybWFsaXplQXJyYXkobnVsbD09bi5zdHJpZGVzPzE6bi5zdHJpZGVzLHQsXCJzdHJpZGVzXCIpLHIucGFkZGluZz1udWxsPT1uLnBhZGRpbmc/XCJ2YWxpZFwiOm4ucGFkZGluZyxjaGVja1BhZGRpbmdNb2RlKHIucGFkZGluZyksci5kYXRhRm9ybWF0PW51bGw9PW4uZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOm4uZGF0YUZvcm1hdCxjaGVja0RhdGFGb3JtYXQoci5kYXRhRm9ybWF0KSxyLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbihuLmFjdGl2YXRpb24pLHIudXNlQmlhcz1udWxsPT1uLnVzZUJpYXN8fG4udXNlQmlhcyxyLmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihuLmJpYXNJbml0aWFsaXplcnx8ci5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLHIuYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChuLmJpYXNDb25zdHJhaW50KSxyLmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihuLmJpYXNSZWd1bGFyaXplciksci5hY3Rpdml0eVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKG4uYWN0aXZpdHlSZWd1bGFyaXplciksci5kaWxhdGlvblJhdGU9bm9ybWFsaXplQXJyYXkobnVsbD09bi5kaWxhdGlvblJhdGU/MTpuLmRpbGF0aW9uUmF0ZSx0LFwiZGlsYXRpb25SYXRlXCIpLDE9PT1yLnJhbmsmJkFycmF5LmlzQXJyYXkoci5kaWxhdGlvblJhdGUpJiYxIT09ci5kaWxhdGlvblJhdGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyIGZvciAxRCBjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KHIuZGlsYXRpb25SYXRlKSk7aWYoMj09PXIucmFuaylpZihcIm51bWJlclwiPT10eXBlb2Ygci5kaWxhdGlvblJhdGUpci5kaWxhdGlvblJhdGU9W3IuZGlsYXRpb25SYXRlLHIuZGlsYXRpb25SYXRlXTtlbHNlIGlmKDIhPT1yLmRpbGF0aW9uUmF0ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJkaWxhdGlvblJhdGUgbXVzdCBiZSBhIG51bWJlciBvciBhcnJheSBvZiB0d28gbnVtYmVycyBmb3IgMkQgY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShyLmRpbGF0aW9uUmF0ZSkpO3JldHVybiByfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUudmVyaWZ5Q29uZmlnPWZ1bmN0aW9uKHQpe2lmKGFzc2VydCQxKFwia2VybmVsU2l6ZVwiaW4gdCxcInJlcXVpcmVkIGtleSAna2VybmVsU2l6ZScgbm90IGluIGNvbmZpZ1wiKSxcIm51bWJlclwiIT10eXBlb2YgdC5rZXJuZWxTaXplJiYhY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgodC5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkJhc2VDb252IGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEgb3IgMiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KHQua2VybmVsU2l6ZSkrXCIuXCIpfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgZT17a2VybmVsU2l6ZTp0aGlzLmtlcm5lbFNpemUsc3RyaWRlczp0aGlzLnN0cmlkZXMscGFkZGluZzp0aGlzLnBhZGRpbmcsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXQsZGlsYXRpb25SYXRlOnRoaXMuZGlsYXRpb25SYXRlLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KX0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGV9KExheWVyKSxDb252PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUodCxuKXt2YXIgcj1hLmNhbGwodGhpcyx0LG4pfHx0aGlzO3JldHVybiByLmtlcm5lbD1udWxsLGUudmVyaWZ5Q29uZmlnKG4pLHIuZmlsdGVycz1uLmZpbHRlcnMsci5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihuLmtlcm5lbEluaXRpYWxpemVyfHxyLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxyLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChuLmtlcm5lbENvbnN0cmFpbnQpLHIua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIobi5rZXJuZWxSZWd1bGFyaXplcikscn1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihhKXthPWdldEV4YWN0bHlPbmVTaGFwZShhKTt2YXIgbz1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8xOmEubGVuZ3RoLTE7aWYobnVsbD09YVtvXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXQgc2hvdWxkIGJlIGRlZmluZWQuIEZvdW5kIFwiK2Fbb10pO3ZhciB0PWFbb10scj10aGlzLmtlcm5lbFNpemUuY29uY2F0KFt0LHRoaXMuZmlsdGVyc10pLHM7dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixyLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy51c2VCaWFzJiYodGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpLHRoaXMuaW5wdXRTcGVjPVt7bmRpbTp0aGlzLnJhbmsrMixheGVzOihzPXt9LHNbb109dCxzKX1dLHRoaXMuYnVpbHQ9ITB9LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSl7dmFyIG89dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBlO2E9Z2V0RXhhY3RseU9uZVRlbnNvcihhKTt2YXIgbj1udWxsPT1vLmJpYXM/bnVsbDpvLmJpYXMucmVhZCgpO2lmKDE9PT1vLnJhbmspZT1jb252MWRXaXRoQmlhcyhhLG8ua2VybmVsLnJlYWQoKSxuLG8uc3RyaWRlc1swXSxvLnBhZGRpbmcsby5kYXRhRm9ybWF0LG8uZGlsYXRpb25SYXRlWzBdKTtlbHNlIGlmKDI9PT1vLnJhbmspZT1jb252MmRXaXRoQmlhcyhhLG8ua2VybmVsLnJlYWQoKSxuLG8uc3RyaWRlcyxvLnBhZGRpbmcsby5kYXRhRm9ybWF0LG8uZGlsYXRpb25SYXRlKTtlbHNlIGlmKDM9PT1vLnJhbmspdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCIzRCBjb252b2x1dGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gbnVsbCE9by5hY3RpdmF0aW9uJiYoZT1vLmFjdGl2YXRpb24uYXBwbHkoZSkpLGV9KX0sZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKG8pe289Z2V0RXhhY3RseU9uZVNoYXBlKG8pO2Zvcih2YXIgcz1bXSx0PVwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/by5zbGljZSgxLG8ubGVuZ3RoLTEpOm8uc2xpY2UoMiksbj0wLHA7bjx0Lmxlbmd0aDsrK24pcD1jb252T3V0cHV0TGVuZ3RoKHRbbl0sdGhpcy5rZXJuZWxTaXplW25dLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbbl0sXCJudW1iZXJcIj09dHlwZW9mIHRoaXMuZGlsYXRpb25SYXRlP3RoaXMuZGlsYXRpb25SYXRlOnRoaXMuZGlsYXRpb25SYXRlW25dKSxzLnB1c2gocCk7dmFyIGw9W29bMF1dO3JldHVyblwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/KGw9bC5jb25jYXQocykpLnB1c2godGhpcy5maWx0ZXJzKToobC5wdXNoKHRoaXMuZmlsdGVycyksbD1sLmNvbmNhdChzKSksbH0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2ZpbHRlcnM6dGhpcy5maWx0ZXJzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS52ZXJpZnlDb25maWc9ZnVuY3Rpb24odCl7aWYoIShcImZpbHRlcnNcImluIHQpfHxcIm51bWJlclwiIT10eXBlb2YgdC5maWx0ZXJzfHwxPnQuZmlsdGVycyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnZvbHV0aW9uIGxheWVyIGV4cGVjdGVkIGNvbmZpZy5maWx0ZXJzIHRvIGJlIGEgJ251bWJlcicgPiAwIGJ1dCBnb3QgXCIrSlNPTi5zdHJpbmdpZnkodC5maWx0ZXJzKSl9LGV9KEJhc2VDb252KSxDb252MkQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZSh0KXt2YXIgbj1hLmNhbGwodGhpcywyLHQpfHx0aGlzO3JldHVybiBlLnZlcmlmeUNvbmZpZyh0KSxufXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgZS5yYW5rLGV9LGUudmVyaWZ5Q29uZmlnPWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiB0Lmtlcm5lbFNpemUmJiFjaGVja0FycmF5VHlwZUFuZExlbmd0aCh0Lmtlcm5lbFNpemUsXCJudW1iZXJcIiwxLDIpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjJEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEgb3IgMiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KHQua2VybmVsU2l6ZSkrXCIuXCIpfSxlLmNsYXNzTmFtZT1cIkNvbnYyRFwiLGV9KENvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb252MkQpO3ZhciBDb252MkRUcmFuc3Bvc2U9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztpZih0LmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0fSldLFwic2FtZVwiIT09dC5wYWRkaW5nJiZcInZhbGlkXCIhPT10LnBhZGRpbmcpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252MkRUcmFuc3Bvc2UgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlcyAnc2FtZScgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCBwYWRkaW5nIG1vZGUgXCIrdC5wYWRkaW5nKTtyZXR1cm4gdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihhKXtpZig0IT09KGE9Z2V0RXhhY3RseU9uZVNoYXBlKGEpKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBzaG91bGQgaGF2ZSByYW5rIDQ7IFJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShhKSk7dmFyIG89XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTphLmxlbmd0aC0xO2lmKG51bGw9PWFbb10pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZC4gRm91bmQgYE5vbmVgLlwiKTt2YXIgdD1hW29dLHI9dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbdGhpcy5maWx0ZXJzLHRdKSxzO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIscixcImZsb2F0MzJcIix0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMmJih0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMuZmlsdGVyc10sXCJmbG9hdDMyXCIsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpLHRoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjQsYXhlczoocz17fSxzW29dPXQscyl9KV0sdGhpcy5idWlsdD0hMH0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihtKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihtKTtpZig0IT09bi5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252MkRUcmFuc3Bvc2UuY2FsbCgpIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIHJhbmstNCwgYnV0IHJlY2VpdmVkIGEgdGVuc29yIG9mIHJhbmstXCIrbi5zaGFwZS5sZW5ndGgpO3ZhciBnPW4uc2hhcGUsYT1nWzBdLG8seTtcImNoYW5uZWxzRmlyc3RcIj09PWUuZGF0YUZvcm1hdD8obz0yLHk9Myk6KG89MSx5PTIpO3ZhciBiPWdbb10scz1nW3ldLGw9ZS5rZXJuZWxTaXplWzBdLHU9ZS5rZXJuZWxTaXplWzFdLGM9ZS5zdHJpZGVzWzBdLHA9ZS5zdHJpZGVzWzFdLGg9W2EsZGVjb252TGVuZ3RoKGIsYyxsLGUucGFkZGluZyksZGVjb252TGVuZ3RoKHMscCx1LGUucGFkZGluZyksZS5maWx0ZXJzXTtcImNoYW5uZWxzTGFzdFwiIT09ZS5kYXRhRm9ybWF0JiYobj10cmFuc3Bvc2UobixbMCwyLDMsMV0pKTt2YXIgZD1jb252MmRUcmFuc3Bvc2UobixlLmtlcm5lbC5yZWFkKCksaCxlLnN0cmlkZXMsZS5wYWRkaW5nKTtyZXR1cm5cImNoYW5uZWxzTGFzdFwiIT09ZS5kYXRhRm9ybWF0JiYoZD10cmFuc3Bvc2UoZCxbMCwzLDEsMl0pKSxudWxsIT1lLmJpYXMmJihkPWJpYXNBZGQoZCxlLmJpYXMucmVhZCgpLGUuZGF0YUZvcm1hdCkpLG51bGwhPWUuYWN0aXZhdGlvbiYmKGQ9ZS5hY3RpdmF0aW9uLmFwcGx5KGQpKSxkfSl9LGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihwKXt2YXIgZD0ocD1nZXRFeGFjdGx5T25lU2hhcGUocCkpLnNsaWNlKCksaSx1LGM7XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/KGk9MSx1PTIsYz0zKTooaT0zLHU9MSxjPTIpO3ZhciBtPXRoaXMua2VybmVsU2l6ZVswXSxhPXRoaXMua2VybmVsU2l6ZVsxXSxvPXRoaXMuc3RyaWRlc1swXSxzPXRoaXMuc3RyaWRlc1sxXTtyZXR1cm4gZFtpXT10aGlzLmZpbHRlcnMsZFt1XT1kZWNvbnZMZW5ndGgoZFt1XSxvLG0sdGhpcy5wYWRkaW5nKSxkW2NdPWRlY29udkxlbmd0aChkW2NdLHMsYSx0aGlzLnBhZGRpbmcpLGR9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgZS5kaWxhdGlvblJhdGUsZX0sZS5jbGFzc05hbWU9XCJDb252MkRUcmFuc3Bvc2VcIixlfShDb252MkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb252MkRUcmFuc3Bvc2UpO3ZhciBTZXBhcmFibGVDb252PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSx0KXt2YXIgbj1hLmNhbGwodGhpcyxlLHQpfHx0aGlzO2lmKG4uREVGQVVMVF9ERVBUSFdJU0VfSU5JVElBTElaRVI9XCJnbG9yb3RVbmlmb3JtXCIsbi5ERUZBVUxUX1BPSU5UV0lTRV9JTklUSUFMSVpFUj1cImdsb3JvdFVuaWZvcm1cIixuLmRlcHRod2lzZUtlcm5lbD1udWxsLG4ucG9pbnR3aXNlS2VybmVsPW51bGwsbnVsbD09dC5maWx0ZXJzKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGBmaWx0ZXJzYCBjb25maWd1cmF0aW9uIGZpZWxkIGlzIHJlcXVpcmVkIGJ5IFNlcGFyYWJsZUNvbnYsIGJ1dCBpcyB1bnNwZWNpZmllZC5cIik7aWYobnVsbCE9dC5rZXJuZWxJbml0aWFsaXplcnx8bnVsbCE9dC5rZXJuZWxSZWd1bGFyaXplcnx8bnVsbCE9dC5rZXJuZWxDb25zdHJhaW50KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRmllbGRzIGtlcm5lbEluaXRpYWxpemVyLCBrZXJuZWxSZWd1bGFyaXplciBhbmQga2VybmVsQ29uc3RyYWludCBhcmUgaW52YWxpZCBmb3IgU2VwYXJhYmxlQ29udjJELiBVc2UgZGVwdGh3aXNlSW5pdGlhbGl6ZXIsIGRlcHRod2lzZVJlZ3VsYXJpemVyLCBkZXB0aHdpc2VDb25zdHJhaW50LCBwb2ludHdpc2VJbml0aWFsaXplciwgcG9pbnR3aXNlUmVndWxhcml6ZXIgYW5kIHBvaW50d2lzZUNvbnN0cmFpbnQgaW5zdGVhZC5cIik7aWYobnVsbCE9dC5wYWRkaW5nJiZcInNhbWVcIiE9PXQucGFkZGluZyYmXCJ2YWxpZFwiIT09dC5wYWRkaW5nKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiU2VwYXJhYmxlQ29udlwiK24ucmFuaytcIkQgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzOiAnc2FtZScgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0LnBhZGRpbmcpKTtyZXR1cm4gbi5kZXB0aE11bHRpcGxpZXI9bnVsbD09dC5kZXB0aE11bHRpcGxpZXI/MTp0LmRlcHRoTXVsdGlwbGllcixuLmRlcHRod2lzZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9ERVBUSFdJU0VfSU5JVElBTElaRVIpLG4uZGVwdGh3aXNlUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5kZXB0aHdpc2VSZWd1bGFyaXplciksbi5kZXB0aHdpc2VDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5kZXB0aHdpc2VDb25zdHJhaW50KSxuLnBvaW50d2lzZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9QT0lOVFdJU0VfSU5JVElBTElaRVIpLG4ucG9pbnR3aXNlUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5wb2ludHdpc2VSZWd1bGFyaXplciksbi5wb2ludHdpc2VDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5wb2ludHdpc2VDb25zdHJhaW50KSxufXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKHMpe2lmKChzPWdldEV4YWN0bHlPbmVTaGFwZShzKSkubGVuZ3RoPHRoaXMucmFuaysyKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXRzIHRvIFNlcGFyYWJsZUNvbnZcIit0aGlzLnJhbmsrXCJEIHNob3VsZCBoYXZlIHJhbmsgXCIrKHRoaXMucmFuaysyKStcIiwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShzKSk7dmFyIHA9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTpzLmxlbmd0aC0xO2lmKG51bGw9PXNbcF18fDA+c1twXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHNob3VsZCBiZSBkZWZpbmVkLCBidXQgZm91bmQgXCIrSlNPTi5zdHJpbmdpZnkoc1twXSkpO2Zvcih2YXIgdD1zW3BdLG49dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbdCx0aGlzLmRlcHRoTXVsdGlwbGllcl0pLHI9W10saT0wO2k8dGhpcy5yYW5rOysraSlyLnB1c2goMSk7ci5wdXNoKHQqdGhpcy5kZXB0aE11bHRpcGxpZXIsdGhpcy5maWx0ZXJzKTt2YXIgbDt0aGlzLmRlcHRod2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcImRlcHRod2lzZV9rZXJuZWxcIixuLFwiZmxvYXQzMlwiLHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIsdGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciwhMCx0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpLHRoaXMucG9pbnR3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicG9pbnR3aXNlX2tlcm5lbFwiLHIsXCJmbG9hdDMyXCIsdGhpcy5wb2ludHdpc2VJbml0aWFsaXplcix0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCksdGhpcy5iaWFzPXRoaXMudXNlQmlhcz90aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxcImZsb2F0MzJcIix0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTpudWxsLHRoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOnRoaXMucmFuaysyLGF4ZXM6KGw9e30sbFtwXT10LGwpfSldLHRoaXMuYnVpbHQ9ITB9LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSl7dmFyIHI9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBlO2lmKGE9Z2V0RXhhY3RseU9uZVRlbnNvcihhKSwxPT09ci5yYW5rKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiMUQgc2VwYXJhYmxlIGNvbnZvbHV0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiAyPT09ci5yYW5rJiYoXCJjaGFubmVsc0ZpcnN0XCI9PT1yLmRhdGFGb3JtYXQmJihhPXRyYW5zcG9zZShhLFswLDIsMywxXSkpLGU9c2VwYXJhYmxlQ29udjJkKGEsci5kZXB0aHdpc2VLZXJuZWwucmVhZCgpLHIucG9pbnR3aXNlS2VybmVsLnJlYWQoKSxyLnN0cmlkZXMsci5wYWRkaW5nLHIuZGlsYXRpb25SYXRlLFwiTkhXQ1wiKSksci51c2VCaWFzJiYoZT1iaWFzQWRkKGUsci5iaWFzLnJlYWQoKSxyLmRhdGFGb3JtYXQpKSxudWxsIT1yLmFjdGl2YXRpb24mJihlPXIuYWN0aXZhdGlvbi5hcHBseShlKSksXCJjaGFubmVsc0ZpcnN0XCI9PT1yLmRhdGFGb3JtYXQmJihlPXRyYW5zcG9zZShlLFswLDMsMSwyXSkpLGV9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSBlLnJhbmssZGVsZXRlIGUua2VybmVsSW5pdGlhbGl6ZXIsZGVsZXRlIGUua2VybmVsUmVndWxhcml6ZXIsZGVsZXRlIGUua2VybmVsQ29uc3RyYWludCxlLmRlcHRod2lzZUluaXRpYWxpemVyPXNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpLGUucG9pbnR3aXNlSW5pdGlhbGl6ZXI9c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5wb2ludHdpc2VJbml0aWFsaXplciksZS5kZXB0aHdpc2VSZWd1bGFyaXplcj1zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyKSxlLnBvaW50d2lzZVJlZ3VsYXJpemVyPXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIpLGUuZGVwdGh3aXNlQ29uc3RyYWludD1zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksZS5wb2ludHdpc2VDb25zdHJhaW50PXNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5wb2ludHdpc2VDb25zdHJhaW50KSxlfSxlLmNsYXNzTmFtZT1cIlNlcGFyYWJsZUNvbnZcIixlfShDb252KSxTZXBhcmFibGVDb252MkQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gYS5jYWxsKHRoaXMsMixlKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLmNsYXNzTmFtZT1cIlNlcGFyYWJsZUNvbnYyRFwiLGV9KFNlcGFyYWJsZUNvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTZXBhcmFibGVDb252MkQpO3ZhciBDb252MUQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZSh0KXt2YXIgbj1hLmNhbGwodGhpcywxLHQpfHx0aGlzO3JldHVybiBlLnZlcmlmeUNvbmZpZyh0KSxuLmlucHV0U3BlYz1be25kaW06M31dLG59cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSBlLnJhbmssZGVsZXRlIGUuZGF0YUZvcm1hdCxlfSxlLnZlcmlmeUNvbmZpZz1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdC5rZXJuZWxTaXplJiYhY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgodC5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwxKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnYxRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGxlbmd0aCAxLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkodC5rZXJuZWxTaXplKStcIi5cIil9LGUuY2xhc3NOYW1lPVwiQ29udjFEXCIsZX0oQ29udik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYxRCk7dmFyIENyb3BwaW5nMkQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gdC5jcm9wcGluZz1cIm51bWJlclwiPT10eXBlb2YgZS5jcm9wcGluZz9bW2UuY3JvcHBpbmcsZS5jcm9wcGluZ10sW2UuY3JvcHBpbmcsZS5jcm9wcGluZ11dOlwibnVtYmVyXCI9PXR5cGVvZiBlLmNyb3BwaW5nWzBdP1tbZS5jcm9wcGluZ1swXSxlLmNyb3BwaW5nWzBdXSxbZS5jcm9wcGluZ1sxXSxlLmNyb3BwaW5nWzFdXV06ZS5jcm9wcGluZyx0LmRhdGFGb3JtYXQ9dm9pZCAwPT09ZS5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6ZS5kYXRhRm9ybWF0LHQuaW5wdXRTcGVjPVt7bmRpbTo0fV0sdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24odCl7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W3RbMF0sdFsxXSx0WzJdLXRoaXMuY3JvcHBpbmdbMF1bMF0tdGhpcy5jcm9wcGluZ1swXVsxXSx0WzNdLXRoaXMuY3JvcHBpbmdbMV1bMF0tdGhpcy5jcm9wcGluZ1sxXVsxXV06W3RbMF0sdFsxXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sdFsyXS10aGlzLmNyb3BwaW5nWzFdWzBdLXRoaXMuY3JvcHBpbmdbMV1bMV0sdFszXV19LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCl7dmFyIGE9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiB0PWdldEV4YWN0bHlPbmVUZW5zb3IodCksXCJjaGFubmVsc0xhc3RcIj09PWEuZGF0YUZvcm1hdD9zbGljZUFsb25nQXhpcyhzbGljZUFsb25nQXhpcyh0LGEuY3JvcHBpbmdbMF1bMF0sdC5zaGFwZVsxXS1hLmNyb3BwaW5nWzBdWzBdLWEuY3JvcHBpbmdbMF1bMV0sMiksYS5jcm9wcGluZ1sxXVswXSx0LnNoYXBlWzJdLWEuY3JvcHBpbmdbMV1bMV0tYS5jcm9wcGluZ1sxXVswXSwzKTpzbGljZUFsb25nQXhpcyhzbGljZUFsb25nQXhpcyh0LGEuY3JvcHBpbmdbMF1bMF0sdC5zaGFwZVsyXS1hLmNyb3BwaW5nWzBdWzBdLWEuY3JvcHBpbmdbMF1bMV0sMyksYS5jcm9wcGluZ1sxXVswXSx0LnNoYXBlWzNdLWEuY3JvcHBpbmdbMV1bMV0tYS5jcm9wcGluZ1sxXVswXSw0KX0pfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgZT17Y3JvcHBpbmc6dGhpcy5jcm9wcGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiQ3JvcHBpbmcyRFwiLGV9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ3JvcHBpbmcyRCk7dmFyIFVwU2FtcGxpbmcyRD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiB0LkRFRkFVTFRfU0laRT1bMiwyXSx0LmlucHV0U3BlYz1be25kaW06NH1dLHQuc2l6ZT1udWxsPT1lLnNpemU/dC5ERUZBVUxUX1NJWkU6ZS5zaXplLHQuZGF0YUZvcm1hdD1udWxsPT1lLmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjplLmRhdGFGb3JtYXQsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oYSl7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQpe3ZhciBlPW51bGw9PWFbMl0/bnVsbDp0aGlzLnNpemVbMF0qYVsyXSxyPW51bGw9PWFbM10/bnVsbDp0aGlzLnNpemVbMV0qYVszXTtyZXR1cm5bYVswXSxhWzFdLGUscl19cmV0dXJuIGU9bnVsbD09YVsxXT9udWxsOnRoaXMuc2l6ZVswXSphWzFdLHI9bnVsbD09YVsyXT9udWxsOnRoaXMuc2l6ZVsxXSphWzJdLFthWzBdLGUscixhWzNdXX0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihzKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihzKSxwPW4uc2hhcGU7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT1lLmRhdGFGb3JtYXQpe249dHJhbnNwb3NlKG4sWzAsMiwzLDFdKTt2YXIgcj1lLnNpemVbMF0qcFsyXSxsPWUuc2l6ZVsxXSpwWzNdLGQ9bi5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW3IsbF0pO3JldHVybiB0cmFuc3Bvc2UoZCxbMCwzLDEsMl0pfXJldHVybiByPWUuc2l6ZVswXSpwWzFdLGw9ZS5zaXplWzFdKnBbMl0sbi5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW3IsbF0pfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXtzaXplOnRoaXMuc2l6ZSxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiVXBTYW1wbGluZzJEXCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhVcFNhbXBsaW5nMkQpO3ZhciBEZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcywyLGUpfHx0aGlzO3JldHVybiB0LmRlcHRod2lzZUtlcm5lbD1udWxsLHQuZGVwdGhNdWx0aXBsaWVyPW51bGw9PWUuZGVwdGhNdWx0aXBsaWVyPzE6ZS5kZXB0aE11bHRpcGxpZXIsdC5kZXB0aHdpc2VJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLmRlcHRod2lzZUluaXRpYWxpemVyfHx0LkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSx0LmRlcHRod2lzZUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChlLmRlcHRod2lzZUNvbnN0cmFpbnQpLHQuZGVwdGh3aXNlUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5kZXB0aHdpc2VSZWd1bGFyaXplciksdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihhKXtpZig0PihhPWdldEV4YWN0bHlPbmVTaGFwZShhKSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgaGF2ZSByYW5rIDQuIFJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShhKStcIi5cIik7dmFyIG89XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTozO2lmKG51bGw9PWFbb118fDA+YVtvXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgYmUgZGVmaW5lZCwgYnV0IGlzIG5vdCAoXCIrYVtvXStcIikuXCIpO3ZhciB0PWFbb10sbj1bdGhpcy5rZXJuZWxTaXplWzBdLHRoaXMua2VybmVsU2l6ZVsxXSx0LHRoaXMuZGVwdGhNdWx0aXBsaWVyXTt0aGlzLmRlcHRod2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcImRlcHRod2lzZV9rZXJuZWxcIixuLG51bGwsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcix0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksdGhpcy5iaWFzPXRoaXMudXNlQmlhcz90aGlzLmFkZFdlaWdodChcImJpYXNcIixbdCp0aGlzLmRlcHRoTXVsdGlwbGllcl0sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTpudWxsLHRoaXMuYnVpbHQ9ITB9LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSl7dmFyIHI9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBlPWRlcHRod2lzZUNvbnYyZCQxKGE9Z2V0RXhhY3RseU9uZVRlbnNvcihhKSxyLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksci5zdHJpZGVzLHIucGFkZGluZyxyLmRhdGFGb3JtYXQsbnVsbCk7cmV0dXJuIHIudXNlQmlhcyYmKGU9Ymlhc0FkZChlLHIuYmlhcy5yZWFkKCksci5kYXRhRm9ybWF0KSksbnVsbCE9ci5hY3RpdmF0aW9uJiYoZT1yLmFjdGl2YXRpb24uYXBwbHkoZSkpLGV9KX0sZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKG8pe289Z2V0RXhhY3RseU9uZVNoYXBlKG8pO3ZhciBzPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P29bMl06b1sxXSx0PVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P29bM106b1syXSxuPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P29bMV0qdGhpcy5kZXB0aE11bHRpcGxpZXI6b1szXSp0aGlzLmRlcHRoTXVsdGlwbGllcixyPWNvbnZPdXRwdXRMZW5ndGgocyx0aGlzLmtlcm5lbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSksaT1jb252T3V0cHV0TGVuZ3RoKHQsdGhpcy5rZXJuZWxTaXplWzFdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMV0pO3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P1tvWzBdLG4scixpXTpbb1swXSxyLGksbl19LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBlLmRlcHRoTXVsdGlwbGllcj10aGlzLmRlcHRoTXVsdGlwbGllcixlLmRlcHRod2lzZUluaXRpYWxpemVyPXNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpLGUuZGVwdGh3aXNlUmVndWxhcml6ZXI9c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksZS5kZXB0aHdpc2VDb25zdHJhaW50PXNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksZX0sZS5jbGFzc05hbWU9XCJEZXB0aHdpc2VDb252MkRcIixlfShCYXNlQ29udik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERlcHRod2lzZUNvbnYyRCk7dmFyIERyb3BvdXQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztpZih0LnJhdGU9X01hdGhtYXgoX01hdGhtaW4oZS5yYXRlLDEpLDApLHQucmF0ZVNjYWxhcj1nZXRTY2FsYXIodC5yYXRlKSx0Lm5vaXNlU2hhcGU9ZS5ub2lzZVNoYXBlLHQuc2VlZD1lLnNlZWQsbnVsbCE9dC5zZWVkKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgc2VlZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRHJvcG91dCBsYXllciB5ZXQ6IFwiK3Quc2VlZCk7cmV0dXJuIHQuc3VwcG9ydHNNYXNraW5nPSEwLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuZ2V0Tm9pc2VTaGFwZT1mdW5jdGlvbihhKXtpZihudWxsPT10aGlzLm5vaXNlU2hhcGUpcmV0dXJuIHRoaXMubm9pc2VTaGFwZTtmb3IodmFyIGU9YS5zaGFwZSx0PVtdLG49MDtuPHRoaXMubm9pc2VTaGFwZS5sZW5ndGg7KytuKXQucHVzaChudWxsPT10aGlzLm5vaXNlU2hhcGVbbl0/ZVtuXTp0aGlzLm5vaXNlU2hhcGVbbl0pO3JldHVybiB0fSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKG8sZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3QuaW52b2tlQ2FsbEhvb2sobyxlKTt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKG8pO2lmKG51bGwhPXQubm9pc2VTaGFwZSYmIXV0aWwuYXJyYXlzRXF1YWwobi5zaGFwZSx0Lm5vaXNlU2hhcGUpKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgbm9pc2Ugc2hhcGUgaXMgbm90IGltcGxlbWVudGVkIGluIERyb3BvdXQgbGF5ZXIgeWV0OiBcIitKU09OLnN0cmluZ2lmeSh0Lm5vaXNlU2hhcGUpKTtpZigwPHQucmF0ZSYmMT50LnJhdGUpe3ZhciByPW51bGwhPWUudHJhaW5pbmcmJmUudHJhaW5pbmcscz10LmdldE5vaXNlU2hhcGUobik7cmV0dXJuIGluVHJhaW5QaGFzZShmdW5jdGlvbigpe3JldHVybiBkcm9wb3V0KG4sdC5yYXRlU2NhbGFyLHMsdC5zZWVkKX0sZnVuY3Rpb24oKXtyZXR1cm4gbn0scil9cmV0dXJuIG99KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e3JhdGU6dGhpcy5yYXRlLG5vaXNlU2hhcGU6dGhpcy5ub2lzZVNoYXBlLHNlZWQ6dGhpcy5zZWVkfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJEcm9wb3V0XCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhEcm9wb3V0KTt2YXIgRGVuc2U9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztpZih0LmFjdGl2YXRpb249bnVsbCx0LnVzZUJpYXM9ITAsdC5rZXJuZWw9bnVsbCx0LmJpYXM9bnVsbCx0LkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsdC5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLG51bGw9PWUuYmF0Y2hJbnB1dFNoYXBlJiZudWxsPT1lLmlucHV0U2hhcGUmJm51bGwhPWUuaW5wdXREaW0pe3ZhciBuPW51bGw7bnVsbCE9ZS5iYXRjaFNpemUmJihuPWUuYmF0Y2hTaXplKSx0LmJhdGNoSW5wdXRTaGFwZT1bbixlLmlucHV0RGltXX1yZXR1cm4gdC51bml0cz1lLnVuaXRzLHQuYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKGUuYWN0aXZhdGlvbiksbnVsbCE9ZS51c2VCaWFzJiYodC51c2VCaWFzPWUudXNlQmlhcyksdC5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLmtlcm5lbEluaXRpYWxpemVyfHx0LkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSx0LmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLmJpYXNJbml0aWFsaXplcnx8dC5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLHQua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KGUua2VybmVsQ29uc3RyYWludCksdC5iaWFzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KGUuYmlhc0NvbnN0cmFpbnQpLHQua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5rZXJuZWxSZWd1bGFyaXplciksdC5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5iaWFzUmVndWxhcml6ZXIpLHQuYWN0aXZpdHlSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihlLmFjdGl2aXR5UmVndWxhcml6ZXIpLHQuaW5wdXRTcGVjPVt7bWluTkRpbToyfV0sdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihhKXt2YXIgcj0oYT1nZXRFeGFjdGx5T25lU2hhcGUoYSkpW2EubGVuZ3RoLTFdLG47bnVsbD09dGhpcy5rZXJuZWwmJih0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFtyLHRoaXMudW5pdHNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy51c2VCaWFzJiYodGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLnVuaXRzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpKSksdGhpcy5pbnB1dFNwZWM9W3ttaW5ORGltOjIsYXhlczoobj17fSxuWy0xXT1yLG4pfV0sdGhpcy5idWlsdD0hMH0sZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGEpe3ZhciBuPShhPWdldEV4YWN0bHlPbmVTaGFwZShhKSkuc2xpY2UoKTtyZXR1cm4gbltuLmxlbmd0aC0xXT10aGlzLnVuaXRzLG59LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSxlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dC5pbnZva2VDYWxsSG9vayhhLGUpO3ZhciBuPWRvdCQxKGdldEV4YWN0bHlPbmVUZW5zb3IoYSksdC5rZXJuZWwucmVhZCgpKTtyZXR1cm4gbnVsbCE9dC5iaWFzJiYobj1iaWFzQWRkKG4sdC5iaWFzLnJlYWQoKSkpLG51bGwhPXQuYWN0aXZhdGlvbiYmKG49dC5hY3RpdmF0aW9uLmFwcGx5KG4pKSxufSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KX0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiRGVuc2VcIixlfShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERlbnNlKTt2YXIgRmxhdHRlbj1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzLGV8fHt9KXx8dGhpcztyZXR1cm4gdC5pbnB1dFNwZWM9W3ttaW5ORGltOjN9XSx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihhKXtmb3IodmFyIHI9MCxvPShhPWdldEV4YWN0bHlPbmVTaGFwZShhKSkuc2xpY2UoMSk7cjxvLmxlbmd0aDtyKyspaWYobnVsbD09b1tyXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgdG8gXFxcIkZsYXR0ZW5cXFwiIGlzIG5vdCBmdWxseSBkZWZpbmVkIChnb3QgXCIrYS5zbGljZSgxKStcIikuIE1ha2Ugc3VyZSB0byBwYXNzIGEgY29tcGxldGUgXFxcImlucHV0X3NoYXBlXFxcIiBvciBcXFwiYmF0Y2hfaW5wdXRfc2hhcGVcXFwiIGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBsYXllciBpbiB5b3VyIG1vZGVsLlwiKTtyZXR1cm5bYVswXSxhcnJheVByb2QoYSwxKV19LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSxlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHQuaW52b2tlQ2FsbEhvb2soYSxlKSxiYXRjaEZsYXR0ZW4oZ2V0RXhhY3RseU9uZVRlbnNvcihhKSl9KX0sZS5jbGFzc05hbWU9XCJGbGF0dGVuXCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhGbGF0dGVuKTt2YXIgQWN0aXZhdGlvbiQxPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIHQuc3VwcG9ydHNNYXNraW5nPSEwLHQuYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKGUuYWN0aXZhdGlvbiksdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGEsZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3QuaW52b2tlQ2FsbEhvb2soYSxlKTt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGEpO3JldHVybiB0LmFjdGl2YXRpb24uYXBwbHkobil9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2FjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJBY3RpdmF0aW9uXCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBY3RpdmF0aW9uJDEpO3ZhciBSZXBlYXRWZWN0b3I9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gdC5uPWUubix0LmlucHV0U3BlYz1be25kaW06Mn1dLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKHQpe3JldHVyblt0WzBdLHRoaXMubix0WzFdXX0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbih0KXt2YXIgYT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHJlcGVhdCh0PWdldEV4YWN0bHlPbmVUZW5zb3IodCksYS5uKX0pfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgZT17bjp0aGlzLm59LHQ9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmNsYXNzTmFtZT1cIlJlcGVhdFZlY3RvclwiLGV9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVwZWF0VmVjdG9yKTt2YXIgUmVzaGFwZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzLGUpfHx0aGlzO3QudGFyZ2V0U2hhcGU9ZS50YXJnZXRTaGFwZTtmb3IodmFyIG49MDtuPHQudGFyZ2V0U2hhcGUubGVuZ3RoOysrbil0LmlzVW5rbm93bih0LnRhcmdldFNoYXBlW25dKSYmKHQudGFyZ2V0U2hhcGVbbl09bnVsbCk7cmV0dXJuIHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuaXNVbmtub3duPWZ1bmN0aW9uKHQpe3JldHVybiAwPnR8fG51bGw9PXR9LGUucHJvdG90eXBlLmZpeFVua25vd25EaW1lbnNpb249ZnVuY3Rpb24ocCxlKXtmb3IodmFyIHQ9XCJUb3RhbCBzaXplIG9mIG5ldyBhcnJheSBtdXN0IGJlIHVuY2hhbmdlZC5cIixuPWUuc2xpY2UoKSxyPTEsZD1udWxsLHU9MCxjO3U8bi5sZW5ndGg7Kyt1KWlmKGM9blt1XSx0aGlzLmlzVW5rbm93bihjKSl7aWYobnVsbCE9ZCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbiBvbmx5IHNwZWNpZml5IG9uZSB1bmtub3duIGRpbWVuc2lvbi5cIik7ZD11fWVsc2Ugcio9Yzt2YXIgbT1hcnJheVByb2QocCk7aWYobnVsbCE9PWQpe2lmKDA9PT1yfHwwIT1tJXIpdGhyb3cgbmV3IFZhbHVlRXJyb3IodCk7bltkXT1tL3J9ZWxzZSBpZihtIT09cil0aHJvdyBuZXcgVmFsdWVFcnJvcih0KTtyZXR1cm4gbn0sZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgZT0hMSxyPTA7cjxhLmxlbmd0aDsrK3IpaWYodGhpcy5pc1Vua25vd24oYVtyXSkpe2U9ITA7YnJlYWt9cmV0dXJuIGU/YS5zbGljZSgwLDEpLmNvbmNhdCh0aGlzLnRhcmdldFNoYXBlKTphLnNsaWNlKDAsMSkuY29uY2F0KHRoaXMuZml4VW5rbm93bkRpbWVuc2lvbihhLnNsaWNlKDEpLHRoaXMudGFyZ2V0U2hhcGUpKX0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihvLGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt0Lmludm9rZUNhbGxIb29rKG8sZSk7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihvKSxyPW4uc2hhcGUscz1yLnNsaWNlKDAsMSkuY29uY2F0KHQuZml4VW5rbm93bkRpbWVuc2lvbihyLnNsaWNlKDEpLHQudGFyZ2V0U2hhcGUpKTtyZXR1cm4gbi5yZXNoYXBlKHMpfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXt0YXJnZXRTaGFwZTp0aGlzLnRhcmdldFNoYXBlfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJSZXNoYXBlXCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZXNoYXBlKTt2YXIgUGVybXV0ZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzLGUpfHx0aGlzO2lmKG51bGw9PWUuZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkIGBkaW1zYCBpcyBtaXNzaW5nIGR1cmluZyBQZXJtdXRlIGNvbnN0cnVjdG9yIGNhbGwuXCIpO2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiUGVybXV0ZSBjb25zdHJ1Y3RvciByZXF1aXJlcyBgZGltc2AgdG8gYmUgYW4gQXJyYXksIGJ1dCByZWNlaXZlZCBcIitlLmRpbXMrXCIgaW5zdGVhZC5cIik7dmFyIG49cmFuZ2UkMSgxLGUuZGltcy5sZW5ndGgrMSk7aWYoIXV0aWwuYXJyYXlzRXF1YWwoZS5kaW1zLnNsaWNlKCkuc29ydCgpLG4pKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVybXV0YXRpb24gYGRpbXNgOiBcIitKU09OLnN0cmluZ2lmeShlLmRpbXMpK1wiIGBkaW1zYCBtdXN0IGNvbnRhaW4gY29uc2VjdXRpdmUgaW50ZWdlcnMgc3RhcnRpbmcgZnJvbSAxLlwiKTtyZXR1cm4gdC5kaW1zPWUuZGltcyx0LmRpbXNJbmNsdWRpbmdCYXRjaD1bMF0uY29uY2F0KHQuZGltcyksdC5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06dC5kaW1zLmxlbmd0aCsxfSldLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGEpe3ZhciBvPShhPWdldEV4YWN0bHlPbmVTaGFwZShhKSkuc2xpY2UoKTtyZXR1cm4gdGhpcy5kaW1zLmZvckVhY2goZnVuY3Rpb24oZSx0KXtvW3QrMV09YVtlXX0pLG99LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCl7cmV0dXJuIHRyYW5zcG9zZShnZXRFeGFjdGx5T25lVGVuc29yKHQpLHRoaXMuZGltc0luY2x1ZGluZ0JhdGNoKX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2RpbXM6dGhpcy5kaW1zfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJQZXJtdXRlXCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhQZXJtdXRlKTt2YXIgRW1iZWRkaW5nPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMsZSl8fHRoaXM7aWYodC5lbWJlZGRpbmdzPW51bGwsdC5ERUZBVUxUX0VNQkVERElOR1NfSU5JVElBTElaRVI9XCJyYW5kb21Vbmlmb3JtXCIsbnVsbD09ZS5iYXRjaElucHV0U2hhcGUmJm51bGw9PWUuaW5wdXRTaGFwZSl7dmFyIG49bnVsbDtudWxsIT1lLmJhdGNoU2l6ZSYmKG49ZS5iYXRjaFNpemUpLHQuYmF0Y2hJbnB1dFNoYXBlPW51bGw9PWUuaW5wdXRMZW5ndGg/W24sbnVsbF06W25dLmNvbmNhdCh0b0xpc3QoZS5pbnB1dExlbmd0aCkpfXJldHVybiB0LmlucHV0RGltPWUuaW5wdXREaW0sdC5vdXRwdXREaW09ZS5vdXRwdXREaW0sdC5lbWJlZGRpbmdzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoZS5lbWJlZGRpbmdzSW5pdGlhbGl6ZXJ8fHQuREVGQVVMVF9FTUJFRERJTkdTX0lOSVRJQUxJWkVSKSx0LmVtYmVkZGluZ3NSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihlLmVtYmVkZGluZ3NSZWd1bGFyaXplciksdC5hY3Rpdml0eVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKGUuYWN0aXZpdHlSZWd1bGFyaXplciksdC5lbWJlZGRpbmdzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KGUuZW1iZWRkaW5nc0NvbnN0cmFpbnQpLHQubWFza1plcm89ZS5tYXNrWmVybyx0LmlucHV0TGVuZ3RoPWUuaW5wdXRMZW5ndGgsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbigpe3RoaXMuZW1iZWRkaW5ncz10aGlzLmFkZFdlaWdodChcImVtYmVkZGluZ3NcIixbdGhpcy5pbnB1dERpbSx0aGlzLm91dHB1dERpbV0sdGhpcy5kdHlwZSx0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplcix0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciwhMCx0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50KSx0aGlzLmJ1aWx0PSEwfSxlLnByb3RvdHlwZS53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlPWZ1bmN0aW9uKCl7fSxlLnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbigpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiY29tcHV0ZU1hc2sgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciBFbWJlZGRpbmcgeWV0XCIpfSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24obyl7aWYobz1nZXRFeGFjdGx5T25lU2hhcGUobyksbnVsbD09dGhpcy5pbnB1dExlbmd0aClyZXR1cm4gby5jb25jYXQoW3RoaXMub3V0cHV0RGltXSk7dmFyIHM9dG9MaXN0KHRoaXMuaW5wdXRMZW5ndGgpO2lmKHMubGVuZ3RoIT09by5sZW5ndGgtMSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlxcXCJpbnB1dExlbmd0aFxcXCIgaXMgXCIrdGhpcy5pbnB1dExlbmd0aCtcIiwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlIGhhcyBzaGFwZSBcIitvKTtmb3IodmFyIHQ9MCxwPTA7cDxzLmxlbmd0aDsrK3Ape3ZhciBsPXNbcF0saT1vW3ArMV07aWYobnVsbCE9bCYmbnVsbCE9aSYmbCE9PWkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJcXFwiaW5wdXRMZW5ndGhcXFwiIGlzIFwiK3RoaXMuaW5wdXRMZW5ndGgrXCIsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZSBoYXMgc2hhcGUgXCIrbyk7bnVsbD09bCYmKHNbdF09aSksdCsrfXJldHVybltvWzBdXS5jb25jYXQocyxbdGhpcy5vdXRwdXREaW1dKX0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihhLGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt0Lmludm9rZUNhbGxIb29rKGEsZSk7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihhKTtyZXR1cm5cImludDMyXCIhPT1uLmR0eXBlJiYobj1jYXN0JDEobixcImludDMyXCIpKSxnYXRoZXIkMSh0LmVtYmVkZGluZ3MucmVhZCgpLG4uYXMxRCgpKS5yZXNoYXBlKGdldEV4YWN0bHlPbmVTaGFwZSh0LmNvbXB1dGVPdXRwdXRTaGFwZShuLnNoYXBlKSkpfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXtpbnB1dERpbTp0aGlzLmlucHV0RGltLG91dHB1dERpbTp0aGlzLm91dHB1dERpbSxlbWJlZGRpbmdzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIpLGVtYmVkZGluZ3NSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGVtYmVkZGluZ3NDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksbWFza1plcm86dGhpcy5tYXNrWmVybyxpbnB1dExlbmd0aDp0aGlzLmlucHV0TGVuZ3RofSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJFbWJlZGRpbmdcIixlfShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEVtYmVkZGluZyk7dmFyIE1lcmdlPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMsZXx8e30pfHx0aGlzO3JldHVybiB0LnN1cHBvcnRzTWFza2luZz0hMCx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oKXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn0sZS5wcm90b3R5cGUuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZT1mdW5jdGlvbihvLGUpe2lmKG51bGw9PW98fG51bGw9PWUpcmV0dXJuIG51bGw7aWYoby5sZW5ndGg8ZS5sZW5ndGgpcmV0dXJuIHRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZShlLG8pO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbztmb3IodmFyIHQ9by5zbGljZSgwLG8ubGVuZ3RoLWUubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciBzPW9bby5sZW5ndGgtZS5sZW5ndGgrbl0saT1lW25dO2lmKG51bGw9PXN8fG51bGw9PWl8fDA+c3x8MD5pKXQucHVzaChudWxsKTtlbHNlIGlmKDE9PT1zKXQucHVzaChpKTtlbHNlIGlmKDE9PT1pKXQucHVzaChzKTtlbHNle2lmKHMhPT1pKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIitKU09OLnN0cmluZ2lmeShvKStcIiBcIitKU09OLnN0cmluZ2lmeShlKSk7dC5wdXNoKHMpfX1yZXR1cm4gdH0sZS5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24ocCl7aWYoQXJyYXkuaXNBcnJheShwKSYmIUFycmF5LmlzQXJyYXkocFswXSkmJihwPVtnZXRFeGFjdGx5T25lU2hhcGUocCldKSwyPihwPXApLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgbWVyZ2UgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhbiBBcnJheSBvZiBhdCBsZWFzdCAyIGlucHV0cy4gR290IFwiK3AubGVuZ3RoK1wiIGlucHV0KHMpLlwiKTtmb3IodmFyIGw9W10sZD0wLHU9cDtkPHUubGVuZ3RoO2QrKyludWxsIT0obT11W2RdKSYmbnVsbCE9PW1bMF0mJmwucHVzaChtWzBdKTtpZigxPChsPXVuaXF1ZShsKSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2FuIG5vdCBtZXJnZSB0ZW5zb3JzIHdpdGggZGlmZmVyZW50IGJhdGNoIHNpemVzLiBHb3QgdGVuc29ycyB3aXRoIHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkocCkrXCIuXCIpO2Zvcih2YXIgcj1udWxsPT1wWzBdP251bGw6cFswXS5zbGljZSgxKSxjPTEsbTtjPHAubGVuZ3RoOysrYyltPW51bGw9PXBbY10/bnVsbDpwW2NdLnNsaWNlKDEpLHI9dGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHIsbSk7dmFyIGg9cC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RofSk7dGhpcy5yZXNoYXBlUmVxdWlyZWQ9LTEhPT1wLmluZGV4T2YobnVsbCl8fDEhPT11bmlxdWUoaCkubGVuZ3RofSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHgpe3ZhciBOPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZih4PXgsTi5yZXNoYXBlUmVxdWlyZWQpe3ZhciBlPVtdLHQ9eC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmFua30pO2lmKC0xPT09dC5pbmRleE9mKG51bGwpKXtmb3IodmFyIG49bWF4JDEodCkscj0wLGk9eDtyPGkubGVuZ3RoO3IrKyl7Zm9yKHZhciBvPShwPWlbcl0pLnJhbmssST0wO0k8bi1vOysrSSlwPWV4cGFuZERpbXMkMShwLDEpO2UucHVzaChwKX1yZXR1cm4gTi5tZXJnZUZ1bmN0aW9uKGUpfWZvcih2YXIgUz0hMSxDPTAsaz14O0M8ay5sZW5ndGg7QysrKXt2YXIgcDtpZihudWxsPT0obz0ocD1rW0NdKS5yYW5rKSl7dmFyIFQ9cC5zaGFwZSxkPVRbMF0sRT1ULnNsaWNlKDEpLmNvbmNhdChbZF0pLFI9cC5yZXNoYXBlKFtkXS5jb25jYXQoYXJyYXlQcm9kKFQuc2xpY2UoMSkpKSk7Uj0oUj10cmFuc3Bvc2UoUixbMSwwXSkpLnJlc2hhcGUoRSksZS5wdXNoKFIpLFM9ITB9ZWxzZSBpZigxPG8pe3ZhciBEPXJhbmdlJDEoMSxvKS5jb25jYXQoWzBdKTtlLnB1c2godHJhbnNwb3NlKHAsRCkpLFM9ITB9ZWxzZSBlLnB1c2gocCl9dmFyIFA9Ti5tZXJnZUZ1bmN0aW9uKGUpLEE9UC5yYW5rO2lmKFMpaWYobnVsbD09QSl7dmFyIGI9UC5zaGFwZTtFPVtkPWJbYi5sZW5ndGgtMV1dLmNvbmNhdChiLnNsaWNlKDAsYi5sZW5ndGgtMSkpLFA9dHJhbnNwb3NlKFAucmVzaGFwZShbLTEsZF0pLFsxLDBdKS5yZXNoYXBlKEUpfWVsc2UgMTxBJiYoRD1bQS0xXS5jb25jYXQocmFuZ2UkMSgwLEEtMSkpLFA9dHJhbnNwb3NlKFAsRCkpO3JldHVybiBQfXJldHVybiBOLm1lcmdlRnVuY3Rpb24oeCl9KX0sZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKHMpe3ZhciBwPW51bGw9PShzPXMpWzBdP251bGw6c1swXS5zbGljZSgxKTtmb3IodmFyIGw9MSxkO2w8cy5sZW5ndGg7KytsKWQ9bnVsbD09c1tsXT9udWxsOnNbbF0uc2xpY2UoMSkscD10aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUocCxkKTtmb3IodmFyIHU9W10sYz0wLG09cztjPG0ubGVuZ3RoO2MrKyludWxsIT0oZD1tW2NdKSYmbnVsbCE9PWRbMF0mJnUucHVzaChkWzBdKTtyZXR1cm4gcD0xPT09KHU9dW5pcXVlKHUpKS5sZW5ndGg/dS5jb25jYXQocCk6W251bGxdLmNvbmNhdChwKX0sZS5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImNvbXB1dGVNYXNrIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgTWVyZ2UgeWV0XCIpfSxlfShMYXllciksQWRkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGEuY2FsbCh0aGlzLGUpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oYSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIGU9YVswXS5jbG9uZSgpLHI9MTtyPGEubGVuZ3RoOysrcillPWFkZChlLGFbcl0pO3JldHVybiBlfSl9LGUuY2xhc3NOYW1lPVwiQWRkXCIsZX0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBZGQpO3ZhciBNdWx0aXBseT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3JldHVybiBhLmNhbGwodGhpcyxlKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFbMF0uY2xvbmUoKSxyPTE7cjxhLmxlbmd0aDsrK3IpZT1tdWwoZSxhW3JdKTtyZXR1cm4gZX0pfSxlLmNsYXNzTmFtZT1cIk11bHRpcGx5XCIsZX0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNdWx0aXBseSk7dmFyIEF2ZXJhZ2U9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gYS5jYWxsKHRoaXMsZSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgZT1hWzBdLmNsb25lKCkscj0xO3I8YS5sZW5ndGg7KytyKWU9YWRkKGUsYVtyXSk7cmV0dXJuIG11bChnZXRTY2FsYXIoMS9hLmxlbmd0aCksZSl9KX0sZS5jbGFzc05hbWU9XCJBdmVyYWdlXCIsZX0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBdmVyYWdlKTt2YXIgTWF4aW11bT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3JldHVybiBhLmNhbGwodGhpcyxlKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciBlPWFbMF0scj0xO3I8YS5sZW5ndGg7KytyKWU9bWF4aW11bShlLGFbcl0pO3JldHVybiBlfSl9LGUuY2xhc3NOYW1lPVwiTWF4aW11bVwiLGV9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4aW11bSk7dmFyIE1pbmltdW09ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gYS5jYWxsKHRoaXMsZSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgZT1hWzBdLHI9MTtyPGEubGVuZ3RoOysrcillPW1pbmltdW0oZSxhW3JdKTtyZXR1cm4gZX0pfSxlLmNsYXNzTmFtZT1cIk1pbmltdW1cIixlfShNZXJnZSk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1pbmltdW0pO3ZhciBDb25jYXRlbmF0ZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciByPWEuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiByLkRFRkFVTFRfQVhJUz0tMSxudWxsPT1lJiYoZT17fSksci5heGlzPW51bGw9PWUuYXhpcz9yLkRFRkFVTFRfQVhJUzplLmF4aXMsci5zdXBwb3J0c01hc2tpbmc9ITAsci5yZXNoYXBlUmVxdWlyZWQ9ITEscn1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihwKXtpZighQXJyYXkuaXNBcnJheShwKXx8IUFycmF5LmlzQXJyYXkocFswXSl8fDE9PT1wLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgYENvbmNhdGVuYXRlYCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBhdCBsZWFzdCAyIGlucHV0c1wiKTtmb3IodmFyIGQ9ITAsbT0wLGg9cD1wO208aC5sZW5ndGg7bSsrKWlmKG51bGwhPSh1PWhbbV0pKXtkPSExO2JyZWFrfWlmKCFkKXtmb3IodmFyIHI9W10saT0wLGc7aTxwLmxlbmd0aDsrK2kpe2c9cFtpXS5zbGljZSgpLGcuc3BsaWNlKHRoaXMuYXhpcywxKTtmb3IodmFyIGY9ITEseT0wLGI9cix1O3k8Yi5sZW5ndGg7eSsrKWlmKHU9Ylt5XSx1dGlsLmFycmF5c0VxdWFsKHUsZykpe2Y9ITA7YnJlYWt9Znx8ci5wdXNoKGcpfWlmKDE8ci5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgcmVxdWlyZXMgaW5wdXRzIHdpdGggbWF0Y2hpbmcgc2hhcGVzIGV4Y2VwdCBmb3IgdGhlIGNvbmNhdCBheGlzLiBHb3QgaW5wdXQgc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeShwKSl9fSxlLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGEpe3ZhciBlPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gY29uY2F0ZW5hdGUoYSxlLmF4aXMpfSl9LGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihzKXtpZighQXJyYXkuaXNBcnJheShzKXx8IUFycmF5LmlzQXJyYXkoc1swXSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgaW5wdXRzLlwiKTtmb3IodmFyIGU9cyx0PWVbMF0uc2xpY2UoKSxuPTA+dGhpcy5heGlzP3QubGVuZ3RoK3RoaXMuYXhpczp0aGlzLmF4aXMscj0wLHA9ZS5zbGljZSgxKSxhO3I8cC5sZW5ndGg7cisrKXtpZihhPXBbcl0sbnVsbD09dFtuXXx8bnVsbD09YVtuXSl7dFtuXT1udWxsO2JyZWFrfXRbbl0rPWFbbl19cmV0dXJuIHR9LGUucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJjb21wdXRlTWFzayBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIENvbmNhdGVuYXRlIHlldFwiKX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2F4aXM6dGhpcy5heGlzfSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJDb25jYXRlbmF0ZVwiLGV9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29uY2F0ZW5hdGUpO3ZhciBEb3Q9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gdC5heGVzPWUuYXhlcyx0Lm5vcm1hbGl6ZT1udWxsIT1lLm5vcm1hbGl6ZSYmZS5ub3JtYWxpemUsdC5zdXBwb3J0c01hc2tpbmc9ITAsdC5yZXNoYXBlUmVxdWlyZWQ9ITEsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihhKXt1dGlsLmFzc2VydChBcnJheS5pc0FycmF5KGEpJiYyPT09YS5sZW5ndGgmJkFycmF5LmlzQXJyYXkoYVswXSkmJkFycmF5LmlzQXJyYXkoYVsxXSksXCJBIGBEb3RgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGV4YWN0bHkgMiBpbnB1dHMuXCIpO3ZhciBlPWFbMF0sdD1hWzFdO2lmKDM8ZS5sZW5ndGh8fDM8dC5sZW5ndGgpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJEb3QgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldC5cIik7dmFyIG49dGhpcy5pbnRlcnByZXRBeGVzKGUsdCk7aWYoZVtuWzBdXSE9PXRbblsxXV0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEaW1lbnNpb24gaW5jb21wYXRpYmlsaXR5OiBcIitlW25bMF1dK1wiICE9PSBcIit0W25bMV1dKX0sZS5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihhKXtpZigyIT09YS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGBEb3RgIGxheWVyIG11c3QgYmUgY2FsbGVkIG9uIGV4YWN0bHkgMiBpbnB1dHMsIGJ1dCByZWNlaXZlZCBcIithLmxlbmd0aCtcIiBpbnB1dChzKS5cIik7dmFyIGU9YVswXSxvPWFbMV0scztyZXR1cm4gcz1BcnJheS5pc0FycmF5KHRoaXMuYXhlcyk/dGhpcy5heGVzLm1hcChmdW5jdGlvbihlLHQpe3JldHVybiBpbnRlcnByZXRBeGlzKGUsYVt0XS5zaGFwZS5sZW5ndGgpfSk6W2ludGVycHJldEF4aXModGhpcy5heGVzLGUuc2hhcGUubGVuZ3RoKSxpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyxvLnNoYXBlLmxlbmd0aCldLHRoaXMubm9ybWFsaXplJiYoZT1sMk5vcm1hbGl6ZShlLHNbMF0pLG89bDJOb3JtYWxpemUobyxzWzFdKSksYmF0Y2hEb3QoZSxvLHMpfSxlLnByb3RvdHlwZS5pbnRlcnByZXRBeGVzPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5heGVzKT90aGlzLmF4ZXM6W2ludGVycHJldEF4aXModGhpcy5heGVzLGEubGVuZ3RoKSxpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyxlLmxlbmd0aCldfSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oYSl7dXRpbC5hc3NlcnQoQXJyYXkuaXNBcnJheShhKSYmMj09PWEubGVuZ3RoJiZBcnJheS5pc0FycmF5KGFbMF0pJiZBcnJheS5pc0FycmF5KGFbMV0pLFwiQSBgRG90YCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBleGFjdGx5IDIgaW5wdXRzLlwiKTt2YXIgZT1hWzBdLnNsaWNlKCksdD1hWzFdLnNsaWNlKCk7aWYoMzxlLmxlbmd0aHx8Mzx0Lmxlbmd0aCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkRvdCBsYXllciBkb2VzIG5vdCBzdXBwb3J0IHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0LlwiKTt2YXIgbj10aGlzLmludGVycHJldEF4ZXMoZSx0KTtlLnNwbGljZShuWzBdLDEpLHQuc3BsaWNlKG5bMV0sMSksdC5zcGxpY2UoMCwxKTt2YXIgcj1lLmNvbmNhdCh0KTtyZXR1cm4gMT09PXIubGVuZ3RoJiZyLnB1c2goMSkscn0sZS5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImNvbXB1dGVNYXNrIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgRG90IHlldFwiKX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2F4ZXM6dGhpcy5heGVzLG5vcm1hbGl6ZTp0aGlzLm5vcm1hbGl6ZX0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiRG90XCIsZX0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhEb3QpO3ZhciBCYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgcj10aGlzO3JldHVybiBudWxsPT1lJiYoZT17fSksKHI9YS5jYWxsKHRoaXMsZSl8fHRoaXMpLnN1cHBvcnRzTWFza2luZz0hMCxyLmF4aXM9bnVsbD09ZS5heGlzPy0xOmUuYXhpcyxyLm1vbWVudHVtPW51bGw9PWUubW9tZW50dW0/Ljk5OmUubW9tZW50dW0sci5lcHNpbG9uPW51bGw9PWUuZXBzaWxvbj8uMDAxOmUuZXBzaWxvbixyLmNlbnRlcj1udWxsPT1lLmNlbnRlcnx8ZS5jZW50ZXIsci5zY2FsZT1udWxsPT1lLnNjYWxlfHxlLnNjYWxlLHIuYmV0YUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKGUuYmV0YUluaXRpYWxpemVyfHxcInplcm9zXCIpLHIuZ2FtbWFJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLmdhbW1hSW5pdGlhbGl6ZXJ8fFwib25lc1wiKSxyLm1vdmluZ01lYW5Jbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLm1vdmluZ01lYW5Jbml0aWFsaXplcnx8XCJ6ZXJvc1wiKSxyLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoZS5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyfHxcIm9uZXNcIiksci5iZXRhQ29uc3RyYWludD1nZXRDb25zdHJhaW50KGUuYmV0YUNvbnN0cmFpbnQpLHIuZ2FtbWFDb25zdHJhaW50PWdldENvbnN0cmFpbnQoZS5nYW1tYUNvbnN0cmFpbnQpLHIuYmV0YVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKGUuYmV0YVJlZ3VsYXJpemVyKSxyLmdhbW1hUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5nYW1tYVJlZ3VsYXJpemVyKSxyLnN0ZXBDb3VudD0wLHJ9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oYSl7YT1nZXRFeGFjdGx5T25lU2hhcGUoYSk7dmFyIG89MDw9dGhpcy5heGlzP3RoaXMuYXhpczp0aGlzLmF4aXMrYS5sZW5ndGgsdD1hW29dO2lmKG51bGw9PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBeGlzIFwiK28rXCIgb2YgaW5wdXQgdGVuc29yIHNob3VsZCBoYXZlIGEgZGVmaW5lZCBkaW1lbnNpb24gYnV0IHRoZSBsYXllciByZWNlaXZlZCBhbiBpbnB1dCB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KGEpK1wiLlwiKTt0aGlzLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTphLmxlbmd0aCxheGVzOihzPXt9LHNbb109dCxzKX0pXTt2YXIgbj1bdF0sczt0aGlzLnNjYWxlJiYodGhpcy5nYW1tYT10aGlzLmFkZFdlaWdodChcImdhbW1hXCIsbixudWxsLHRoaXMuZ2FtbWFJbml0aWFsaXplcix0aGlzLmdhbW1hUmVndWxhcml6ZXIsITAsdGhpcy5nYW1tYUNvbnN0cmFpbnQpKSx0aGlzLmNlbnRlciYmKHRoaXMuYmV0YT10aGlzLmFkZFdlaWdodChcImJldGFcIixuLG51bGwsdGhpcy5iZXRhSW5pdGlhbGl6ZXIsdGhpcy5iZXRhUmVndWxhcml6ZXIsITAsdGhpcy5iZXRhQ29uc3RyYWludCkpLHRoaXMubW92aW5nTWVhbj10aGlzLmFkZFdlaWdodChcIm1vdmluZ19tZWFuXCIsbixudWxsLHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyLG51bGwsITEpLHRoaXMubW92aW5nVmFyaWFuY2U9dGhpcy5hZGRXZWlnaHQoXCJtb3ZpbmdfdmFyaWFuY2VcIixuLG51bGwsdGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyLG51bGwsITEpLHRoaXMuYnVpbHQ9ITB9LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYixlKXt2YXIgeD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9bnVsbCE9ZS50cmFpbmluZyYmZS50cmFpbmluZyxuPWdldEV4YWN0bHlPbmVUZW5zb3IoYikscj1uLnNoYXBlLGE9ci5sZW5ndGgsbz1yYW5nZSQxKDAsYSkscz0wPD14LmF4aXM/eC5heGlzOnguYXhpcythO28uc3BsaWNlKHMsMSk7dmFyIGk9cHlMaXN0UmVwZWF0KDEsYSk7aVtzXT1yW3NdO3ZhciBsPW8uc2xpY2UoKTtsLnNvcnQoKTt2YXIgdT0hdXRpbC5hcnJheXNFcXVhbChsLHJhbmdlJDEoMCxhKS5zbGljZSgwLGEtMSkpO2lmKCF0KXJldHVybiBmdW5jdGlvbigpe2lmKHUpe3ZhciBvPXgubW92aW5nTWVhbi5yZWFkKCkucmVzaGFwZShpKSxlPXgubW92aW5nVmFyaWFuY2UucmVhZCgpLnJlc2hhcGUoaSksdD14LmNlbnRlcj94LmJldGEucmVhZCgpLnJlc2hhcGUoaSk6bnVsbCxyPXguc2NhbGU/eC5nYW1tYS5yZWFkKCkucmVzaGFwZShpKTpudWxsO3JldHVybiBiYXRjaE5vcm1hbGl6YXRpb24kMShuLG8sZSx0LHIseC5lcHNpbG9uKX1yZXR1cm4gYmF0Y2hOb3JtYWxpemF0aW9uJDEobix4Lm1vdmluZ01lYW4ucmVhZCgpLHgubW92aW5nVmFyaWFuY2UucmVhZCgpLG51bGw9PXguYmV0YT9udWxsOnguYmV0YS5yZWFkKCksbnVsbD09eC5nYW1tYT9udWxsOnguZ2FtbWEucmVhZCgpLHguZXBzaWxvbil9KCk7dmFyIHA9bm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKG4seC5nYW1tYS5yZWFkKCkseC5iZXRhLnJlYWQoKSxvLHguZXBzaWxvbiksYz1wWzBdLGQ9cFsxXSxoPXBbMl0sZz1hcnJheVByb2Qoby5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4uc2hhcGVbdF19KSksbT1oLm11bChnZXRTY2FsYXIoZy8oZy0oMSt4LmVwc2lsb24pKSkpO3JldHVybiBmdW5jdGlvbigpe3guc3RlcENvdW50Kys7dmFyIGE9bW92aW5nQXZlcmFnZSh4Lm1vdmluZ01lYW4ucmVhZCgpLGQseC5tb21lbnR1bSx4LnN0ZXBDb3VudCk7eC5tb3ZpbmdNZWFuLndyaXRlKGEpO3ZhciBlPW1vdmluZ0F2ZXJhZ2UoeC5tb3ZpbmdWYXJpYW5jZS5yZWFkKCksbSx4Lm1vbWVudHVtLHguc3RlcENvdW50KTt4Lm1vdmluZ1ZhcmlhbmNlLndyaXRlKGUpfSgpLGN9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2F4aXM6dGhpcy5heGlzLG1vbWVudHVtOnRoaXMubW9tZW50dW0sZXBzaWxvbjp0aGlzLmVwc2lsb24sY2VudGVyOnRoaXMuY2VudGVyLHNjYWxlOnRoaXMuc2NhbGUsYmV0YUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmV0YUluaXRpYWxpemVyKSxnYW1tYUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZ2FtbWFJbml0aWFsaXplciksbW92aW5nTWVhbkluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyKSxtb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nVmFyaWFuY2VJbml0aWFsaXplciksYmV0YVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmV0YVJlZ3VsYXJpemVyKSxnYW1tYVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZ2FtbWFSZWd1bGFyaXplciksYmV0YUNvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJldGFDb25zdHJhaW50KSxnYW1tYUNvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmdhbW1hQ29uc3RyYWludCl9LHQ9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmNsYXNzTmFtZT1cIkJhdGNoTm9ybWFsaXphdGlvblwiLGV9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQmF0Y2hOb3JtYWxpemF0aW9uKTt2YXIgWmVyb1BhZGRpbmcyRD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciBvPXRoaXM7aWYobnVsbD09ZSYmKGU9e30pLChvPWEuY2FsbCh0aGlzLGUpfHx0aGlzKS5kYXRhRm9ybWF0PW51bGw9PWUuZGF0YUZvcm1hdD9pbWFnZURhdGFGb3JtYXQoKTplLmRhdGFGb3JtYXQsbnVsbD09ZS5wYWRkaW5nKW8ucGFkZGluZz1bWzEsMV0sWzEsMV1dO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGUucGFkZGluZylvLnBhZGRpbmc9W1tlLnBhZGRpbmcsZS5wYWRkaW5nXSxbZS5wYWRkaW5nLGUucGFkZGluZ11dO2Vsc2V7aWYoZS5wYWRkaW5nPWUucGFkZGluZywyIT09ZS5wYWRkaW5nLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIitlLnBhZGRpbmcubGVuZ3RoK1wiIGFycmF5LlwiKTt2YXIgcyxwO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlLnBhZGRpbmdbMF0pcz1bZS5wYWRkaW5nWzBdLGUucGFkZGluZ1swXV0scD1bZS5wYWRkaW5nWzFdLGUucGFkZGluZ1sxXV07ZWxzZXtpZihlLnBhZGRpbmc9ZS5wYWRkaW5nLDIhPT1lLnBhZGRpbmdbMF0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiWmVyb1BhZGRpbmcyRCBleHBlY3RzIGhlaWdodCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIitlLnBhZGRpbmdbMF0ubGVuZ3RoK1wiIGFycmF5LlwiKTtpZihzPWUucGFkZGluZ1swXSwyIT09ZS5wYWRkaW5nWzFdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyB3aWR0aCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIitlLnBhZGRpbmdbMV0ubGVuZ3RoK1wiIGFycmF5LlwiKTtwPWUucGFkZGluZ1sxXX1vLnBhZGRpbmc9W3MscF19cmV0dXJuIG8uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjR9KV0sb31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oYSl7dmFyIHIsbztyZXR1cm4gYT1nZXRFeGFjdGx5T25lU2hhcGUoYSksXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/KHI9bnVsbCE9YVsyXSYmMDw9YVsyXT9hWzJdK3RoaXMucGFkZGluZ1swXVswXSt0aGlzLnBhZGRpbmdbMF1bMV06bnVsbCxvPW51bGwhPWFbM10mJjA8PWFbM10/YVszXSt0aGlzLnBhZGRpbmdbMV1bMF0rdGhpcy5wYWRkaW5nWzFdWzFdOm51bGwsW2FbMF0sYVsxXSxyLG9dKToocj1udWxsIT1hWzFdJiYwPD1hWzFdP2FbMV0rdGhpcy5wYWRkaW5nWzBdWzBdK3RoaXMucGFkZGluZ1swXVsxXTpudWxsLG89bnVsbCE9YVsyXSYmMDw9YVsyXT9hWzJdK3RoaXMucGFkZGluZ1sxXVswXSt0aGlzLnBhZGRpbmdbMV1bMV06bnVsbCxbYVswXSxyLG8sYVszXV0pfSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gc3BhdGlhbDJkUGFkZGluZyhnZXRFeGFjdGx5T25lVGVuc29yKHQpLGUucGFkZGluZyxlLmRhdGFGb3JtYXQpfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXtwYWRkaW5nOnRoaXMucGFkZGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiWmVyb1BhZGRpbmcyRFwiLGV9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoWmVyb1BhZGRpbmcyRCk7dmFyIFBvb2xpbmcxRD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PXRoaXM7aWYobnVsbD09ZS5wb29sU2l6ZSYmKGUucG9vbFNpemU9MiksdD1hLmNhbGwodGhpcyxlKXx8dGhpcyxcIm51bWJlclwiPT10eXBlb2YgZS5wb29sU2l6ZSl0LnBvb2xTaXplPVtlLnBvb2xTaXplXTtlbHNle2lmKCFBcnJheS5pc0FycmF5KGUucG9vbFNpemUpfHwxIT09ZS5wb29sU2l6ZS5sZW5ndGh8fFwibnVtYmVyXCIhPXR5cGVvZiBlLnBvb2xTaXplWzBdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwicG9vbFNpemUgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlLnBvb2xTaXplKSk7dC5wb29sU2l6ZT1lLnBvb2xTaXplfWlmKG51bGw9PWUuc3RyaWRlcyl0LnN0cmlkZXM9dC5wb29sU2l6ZTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBlLnN0cmlkZXMpdC5zdHJpZGVzPVtlLnN0cmlkZXNdO2Vsc2V7aWYoIUFycmF5LmlzQXJyYXkoZS5zdHJpZGVzKXx8MSE9PWUuc3RyaWRlcy5sZW5ndGh8fFwibnVtYmVyXCIhPXR5cGVvZiBlLnN0cmlkZXNbMF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzdHJpZGVzIGZvciAxRCBjb252b2x1dGlvbmFsIGxheWVyIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gQXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZS5zdHJpZGVzKSk7dC5zdHJpZGVzPWUuc3RyaWRlc31yZXR1cm4gdC5wYWRkaW5nPW51bGw9PWUucGFkZGluZz9cInZhbGlkXCI6ZS5wYWRkaW5nLGNoZWNrUGFkZGluZ01vZGUodC5wYWRkaW5nKSx0LmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTozfSldLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGEpe3ZhciBuPWNvbnZPdXRwdXRMZW5ndGgoKGE9Z2V0RXhhY3RseU9uZVNoYXBlKGEpKVsxXSx0aGlzLnBvb2xTaXplWzBdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMF0pO3JldHVyblthWzBdLG4sYVsyXV19LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSxvKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dC5pbnZva2VDYWxsSG9vayhhLG8pLGE9ZXhwYW5kRGltcyQxKGdldEV4YWN0bHlPbmVUZW5zb3IoYSksMik7dmFyIGU9dC5wb29saW5nRnVuY3Rpb24oZ2V0RXhhY3RseU9uZVRlbnNvcihhKSxbdC5wb29sU2l6ZVswXSwxXSxbdC5zdHJpZGVzWzBdLDFdLHQucGFkZGluZyxcImNoYW5uZWxzTGFzdFwiKTtyZXR1cm4gc3F1ZWV6ZShlLFsyXSl9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e3Bvb2xTaXplOnRoaXMucG9vbFNpemUscGFkZGluZzp0aGlzLnBhZGRpbmcsc3RyaWRlczp0aGlzLnN0cmlkZXN9LHQ9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlfShMYXllciksTWF4UG9vbGluZzFEPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGEuY2FsbCh0aGlzLGUpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihhLGUsdCxuLHIpe3JldHVybiBjaGVja0RhdGFGb3JtYXQociksY2hlY2tQYWRkaW5nTW9kZShuKSxwb29sMmQoYSxlLHQsbixyLFwibWF4XCIpfSxlLmNsYXNzTmFtZT1cIk1heFBvb2xpbmcxRFwiLGV9KFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heFBvb2xpbmcxRCk7dmFyIEF2ZXJhZ2VQb29saW5nMUQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gYS5jYWxsKHRoaXMsZSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uPWZ1bmN0aW9uKGEsZSx0LG4scil7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdChyKSxjaGVja1BhZGRpbmdNb2RlKG4pLHBvb2wyZChhLGUsdCxuLHIsXCJhdmdcIil9LGUuY2xhc3NOYW1lPVwiQXZlcmFnZVBvb2xpbmcxRFwiLGV9KFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEF2ZXJhZ2VQb29saW5nMUQpO3ZhciBQb29saW5nMkQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD10aGlzO2lmKG51bGw9PWUucG9vbFNpemUmJihlLnBvb2xTaXplPVsyLDJdKSwodD1hLmNhbGwodGhpcyxlKXx8dGhpcykucG9vbFNpemU9QXJyYXkuaXNBcnJheShlLnBvb2xTaXplKT9lLnBvb2xTaXplOltlLnBvb2xTaXplLGUucG9vbFNpemVdLG51bGw9PWUuc3RyaWRlcyl0LnN0cmlkZXM9dC5wb29sU2l6ZTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZS5zdHJpZGVzKSl7aWYoMiE9PWUuc3RyaWRlcy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJZiB0aGUgc3RyaWRlcyBwcm9wZXJ0eSBvZiBhIDJEIHBvb2xpbmcgbGF5ZXIgaXMgYW4gQXJyYXksIGl0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBsZW5ndGggb2YgMiwgYnV0IHJlY2VpdmVkIGxlbmd0aCBcIitlLnN0cmlkZXMubGVuZ3RoK1wiLlwiKTt0LnN0cmlkZXM9ZS5zdHJpZGVzfWVsc2UgdC5zdHJpZGVzPVtlLnN0cmlkZXMsZS5zdHJpZGVzXTtyZXR1cm4gdC5wYWRkaW5nPW51bGw9PWUucGFkZGluZz9cInZhbGlkXCI6ZS5wYWRkaW5nLHQuZGF0YUZvcm1hdD1udWxsPT1lLmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjplLmRhdGFGb3JtYXQsY2hlY2tEYXRhRm9ybWF0KHQuZGF0YUZvcm1hdCksY2hlY2tQYWRkaW5nTW9kZSh0LnBhZGRpbmcpLHQuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjR9KV0sdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oYSl7YT1nZXRFeGFjdGx5T25lU2hhcGUoYSk7dmFyIHI9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/YVsyXTphWzFdLG89XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/YVszXTphWzJdO3JldHVybiByPWNvbnZPdXRwdXRMZW5ndGgocix0aGlzLnBvb2xTaXplWzBdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMF0pLG89Y29udk91dHB1dExlbmd0aChvLHRoaXMucG9vbFNpemVbMV0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1sxXSksXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W2FbMF0sYVsxXSxyLG9dOlthWzBdLHIsbyxhWzNdXX0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihhLGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gdC5pbnZva2VDYWxsSG9vayhhLGUpLHQucG9vbGluZ0Z1bmN0aW9uKGdldEV4YWN0bHlPbmVUZW5zb3IoYSksdC5wb29sU2l6ZSx0LnN0cmlkZXMsdC5wYWRkaW5nLHQuZGF0YUZvcm1hdCl9KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e3Bvb2xTaXplOnRoaXMucG9vbFNpemUscGFkZGluZzp0aGlzLnBhZGRpbmcsc3RyaWRlczp0aGlzLnN0cmlkZXMsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LHQ9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlfShMYXllciksTWF4UG9vbGluZzJEPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGEuY2FsbCh0aGlzLGUpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihhLGUsdCxuLHIpe3JldHVybiBjaGVja0RhdGFGb3JtYXQociksY2hlY2tQYWRkaW5nTW9kZShuKSxwb29sMmQoYSxlLHQsbixyLFwibWF4XCIpfSxlLmNsYXNzTmFtZT1cIk1heFBvb2xpbmcyRFwiLGV9KFBvb2xpbmcyRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heFBvb2xpbmcyRCk7dmFyIEF2ZXJhZ2VQb29saW5nMkQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gYS5jYWxsKHRoaXMsZSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uPWZ1bmN0aW9uKGEsZSx0LG4scil7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdChyKSxjaGVja1BhZGRpbmdNb2RlKG4pLHBvb2wyZChhLGUsdCxuLHIsXCJhdmdcIil9LGUuY2xhc3NOYW1lPVwiQXZlcmFnZVBvb2xpbmcyRFwiLGV9KFBvb2xpbmcyRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEF2ZXJhZ2VQb29saW5nMkQpO3ZhciBHbG9iYWxQb29saW5nMUQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gdC5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06M30pXSx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbih0KXtyZXR1cm5bdFswXSx0WzJdXX0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbigpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yfSxlfShMYXllciksR2xvYmFsQXZlcmFnZVBvb2xpbmcxRD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3JldHVybiBhLmNhbGwodGhpcyxlKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGEpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIGU9Z2V0RXhhY3RseU9uZVRlbnNvcihhKTtyZXR1cm4gbWVhbihlLDEpfSl9LGUuY2xhc3NOYW1lPVwiR2xvYmFsQXZlcmFnZVBvb2xpbmcxRFwiLGV9KEdsb2JhbFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQpO3ZhciBHbG9iYWxNYXhQb29saW5nMUQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gYS5jYWxsKHRoaXMsZSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihhKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBlPWdldEV4YWN0bHlPbmVUZW5zb3IoYSk7cmV0dXJuIG1heChlLDEpfSl9LGUuY2xhc3NOYW1lPVwiR2xvYmFsTWF4UG9vbGluZzFEXCIsZX0oR2xvYmFsUG9vbGluZzFEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsTWF4UG9vbGluZzFEKTt2YXIgR2xvYmFsUG9vbGluZzJEPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIHQuZGF0YUZvcm1hdD1udWxsPT1lLmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjplLmRhdGFGb3JtYXQsY2hlY2tEYXRhRm9ybWF0KHQuZGF0YUZvcm1hdCksdC5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NH0pXSx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbih0KXtyZXR1cm4gdD10LFwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W3RbMF0sdFszXV06W3RbMF0sdFsxXV19LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2RhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZX0oTGF5ZXIpLEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09YSYmYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihhKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihhKTtyZXR1cm5cImNoYW5uZWxzTGFzdFwiPT09ZS5kYXRhRm9ybWF0P21lYW4obixbMSwyXSk6bWVhbihuLFsyLDNdKX0pfSxlLmNsYXNzTmFtZT1cIkdsb2JhbEF2ZXJhZ2VQb29saW5nMkRcIixlfShHbG9iYWxQb29saW5nMkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxBdmVyYWdlUG9vbGluZzJEKTt2YXIgR2xvYmFsTWF4UG9vbGluZzJEPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSl7dmFyIGU9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoYSk7cmV0dXJuXCJjaGFubmVsc0xhc3RcIj09PWUuZGF0YUZvcm1hdD9tYXgobixbMSwyXSk6bWF4KG4sWzIsM10pfSl9LGUuY2xhc3NOYW1lPVwiR2xvYmFsTWF4UG9vbGluZzJEXCIsZX0oR2xvYmFsUG9vbGluZzJEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsTWF4UG9vbGluZzJEKTt2YXIgUk5OPWZ1bmN0aW9uKG0pe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9bS5jYWxsKHRoaXMsZSl8fHRoaXMsYTtpZihudWxsPT1lLmNlbGwpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjZWxsIHByb3BlcnR5IGlzIG1pc3NpbmcgZm9yIHRoZSBjb25zdHJ1Y3RvciBvZiBSTk4uXCIpO2lmKG51bGw9PShhPUFycmF5LmlzQXJyYXkoZS5jZWxsKT9uZXcgU3RhY2tlZFJOTkNlbGxzKHtjZWxsczplLmNlbGx9KTplLmNlbGwpLnN0YXRlU2l6ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBSTk4gY2VsbCBzaG91bGQgaGF2ZSBhbiBhdHRyaWJ1dGUgYHN0YXRlU2l6ZWAgKHR1cGxlIG9mIGludGVnZXJzLCBvbmUgaW50ZWdlciBwZXIgUk5OIHN0YXRlKS5cIik7cmV0dXJuIHQuY2VsbD1hLHQucmV0dXJuU2VxdWVuY2VzPW51bGwhPWUucmV0dXJuU2VxdWVuY2VzJiZlLnJldHVyblNlcXVlbmNlcyx0LnJldHVyblN0YXRlPW51bGwhPWUucmV0dXJuU3RhdGUmJmUucmV0dXJuU3RhdGUsdC5nb0JhY2t3YXJkcz1udWxsIT1lLmdvQmFja3dhcmRzJiZlLmdvQmFja3dhcmRzLHQuX3N0YXRlZnVsPW51bGwhPWUuc3RhdGVmdWwmJmUuc3RhdGVmdWwsdC51bnJvbGw9bnVsbCE9ZS51bnJvbGwmJmUudW5yb2xsLHQuc3VwcG9ydHNNYXNraW5nPSEwLHQuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjN9KV0sdC5zdGF0ZVNwZWM9bnVsbCx0LnN0YXRlcz1udWxsLHQubnVtQ29uc3RhbnRzPW51bGwsdC5rZXB0U3RhdGVzPVtdLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsbSksZS5wcm90b3R5cGUuZ2V0U3RhdGVzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXRoaXMuc3RhdGVzP3JhbmdlJDEoMCxBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoOjEpLm1hcChmdW5jdGlvbigpe3JldHVybiBudWxsfSk6dGhpcy5zdGF0ZXN9LGUucHJvdG90eXBlLnNldFN0YXRlcz1mdW5jdGlvbih0KXt0aGlzLnN0YXRlcz10fSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24ocCl7aXNBcnJheU9mU2hhcGVzKHApJiYocD1wWzBdKSxwPXA7dmFyIGw9dGhpcy5jZWxsLnN0YXRlU2l6ZTtBcnJheS5pc0FycmF5KGwpfHwobD1bbF0pO3ZhciBkPWxbMF0scjtpZihyPXRoaXMucmV0dXJuU2VxdWVuY2VzP1twWzBdLHBbMV0sZF06W3BbMF0sZF0sdGhpcy5yZXR1cm5TdGF0ZSl7Zm9yKHZhciB1PVtdLGk9MCxjPWwsbztpPGMubGVuZ3RoO2krKylvPWNbaV0sdS5wdXNoKFtwWzBdLG9dKTtyZXR1cm5bcl0uY29uY2F0KHUpfXJldHVybiByfSxlLnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbigpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiY29tcHV0ZU1hc2sgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciBSTk4geWV0XCIpfSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLm51bUNvbnN0YW50cyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkNvbnN0YW50cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBSTk4geWV0LlwiKTtpc0FycmF5T2ZTaGFwZXMoYSkmJihhPWFbMF0pLGE9YTt2YXIgbz10aGlzLnN0YXRlZnVsP2FbMF06bnVsbCx0PWFbYS5sZW5ndGgtMV07dGhpcy5pbnB1dFNwZWNbMF09bmV3IElucHV0U3BlYyh7c2hhcGU6W28sbnVsbCx0XX0pO3ZhciBuPVthWzBdXS5jb25jYXQoYS5zbGljZSgyKSkscztpZighKHRoaXMuY2VsbC5idWlsZChuKSxzPUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZTpbdGhpcy5jZWxsLnN0YXRlU2l6ZV0sbnVsbCE9dGhpcy5zdGF0ZVNwZWMpKXRoaXMuc3RhdGVTcGVjPXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgSW5wdXRTcGVjKHtzaGFwZTpbbnVsbCx0XX0pfSk7ZWxzZSBpZighdXRpbC5hcnJheXNFcXVhbCh0aGlzLnN0YXRlU3BlYy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV19KSxzKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFuIGluaXRpYWxTdGF0ZSB3YXMgcGFzc2VkIHRoYXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBjZWxsLnN0YXRlU2l6ZS4gUmVjZWl2ZWQgc3RhdGVTcGVjPVwiK3RoaXMuc3RhdGVTcGVjK1wiOyBIb3dldmVyIGNlbGwuc3RhdGVTaXplIGlzIFwiK3RoaXMuY2VsbC5zdGF0ZVNpemUpO3RoaXMuc3RhdGVmdWwmJnRoaXMucmVzZXRTdGF0ZXMoKX0sZS5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24ocCxsKXt2YXIgZD10aGlzO3ZvaWQgMD09PWwmJihsPSExKSx0aWR5KGZ1bmN0aW9uKCl7aWYoIWQuc3RhdGVmdWwpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiQ2Fubm90IGNhbGwgcmVzZXRTdGF0ZXMoKSBvbiBhbiBSTk4gTGF5ZXIgdGhhdCBpcyBub3Qgc3RhdGVmdWwuXCIpO3ZhciB0PWQuaW5wdXRTcGVjWzBdLnNoYXBlWzBdO2lmKG51bGw9PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJZiBhbiBSTk4gaXMgc3RhdGVmdWwsIGl0IG5lZWRzIHRvIGtub3cgaXRzIGJhdGNoIHNpemUuIFNwZWNpZnkgdGhlIGJhdGNoIHNpemUgb2YgeW91ciBpbnB1dCB0ZW5zb3JzOiBcXG4tIElmIHVzaW5nIGEgU2VxdWVudGlhbCBtb2RlbCwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSBwYXNzaW5nIGEgYGJhdGNoSW5wdXRTaGFwZWAgb3B0aW9uIHRvIHlvdXIgZmlyc3QgbGF5ZXIuXFxuLSBJZiB1c2luZyB0aGUgZnVuY3Rpb25hbCBBUEksIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgcGFzc2luZyBhIGBiYXRjaFNoYXBlYCBvcHRpb24gdG8geW91ciBJbnB1dCBsYXllci5cIik7aWYobnVsbD09ZC5zdGF0ZXMpZC5zdGF0ZXM9QXJyYXkuaXNBcnJheShkLmNlbGwuc3RhdGVTaXplKT9kLmNlbGwuc3RhdGVTaXplLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gemVyb3MoW3QsYV0pfSk6W3plcm9zKFt0LGQuY2VsbC5zdGF0ZVNpemVdKV07ZWxzZSBpZihudWxsPT1wKWRpc3Bvc2UoZC5zdGF0ZXMpLG51bGwhPWQua2VwdFN0YXRlcyYmKGRpc3Bvc2UoZC5rZXB0U3RhdGVzKSxkLmtlcHRTdGF0ZXM9W10pLEFycmF5LmlzQXJyYXkoZC5jZWxsLnN0YXRlU2l6ZSk/ZC5zdGF0ZXM9ZC5jZWxsLnN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIHplcm9zKFt0LGFdKX0pOmQuc3RhdGVzWzBdPXplcm9zKFt0LGQuY2VsbC5zdGF0ZVNpemVdKTtlbHNle2lmKEFycmF5LmlzQXJyYXkocCl8fChwPVtwXSkscC5sZW5ndGghPT1kLnN0YXRlcy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllciBcIitkLm5hbWUrXCIgZXhwZWN0cyBcIitkLnN0YXRlcy5sZW5ndGgrXCIgc3RhdGUocyksIGJ1dCBpdCByZWNlaXZlZCBcIitwLmxlbmd0aCtcIiBzdGF0ZSB2YWx1ZShzKS4gSW5wdXQgcmVjZWl2ZWQ6IFwiK3ApOyEwPT09bD9kLmtlcHRTdGF0ZXMucHVzaChkLnN0YXRlcy5zbGljZSgpKTpkaXNwb3NlKGQuc3RhdGVzKTtmb3IodmFyIGU9MDtlPGQuc3RhdGVzLmxlbmd0aDsrK2Upe3ZhciBuPXBbZV0sYT1BcnJheS5pc0FycmF5KGQuY2VsbC5zdGF0ZVNpemUpP2QuY2VsbC5zdGF0ZVNpemVbZV06ZC5jZWxsLnN0YXRlU2l6ZSxyPVt0LGFdO2lmKCF1dGlsLmFycmF5c0VxdWFsKG4uc2hhcGUscikpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJTdGF0ZSBcIitlK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK2QubmFtZStcIjogZXhwZWN0ZWQgc2hhcGU9XCIrcitcIiwgcmVjZWl2ZWQgc2hhcGU9XCIrbi5zaGFwZSk7ZC5zdGF0ZXNbZV09bn19ZC5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4ga2VlcCh0KX0pfSl9LGUucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsZyl7dmFyIHk9bnVsbD09Zz9udWxsOmcuaW5pdGlhbFN0YXRlLGI9bnVsbD09Zz9udWxsOmcuY29uc3RhbnRzO251bGw9PWcmJihnPXt9KTt2YXIgeD1zdGFuZGFyZGl6ZUFyZ3MoZSx5LGIsdGhpcy5udW1Db25zdGFudHMpO2U9eC5pbnB1dHMseT14LmluaXRpYWxTdGF0ZSxiPXguY29uc3RhbnRzO3ZhciBhPVtdLE49W107aWYobnVsbCE9eSl7Zy5pbml0aWFsU3RhdGU9eSxhPWEuY29uY2F0KHkpLHRoaXMuc3RhdGVTcGVjPVtdO2Zvcih2YXIgST0wLHY9eSx1O0k8di5sZW5ndGg7SSsrKXU9dltJXSx0aGlzLnN0YXRlU3BlYy5wdXNoKG5ldyBJbnB1dFNwZWMoe3NoYXBlOnUuc2hhcGV9KSk7Tj1OLmNvbmNhdCh0aGlzLnN0YXRlU3BlYyl9aWYobnVsbCE9YiYmKGcuY29uc3RhbnRzPWIsYT1hLmNvbmNhdChiKSx0aGlzLm51bUNvbnN0YW50cz1iLmxlbmd0aCksYVswXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3Ipe3ZhciBTPVtlXS5jb25jYXQoYSkscD10aGlzLmlucHV0U3BlYy5jb25jYXQoTiksaD10aGlzLmlucHV0U3BlYzt0aGlzLmlucHV0U3BlYz1wO3ZhciBkPW0ucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyxTLGcpO3JldHVybiB0aGlzLmlucHV0U3BlYz1oLGR9cmV0dXJuIG0ucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyxlLGcpfSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGQsbSl7dmFyIGc9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBlPW51bGw9PW0/bnVsbDptLm1hc2ssdD1udWxsPT1tP251bGw6bS50cmFpbmluZyxuPW51bGw9PW0/bnVsbDptLmluaXRpYWxTdGF0ZTtpZihkPWdldEV4YWN0bHlPbmVUZW5zb3IoZCksbnVsbD09biYmKG49Zy5zdGF0ZWZ1bD9nLnN0YXRlczpnLmdldEluaXRpYWxTdGF0ZShkKSksbnVsbCE9ZSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk1hc2tpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBSTk4geWV0XCIpO3ZhciByPUFycmF5LmlzQXJyYXkoZy5jZWxsLnN0YXRlU2l6ZSk/Zy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MTtpZihuLmxlbmd0aCE9PXIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJSTk4gTGF5ZXIgaGFzIFwiK3IrXCIgc3RhdGUocykgYnV0IHdhcyBwYXNzZWQgXCIrbi5sZW5ndGgrXCIgaW5pdGlhbCBzdGF0ZShzKS5cIik7Zy51bnJvbGwmJmNvbnNvbGUud2FybihcIklnbm9yaW5nIHVucm9sbCA9IHRydWUgZm9yIFJOTiBsYXllciwgZHVlIHRvIGltcGVyYXRpdmUgYmFja2VuZC5cIik7dmFyIG89e3RyYWluaW5nOnR9LHM9cm5uKGZ1bmN0aW9uKGEsZSl7dmFyIHQ9Zy5jZWxsLmNhbGwoW2FdLmNvbmNhdChlKSxvKTtyZXR1cm5bdFswXSx0LnNsaWNlKDEpXX0sZCxuLGcuZ29CYWNrd2FyZHMsbnVsbCxudWxsLGcudW5yb2xsLGcucmV0dXJuU2VxdWVuY2VzKSxpPXNbMF0sbD1zWzFdLHU9c1syXTtnLnN0YXRlZnVsJiZnLnJlc2V0U3RhdGVzKHUsdCk7dmFyIHA9Zy5yZXR1cm5TZXF1ZW5jZXM/bDppO3JldHVybiBnLnJldHVyblN0YXRlP1twXS5jb25jYXQodSk6cH0pfSxlLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGU9ZnVuY3Rpb24oYSl7dmFyIGU9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PXplcm9zKGEuc2hhcGUpO3JldHVybiB0PWV4cGFuZERpbXMkMSh0PXN1bSQxKHQsWzEsMl0pKSxBcnJheS5pc0FycmF5KGUuY2VsbC5zdGF0ZVNpemUpP2UuY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uKGEpe3JldHVybiAxPGE/dGlsZSQxKHQsWzEsYV0pOnR9KToxPGUuY2VsbC5zdGF0ZVNpemU/W3RpbGUkMSh0LFsxLGUuY2VsbC5zdGF0ZVNpemVdKV06W3RdfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuY2VsbC50cmFpbmFibGVXZWlnaHRzOltdfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuY2VsbC5ub25UcmFpbmFibGVXZWlnaHRzOnRoaXMuY2VsbC53ZWlnaHRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXtyZXR1cm5TZXF1ZW5jZXM6dGhpcy5yZXR1cm5TZXF1ZW5jZXMscmV0dXJuU3RhdGU6dGhpcy5yZXR1cm5TdGF0ZSxnb0JhY2t3YXJkczp0aGlzLmdvQmFja3dhcmRzLHN0YXRlZnVsOnRoaXMuc3RhdGVmdWwsdW5yb2xsOnRoaXMudW5yb2xsfTtudWxsIT10aGlzLm51bUNvbnN0YW50cyYmKGUubnVtQ29uc3RhbnRzPXRoaXMubnVtQ29uc3RhbnRzKTt2YXIgdD10aGlzLmNlbGwuZ2V0Q29uZmlnKCk7ZS5jZWxsPXtjbGFzc05hbWU6dGhpcy5jZWxsLmdldENsYXNzTmFtZSgpLGNvbmZpZzp0fTt2YXIgYT1tLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLGEpLGV9LGUuY2xhc3NOYW1lPVwiUk5OXCIsZX0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSTk4pO3ZhciBSTk5DZWxsPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGV9KExheWVyKSxTaW1wbGVSTk5DZWxsPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIHQuREVGQVVMVF9BQ1RJVkFUSU9OPVwidGFuaFwiLHQuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIix0LkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLHQuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIix0LnVuaXRzPWUudW5pdHMsdC5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24obnVsbD09ZS5hY3RpdmF0aW9uP3QuREVGQVVMVF9BQ1RJVkFUSU9OOmUuYWN0aXZhdGlvbiksdC51c2VCaWFzPW51bGw9PWUudXNlQmlhc3x8ZS51c2VCaWFzLHQua2VybmVsSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoZS5rZXJuZWxJbml0aWFsaXplcnx8dC5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksdC5yZWN1cnJlbnRJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLnJlY3VycmVudEluaXRpYWxpemVyfHx0LkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKSx0LmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLmJpYXNJbml0aWFsaXplcnx8dC5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLHQua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5rZXJuZWxSZWd1bGFyaXplciksdC5yZWN1cnJlbnRSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihlLnJlY3VycmVudFJlZ3VsYXJpemVyKSx0LmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihlLmJpYXNSZWd1bGFyaXplciksdC5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQoZS5rZXJuZWxDb25zdHJhaW50KSx0LnJlY3VycmVudENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChlLnJlY3VycmVudENvbnN0cmFpbnQpLHQuYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChlLmJpYXNDb25zdHJhaW50KSx0LmRyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09ZS5kcm9wb3V0PzA6ZS5kcm9wb3V0XSldKSx0LnJlY3VycmVudERyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09ZS5yZWN1cnJlbnREcm9wb3V0PzA6ZS5yZWN1cnJlbnREcm9wb3V0XSldKSx0LnN0YXRlU2l6ZT10LnVuaXRzLHQuZHJvcG91dE1hc2s9bnVsbCx0LnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwsdH1yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbih0KXt0PWdldEV4YWN0bHlPbmVTaGFwZSh0KSx0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFt0W3QubGVuZ3RoLTFdLHRoaXMudW5pdHNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJyZWN1cnJlbnRfa2VybmVsXCIsW3RoaXMudW5pdHMsdGhpcy51bml0c10sbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLmJpYXM9dGhpcy51c2VCaWFzP3RoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLnVuaXRzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpOm51bGwsdGhpcy5idWlsdD0hMH0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihwLGQpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09KHA9cCkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiU2ltcGxlUk5OQ2VsbCBleHBlY3RzIDIgaW5wdXQgVGVuc29ycywgZ290IFwiK3AubGVuZ3RoK1wiLlwiKTt2YXIgZT1wWzFdO3A9cFswXTt2YXIgbj1udWxsIT1kLnRyYWluaW5nJiZkLnRyYWluaW5nLGE7MDx0LmRyb3BvdXQmJjE+dC5kcm9wb3V0JiZudWxsPT10LmRyb3BvdXRNYXNrJiYodC5kcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKHApfSx0LmRyb3BvdXQsbikpLDA8dC5yZWN1cnJlbnREcm9wb3V0JiYxPnQucmVjdXJyZW50RHJvcG91dCYmbnVsbD09dC5yZWN1cnJlbnREcm9wb3V0TWFzayYmKHQucmVjdXJyZW50RHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShlKX0sdC5yZWN1cnJlbnREcm9wb3V0LG4pKTt2YXIgdT10LmRyb3BvdXRNYXNrLG89dC5yZWN1cnJlbnREcm9wb3V0TWFzazthPWRvdCQxKG51bGw9PXU/cDptdWwocCx1KSx0Lmtlcm5lbC5yZWFkKCkpLG51bGwhPXQuYmlhcyYmKGE9Ymlhc0FkZChhLHQuYmlhcy5yZWFkKCkpKSxudWxsIT1vJiYoZT1tdWwoZSxvKSk7dmFyIHM9YWRkKGEsZG90JDEoZSx0LnJlY3VycmVudEtlcm5lbC5yZWFkKCkpKTtyZXR1cm4gbnVsbCE9dC5hY3RpdmF0aW9uJiYocz10LmFjdGl2YXRpb24uYXBwbHkocykpLFtzLHNdfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dH0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiU2ltcGxlUk5OQ2VsbFwiLGV9KFJOTkNlbGwpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTaW1wbGVSTk5DZWxsKTt2YXIgU2ltcGxlUk5OPWZ1bmN0aW9uKHMpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGUuY2VsbD1uZXcgU2ltcGxlUk5OQ2VsbChlKSxzLmNhbGwodGhpcyxlKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxzKSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe251bGwhPW4uY2VsbC5kcm9wb3V0TWFzayYmKGRpc3Bvc2Uobi5jZWxsLmRyb3BvdXRNYXNrKSxuLmNlbGwuZHJvcG91dE1hc2s9bnVsbCksbnVsbCE9bi5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrJiYoZGlzcG9zZShuLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLG4uY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTt2YXIgcj1udWxsPT10P251bGw6dC5tYXNrLGk9bnVsbD09dD9udWxsOnQudHJhaW5pbmcsYT1udWxsPT10P251bGw6dC5pbml0aWFsU3RhdGU7cmV0dXJuIHMucHJvdG90eXBlLmNhbGwuY2FsbChuLGUse21hc2s6cix0cmFpbmluZzppLGluaXRpYWxTdGF0ZTphfSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwidW5pdHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJhY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ1c2VCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudXNlQmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJrZXJuZWxJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInJlY3VycmVudEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiYmlhc0luaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImtlcm5lbFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmVjdXJyZW50UmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJiaWFzUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwia2VybmVsQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmVjdXJyZW50Q29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiYmlhc0NvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJkcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuZHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJyZWN1cnJlbnREcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgZT17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXR9LHQ9cy5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSB0LmNlbGwsT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiU2ltcGxlUk5OXCIsZX0oUk5OKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2ltcGxlUk5OKTt2YXIgR1JVQ2VsbD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWEuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiB0LkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIix0LkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT049XCJoYXJkU2lnbW9pZFwiLHQuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIix0LkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLHQuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIix0LnVuaXRzPWUudW5pdHMsdC5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09ZS5hY3RpdmF0aW9uP3QuREVGQVVMVF9BQ1RJVkFUSU9OOmUuYWN0aXZhdGlvbiksdC5yZWN1cnJlbnRBY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09ZS5yZWN1cnJlbnRBY3RpdmF0aW9uP3QuREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTjplLnJlY3VycmVudEFjdGl2YXRpb24pLHQudXNlQmlhcz1udWxsPT1lLnVzZUJpYXN8fGUudXNlQmlhcyx0Lmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKGUua2VybmVsSW5pdGlhbGl6ZXJ8fHQuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLHQucmVjdXJyZW50SW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoZS5yZWN1cnJlbnRJbml0aWFsaXplcnx8dC5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksdC5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoZS5iaWFzSW5pdGlhbGl6ZXJ8fHQuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSx0Lmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKGUua2VybmVsUmVndWxhcml6ZXIpLHQucmVjdXJyZW50UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5yZWN1cnJlbnRSZWd1bGFyaXplciksdC5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5iaWFzUmVndWxhcml6ZXIpLHQua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KGUua2VybmVsQ29uc3RyYWludCksdC5yZWN1cnJlbnRDb25zdHJhaW50PWdldENvbnN0cmFpbnQoZS5yZWN1cnJlbnRDb25zdHJhaW50KSx0LmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQoZS5iaWFzQ29uc3RyYWludCksdC5kcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PWUuZHJvcG91dD8wOmUuZHJvcG91dF0pXSksdC5yZWN1cnJlbnREcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PWUucmVjdXJyZW50RHJvcG91dD8wOmUucmVjdXJyZW50RHJvcG91dF0pXSksdC5pbXBsZW1lbnRhdGlvbj1lLmltcGxlbWVudGF0aW9uLHQuc3RhdGVTaXplPXQudW5pdHMsdC5kcm9wb3V0TWFzaz1udWxsLHQucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGEpe3ZhciBuPShhPWdldEV4YWN0bHlPbmVTaGFwZShhKSlbYS5sZW5ndGgtMV07dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbbiwzKnRoaXMudW5pdHNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJyZWN1cnJlbnRfa2VybmVsXCIsW3RoaXMudW5pdHMsMyp0aGlzLnVuaXRzXSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMuYmlhcz10aGlzLnVzZUJpYXM/dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsWzMqdGhpcy51bml0c10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTpudWxsLHRoaXMuYnVpbHQ9ITB9LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oeCxDKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PSh4PXgpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkdSVUNlbGwgZXhwZWN0cyAyIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCBcIit4Lmxlbmd0aCtcIi5cIik7dmFyIGU9bnVsbCE9Qy50cmFpbmluZyYmQy50cmFpbmluZyxuPXhbMV07eD14WzBdLDA8dC5kcm9wb3V0JiYxPnQuZHJvcG91dCYmbnVsbD09dC5kcm9wb3V0TWFzayYmKHQuZHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZSh4KX0sdC5kcm9wb3V0LGUsMykpLDA8dC5yZWN1cnJlbnREcm9wb3V0JiYxPnQucmVjdXJyZW50RHJvcG91dCYmbnVsbD09dC5yZWN1cnJlbnREcm9wb3V0TWFzayYmKHQucmVjdXJyZW50RHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShuKX0sdC5yZWN1cnJlbnREcm9wb3V0LGUsMykpO3ZhciByPXQuZHJvcG91dE1hc2ssbD10LnJlY3VycmVudERyb3BvdXRNYXNrLHUsayxUOzA8dC5kcm9wb3V0JiYxPnQuZHJvcG91dCYmKHg9bXVsKHgsclswXSkpO3ZhciBFPWRvdCQxKHgsdC5rZXJuZWwucmVhZCgpKTt0LnVzZUJpYXMmJihFPWJpYXNBZGQoRSx0LmJpYXMucmVhZCgpKSksMDx0LnJlY3VycmVudERyb3BvdXQmJjE+dC5yZWN1cnJlbnREcm9wb3V0JiYobj1tdWwobixsWzBdKSk7dmFyIFI9dC5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLHA9c3BsaXQkMShSLFsyKnQudW5pdHMsdC51bml0c10sUi5yYW5rLTEpLGg9cFswXSxkPXBbMV0sZj1kb3QkMShuLGgpLGc9c3BsaXQkMShFLDMsRS5yYW5rLTEpLG09Z1swXSx5PWdbMV0sdj1nWzJdLGI9c3BsaXQkMShmLDIsZi5yYW5rLTEpLEQ9YlswXSx3PWJbMV07dT10LnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoYWRkKG0sRCkpLGs9dC5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGFkZCh5LHcpKTt2YXIgUz1kb3QkMShtdWwoayxuKSxkKTtUPXQuYWN0aXZhdGlvbi5hcHBseShhZGQodixTKSk7dmFyIEk9YWRkKG11bCh1LG4pLG11bChhZGQoZ2V0U2NhbGFyKDEpLG5lZyh1KSksVCkpO3JldHVybltJLEldfSl9LGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSx0PWEucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX0sZS5jbGFzc05hbWU9XCJHUlVDZWxsXCIsZX0oUk5OQ2VsbCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdSVUNlbGwpO3ZhciBHUlU9ZnVuY3Rpb24ocyl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gMD09PWUuaW1wbGVtZW50YXRpb24mJmNvbnNvbGUud2FybihcImBpbXBsZW1lbnRhdGlvbj0wYCBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgbm93IGRlZmF1bHRzIHRvIGBpbXBsZW1lbnRhdGlvbj0xYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGxheWVyIGNhbGwuXCIpLGUuY2VsbD1uZXcgR1JVQ2VsbChlKSxzLmNhbGwodGhpcyxlKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxzKSxlLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe251bGwhPW4uY2VsbC5kcm9wb3V0TWFzayYmKGRpc3Bvc2Uobi5jZWxsLmRyb3BvdXRNYXNrKSxuLmNlbGwuZHJvcG91dE1hc2s9bnVsbCksbnVsbCE9bi5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrJiYoZGlzcG9zZShuLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLG4uY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTt2YXIgcj1udWxsPT10P251bGw6dC5tYXNrLGk9bnVsbD09dD9udWxsOnQudHJhaW5pbmcsYT1udWxsPT10P251bGw6dC5pbml0aWFsU3RhdGU7cmV0dXJuIHMucHJvdG90eXBlLmNhbGwuY2FsbChuLGUse21hc2s6cix0cmFpbmluZzppLGluaXRpYWxTdGF0ZTphfSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwidW5pdHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJhY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJyZWN1cnJlbnRBY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50QWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ1c2VCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudXNlQmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJrZXJuZWxJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInJlY3VycmVudEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiYmlhc0luaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImtlcm5lbFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmVjdXJyZW50UmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJiaWFzUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwia2VybmVsQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmVjdXJyZW50Q29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiYmlhc0NvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJkcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuZHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJyZWN1cnJlbnREcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpbXBsZW1lbnRhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmltcGxlbWVudGF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSx0PXMucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5jZWxsLE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmZyb21Db25maWc9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gMD09PWUuaW1wbG1lbnRhdGlvbiYmKGUuaW1wbGVtZW50YXRpb249MSksbmV3IGEoZSl9LGUuY2xhc3NOYW1lPVwiR1JVXCIsZX0oUk5OKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR1JVKTt2YXIgTFNUTUNlbGw9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZShlKXt2YXIgdD1hLmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gdC5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsdC5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OPVwiaGFyZFNpZ21vaWRcIix0LkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsdC5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIix0LkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsdC51bml0cz1lLnVuaXRzLHQuYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PWUuYWN0aXZhdGlvbj90LkRFRkFVTFRfQUNUSVZBVElPTjplLmFjdGl2YXRpb24pLHQucmVjdXJyZW50QWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PWUucmVjdXJyZW50QWN0aXZhdGlvbj90LkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT046ZS5yZWN1cnJlbnRBY3RpdmF0aW9uKSx0LnVzZUJpYXM9bnVsbD09ZS51c2VCaWFzfHxlLnVzZUJpYXMsdC5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihlLmtlcm5lbEluaXRpYWxpemVyfHx0LkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSx0LnJlY3VycmVudEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKGUucmVjdXJyZW50SW5pdGlhbGl6ZXJ8fHQuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpLHQuYmlhc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKGUuYmlhc0luaXRpYWxpemVyfHx0LkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksdC51bml0Rm9yZ2V0Qmlhcz1lLnVuaXRGb3JnZXRCaWFzLHQua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoZS5rZXJuZWxSZWd1bGFyaXplciksdC5yZWN1cnJlbnRSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihlLnJlY3VycmVudFJlZ3VsYXJpemVyKSx0LmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihlLmJpYXNSZWd1bGFyaXplciksdC5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQoZS5rZXJuZWxDb25zdHJhaW50KSx0LnJlY3VycmVudENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChlLnJlY3VycmVudENvbnN0cmFpbnQpLHQuYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChlLmJpYXNDb25zdHJhaW50KSx0LmRyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09ZS5kcm9wb3V0PzA6ZS5kcm9wb3V0XSldKSx0LnJlY3VycmVudERyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09ZS5yZWN1cnJlbnREcm9wb3V0PzA6ZS5yZWN1cnJlbnREcm9wb3V0XSldKSx0LmltcGxlbWVudGF0aW9uPWUuaW1wbGVtZW50YXRpb24sdC5zdGF0ZVNpemU9W3QudW5pdHMsdC51bml0c10sdC5kcm9wb3V0TWFzaz1udWxsLHQucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCx0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKG8pe3ZhciBzPShvPWdldEV4YWN0bHlPbmVTaGFwZShvKSlbby5sZW5ndGgtMV0scixwO2lmKHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW3MsNCp0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLFt0aGlzLnVuaXRzLDQqdGhpcy51bml0c10sbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMpe2lmKHRoaXMudW5pdEZvcmdldEJpYXMpe3ZhciBsPXRoaXMuYmlhc0luaXRpYWxpemVyLGk9dGhpcy51bml0cztyPW5ldygocD1mdW5jdGlvbihhKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT1hJiZhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzJDEoZSxhKSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbigpe3ZhciBlPWwuYXBwbHkoW2ldKSx0PW5ldyBPbmVzKCkuYXBwbHkoW2ldKSxhPWwuYXBwbHkoWzIqaV0pO3JldHVybiBjb25jYXRBbG9uZ0ZpcnN0QXhpcyhjb25jYXRBbG9uZ0ZpcnN0QXhpcyhlLHQpLGEpfSxlfShJbml0aWFsaXplcikpLmNsYXNzTmFtZT1cIkN1c3RvbUluaXRcIixwKX1lbHNlIHI9dGhpcy5iaWFzSW5pdGlhbGl6ZXI7dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFs0KnRoaXMudW5pdHNdLG51bGwscix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KX1lbHNlIHRoaXMuYmlhcz1udWxsO3RoaXMuYnVpbHQ9ITB9LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYix4KXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIGU9bnVsbCE9eC50cmFpbmluZyYmeC50cmFpbmluZztpZigzIT09KGI9YikubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTFNUTUNlbGwgZXhwZWN0cyAzIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCBcIitiLmxlbmd0aCtcIi5cIik7dmFyIG49YlsxXSxyPWJbMl07Yj1iWzBdLDA8dC5kcm9wb3V0JiYxPnQuZHJvcG91dCYmbnVsbD09dC5kcm9wb3V0TWFzayYmKHQuZHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShiKX0sdC5kcm9wb3V0LGUsNCkpLDA8dC5yZWN1cnJlbnREcm9wb3V0JiYxPnQucmVjdXJyZW50RHJvcG91dCYmbnVsbD09dC5yZWN1cnJlbnREcm9wb3V0TWFzayYmKHQucmVjdXJyZW50RHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShuKX0sdC5yZWN1cnJlbnREcm9wb3V0LGUsNCkpO3ZhciBhPXQuZHJvcG91dE1hc2ssYz10LnJlY3VycmVudERyb3BvdXRNYXNrLHAsTixJLFM7MDx0LmRyb3BvdXQmJjE+dC5kcm9wb3V0JiYoYj1tdWwoYixhWzBdKSk7dmFyIEM9ZG90JDEoYix0Lmtlcm5lbC5yZWFkKCkpOzA8dC5yZWN1cnJlbnREcm9wb3V0JiYxPnQucmVjdXJyZW50RHJvcG91dCYmKG49bXVsKG4sY1swXSkpLEM9YWRkKEMsZG90JDEobix0LnJlY3VycmVudEtlcm5lbC5yZWFkKCkpKSx0LnVzZUJpYXMmJihDPWJpYXNBZGQoQyx0LmJpYXMucmVhZCgpKSk7dmFyIGs9c3BsaXQkMShDLDQsQy5yYW5rLTEpLGQ9a1swXSxmPWtbMV0sZz1rWzJdLG09a1szXTtwPXQucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShkKSxOPXQucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShmKSxJPWFkZChtdWwoTixyKSxtdWwocCx0LmFjdGl2YXRpb24uYXBwbHkoZykpKSxTPXQucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShtKTt2YXIgeT1tdWwoUyx0LmFjdGl2YXRpb24uYXBwbHkoSSkpO3JldHVyblt5LHksSV19KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbikscmVjdXJyZW50QWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSx1bml0Rm9yZ2V0Qmlhczp0aGlzLnVuaXRGb3JnZXRCaWFzLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXQsaW1wbGVtZW50YXRpb246dGhpcy5pbXBsZW1lbnRhdGlvbn0sdD1hLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9LGUuY2xhc3NOYW1lPVwiTFNUTUNlbGxcIixlfShSTk5DZWxsKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTFNUTUNlbGwpO3ZhciBMU1RNPWZ1bmN0aW9uKHMpe2Z1bmN0aW9uIGUoZSl7cmV0dXJuIDA9PT1lLmltcGxlbWVudGF0aW9uJiZjb25zb2xlLndhcm4oXCJgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byBgaW1wbGVtZW50YXRpb249MWAuIFBsZWFzZSB1cGRhdGUgeW91ciBsYXllciBjYWxsLlwiKSxlLmNlbGw9bmV3IExTVE1DZWxsKGUpLHMuY2FsbCh0aGlzLGUpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMkMShlLHMpLGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bnVsbCE9bi5jZWxsLmRyb3BvdXRNYXNrJiYoZGlzcG9zZShuLmNlbGwuZHJvcG91dE1hc2spLG4uY2VsbC5kcm9wb3V0TWFzaz1udWxsKSxudWxsIT1uLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2smJihkaXNwb3NlKG4uY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksbi5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO3ZhciByPW51bGw9PXQ/bnVsbDp0Lm1hc2ssaT1udWxsPT10P251bGw6dC50cmFpbmluZyxhPW51bGw9PXQ/bnVsbDp0LmluaXRpYWxTdGF0ZTtyZXR1cm4gcy5wcm90b3R5cGUuY2FsbC5jYWxsKG4sZSx7bWFzazpyLHRyYWluaW5nOmksaW5pdGlhbFN0YXRlOmF9KX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ1bml0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVuaXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5hY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInJlY3VycmVudEFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRBY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInVzZUJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51c2VCaWFzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImtlcm5lbEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmVjdXJyZW50SW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJiaWFzSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwidW5pdEZvcmdldEJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0Rm9yZ2V0Qmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJrZXJuZWxSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInJlY3VycmVudFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiYmlhc1JlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc1JlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImtlcm5lbENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInJlY3VycmVudENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImJpYXNDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0NvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiZHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmRyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwicmVjdXJyZW50RHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaW1wbGVtZW50YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5pbXBsZW1lbnRhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgZT17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLHVuaXRGb3JnZXRCaWFzOnRoaXMudW5pdEZvcmdldEJpYXMsa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSx0PXMucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5jZWxsLE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmZyb21Db25maWc9ZnVuY3Rpb24oYSxlKXtyZXR1cm4gMD09PWUuaW1wbG1lbnRhdGlvbiYmKGUuaW1wbGVtZW50YXRpb249MSksbmV3IGEoZSl9LGUuY2xhc3NOYW1lPVwiTFNUTVwiLGV9KFJOTik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExTVE0pO3ZhciBTdGFja2VkUk5OQ2VsbHM9ZnVuY3Rpb24ocyl7ZnVuY3Rpb24gZShlKXt2YXIgdD1zLmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gdC5jZWxscz1lLmNlbGxzLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUscyksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwic3RhdGVTaXplXCIse2dldDpmdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxlPTAsbz10aGlzLmNlbGxzLnNsaWNlKCkucmV2ZXJzZSgpLG47ZTxvLmxlbmd0aDtlKyspbj1vW2VdLEFycmF5LmlzQXJyYXkobi5zdGF0ZVNpemUpP2EucHVzaC5hcHBseShhLG4uc3RhdGVTaXplKTphLnB1c2gobi5zdGF0ZVNpemUpO3JldHVybiBhfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24ocCxhKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciBlPShwPXApLnNsaWNlKDEpLG49W10saT0wLG09dC5jZWxscy5zbGljZSgpLnJldmVyc2UoKSxvO2k8bS5sZW5ndGg7aSsrKW89bVtpXSxBcnJheS5pc0FycmF5KG8uc3RhdGVTaXplKT9uLnB1c2goZS5zcGxpY2UoMCxvLnN0YXRlU2l6ZS5sZW5ndGgpKTpuLnB1c2goZS5zcGxpY2UoMCwxKSk7bi5yZXZlcnNlKCk7Zm9yKHZhciBnPVtdLHU9MCxmO3U8dC5jZWxscy5sZW5ndGg7Kyt1KW89dC5jZWxsc1t1XSxlPW5bdV0sZj0wPT11P1twWzBdXS5jb25jYXQoZSk6W2ZbMF1dLmNvbmNhdChlKSxmPW8uY2FsbChmLGEpLGcucHVzaChmLnNsaWNlKDEpKTtlPVtdO2Zvcih2YXIgeT0wLGI9Zy5zbGljZSgpLnJldmVyc2UoKSxoO3k8Yi5sZW5ndGg7eSsrKWg9Ylt5XSxlLnB1c2guYXBwbHkoZSxoKTtyZXR1cm5bZlswXV0uY29uY2F0KGUpfSl9LGUucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGEpe3ZhciBvO2lzQXJyYXlPZlNoYXBlcyhhKSYmKGE9YVswXSksYT1hO2Zvcih2YXIgcz0wLHA9dGhpcy5jZWxscyxyO3M8cC5sZW5ndGg7cysrKXI9cFtzXSxyLmJ1aWxkKGEpLG89QXJyYXkuaXNBcnJheShyLnN0YXRlU2l6ZSk/ci5zdGF0ZVNpemVbMF06ci5zdGF0ZVNpemUsYT1bYVswXSxvXTt0aGlzLmJ1aWx0PSEwfSxlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLHA9dGhpcy5jZWxscyxyO3Q8cC5sZW5ndGg7dCsrKXI9cFt0XSxlLnB1c2goe2NsYXNzTmFtZTp0aGlzLmdldENsYXNzTmFtZSgpLGNvbmZpZzpyLmdldENvbmZpZygpfSk7dmFyIGw9e2NlbGxzOmV9LGE9cy5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24obCxhKSxsfSxlLmZyb21Db25maWc9ZnVuY3Rpb24ocyxlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTtmb3IodmFyIHA9W10scj0wLGw9ZS5jZWxscyxhO3I8bC5sZW5ndGg7cisrKWE9bFtyXSxwLnB1c2goZGVzZXJpYWxpemUoYSx0KSk7cmV0dXJuIG5ldyBzKHtjZWxsczpwfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudHJhaW5hYmxlKXJldHVybltdO2Zvcih2YXIgYT1bXSxlPTAsbz10aGlzLmNlbGxzLG47ZTxvLmxlbmd0aDtlKyspbj1vW2VdLGEucHVzaC5hcHBseShhLG4udHJhaW5hYmxlV2VpZ2h0cyk7cmV0dXJuIGF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIHM9W10sZT0wLHA9dGhpcy5jZWxscyxuO2U8cC5sZW5ndGg7ZSsrKW49cFtlXSxzLnB1c2guYXBwbHkocyxuLm5vblRyYWluYWJsZVdlaWdodHMpO2lmKCF0aGlzLnRyYWluYWJsZSl7Zm9yKHZhciBsPVtdLGk9MCxkPXRoaXMuY2VsbHM7aTxkLmxlbmd0aDtpKyspbj1kW2ldLGwucHVzaC5hcHBseShsLG4udHJhaW5hYmxlV2VpZ2h0cyk7cmV0dXJuIGwuY29uY2F0KHMpfXJldHVybiBzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9W10sZT0wLG89dGhpcy5jZWxscyxuO2U8by5sZW5ndGg7ZSsrKW49b1tlXSxhLnB1c2guYXBwbHkoYSxuLndlaWdodHMpO3JldHVybiBiYXRjaEdldFZhbHVlKGEpfSxlLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHApe2Zvcih2YXIgZT1bXSx0PTAsbD10aGlzLmNlbGxzO3Q8bC5sZW5ndGg7dCsrKWZvcih2YXIgcj1sW3RdLGk9ci53ZWlnaHRzLmxlbmd0aCxhPXAuc3BsaWNlKGkpLG89MDtvPHIud2VpZ2h0cy5sZW5ndGg7KytvKWUucHVzaChbci53ZWlnaHRzW29dLGFbb11dKTtiYXRjaFNldFZhbHVlKGUpfSxlLmNsYXNzTmFtZT1cIlN0YWNrZWRSTk5DZWxsc1wiLGV9KFJOTkNlbGwpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTdGFja2VkUk5OQ2VsbHMpO3ZhciBXcmFwcGVyPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIHQubGF5ZXI9ZS5sYXllcix0fXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKCl7dGhpcy5idWlsdD0hMH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwidHJhaW5hYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmxheWVyJiZ0aGlzLmxheWVyLnRyYWluYWJsZX0sc2V0OmZ1bmN0aW9uKHQpe251bGwhPXRoaXMubGF5ZXImJih0aGlzLmxheWVyLnRyYWluYWJsZT10KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLnRyYWluYWJsZVdlaWdodHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci5ub25UcmFpbmFibGVXZWlnaHRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInVwZGF0ZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIuX3VwZGF0ZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibG9zc2VzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLmxvc3Nlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIuZ2V0V2VpZ2h0cygpfSxlLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3RoaXMubGF5ZXIuc2V0V2VpZ2h0cyh0KX0sZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e2xheWVyOntjbGFzc05hbWU6dGhpcy5sYXllci5nZXRDbGFzc05hbWUoKSxjb25maWc6dGhpcy5sYXllci5nZXRDb25maWcoKX19LHQ9YS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmZyb21Db25maWc9ZnVuY3Rpb24oYSxlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTt2YXIgbz1kZXNlcmlhbGl6ZShlLmxheWVyLHQpO2RlbGV0ZSBlLmxheWVyO3ZhciByPXtsYXllcjpvfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihyLGUpLG5ldyBhKHIpfSxlfShMYXllciksVGltZURpc3RyaWJ1dGVkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9YS5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIHQuc3VwcG9ydHNNYXNraW5nPSEwLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUsYSksZS5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYoMz4oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRpbWVEaXN0cmlidXRlZCBsYXllciBleHBlY3RzIGFuIGlucHV0IHNoYXBlID49IDNELCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkoZSkpO3RoaXMuaW5wdXRTcGVjPVt7c2hhcGU6ZX1dO3ZhciByPVtlWzBdXS5jb25jYXQoZS5zbGljZSgyKSk7dGhpcy5sYXllci5idWlsdHx8KHRoaXMubGF5ZXIuYnVpbGQociksdGhpcy5sYXllci5idWlsdD0hMCksYS5wcm90b3R5cGUuYnVpbGQuY2FsbCh0aGlzLGUpfSxlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oYSl7dmFyIG89WyhhPWdldEV4YWN0bHlPbmVTaGFwZShhKSlbMF1dLmNvbmNhdChhLnNsaWNlKDIpKSx0PXRoaXMubGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKG8pLG49YVsxXTtyZXR1cm5bdFswXSxuXS5jb25jYXQodC5zbGljZSgxKSl9LGUucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oYSxyKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHJubihmdW5jdGlvbihhKXtyZXR1cm5bZ2V0RXhhY3RseU9uZVRlbnNvcih0LmxheWVyLmNhbGwoYSxyKSksW11dfSxhPWdldEV4YWN0bHlPbmVUZW5zb3IoYSksW10sITEsbnVsbCxudWxsLCExLCEwKVsxXX0pfSxlLmNsYXNzTmFtZT1cIlRpbWVEaXN0cmlidXRlZFwiLGV9KFdyYXBwZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhUaW1lRGlzdHJpYnV0ZWQpO3ZhciBWQUxJRF9CSURJUkVDVElPTkFMX01FUkdFX01PREVTPVtcInN1bVwiLFwibXVsXCIsXCJjb25jYXRcIixcImF2ZVwiXSxCaWRpcmVjdGlvbmFsPWZ1bmN0aW9uKHkpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9eS5jYWxsKHRoaXMsZSl8fHRoaXMsYT1lLmxheWVyLmdldENvbmZpZygpO2lmKHQuZm9yd2FyZExheWVyPWRlc2VyaWFsaXplKHtjbGFzc05hbWU6ZS5sYXllci5nZXRDbGFzc05hbWUoKSxjb25maWc6YX0pLGEuZ29CYWNrd2FyZHM9ITAhPT1hLmdvQmFja3dhcmRzLHQuYmFja3dhcmRMYXllcj1kZXNlcmlhbGl6ZSh7Y2xhc3NOYW1lOmUubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOmF9KSx0LmZvcndhcmRMYXllci5uYW1lPVwiZm9yd2FyZF9cIit0LmZvcndhcmRMYXllci5uYW1lLHQuYmFja3dhcmRMYXllci5uYW1lPVwiYmFja3dhcmRfXCIrdC5iYWNrd2FyZExheWVyLm5hbWUsY2hlY2tCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlKGUubWVyZ2VNb2RlKSx0Lm1lcmdlTW9kZT1lLm1lcmdlTW9kZSxlLndlaWdodHMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJ3ZWlnaHRzIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkIGZvciBCaWRpcmVjdGlvbmFsIGxheWVyIHlldC5cIik7cmV0dXJuIHQuX3N0YXRlZnVsPWUubGF5ZXIuc3RhdGVmdWwsdC5yZXR1cm5TZXF1ZW5jZXM9ZS5sYXllci5yZXR1cm5TZXF1ZW5jZXMsdC5yZXR1cm5TdGF0ZT1lLmxheWVyLnJldHVyblN0YXRlLHQuc3VwcG9ydHNNYXNraW5nPSEwLHQuX3RyYWluYWJsZT0hMCx0LmlucHV0U3BlYz1lLmxheWVyLmlucHV0U3BlYyx0Lm51bUNvbnN0YW50cz1udWxsLHR9cmV0dXJuIF9fZXh0ZW5kcyQxKGUseSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwidHJhaW5hYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90cmFpbmFibGV9LHNldDpmdW5jdGlvbih0KXt0aGlzLl90cmFpbmFibGU9dCxudWxsIT10aGlzLmZvcndhcmRMYXllciYmKHRoaXMuZm9yd2FyZExheWVyLnRyYWluYWJsZT10KSxudWxsIT10aGlzLmJhY2t3YXJkTGF5ZXImJih0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlPXQpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIuZ2V0V2VpZ2h0cygpLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIuZ2V0V2VpZ2h0cygpKX0sZS5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihhKXt2YXIgZT1hLmxlbmd0aCx0PV9NYXRoZmxvb3IoZS8yKTt0aGlzLmZvcndhcmRMYXllci5zZXRXZWlnaHRzKGEuc2xpY2UoMCx0KSksdGhpcy5iYWNrd2FyZExheWVyLnNldFdlaWdodHMoYS5zbGljZSh0KSl9LGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihhKXt2YXIgZT10aGlzLmZvcndhcmRMYXllci5jb21wdXRlT3V0cHV0U2hhcGUoYSksbyxzLHA7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoZVswXSl8fChlPVtlXSksZT1lLHRoaXMucmV0dXJuU3RhdGU/KHA9ZS5zbGljZSgxKSxvPWVbMF0pOm89ZVswXSxvPW8sXCJjb25jYXRcIj09PXRoaXMubWVyZ2VNb2RlPyhvW28ubGVuZ3RoLTFdKj0yLHM9W29dKTpzPW51bGw9PXRoaXMubWVyZ2VNb2RlP1tvLG8uc2xpY2UoKV06W29dLHRoaXMucmV0dXJuU3RhdGU/bnVsbD09dGhpcy5tZXJnZU1vZGU/cy5jb25jYXQocCkuY29uY2F0KHAuc2xpY2UoKSk6W29dLmNvbmNhdChwKS5jb25jYXQocC5zbGljZSgpKTpzaW5nbGV0b25PckFycmF5KHMpfSxlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLGIpe3ZhciB4PW51bGw9PWI/bnVsbDpiLmluaXRpYWxTdGF0ZSxOPW51bGw9PWI/bnVsbDpiLmNvbnN0YW50cztudWxsPT1iJiYoYj17fSk7dmFyIEk9c3RhbmRhcmRpemVBcmdzKGUseCxOLHRoaXMubnVtQ29uc3RhbnRzKTtpZihlPUkuaW5wdXRzLHg9SS5pbml0aWFsU3RhdGUsTj1JLmNvbnN0YW50cyxBcnJheS5pc0FycmF5KGUpJiYoeD1lLnNsaWNlKDEpLGU9ZVswXSksKG51bGw9PXh8fDA9PT14Lmxlbmd0aCkmJm51bGw9PU4pcmV0dXJuIHkucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyxlLGIpO3ZhciBhPVtdLG89W107aWYobnVsbCE9eCl7dmFyIHM9eC5sZW5ndGg7aWYoMDxzJTIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXaGVuIHBhc3NpbmcgYGluaXRpYWxTdGF0ZWAgdG8gYSBCaWRyZWN0aW9uYWwgUk5OLCB0aGUgc3RhdGUgc2hvdWxkIGJlIGFuIEFycmF5IGNvbnRhaW5pbmcgdGhlIHN0YXRlcyBvZiB0aGUgdW5kZXJseWluZyBSTk5zLlwiKTtiLmluaXRpYWxTdGF0ZT14LGEucHVzaC5hcHBseShhLHgpO3ZhciBsPXgubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgSW5wdXRTcGVjKHtzaGFwZTp0LnNoYXBlfSl9KTt0aGlzLmZvcndhcmRMYXllci5zdGF0ZVNwZWM9bC5zbGljZSgwLHMvMiksdGhpcy5iYWNrd2FyZExheWVyLnN0YXRlU3BlYz1sLnNsaWNlKHMvMiksby5wdXNoLmFwcGx5KG8sbCl9aWYobnVsbCE9Til0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlN1cHBvcnQgZm9yIGNvbnN0YW50cyBpbiBCaWRpcmVjdGlvbmFsIGxheWVycyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtmb3IodmFyIHU9YVswXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3IsYz0wLHY9YTtjPHYubGVuZ3RoO2MrKylpZih2W2NdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvciE9dSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBpbml0aWFsIHN0YXRlIG9mIGEgQmlkaXJlY3Rpb25hbCBsYXllciBjYW5ub3QgYmUgc3BlY2lmaWVkIGFzIGEgbWl4IG9mIHN5bWJvbGljIGFuZCBub24tc3ltYm9saWMgdGVuc29yc1wiKTtpZih1KXt2YXIgaD1bZV0uY29uY2F0KGEpLGQ9dGhpcy5pbnB1dFNwZWMuY29uY2F0KG8pLGY9dGhpcy5pbnB1dFNwZWM7dGhpcy5pbnB1dFNwZWM9ZDt2YXIgZz15LnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsaCxiKTtyZXR1cm4gdGhpcy5pbnB1dFNwZWM9ZixnfXJldHVybiB5LnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsZSxiKX0sZS5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihwLGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihudWxsIT1lLm1hc2spdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgc3VwcG9ydCBmb3IgbWFza2luZyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEJpZGlyZWN0aW9uYWwgbGF5ZXJzIHlldC5cIik7dmFyIG49ZS5pbml0aWFsU3RhdGUscyxkLGMsbTtpZihudWxsPT1uKXM9dC5mb3J3YXJkTGF5ZXIuY2FsbChwLGUpLGQ9dC5iYWNrd2FyZExheWVyLmNhbGwocCxlKTtlbHNle3ZhciBoPW4uc2xpY2UoMCxuLmxlbmd0aC8yKSxsPW4uc2xpY2Uobi5sZW5ndGgvMik7cz10LmZvcndhcmRMYXllci5jYWxsKHAsT2JqZWN0LmFzc2lnbihlLHtpbml0aWFsU3RhdGU6aH0pKSxkPXQuYmFja3dhcmRMYXllci5jYWxsKHAsT2JqZWN0LmFzc2lnbihlLHtpbml0aWFsU3RhdGU6bH0pKX1yZXR1cm4gdC5yZXR1cm5TdGF0ZSYmKEFycmF5LmlzQXJyYXkocykmJihjPXMuc2xpY2UoMSkuY29uY2F0KGQuc2xpY2UoMSkpKSxzPXNbMF0sZD1kWzBdKSx0LnJldHVyblNlcXVlbmNlcyYmKGQ9cmV2ZXJzZShkLDEpKSxcImNvbmNhdFwiPT09dC5tZXJnZU1vZGU/bT1jb25jYXRlbmF0ZShbcyxkXSk6XCJzdW1cIj09PXQubWVyZ2VNb2RlP209YWRkKHMsZCk6XCJhdmVcIj09PXQubWVyZ2VNb2RlP209bXVsKGdldFNjYWxhciguNSksYWRkKHMsZCkpOlwibXVsXCI9PT10Lm1lcmdlTW9kZT9tPW11bChzLGQpOm51bGw9PXQubWVyZ2VNb2RlJiYobT1bcyxkXSksdC5yZXR1cm5TdGF0ZT9udWxsPT10Lm1lcmdlTW9kZT9tLmNvbmNhdChjKTpbbV0uY29uY2F0KGMpOm19KX0sZS5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24oKXt0aGlzLmZvcndhcmRMYXllci5yZXNldFN0YXRlcygpLHRoaXMuYmFja3dhcmRMYXllci5yZXNldFN0YXRlcygpfSxlLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihhKXt2YXIgZT10aGlzO25hbWVTY29wZSh0aGlzLmZvcndhcmRMYXllci5uYW1lLGZ1bmN0aW9uKCl7ZS5mb3J3YXJkTGF5ZXIuYnVpbGQoYSl9KSxuYW1lU2NvcGUodGhpcy5iYWNrd2FyZExheWVyLm5hbWUsZnVuY3Rpb24oKXtlLmJhY2t3YXJkTGF5ZXIuYnVpbGQoYSl9KSx0aGlzLmJ1aWx0PSEwfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlV2VpZ2h0cyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLm5vblRyYWluYWJsZVdlaWdodHMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXttZXJnZU1vZGU6dGhpcy5tZXJnZU1vZGV9LHQ9eS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfSxlLmZyb21Db25maWc9ZnVuY3Rpb24oYSxlKXt2YXIgdD1kZXNlcmlhbGl6ZShlLmxheWVyKTtpZihkZWxldGUgZS5sYXllcixudWxsIT1lLm51bUNvbnN0YW50cyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkRlc2VyaWFsaXphdGlvbiBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgd2l0aCBudW1Db25zdGFudHMgcHJlc2VudCBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7dmFyIG49ZTtyZXR1cm4gbi5sYXllcj10LG5ldyBhKG4pfSxlLmNsYXNzTmFtZT1cIkJpZGlyZWN0aW9uYWxcIixlfShXcmFwcGVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQmlkaXJlY3Rpb25hbCk7dmFyIGdsb2JhbE1heFBvb2wxZD1nbG9iYWxNYXhQb29saW5nMWQsZ2xvYmFsTWF4UG9vbDJkPWdsb2JhbE1heFBvb2xpbmcyZCxtYXhQb29sMWQ9bWF4UG9vbGluZzFkLG1heFBvb2wyZD1tYXhQb29saW5nMmQsZXhwb3J0c19sYXllcnM9T2JqZWN0LmZyZWV6ZSh7aW5wdXRMYXllcjppbnB1dExheWVyLGVsdTplbHUkMixyZUxVOnJlTFUsbGVha3lSZUxVOmxlYWt5UmVMVSxzb2Z0bWF4OnNvZnRtYXgkMSx0aHJlc2hvbGRlZFJlTFU6dGhyZXNob2xkZWRSZUxVLGNvbnYxZDpjb252MWQkMixjb252MmQ6Y29udjJkJDIsY29udjJkVHJhbnNwb3NlOmNvbnYyZFRyYW5zcG9zZSQxLHNlcGFyYWJsZUNvbnYyZDpzZXBhcmFibGVDb252MmQkMSxjcm9wcGluZzJEOmNyb3BwaW5nMkQsdXBTYW1wbGluZzJkOnVwU2FtcGxpbmcyZCxkZXB0aHdpc2VDb252MmQ6ZGVwdGh3aXNlQ29udjJkJDIsYWN0aXZhdGlvbjphY3RpdmF0aW9uLGRlbnNlOmRlbnNlLGRyb3BvdXQ6ZHJvcG91dCQxLGZsYXR0ZW46ZmxhdHRlbiQxJDEscmVwZWF0VmVjdG9yOnJlcGVhdFZlY3RvcixyZXNoYXBlOnJlc2hhcGUkMSxwZXJtdXRlOnBlcm11dGUsZW1iZWRkaW5nOmVtYmVkZGluZyxhZGQ6YWRkJDIsYXZlcmFnZTphdmVyYWdlJDEsY29uY2F0ZW5hdGU6Y29uY2F0ZW5hdGUkMixtYXhpbXVtOm1heGltdW0kMixtaW5pbXVtOm1pbmltdW0kMixtdWx0aXBseTptdWx0aXBseSQxLGRvdDpkb3QkMSQxLGJhdGNoTm9ybWFsaXphdGlvbjpiYXRjaE5vcm1hbGl6YXRpb24kMSQxLHplcm9QYWRkaW5nMmQ6emVyb1BhZGRpbmcyZCxhdmVyYWdlUG9vbGluZzFkOmF2ZXJhZ2VQb29saW5nMWQsYXZnUG9vbDFkOmF2Z1Bvb2wxZCxhdmdQb29saW5nMWQ6YXZnUG9vbGluZzFkLGF2ZXJhZ2VQb29saW5nMmQ6YXZlcmFnZVBvb2xpbmcyZCxhdmdQb29sMmQ6YXZnUG9vbDJkLGF2Z1Bvb2xpbmcyZDphdmdQb29saW5nMmQsZ2xvYmFsQXZlcmFnZVBvb2xpbmcxZDpnbG9iYWxBdmVyYWdlUG9vbGluZzFkLGdsb2JhbEF2ZXJhZ2VQb29saW5nMmQ6Z2xvYmFsQXZlcmFnZVBvb2xpbmcyZCxnbG9iYWxNYXhQb29saW5nMWQ6Z2xvYmFsTWF4UG9vbGluZzFkLGdsb2JhbE1heFBvb2xpbmcyZDpnbG9iYWxNYXhQb29saW5nMmQsbWF4UG9vbGluZzFkOm1heFBvb2xpbmcxZCxtYXhQb29saW5nMmQ6bWF4UG9vbGluZzJkLGdydTpncnUsZ3J1Q2VsbDpncnVDZWxsLGxzdG06bHN0bSxsc3RtQ2VsbDpsc3RtQ2VsbCxzaW1wbGVSTk46c2ltcGxlUk5OLHNpbXBsZVJOTkNlbGw6c2ltcGxlUk5OQ2VsbCxybm46cm5uJDEsc3RhY2tlZFJOTkNlbGxzOnN0YWNrZWRSTk5DZWxscyxiaWRpcmVjdGlvbmFsOmJpZGlyZWN0aW9uYWwsdGltZURpc3RyaWJ1dGVkOnRpbWVEaXN0cmlidXRlZCxnbG9iYWxNYXhQb29sMWQ6Z2xvYmFsTWF4UG9vbDFkLGdsb2JhbE1heFBvb2wyZDpnbG9iYWxNYXhQb29sMmQsbWF4UG9vbDFkOm1heFBvb2wxZCxtYXhQb29sMmQ6bWF4UG9vbDJkLExheWVyOkxheWVyLFJOTjpSTk4sUk5OQ2VsbDpSTk5DZWxsLGlucHV0OmlucHV0fSksZXhwb3J0c19tb2RlbHM9T2JqZWN0LmZyZWV6ZSh7bW9kZWxGcm9tSlNPTjptb2RlbEZyb21KU09OfSksZXhwb3J0c19tZXRyaWNzPU9iamVjdC5mcmVlemUoe2JpbmFyeUFjY3VyYWN5OmJpbmFyeUFjY3VyYWN5JDEsYmluYXJ5Q3Jvc3NlbnRyb3B5OmJpbmFyeUNyb3NzZW50cm9weSQyLGNhdGVnb3JpY2FsQWNjdXJhY3k6Y2F0ZWdvcmljYWxBY2N1cmFjeSQxLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDIscHJlY2lzaW9uOnByZWNpc2lvbiQxLHJlY2FsbDpyZWNhbGwkMSxjb3NpbmVQcm94aW1pdHk6Y29zaW5lUHJveGltaXR5JDEsbWVhbkFic29sdXRlRXJyb3I6bWVhbkFic29sdXRlRXJyb3IkMSxtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I6bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yJDEsTUFQRTpNQVBFJDIsbWFwZTptYXBlJDIsbWVhblNxdWFyZWRFcnJvcjptZWFuU3F1YXJlZEVycm9yJDEkMSxNU0U6TVNFJDIsbXNlOm1zZSQyfSksZXhwb3J0c19yZWd1bGFyaXplcnM9T2JqZWN0LmZyZWV6ZSh7bDFsMjpsMWwyLGwxOmwxJDEsbDI6bDIkMX0pLENhbGxiYWNrPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09YSYmYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUubW9kZWw9bnVsbCxlfXJldHVybiBfX2V4dGVuZHMkMShlLGEpLGUucHJvdG90eXBlLnNldE1vZGVsPWZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIE1vZGVsKSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBtdXN0IGJlIGEgTW9kZWwsIG5vdCBzb21lIG90aGVyIENvbnRhaW5lclwiKTt0aGlzLm1vZGVsPXR9LGV9KEJhc2VDYWxsYmFjayksX19hc3NpZ24kMj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihvKXtmb3IodmFyIGU9MSxzPWFyZ3VtZW50cy5sZW5ndGgscjtlPHM7ZSsrKWZvcih2YXIgaSBpbiByPWFyZ3VtZW50c1tlXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixpKSYmKG9baV09cltpXSk7cmV0dXJuIG99LGNvbW1vbmpzR2xvYmFsJDE9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsP1widW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP3t9OnNlbGY6Z2xvYmFsOndpbmRvdyxhc3Byb21pc2U9YXNQcm9taXNlLGJhc2U2NF8xPWNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24ocyxlKXt2YXIgdD1lO3QubGVuZ3RoPWZ1bmN0aW9uKG4pe3ZhciBlPW4ubGVuZ3RoO2lmKCFlKXJldHVybiAwO2Zvcih2YXIgcj0wOzE8LS1lJTQmJlwiPVwiPT09bi5jaGFyQXQoZSk7KSsrcjtyZXR1cm4gX01hdGhjZWlsKDMqbi5sZW5ndGgpLzQtcn07Zm9yKHZhciBsPUFycmF5KDY0KSxpPUFycmF5KDEyMyksYT0wOzY0PmE7KWlbbFthXT0yNj5hP2ErNjU6NTI+YT9hKzcxOjYyPmE/YS00OjQzfGEtNTldPWErKzt0LmVuY29kZT1mdW5jdGlvbihyLGUsZCl7Zm9yKHZhciBhPW51bGwsdT1bXSxzPTAsYz0wLGgsZztlPGQ7KWc9cltlKytdLDA9PWM/KHVbcysrXT1sW2c+PjJdLGg9KDMmZyk8PDQsYz0xKToxPT1jPyh1W3MrK109bFtofGc+PjRdLGg9KDE1JmcpPDwyLGM9Mik6Mj09Yz8odVtzKytdPWxbaHxnPj42XSx1W3MrK109bFs2MyZnXSxjPTApOnZvaWQgMCw4MTkxPHMmJigoYXx8KGE9W10pKS5wdXNoKF9TdHJpbmdmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHUpKSxzPTApO3JldHVybiBjJiYodVtzKytdPWxbaF0sdVtzKytdPTYxLDE9PWMmJih1W3MrK109NjEpKSxhPyhzJiZhLnB1c2goX1N0cmluZ2Zyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsdS5zbGljZSgwLHMpKSksYS5qb2luKFwiXCIpKTpfU3RyaW5nZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx1LnNsaWNlKDAscykpfSx0LmRlY29kZT1mdW5jdGlvbihuLGUsdCl7Zm9yKHZhciBsPXQsbz0wLGQ9MCx1LGM7ZDxuLmxlbmd0aCYmKGM9bi5jaGFyQ29kZUF0KGQrKyksISg2MT09PWMmJjE8bykpOyl7aWYodm9pZCAwPT09KGM9aVtjXSkpdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGVuY29kaW5nXCIpOzA9PW8/KHU9YyxvPTEpOjE9PW8/KGVbdCsrXT11PDwyfCg0OCZjKT4+NCx1PWMsbz0yKToyPT1vPyhlW3QrK109KDE1JnUpPDw0fCg2MCZjKT4+Mix1PWMsbz0zKTozPT1vPyhlW3QrK109KDMmdSk8PDZ8YyxvPTApOnZvaWQgMH1pZigxPT1vKXRocm93IEVycm9yKFwiaW52YWxpZCBlbmNvZGluZ1wiKTtyZXR1cm4gdC1sfSx0LnRlc3Q9ZnVuY3Rpb24odCl7cmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHQpfX0pLGV2ZW50ZW1pdHRlcj1FdmVudEVtaXR0ZXI7RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbj1mdW5jdGlvbihuLGUsdCl7cmV0dXJuKHRoaXMuX2xpc3RlbmVyc1tuXXx8KHRoaXMuX2xpc3RlbmVyc1tuXT1bXSkpLnB1c2goe2ZuOmUsY3R4OnR8fHRoaXN9KSx0aGlzfSxFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZj1mdW5jdGlvbihuLGUpe2lmKHZvaWQgMD09PW4pdGhpcy5fbGlzdGVuZXJzPXt9O2Vsc2UgaWYodm9pZCAwPT09ZSl0aGlzLl9saXN0ZW5lcnNbbl09W107ZWxzZSBmb3IodmFyIHQ9dGhpcy5fbGlzdGVuZXJzW25dLGE9MDthPHQubGVuZ3RoOyl0W2FdLmZuPT09ZT90LnNwbGljZShhLDEpOisrYTtyZXR1cm4gdGhpc30sRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKG4pe3ZhciBlPXRoaXMuX2xpc3RlbmVyc1tuXTtpZihlKXtmb3IodmFyIHQ9W10sYT0xO2E8YXJndW1lbnRzLmxlbmd0aDspdC5wdXNoKGFyZ3VtZW50c1thKytdKTtmb3IoYT0wO2E8ZS5sZW5ndGg7KWVbYV0uZm4uYXBwbHkoZVthKytdLmN0eCx0KX1yZXR1cm4gdGhpc307dmFyIGZsb2F0XzE9ZmFjdG9yeShmYWN0b3J5KSxpbnF1aXJlXzE9aW5xdWlyZSx1dGY4XzE9Y3JlYXRlQ29tbW9uanNNb2R1bGUkMShmdW5jdGlvbihuLGUpe3ZhciB0PWU7dC5sZW5ndGg9ZnVuY3Rpb24obil7Zm9yKHZhciBlPTAsbz0wLHM9MDtzPG4ubGVuZ3RoOysrcykxMjg+KG89bi5jaGFyQ29kZUF0KHMpKT9lKz0xOjIwNDg+bz9lKz0yOjU1Mjk2PT0oNjQ1MTImbykmJjU2MzIwPT0oNjQ1MTImbi5jaGFyQ29kZUF0KHMrMSkpPygrK3MsZSs9NCk6ZSs9MztyZXR1cm4gZX0sdC5yZWFkPWZ1bmN0aW9uKGksZSxwKXtpZigxPnAtZSlyZXR1cm5cIlwiO2Zvcih2YXIgYT1udWxsLGw9W10sbz0wLGQ7ZTxwOykxMjg+KGQ9aVtlKytdKT9sW28rK109ZDoxOTE8ZCYmMjI0PmQ/bFtvKytdPSgzMSZkKTw8Nnw2MyZpW2UrK106MjM5PGQmJjM2NT5kPyhkPSgoNyZkKTw8MTh8KDYzJmlbZSsrXSk8PDEyfCg2MyZpW2UrK10pPDw2fDYzJmlbZSsrXSktNjU1MzYsbFtvKytdPTU1Mjk2KyhkPj4xMCksbFtvKytdPTU2MzIwKygxMDIzJmQpKTpsW28rK109KDE1JmQpPDwxMnwoNjMmaVtlKytdKTw8Nnw2MyZpW2UrK10sODE5MTxvJiYoKGF8fChhPVtdKSkucHVzaChfU3RyaW5nZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxsKSksbz0wKTtyZXR1cm4gYT8obyYmYS5wdXNoKF9TdHJpbmdmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGwuc2xpY2UoMCxvKSkpLGEuam9pbihcIlwiKSk6X1N0cmluZ2Zyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsbC5zbGljZSgwLG8pKX0sdC53cml0ZT1mdW5jdGlvbihpLGUsdCl7Zm9yKHZhciBwPXQsbz0wLGwsZDtvPGkubGVuZ3RoOysrbykxMjg+KGw9aS5jaGFyQ29kZUF0KG8pKT9lW3QrK109bDoyMDQ4Pmw/KGVbdCsrXT0xOTJ8bD4+NixlW3QrK109MTI4fDYzJmwpOjU1Mjk2PT0oNjQ1MTImbCkmJjU2MzIwPT0oNjQ1MTImKGQ9aS5jaGFyQ29kZUF0KG8rMSkpKT8obD02NTUzNisoKDEwMjMmbCk8PDEwKSsoMTAyMyZkKSwrK28sZVt0KytdPTI0MHxsPj4xOCxlW3QrK109MTI4fDYzJmw+PjEyLGVbdCsrXT0xMjh8NjMmbD4+NixlW3QrK109MTI4fDYzJmwpOihlW3QrK109MjI0fGw+PjEyLGVbdCsrXT0xMjh8NjMmbD4+NixlW3QrK109MTI4fDYzJmwpO3JldHVybiB0LXB9fSkscG9vbF8xPXBvb2wkMSxsb25nYml0cz1Mb25nQml0cyx6ZXJvPUxvbmdCaXRzLnplcm89bmV3IExvbmdCaXRzKDAsMCk7emVyby50b051bWJlcj1mdW5jdGlvbigpe3JldHVybiAwfSx6ZXJvLnp6RW5jb2RlPXplcm8uenpEZWNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30semVyby5sZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gMX07dmFyIHplcm9IYXNoPUxvbmdCaXRzLnplcm9IYXNoPVwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7TG9uZ0JpdHMuZnJvbU51bWJlcj1mdW5jdGlvbihuKXtpZigwPT09bilyZXR1cm4gemVybzt2YXIgbz0wPm47byYmKG49LW4pO3ZhciB0PW4+Pj4wLHM9KG4tdCkvNDI5NDk2NzI5Nj4+PjA7cmV0dXJuIG8mJihzPX5zPj4+MCx0PX50Pj4+MCw0Mjk0OTY3Mjk1PCsrdCYmKHQ9MCw0Mjk0OTY3Mjk1PCsrcyYmKHM9MCkpKSxuZXcgTG9uZ0JpdHModCxzKX0sTG9uZ0JpdHMuZnJvbT1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih0KTtpZihtaW5pbWFsLmlzU3RyaW5nKHQpKXtpZighbWluaW1hbC5Mb25nKXJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHQsMTApKTt0PW1pbmltYWwuTG9uZy5mcm9tU3RyaW5nKHQpfXJldHVybiB0Lmxvd3x8dC5oaWdoP25ldyBMb25nQml0cyh0Lmxvdz4+PjAsdC5oaWdoPj4+MCk6emVyb30sTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyPWZ1bmN0aW9uKG4pe2lmKCFuJiZ0aGlzLmhpPj4+MzEpe3ZhciBlPTErfnRoaXMubG8+Pj4wLHQ9fnRoaXMuaGk+Pj4wO3JldHVybiBlfHwodD10KzE+Pj4wKSwtKGUrNDI5NDk2NzI5Nip0KX1yZXR1cm4gdGhpcy5sbys0Mjk0OTY3Mjk2KnRoaXMuaGl9LExvbmdCaXRzLnByb3RvdHlwZS50b0xvbmc9ZnVuY3Rpb24odCl7cmV0dXJuIG1pbmltYWwuTG9uZz9uZXcgbWluaW1hbC5Mb25nKDB8dGhpcy5sbywwfHRoaXMuaGksISF0KTp7bG93OjB8dGhpcy5sbyxoaWdoOjB8dGhpcy5oaSx1bnNpZ25lZDohIXR9fTt2YXIgY2hhckNvZGVBdD1TdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7TG9uZ0JpdHMuZnJvbUhhc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT16ZXJvSGFzaD96ZXJvOm5ldyBMb25nQml0cygoY2hhckNvZGVBdC5jYWxsKHQsMCl8Y2hhckNvZGVBdC5jYWxsKHQsMSk8PDh8Y2hhckNvZGVBdC5jYWxsKHQsMik8PDE2fGNoYXJDb2RlQXQuY2FsbCh0LDMpPDwyNCk+Pj4wLChjaGFyQ29kZUF0LmNhbGwodCw0KXxjaGFyQ29kZUF0LmNhbGwodCw1KTw8OHxjaGFyQ29kZUF0LmNhbGwodCw2KTw8MTZ8Y2hhckNvZGVBdC5jYWxsKHQsNyk8PDI0KT4+PjApfSxMb25nQml0cy5wcm90b3R5cGUudG9IYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIF9TdHJpbmdmcm9tQ2hhckNvZGUoMjU1JnRoaXMubG8sMjU1JnRoaXMubG8+Pj44LDI1NSZ0aGlzLmxvPj4+MTYsdGhpcy5sbz4+PjI0LDI1NSZ0aGlzLmhpLDI1NSZ0aGlzLmhpPj4+OCwyNTUmdGhpcy5oaT4+PjE2LHRoaXMuaGk+Pj4yNCl9LExvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGk+PjMxO3JldHVybiB0aGlzLmhpPSgodGhpcy5oaTw8MXx0aGlzLmxvPj4+MzEpXnQpPj4+MCx0aGlzLmxvPSh0aGlzLmxvPDwxXnQpPj4+MCx0aGlzfSxMb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGU9ZnVuY3Rpb24oKXt2YXIgdD0tKDEmdGhpcy5sbyk7cmV0dXJuIHRoaXMubG89KCh0aGlzLmxvPj4+MXx0aGlzLmhpPDwzMSledCk+Pj4wLHRoaXMuaGk9KHRoaXMuaGk+Pj4xXnQpPj4+MCx0aGlzfSxMb25nQml0cy5wcm90b3R5cGUubGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5sbyxlPSh0aGlzLmxvPj4+Mjh8dGhpcy5oaTw8NCk+Pj4wLHQ9dGhpcy5oaT4+PjI0O3JldHVybiAwPT10PzA9PWU/MTYzODQ+bj8xMjg+bj8xOjI6MjA5NzE1Mj5uPzM6NDoxNjM4ND5lPzEyOD5lPzU6NjoyMDk3MTUyPmU/Nzo4OjEyOD50Pzk6MTB9O3ZhciBtaW5pbWFsPWNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24obyxlKXtmdW5jdGlvbiBzKG8sZSx0KXtmb3IodmFyIGE9T2JqZWN0LmtleXMoZSkscj0wO3I8YS5sZW5ndGg7KytyKXZvaWQgMCE9PW9bYVtyXV0mJnR8fChvW2Fbcl1dPWVbYVtyXV0pO3JldHVybiBvfWZ1bmN0aW9uIHQoYSl7ZnVuY3Rpb24gbih0LGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2Ygbj92b2lkKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLG4pOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic3RhY2tcIix7dmFsdWU6bmV3IEVycm9yKCkuc3RhY2t8fFwiXCJ9KSxlJiZzKHRoaXMsZSkpOm5ldyBuKHQsZSl9cmV0dXJuKG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3I9bixPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsXCJuYW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBhfX0pLG4ucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZStcIjogXCIrdGhpcy5tZXNzYWdlfSxufXZhciBuPWU7bi5hc1Byb21pc2U9YXNwcm9taXNlLG4uYmFzZTY0PWJhc2U2NF8xLG4uRXZlbnRFbWl0dGVyPWV2ZW50ZW1pdHRlcixuLmZsb2F0PWZsb2F0XzEsbi5pbnF1aXJlPWlucXVpcmVfMSxuLnV0Zjg9dXRmOF8xLG4ucG9vbD1wb29sXzEsbi5Mb25nQml0cz1sb25nYml0cyxuLmVtcHR5QXJyYXk9T2JqZWN0LmZyZWV6ZT9PYmplY3QuZnJlZXplKFtdKTpbXSxuLmVtcHR5T2JqZWN0PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZSh7fSk6e30sbi5pc05vZGU9ISEoY29tbW9uanNHbG9iYWwkMS5wcm9jZXNzJiZjb21tb25qc0dsb2JhbCQxLnByb2Nlc3MudmVyc2lvbnMmJmNvbW1vbmpzR2xvYmFsJDEucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSxuLmlzSW50ZWdlcj1fTnVtYmVyaXNJbnRlZ2VyfHxmdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaXNGaW5pdGUodCkmJl9NYXRoZmxvb3IodCk9PT10fSxuLmlzU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgU3RyaW5nfSxuLmlzT2JqZWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0JiZcIm9iamVjdFwiPT10eXBlb2YgdH0sbi5pc3NldD1uLmlzU2V0PWZ1bmN0aW9uKG4sZSl7dmFyIHQ9bltlXTtyZXR1cm4gbnVsbCE9dCYmbi5oYXNPd25Qcm9wZXJ0eShlKSYmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHwwPChBcnJheS5pc0FycmF5KHQpP3QubGVuZ3RoOk9iamVjdC5rZXlzKHQpLmxlbmd0aCkpfSxuLkJ1ZmZlcj1mdW5jdGlvbigpe3RyeXt2YXIgdD1uLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO3JldHVybiB0LnByb3RvdHlwZS51dGY4V3JpdGU/dDpudWxsfWNhdGNoKHQpe3JldHVybiBudWxsfX0oKSxuLl9CdWZmZXJfZnJvbT1udWxsLG4uX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsLG4ubmV3QnVmZmVyPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P24uQnVmZmVyP24uX0J1ZmZlcl9hbGxvY1Vuc2FmZSh0KTpuZXcgbi5BcnJheSh0KTpuLkJ1ZmZlcj9uLl9CdWZmZXJfZnJvbSh0KTpcInVuZGVmaW5lZFwiPT10eXBlb2YgVWludDhBcnJheT90Om5ldyBVaW50OEFycmF5KHQpfSxuLkFycmF5PVwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P0FycmF5OlVpbnQ4QXJyYXksbi5Mb25nPWNvbW1vbmpzR2xvYmFsJDEuZGNvZGVJTyYmY29tbW9uanNHbG9iYWwkMS5kY29kZUlPLkxvbmd8fG4uaW5xdWlyZShcImxvbmdcIiksbi5rZXkyUmU9L150cnVlfGZhbHNlfDB8MSQvLG4ua2V5MzJSZT0vXi0/KD86MHxbMS05XVswLTldKikkLyxuLmtleTY0UmU9L14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvLG4ubG9uZ1RvSGFzaD1mdW5jdGlvbih0KXtyZXR1cm4gdD9uLkxvbmdCaXRzLmZyb20odCkudG9IYXNoKCk6bi5Mb25nQml0cy56ZXJvSGFzaH0sbi5sb25nRnJvbUhhc2g9ZnVuY3Rpb24oYSxlKXt2YXIgdD1uLkxvbmdCaXRzLmZyb21IYXNoKGEpO3JldHVybiBuLkxvbmc/bi5Mb25nLmZyb21CaXRzKHQubG8sdC5oaSxlKTp0LnRvTnVtYmVyKCEhZSl9LG4ubWVyZ2U9cyxuLmxjRmlyc3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkrdC5zdWJzdHJpbmcoMSl9LG4ubmV3RXJyb3I9dCxuLlByb3RvY29sRXJyb3I9dChcIlByb3RvY29sRXJyb3JcIiksbi5vbmVPZkdldHRlcj1mdW5jdGlvbihuKXtmb3IodmFyIHI9e30sZT0wO2U8bi5sZW5ndGg7KytlKXJbbltlXV09MTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHQ9T2JqZWN0LmtleXModGhpcyksZT10Lmxlbmd0aC0xOy0xPGU7LS1lKWlmKDE9PT1yW3RbZV1dJiZ2b2lkIDAhPT10aGlzW3RbZV1dJiZudWxsIT09dGhpc1t0W2VdXSlyZXR1cm4gdFtlXX19LG4ub25lT2ZTZXR0ZXI9ZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8bi5sZW5ndGg7Kyt0KW5bdF0hPT1lJiZkZWxldGUgdGhpc1tuW3RdXX19LG4udG9KU09OT3B0aW9ucz17bG9uZ3M6U3RyaW5nLGVudW1zOlN0cmluZyxieXRlczpTdHJpbmcsanNvbjohMH0sbi5fY29uZmlndXJlPWZ1bmN0aW9uKCl7dmFyIHI9bi5CdWZmZXI7cj8obi5fQnVmZmVyX2Zyb209ci5mcm9tIT09VWludDhBcnJheS5mcm9tJiZyLmZyb218fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyByKGUsdCl9LG4uX0J1ZmZlcl9hbGxvY1Vuc2FmZT1yLmFsbG9jVW5zYWZlfHxmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHIoZSl9KTpuLl9CdWZmZXJfZnJvbT1uLl9CdWZmZXJfYWxsb2NVbnNhZmU9bnVsbH19KSx3cml0ZXI9V3JpdGVyLExvbmdCaXRzJDE9bWluaW1hbC5Mb25nQml0cyxiYXNlNjQ9bWluaW1hbC5iYXNlNjQsdXRmOD1taW5pbWFsLnV0ZjgsQnVmZmVyV3JpdGVyO1dyaXRlci5jcmVhdGU9bWluaW1hbC5CdWZmZXI/ZnVuY3Rpb24oKXtyZXR1cm4oV3JpdGVyLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgQnVmZmVyV3JpdGVyfSkoKX06ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFdyaXRlcn0sV3JpdGVyLmFsbG9jPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbWluaW1hbC5BcnJheSh0KX0sbWluaW1hbC5BcnJheSE9PUFycmF5JiYoV3JpdGVyLmFsbG9jPW1pbmltYWwucG9vbChXcml0ZXIuYWxsb2MsbWluaW1hbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxXcml0ZXIucHJvdG90eXBlLl9wdXNoPWZ1bmN0aW9uKG4sZSx0KXtyZXR1cm4gdGhpcy50YWlsPXRoaXMudGFpbC5uZXh0PW5ldyBPcChuLGUsdCksdGhpcy5sZW4rPWUsdGhpc30sVmFyaW50T3AucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKSxWYXJpbnRPcC5wcm90b3R5cGUuZm49d3JpdGVWYXJpbnQzMixXcml0ZXIucHJvdG90eXBlLnVpbnQzMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sZW4rPSh0aGlzLnRhaWw9dGhpcy50YWlsLm5leHQ9bmV3IFZhcmludE9wKDEyOD4odD4+Pj0wKT8xOjE2Mzg0PnQ/MjoyMDk3MTUyPnQ/MzoyNjg0MzU0NTY+dD80OjUsdCkpLmxlbix0aGlzfSxXcml0ZXIucHJvdG90eXBlLmludDMyPWZ1bmN0aW9uKHQpe3JldHVybiAwPnQ/dGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LDEwLExvbmdCaXRzJDEuZnJvbU51bWJlcih0KSk6dGhpcy51aW50MzIodCl9LFdyaXRlci5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVpbnQzMigodDw8MV50Pj4zMSk+Pj4wKX0sV3JpdGVyLnByb3RvdHlwZS51aW50NjQ9ZnVuY3Rpb24oYSl7dmFyIGU9TG9uZ0JpdHMkMS5mcm9tKGEpO3JldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsZS5sZW5ndGgoKSxlKX0sV3JpdGVyLnByb3RvdHlwZS5pbnQ2ND1Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCxXcml0ZXIucHJvdG90eXBlLnNpbnQ2ND1mdW5jdGlvbihhKXt2YXIgZT1Mb25nQml0cyQxLmZyb20oYSkuenpFbmNvZGUoKTtyZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LGUubGVuZ3RoKCksZSl9LFdyaXRlci5wcm90b3R5cGUuYm9vbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsMSx0PzE6MCl9LFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsNCx0Pj4+MCl9LFdyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzI9V3JpdGVyLnByb3RvdHlwZS5maXhlZDMyLFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2ND1mdW5jdGlvbihhKXt2YXIgZT1Mb25nQml0cyQxLmZyb20oYSk7cmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLDQsZS5sbykuX3B1c2god3JpdGVGaXhlZDMyLDQsZS5oaSl9LFdyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQ9V3JpdGVyLnByb3RvdHlwZS5maXhlZDY0LFdyaXRlci5wcm90b3R5cGUuZmxvYXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2gobWluaW1hbC5mbG9hdC53cml0ZUZsb2F0TEUsNCx0KX0sV3JpdGVyLnByb3RvdHlwZS5kb3VibGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2gobWluaW1hbC5mbG9hdC53cml0ZURvdWJsZUxFLDgsdCl9O3ZhciB3cml0ZUJ5dGVzPW1pbmltYWwuQXJyYXkucHJvdG90eXBlLnNldD9mdW5jdGlvbihuLGUsdCl7ZS5zZXQobix0KX06ZnVuY3Rpb24obixlLHQpe2Zvcih2YXIgYT0wO2E8bi5sZW5ndGg7KythKWVbdCthXT1uW2FdfTtXcml0ZXIucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKG4pe3ZhciByPW4ubGVuZ3RoPj4+MDtpZighcilyZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsMSwwKTtpZihtaW5pbWFsLmlzU3RyaW5nKG4pKXt2YXIgbz1Xcml0ZXIuYWxsb2Mocj1iYXNlNjQubGVuZ3RoKG4pKTtiYXNlNjQuZGVjb2RlKG4sbywwKSxuPW99cmV0dXJuIHRoaXMudWludDMyKHIpLl9wdXNoKHdyaXRlQnl0ZXMscixuKX0sV3JpdGVyLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oYSl7dmFyIGU9dXRmOC5sZW5ndGgoYSk7cmV0dXJuIGU/dGhpcy51aW50MzIoZSkuX3B1c2godXRmOC53cml0ZSxlLGEpOnRoaXMuX3B1c2god3JpdGVCeXRlLDEsMCl9LFdyaXRlci5wcm90b3R5cGUuZm9yaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz1uZXcgU3RhdGUodGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgT3Aobm9vcCwwLDApLHRoaXMubGVuPTAsdGhpc30sV3JpdGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyBPcChub29wLDAsMCksdGhpcy5sZW49MCksdGhpc30sV3JpdGVyLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgbj10aGlzLmhlYWQsZT10aGlzLnRhaWwsdD10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMih0KSx0JiYodGhpcy50YWlsLm5leHQ9bi5uZXh0LHRoaXMudGFpbD1lLHRoaXMubGVuKz10KSx0aGlzfSxXcml0ZXIucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbigpe2Zvcih2YXIgbj10aGlzLmhlYWQubmV4dCxyPXRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLHQ9MDtuOyluLmZuKG4udmFsLHIsdCksdCs9bi5sZW4sbj1uLm5leHQ7cmV0dXJuIHJ9LFdyaXRlci5fY29uZmlndXJlPWZ1bmN0aW9uKHQpe0J1ZmZlcldyaXRlcj10fTt2YXIgd3JpdGVyX2J1ZmZlcj1CdWZmZXJXcml0ZXIkMTsoQnVmZmVyV3JpdGVyJDEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUod3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPUJ1ZmZlcldyaXRlciQxO3ZhciBCdWZmZXIkMT1taW5pbWFsLkJ1ZmZlcjtCdWZmZXJXcml0ZXIkMS5hbGxvYz1mdW5jdGlvbih0KXtyZXR1cm4oQnVmZmVyV3JpdGVyJDEuYWxsb2M9bWluaW1hbC5fQnVmZmVyX2FsbG9jVW5zYWZlKSh0KX07dmFyIHdyaXRlQnl0ZXNCdWZmZXI9QnVmZmVyJDEmJkJ1ZmZlciQxLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJlwic2V0XCI9PT1CdWZmZXIkMS5wcm90b3R5cGUuc2V0Lm5hbWU/ZnVuY3Rpb24obixlLHQpe2Uuc2V0KG4sdCl9OmZ1bmN0aW9uKG4sZSx0KXtpZihuLmNvcHkpbi5jb3B5KGUsdCwwLG4ubGVuZ3RoKTtlbHNlIGZvcih2YXIgbz0wO288bi5sZW5ndGg7KWVbdCsrXT1uW28rK119O0J1ZmZlcldyaXRlciQxLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbihhKXttaW5pbWFsLmlzU3RyaW5nKGEpJiYoYT1taW5pbWFsLl9CdWZmZXJfZnJvbShhLFwiYmFzZTY0XCIpKTt2YXIgbj1hLmxlbmd0aD4+PjA7cmV0dXJuIHRoaXMudWludDMyKG4pLG4mJnRoaXMuX3B1c2god3JpdGVCeXRlc0J1ZmZlcixuLGEpLHRoaXN9LEJ1ZmZlcldyaXRlciQxLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oYSl7dmFyIGU9QnVmZmVyJDEuYnl0ZUxlbmd0aChhKTtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlcixlLGEpLHRoaXN9O3ZhciByZWFkZXI9UmVhZGVyLExvbmdCaXRzJDI9bWluaW1hbC5Mb25nQml0cyx1dGY4JDE9bWluaW1hbC51dGY4LGNyZWF0ZV9hcnJheT1cInVuZGVmaW5lZFwiPT10eXBlb2YgVWludDhBcnJheT9mdW5jdGlvbih0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiBuZXcgUmVhZGVyKHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9OmZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxBcnJheS5pc0FycmF5KHQpKXJldHVybiBuZXcgUmVhZGVyKHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9LEJ1ZmZlclJlYWRlcjtSZWFkZXIuY3JlYXRlPW1pbmltYWwuQnVmZmVyP2Z1bmN0aW9uKHQpe3JldHVybihSZWFkZXIuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBtaW5pbWFsLkJ1ZmZlci5pc0J1ZmZlcih0KT9uZXcgQnVmZmVyUmVhZGVyKHQpOmNyZWF0ZV9hcnJheSh0KX0pKHQpfTpjcmVhdGVfYXJyYXksUmVhZGVyLnByb3RvdHlwZS5fc2xpY2U9bWluaW1hbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXl8fG1pbmltYWwuQXJyYXkucHJvdG90eXBlLnNsaWNlLFJlYWRlci5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKCl7dmFyIHQ9NDI5NDk2NzI5NTtyZXR1cm4gZnVuY3Rpb24oKXtpZih0PSgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKT4+PjAsMTI4PnRoaXMuYnVmW3RoaXMucG9zKytdKXJldHVybiB0O2lmKHQ9KHR8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KT4+PjAsMTI4PnRoaXMuYnVmW3RoaXMucG9zKytdKXJldHVybiB0O2lmKHQ9KHR8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwxNCk+Pj4wLDEyOD50aGlzLmJ1Zlt0aGlzLnBvcysrXSlyZXR1cm4gdDtpZih0PSh0fCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjEpPj4+MCwxMjg+dGhpcy5idWZbdGhpcy5wb3MrK10pcmV0dXJuIHQ7aWYodD0odHwoMTUmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjgpPj4+MCwxMjg+dGhpcy5idWZbdGhpcy5wb3MrK10pcmV0dXJuIHQ7aWYoKHRoaXMucG9zKz01KT50aGlzLmxlbil0aHJvdyB0aGlzLnBvcz10aGlzLmxlbixpbmRleE91dE9mUmFuZ2UodGhpcywxMCk7cmV0dXJuIHR9fSgpLFJlYWRlci5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx0aGlzLnVpbnQzMigpfSxSZWFkZXIucHJvdG90eXBlLnNpbnQzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCk7cmV0dXJuIDB8dD4+PjFeLSgxJnQpfSxSZWFkZXIucHJvdG90eXBlLmJvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMudWludDMyKCl9LFJlYWRlci5wcm90b3R5cGUuZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsNCk7cmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LFJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzI9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLDQpO3JldHVybiAwfHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LFJlYWRlci5wcm90b3R5cGUuZmxvYXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLDQpO3ZhciB0PW1pbmltYWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCx0fSxSZWFkZXIucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzg+dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsNCk7dmFyIHQ9bWluaW1hbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCx0fSxSZWFkZXIucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy51aW50MzIoKSxlPXRoaXMucG9zLHQ9dGhpcy5wb3MrbjtpZih0PnRoaXMubGVuKXRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLG4pO3JldHVybiB0aGlzLnBvcys9bixBcnJheS5pc0FycmF5KHRoaXMuYnVmKT90aGlzLmJ1Zi5zbGljZShlLHQpOmU9PT10P25ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTp0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLGUsdCl9LFJlYWRlci5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ieXRlcygpO3JldHVybiB1dGY4JDEucmVhZCh0LDAsdC5sZW5ndGgpfSxSZWFkZXIucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2lmKHRoaXMucG9zK3Q+dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsdCk7dGhpcy5wb3MrPXR9ZWxzZSBkbyBpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO3doaWxlKDEyOCZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk7cmV0dXJuIHRoaXN9LFJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGU9ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UgMDp0aGlzLnNraXAoKTticmVhaztjYXNlIDE6dGhpcy5za2lwKDgpO2JyZWFrO2Nhc2UgMjp0aGlzLnNraXAodGhpcy51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOmZvcig7Oyl7aWYoND09KHQ9NyZ0aGlzLnVpbnQzMigpKSlicmVhazt0aGlzLnNraXBUeXBlKHQpfWJyZWFrO2Nhc2UgNTp0aGlzLnNraXAoNCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiK3QrXCIgYXQgb2Zmc2V0IFwiK3RoaXMucG9zKTt9cmV0dXJuIHRoaXN9LFJlYWRlci5fY29uZmlndXJlPWZ1bmN0aW9uKGEpe0J1ZmZlclJlYWRlcj1hO3ZhciBlPW1pbmltYWwuTG9uZz9cInRvTG9uZ1wiOlwidG9OdW1iZXJcIjttaW5pbWFsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUse2ludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZV0oITEpfSx1aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtlXSghMCl9LHNpbnQ2NDpmdW5jdGlvbigpe3JldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZV0oITEpfSxmaXhlZDY0OmZ1bmN0aW9uKCl7cmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZV0oITApfSxzZml4ZWQ2NDpmdW5jdGlvbigpe3JldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2VdKCExKX19KX07dmFyIHJlYWRlcl9idWZmZXI9QnVmZmVyUmVhZGVyJDE7KEJ1ZmZlclJlYWRlciQxLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1CdWZmZXJSZWFkZXIkMSxtaW5pbWFsLkJ1ZmZlciYmKEJ1ZmZlclJlYWRlciQxLnByb3RvdHlwZS5fc2xpY2U9bWluaW1hbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlKSxCdWZmZXJSZWFkZXIkMS5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKTtyZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLHRoaXMucG9zPV9NYXRobWluKHRoaXMucG9zK3QsdGhpcy5sZW4pKX07dmFyIHNlcnZpY2U9U2VydmljZTsoU2VydmljZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShtaW5pbWFsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1TZXJ2aWNlLFNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGw9ZnVuY3Rpb24gaShwLGUsdCxhLG4pe2lmKCFhKXRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7dmFyIHI9dGhpcztpZighbilyZXR1cm4gbWluaW1hbC5hc1Byb21pc2UoaSxyLHAsZSx0LGEpO2lmKHIucnBjSW1wbCl0cnl7cmV0dXJuIHIucnBjSW1wbChwLGVbci5yZXF1ZXN0RGVsaW1pdGVkP1wiZW5jb2RlRGVsaW1pdGVkXCI6XCJlbmNvZGVcIl0oYSkuZmluaXNoKCksZnVuY3Rpb24obyxlKXtpZihvKXJldHVybiByLmVtaXQoXCJlcnJvclwiLG8scCksbihvKTtpZihudWxsIT09ZSl7aWYoIShlIGluc3RhbmNlb2YgdCkpdHJ5e2U9dFtyLnJlc3BvbnNlRGVsaW1pdGVkP1wiZGVjb2RlRGVsaW1pdGVkXCI6XCJkZWNvZGVcIl0oZSl9Y2F0Y2godCl7cmV0dXJuIHIuZW1pdChcImVycm9yXCIsdCxwKSxuKHQpfXJldHVybiByLmVtaXQoXCJkYXRhXCIsZSxwKSxuKG51bGwsZSl9ci5lbmQoITApfSl9Y2F0Y2godCl7cmV0dXJuIHIuZW1pdChcImVycm9yXCIsdCxwKSx2b2lkIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtuKHQpfSwwKX1lbHNlIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtuKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSl9LDApfSxTZXJ2aWNlLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucnBjSW1wbCYmKHR8fHRoaXMucnBjSW1wbChudWxsLG51bGwsbnVsbCksdGhpcy5ycGNJbXBsPW51bGwsdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpKSx0aGlzfTt2YXIgcnBjXzE9Y3JlYXRlQ29tbW9uanNNb2R1bGUkMShmdW5jdGlvbihhLGUpe2UuU2VydmljZT1zZXJ2aWNlfSkscm9vdHM9e30saW5kZXhNaW5pbWFsPWNyZWF0ZUNvbW1vbmpzTW9kdWxlJDEoZnVuY3Rpb24obixlKXtmdW5jdGlvbiB0KCl7ci5SZWFkZXIuX2NvbmZpZ3VyZShyLkJ1ZmZlclJlYWRlciksci51dGlsLl9jb25maWd1cmUoKX12YXIgcj1lO3IuYnVpbGQ9XCJtaW5pbWFsXCIsci5Xcml0ZXI9d3JpdGVyLHIuQnVmZmVyV3JpdGVyPXdyaXRlcl9idWZmZXIsci5SZWFkZXI9cmVhZGVyLHIuQnVmZmVyUmVhZGVyPXJlYWRlcl9idWZmZXIsci51dGlsPW1pbmltYWwsci5ycGM9cnBjXzEsci5yb290cz1yb290cyxyLmNvbmZpZ3VyZT10LHIuV3JpdGVyLl9jb25maWd1cmUoci5CdWZmZXJXcml0ZXIpLHQoKX0pLG1pbmltYWwkMT1pbmRleE1pbmltYWwsbWluaW1hbF8xPW1pbmltYWwkMS5yb290cyxtaW5pbWFsXzI9bWluaW1hbCQxLlJlYWRlcixtaW5pbWFsXzM9bWluaW1hbCQxLnV0aWwsJFJlYWRlcj1taW5pbWFsJDEuUmVhZGVyLCR1dGlsPW1pbmltYWwkMS51dGlsLCRyb290PW1pbmltYWwkMS5yb290cy5kZWZhdWx0fHwobWluaW1hbCQxLnJvb3RzLmRlZmF1bHQ9e30pOyRyb290LnRlbnNvcmZsb3c9ZnVuY3Rpb24oKXt2YXIgbj17fSxhLHI7cmV0dXJuIG4uQW55PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZihuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLnR5cGVVcmw9XCJcIix0LnByb3RvdHlwZS52YWx1ZT0kdXRpbC5uZXdCdWZmZXIoW10pLHQuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuQW55LHI7by5wb3M8dDspc3dpdGNoKHI9by51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmEudHlwZVVybD1vLnN0cmluZygpO2JyZWFrO2Nhc2UgMjphLnZhbHVlPW8uYnl0ZXMoKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksbi5EYXRhVHlwZT0oYT17fSwocj1PYmplY3QuY3JlYXRlKGEpKVthWzBdPVwiRFRfSU5WQUxJRFwiXT0wLHJbYVsxXT1cIkRUX0ZMT0FUXCJdPTEsclthWzJdPVwiRFRfRE9VQkxFXCJdPTIsclthWzNdPVwiRFRfSU5UMzJcIl09MyxyW2FbNF09XCJEVF9VSU5UOFwiXT00LHJbYVs1XT1cIkRUX0lOVDE2XCJdPTUsclthWzZdPVwiRFRfSU5UOFwiXT02LHJbYVs3XT1cIkRUX1NUUklOR1wiXT03LHJbYVs4XT1cIkRUX0NPTVBMRVg2NFwiXT04LHJbYVs5XT1cIkRUX0lOVDY0XCJdPTksclthWzEwXT1cIkRUX0JPT0xcIl09MTAsclthWzExXT1cIkRUX1FJTlQ4XCJdPTExLHJbYVsxMl09XCJEVF9RVUlOVDhcIl09MTIsclthWzEzXT1cIkRUX1FJTlQzMlwiXT0xMyxyW2FbMTRdPVwiRFRfQkZMT0FUMTZcIl09MTQsclthWzEwMV09XCJEVF9GTE9BVF9SRUZcIl09MTAxLHJbYVsxMDJdPVwiRFRfRE9VQkxFX1JFRlwiXT0xMDIsclthWzEwM109XCJEVF9JTlQzMl9SRUZcIl09MTAzLHJbYVsxMDRdPVwiRFRfVUlOVDhfUkVGXCJdPTEwNCxyW2FbMTA1XT1cIkRUX0lOVDE2X1JFRlwiXT0xMDUsclthWzEwNl09XCJEVF9JTlQ4X1JFRlwiXT0xMDYsclthWzEwN109XCJEVF9TVFJJTkdfUkVGXCJdPTEwNyxyW2FbMTA4XT1cIkRUX0NPTVBMRVg2NF9SRUZcIl09MTA4LHJbYVsxMDldPVwiRFRfSU5UNjRfUkVGXCJdPTEwOSxyW2FbMTEwXT1cIkRUX0JPT0xfUkVGXCJdPTExMCxyW2FbMTExXT1cIkRUX1FJTlQ4X1JFRlwiXT0xMTEsclthWzExMl09XCJEVF9RVUlOVDhfUkVGXCJdPTExMixyW2FbMTEzXT1cIkRUX1FJTlQzMl9SRUZcIl09MTEzLHJbYVsxMTRdPVwiRFRfQkZMT0FUMTZfUkVGXCJdPTExNCxyKSxuLlRlbnNvclNoYXBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLmRpbT1bXSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLmRpbT0kdXRpbC5lbXB0eUFycmF5LHQucHJvdG90eXBlLnVua25vd25SYW5rPSExLHQuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDI6YS5kaW0mJmEuZGltLmxlbmd0aHx8KGEuZGltPVtdKSxhLmRpbS5wdXNoKCRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUuRGltLmRlY29kZShvLG8udWludDMyKCkpKTticmVhaztjYXNlIDM6YS51bmtub3duUmFuaz1vLmJvb2woKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHQuRGltPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZihuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLnNpemU9JHV0aWwuTG9uZz8kdXRpbC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5kZWNvZGU9ZnVuY3Rpb24obyxzKXtvIGluc3RhbmNlb2YgJFJlYWRlcnx8KG89JFJlYWRlci5jcmVhdGUobykpO2Zvcih2YXIgdD12b2lkIDA9PT1zP28ubGVuOm8ucG9zK3MsYT1uZXcgJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5EaW0scjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5zaXplPW8uaW50NjQoKTticmVhaztjYXNlIDI6YS5uYW1lPW8uc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSx0fSgpLHR9KCksbi5UZW5zb3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4pe2lmKHRoaXMuZmxvYXRWYWw9W10sdGhpcy5kb3VibGVWYWw9W10sdGhpcy5pbnRWYWw9W10sdGhpcy5zdHJpbmdWYWw9W10sdGhpcy5zY29tcGxleFZhbD1bXSx0aGlzLmludDY0VmFsPVtdLHRoaXMuYm9vbFZhbD1bXSx0aGlzLnVpbnQzMlZhbD1bXSx0aGlzLnVpbnQ2NFZhbD1bXSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLmR0eXBlPTAsdC5wcm90b3R5cGUudGVuc29yU2hhcGU9bnVsbCx0LnByb3RvdHlwZS52ZXJzaW9uTnVtYmVyPTAsdC5wcm90b3R5cGUudGVuc29yQ29udGVudD0kdXRpbC5uZXdCdWZmZXIoW10pLHQucHJvdG90eXBlLmZsb2F0VmFsPSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZG91YmxlVmFsPSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuaW50VmFsPSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3RyaW5nVmFsPSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc2NvbXBsZXhWYWw9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pbnQ2NFZhbD0kdXRpbC5lbXB0eUFycmF5LHQucHJvdG90eXBlLmJvb2xWYWw9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS51aW50MzJWYWw9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS51aW50NjRWYWw9JHV0aWwuZW1wdHlBcnJheSx0LmRlY29kZT1mdW5jdGlvbihzLGkpe3MgaW5zdGFuY2VvZiAkUmVhZGVyfHwocz0kUmVhZGVyLmNyZWF0ZShzKSk7Zm9yKHZhciB0PXZvaWQgMD09PWk/cy5sZW46cy5wb3MraSxhPW5ldyAkcm9vdC50ZW5zb3JmbG93LlRlbnNvcixyO3MucG9zPHQ7KXN3aXRjaChyPXMudWludDMyKCkscj4+PjMpe2Nhc2UgMTphLmR0eXBlPXMuaW50MzIoKTticmVhaztjYXNlIDI6YS50ZW5zb3JTaGFwZT0kcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlLmRlY29kZShzLHMudWludDMyKCkpO2JyZWFrO2Nhc2UgMzphLnZlcnNpb25OdW1iZXI9cy5pbnQzMigpO2JyZWFrO2Nhc2UgNDphLnRlbnNvckNvbnRlbnQ9cy5ieXRlcygpO2JyZWFrO2Nhc2UgNTppZihhLmZsb2F0VmFsJiZhLmZsb2F0VmFsLmxlbmd0aHx8KGEuZmxvYXRWYWw9W10pLDI9PSg3JnIpKWZvcih2YXIgcD1zLnVpbnQzMigpK3MucG9zO3MucG9zPHA7KWEuZmxvYXRWYWwucHVzaChzLmZsb2F0KCkpO2Vsc2UgYS5mbG9hdFZhbC5wdXNoKHMuZmxvYXQoKSk7YnJlYWs7Y2FzZSA2OmlmKGEuZG91YmxlVmFsJiZhLmRvdWJsZVZhbC5sZW5ndGh8fChhLmRvdWJsZVZhbD1bXSksMj09KDcmcikpZm9yKHA9cy51aW50MzIoKStzLnBvcztzLnBvczxwOylhLmRvdWJsZVZhbC5wdXNoKHMuZG91YmxlKCkpO2Vsc2UgYS5kb3VibGVWYWwucHVzaChzLmRvdWJsZSgpKTticmVhaztjYXNlIDc6aWYoYS5pbnRWYWwmJmEuaW50VmFsLmxlbmd0aHx8KGEuaW50VmFsPVtdKSwyPT0oNyZyKSlmb3IocD1zLnVpbnQzMigpK3MucG9zO3MucG9zPHA7KWEuaW50VmFsLnB1c2gocy5pbnQzMigpKTtlbHNlIGEuaW50VmFsLnB1c2gocy5pbnQzMigpKTticmVhaztjYXNlIDg6YS5zdHJpbmdWYWwmJmEuc3RyaW5nVmFsLmxlbmd0aHx8KGEuc3RyaW5nVmFsPVtdKSxhLnN0cmluZ1ZhbC5wdXNoKHMuYnl0ZXMoKSk7YnJlYWs7Y2FzZSA5OmlmKGEuc2NvbXBsZXhWYWwmJmEuc2NvbXBsZXhWYWwubGVuZ3RofHwoYS5zY29tcGxleFZhbD1bXSksMj09KDcmcikpZm9yKHA9cy51aW50MzIoKStzLnBvcztzLnBvczxwOylhLnNjb21wbGV4VmFsLnB1c2gocy5mbG9hdCgpKTtlbHNlIGEuc2NvbXBsZXhWYWwucHVzaChzLmZsb2F0KCkpO2JyZWFrO2Nhc2UgMTA6aWYoYS5pbnQ2NFZhbCYmYS5pbnQ2NFZhbC5sZW5ndGh8fChhLmludDY0VmFsPVtdKSwyPT0oNyZyKSlmb3IocD1zLnVpbnQzMigpK3MucG9zO3MucG9zPHA7KWEuaW50NjRWYWwucHVzaChzLmludDY0KCkpO2Vsc2UgYS5pbnQ2NFZhbC5wdXNoKHMuaW50NjQoKSk7YnJlYWs7Y2FzZSAxMTppZihhLmJvb2xWYWwmJmEuYm9vbFZhbC5sZW5ndGh8fChhLmJvb2xWYWw9W10pLDI9PSg3JnIpKWZvcihwPXMudWludDMyKCkrcy5wb3M7cy5wb3M8cDspYS5ib29sVmFsLnB1c2gocy5ib29sKCkpO2Vsc2UgYS5ib29sVmFsLnB1c2gocy5ib29sKCkpO2JyZWFrO2Nhc2UgMTY6aWYoYS51aW50MzJWYWwmJmEudWludDMyVmFsLmxlbmd0aHx8KGEudWludDMyVmFsPVtdKSwyPT0oNyZyKSlmb3IocD1zLnVpbnQzMigpK3MucG9zO3MucG9zPHA7KWEudWludDMyVmFsLnB1c2gocy51aW50MzIoKSk7ZWxzZSBhLnVpbnQzMlZhbC5wdXNoKHMudWludDMyKCkpO2JyZWFrO2Nhc2UgMTc6aWYoYS51aW50NjRWYWwmJmEudWludDY0VmFsLmxlbmd0aHx8KGEudWludDY0VmFsPVtdKSwyPT0oNyZyKSlmb3IocD1zLnVpbnQzMigpK3MucG9zO3MucG9zPHA7KWEudWludDY0VmFsLnB1c2gocy51aW50NjQoKSk7ZWxzZSBhLnVpbnQ2NFZhbC5wdXNoKHMudWludDY0KCkpO2JyZWFrO2RlZmF1bHQ6cy5za2lwVHlwZSg3JnIpO31yZXR1cm4gYX0sdH0oKSxuLkF0dHJWYWx1ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEobil7aWYobilmb3IodmFyIGU9T2JqZWN0LmtleXMobiksdD0wO3Q8ZS5sZW5ndGg7Kyt0KW51bGwhPW5bZVt0XV0mJih0aGlzW2VbdF1dPW5bZVt0XV0pfXZhciBlO3JldHVybiBhLnByb3RvdHlwZS5saXN0PW51bGwsYS5wcm90b3R5cGUucz0kdXRpbC5uZXdCdWZmZXIoW10pLGEucHJvdG90eXBlLmk9JHV0aWwuTG9uZz8kdXRpbC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxhLnByb3RvdHlwZS5mPTAsYS5wcm90b3R5cGUuYj0hMSxhLnByb3RvdHlwZS50eXBlPTAsYS5wcm90b3R5cGUuc2hhcGU9bnVsbCxhLnByb3RvdHlwZS50ZW5zb3I9bnVsbCxhLnByb3RvdHlwZS5wbGFjZWhvbGRlcj1cIlwiLGEucHJvdG90eXBlLmZ1bmM9bnVsbCxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJ2YWx1ZVwiLHtnZXQ6JHV0aWwub25lT2ZHZXR0ZXIoZT1bXCJsaXN0XCIsXCJzXCIsXCJpXCIsXCJmXCIsXCJiXCIsXCJ0eXBlXCIsXCJzaGFwZVwiLFwidGVuc29yXCIsXCJwbGFjZWhvbGRlclwiLFwiZnVuY1wiXSksc2V0OiR1dGlsLm9uZU9mU2V0dGVyKGUpfSksYS5kZWNvZGU9ZnVuY3Rpb24obyxzKXtvIGluc3RhbmNlb2YgJFJlYWRlcnx8KG89JFJlYWRlci5jcmVhdGUobykpO2Zvcih2YXIgdD12b2lkIDA9PT1zP28ubGVuOm8ucG9zK3MsYT1uZXcgJHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5saXN0PSRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLkxpc3RWYWx1ZS5kZWNvZGUobyxvLnVpbnQzMigpKTticmVhaztjYXNlIDI6YS5zPW8uYnl0ZXMoKTticmVhaztjYXNlIDM6YS5pPW8uaW50NjQoKTticmVhaztjYXNlIDQ6YS5mPW8uZmxvYXQoKTticmVhaztjYXNlIDU6YS5iPW8uYm9vbCgpO2JyZWFrO2Nhc2UgNjphLnR5cGU9by5pbnQzMigpO2JyZWFrO2Nhc2UgNzphLnNoYXBlPSRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUuZGVjb2RlKG8sby51aW50MzIoKSk7YnJlYWs7Y2FzZSA4OmEudGVuc29yPSRyb290LnRlbnNvcmZsb3cuVGVuc29yLmRlY29kZShvLG8udWludDMyKCkpO2JyZWFrO2Nhc2UgOTphLnBsYWNlaG9sZGVyPW8uc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMDphLmZ1bmM9JHJvb3QudGVuc29yZmxvdy5OYW1lQXR0ckxpc3QuZGVjb2RlKG8sby51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSxhLkxpc3RWYWx1ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYodGhpcy5zPVtdLHRoaXMuaT1bXSx0aGlzLmY9W10sdGhpcy5iPVtdLHRoaXMudHlwZT1bXSx0aGlzLnNoYXBlPVtdLHRoaXMudGVuc29yPVtdLHRoaXMuZnVuYz1bXSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLnM9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pPSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZj0kdXRpbC5lbXB0eUFycmF5LHQucHJvdG90eXBlLmI9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS50eXBlPSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc2hhcGU9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS50ZW5zb3I9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5mdW5jPSR1dGlsLmVtcHR5QXJyYXksdC5kZWNvZGU9ZnVuY3Rpb24ocyxpKXtzIGluc3RhbmNlb2YgJFJlYWRlcnx8KHM9JFJlYWRlci5jcmVhdGUocykpO2Zvcih2YXIgdD12b2lkIDA9PT1pP3MubGVuOnMucG9zK2ksYT1uZXcgJHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuTGlzdFZhbHVlLHI7cy5wb3M8dDspc3dpdGNoKHI9cy51aW50MzIoKSxyPj4+Myl7Y2FzZSAyOmEucyYmYS5zLmxlbmd0aHx8KGEucz1bXSksYS5zLnB1c2gocy5ieXRlcygpKTticmVhaztjYXNlIDM6aWYoYS5pJiZhLmkubGVuZ3RofHwoYS5pPVtdKSwyPT0oNyZyKSlmb3IodmFyIHA9cy51aW50MzIoKStzLnBvcztzLnBvczxwOylhLmkucHVzaChzLmludDY0KCkpO2Vsc2UgYS5pLnB1c2gocy5pbnQ2NCgpKTticmVhaztjYXNlIDQ6aWYoYS5mJiZhLmYubGVuZ3RofHwoYS5mPVtdKSwyPT0oNyZyKSlmb3IocD1zLnVpbnQzMigpK3MucG9zO3MucG9zPHA7KWEuZi5wdXNoKHMuZmxvYXQoKSk7ZWxzZSBhLmYucHVzaChzLmZsb2F0KCkpO2JyZWFrO2Nhc2UgNTppZihhLmImJmEuYi5sZW5ndGh8fChhLmI9W10pLDI9PSg3JnIpKWZvcihwPXMudWludDMyKCkrcy5wb3M7cy5wb3M8cDspYS5iLnB1c2gocy5ib29sKCkpO2Vsc2UgYS5iLnB1c2gocy5ib29sKCkpO2JyZWFrO2Nhc2UgNjppZihhLnR5cGUmJmEudHlwZS5sZW5ndGh8fChhLnR5cGU9W10pLDI9PSg3JnIpKWZvcihwPXMudWludDMyKCkrcy5wb3M7cy5wb3M8cDspYS50eXBlLnB1c2gocy5pbnQzMigpKTtlbHNlIGEudHlwZS5wdXNoKHMuaW50MzIoKSk7YnJlYWs7Y2FzZSA3OmEuc2hhcGUmJmEuc2hhcGUubGVuZ3RofHwoYS5zaGFwZT1bXSksYS5zaGFwZS5wdXNoKCRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUuZGVjb2RlKHMscy51aW50MzIoKSkpO2JyZWFrO2Nhc2UgODphLnRlbnNvciYmYS50ZW5zb3IubGVuZ3RofHwoYS50ZW5zb3I9W10pLGEudGVuc29yLnB1c2goJHJvb3QudGVuc29yZmxvdy5UZW5zb3IuZGVjb2RlKHMscy51aW50MzIoKSkpO2JyZWFrO2Nhc2UgOTphLmZ1bmMmJmEuZnVuYy5sZW5ndGh8fChhLmZ1bmM9W10pLGEuZnVuYy5wdXNoKCRyb290LnRlbnNvcmZsb3cuTmFtZUF0dHJMaXN0LmRlY29kZShzLHMudWludDMyKCkpKTticmVhaztkZWZhdWx0OnMuc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksYX0oKSxuLk5hbWVBdHRyTGlzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYodGhpcy5hdHRyPXt9LG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmF0dHI9JHV0aWwuZW1wdHlPYmplY3QsdC5kZWNvZGU9ZnVuY3Rpb24ocyxpKXtzIGluc3RhbmNlb2YgJFJlYWRlcnx8KHM9JFJlYWRlci5jcmVhdGUocykpO2Zvcih2YXIgdD12b2lkIDA9PT1pP3MubGVuOnMucG9zK2kscj1uZXcgJHJvb3QudGVuc29yZmxvdy5OYW1lQXR0ckxpc3QsbixwO3MucG9zPHQ7KXN3aXRjaChwPXMudWludDMyKCkscD4+PjMpe2Nhc2UgMTpyLm5hbWU9cy5zdHJpbmcoKTticmVhaztjYXNlIDI6cy5za2lwKCkucG9zKyssci5hdHRyPT09JHV0aWwuZW1wdHlPYmplY3QmJihyLmF0dHI9e30pLG49cy5zdHJpbmcoKSxzLnBvcysrLHIuYXR0cltuXT0kcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUocyxzLnVpbnQzMigpKTticmVhaztkZWZhdWx0OnMuc2tpcFR5cGUoNyZwKTt9cmV0dXJuIHJ9LHR9KCksbi5Ob2RlRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLmlucHV0PVtdLHRoaXMuYXR0cj17fSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5vcD1cIlwiLHQucHJvdG90eXBlLmlucHV0PSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGV2aWNlPVwiXCIsdC5wcm90b3R5cGUuYXR0cj0kdXRpbC5lbXB0eU9iamVjdCx0LmRlY29kZT1mdW5jdGlvbihzLGkpe3MgaW5zdGFuY2VvZiAkUmVhZGVyfHwocz0kUmVhZGVyLmNyZWF0ZShzKSk7Zm9yKHZhciB0PXZvaWQgMD09PWk/cy5sZW46cy5wb3MraSxyPW5ldyAkcm9vdC50ZW5zb3JmbG93Lk5vZGVEZWYsbixwO3MucG9zPHQ7KXN3aXRjaChwPXMudWludDMyKCkscD4+PjMpe2Nhc2UgMTpyLm5hbWU9cy5zdHJpbmcoKTticmVhaztjYXNlIDI6ci5vcD1zLnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLmlucHV0JiZyLmlucHV0Lmxlbmd0aHx8KHIuaW5wdXQ9W10pLHIuaW5wdXQucHVzaChzLnN0cmluZygpKTticmVhaztjYXNlIDQ6ci5kZXZpY2U9cy5zdHJpbmcoKTticmVhaztjYXNlIDU6cy5za2lwKCkucG9zKyssci5hdHRyPT09JHV0aWwuZW1wdHlPYmplY3QmJihyLmF0dHI9e30pLG49cy5zdHJpbmcoKSxzLnBvcysrLHIuYXR0cltuXT0kcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUocyxzLnVpbnQzMigpKTticmVhaztkZWZhdWx0OnMuc2tpcFR5cGUoNyZwKTt9cmV0dXJuIHJ9LHR9KCksbi5WZXJzaW9uRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLmJhZENvbnN1bWVycz1bXSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLnByb2R1Y2VyPTAsdC5wcm90b3R5cGUubWluQ29uc3VtZXI9MCx0LnByb3RvdHlwZS5iYWRDb25zdW1lcnM9JHV0aWwuZW1wdHlBcnJheSx0LmRlY29kZT1mdW5jdGlvbihzLGkpe3MgaW5zdGFuY2VvZiAkUmVhZGVyfHwocz0kUmVhZGVyLmNyZWF0ZShzKSk7Zm9yKHZhciB0PXZvaWQgMD09PWk/cy5sZW46cy5wb3MraSxhPW5ldyAkcm9vdC50ZW5zb3JmbG93LlZlcnNpb25EZWYscjtzLnBvczx0Oylzd2l0Y2gocj1zLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5wcm9kdWNlcj1zLmludDMyKCk7YnJlYWs7Y2FzZSAyOmEubWluQ29uc3VtZXI9cy5pbnQzMigpO2JyZWFrO2Nhc2UgMzppZihhLmJhZENvbnN1bWVycyYmYS5iYWRDb25zdW1lcnMubGVuZ3RofHwoYS5iYWRDb25zdW1lcnM9W10pLDI9PSg3JnIpKWZvcih2YXIgcD1zLnVpbnQzMigpK3MucG9zO3MucG9zPHA7KWEuYmFkQ29uc3VtZXJzLnB1c2gocy5pbnQzMigpKTtlbHNlIGEuYmFkQ29uc3VtZXJzLnB1c2gocy5pbnQzMigpKTticmVhaztkZWZhdWx0OnMuc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksbi5HcmFwaERlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYodGhpcy5ub2RlPVtdLG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUubm9kZT0kdXRpbC5lbXB0eUFycmF5LHQucHJvdG90eXBlLnZlcnNpb25zPW51bGwsdC5wcm90b3R5cGUubGlicmFyeT1udWxsLHQuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuR3JhcGhEZWYscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5ub2RlJiZhLm5vZGUubGVuZ3RofHwoYS5ub2RlPVtdKSxhLm5vZGUucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk5vZGVEZWYuZGVjb2RlKG8sby51aW50MzIoKSkpO2JyZWFrO2Nhc2UgNDphLnZlcnNpb25zPSRyb290LnRlbnNvcmZsb3cuVmVyc2lvbkRlZi5kZWNvZGUobyxvLnVpbnQzMigpKTticmVhaztjYXNlIDI6YS5saWJyYXJ5PSRyb290LnRlbnNvcmZsb3cuRnVuY3Rpb25EZWZMaWJyYXJ5LmRlY29kZShvLG8udWludDMyKCkpO2JyZWFrO2RlZmF1bHQ6by5za2lwVHlwZSg3JnIpO31yZXR1cm4gYX0sdH0oKSxuLkNvbGxlY3Rpb25EZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKG4pe2lmKG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX12YXIgZTtyZXR1cm4gYS5wcm90b3R5cGUubm9kZUxpc3Q9bnVsbCxhLnByb3RvdHlwZS5ieXRlc0xpc3Q9bnVsbCxhLnByb3RvdHlwZS5pbnQ2NExpc3Q9bnVsbCxhLnByb3RvdHlwZS5mbG9hdExpc3Q9bnVsbCxhLnByb3RvdHlwZS5hbnlMaXN0PW51bGwsT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwia2luZFwiLHtnZXQ6JHV0aWwub25lT2ZHZXR0ZXIoZT1bXCJub2RlTGlzdFwiLFwiYnl0ZXNMaXN0XCIsXCJpbnQ2NExpc3RcIixcImZsb2F0TGlzdFwiLFwiYW55TGlzdFwiXSksc2V0OiR1dGlsLm9uZU9mU2V0dGVyKGUpfSksYS5kZWNvZGU9ZnVuY3Rpb24obyxzKXtvIGluc3RhbmNlb2YgJFJlYWRlcnx8KG89JFJlYWRlci5jcmVhdGUobykpO2Zvcih2YXIgdD12b2lkIDA9PT1zP28ubGVuOm8ucG9zK3MsYT1uZXcgJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLHI7by5wb3M8dDspc3dpdGNoKHI9by51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmEubm9kZUxpc3Q9JHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLk5vZGVMaXN0LmRlY29kZShvLG8udWludDMyKCkpO2JyZWFrO2Nhc2UgMjphLmJ5dGVzTGlzdD0kcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuQnl0ZXNMaXN0LmRlY29kZShvLG8udWludDMyKCkpO2JyZWFrO2Nhc2UgMzphLmludDY0TGlzdD0kcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuSW50NjRMaXN0LmRlY29kZShvLG8udWludDMyKCkpO2JyZWFrO2Nhc2UgNDphLmZsb2F0TGlzdD0kcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuRmxvYXRMaXN0LmRlY29kZShvLG8udWludDMyKCkpO2JyZWFrO2Nhc2UgNTphLmFueUxpc3Q9JHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLkFueUxpc3QuZGVjb2RlKG8sby51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSxhLk5vZGVMaXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLnZhbHVlPVtdLG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUudmFsdWU9JHV0aWwuZW1wdHlBcnJheSx0LmRlY29kZT1mdW5jdGlvbihvLHMpe28gaW5zdGFuY2VvZiAkUmVhZGVyfHwobz0kUmVhZGVyLmNyZWF0ZShvKSk7Zm9yKHZhciB0PXZvaWQgMD09PXM/by5sZW46by5wb3MrcyxhPW5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuTm9kZUxpc3QscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS52YWx1ZSYmYS52YWx1ZS5sZW5ndGh8fChhLnZhbHVlPVtdKSxhLnZhbHVlLnB1c2goby5zdHJpbmcoKSk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSx0fSgpLGEuQnl0ZXNMaXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLnZhbHVlPVtdLG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUudmFsdWU9JHV0aWwuZW1wdHlBcnJheSx0LmRlY29kZT1mdW5jdGlvbihvLHMpe28gaW5zdGFuY2VvZiAkUmVhZGVyfHwobz0kUmVhZGVyLmNyZWF0ZShvKSk7Zm9yKHZhciB0PXZvaWQgMD09PXM/by5sZW46by5wb3MrcyxhPW5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuQnl0ZXNMaXN0LHI7by5wb3M8dDspc3dpdGNoKHI9by51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmEudmFsdWUmJmEudmFsdWUubGVuZ3RofHwoYS52YWx1ZT1bXSksYS52YWx1ZS5wdXNoKG8uYnl0ZXMoKSk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSx0fSgpLGEuSW50NjRMaXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLnZhbHVlPVtdLG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUudmFsdWU9JHV0aWwuZW1wdHlBcnJheSx0LmRlY29kZT1mdW5jdGlvbihzLGkpe3MgaW5zdGFuY2VvZiAkUmVhZGVyfHwocz0kUmVhZGVyLmNyZWF0ZShzKSk7Zm9yKHZhciB0PXZvaWQgMD09PWk/cy5sZW46cy5wb3MraSxhPW5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuSW50NjRMaXN0LHI7cy5wb3M8dDspc3dpdGNoKHI9cy51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmlmKGEudmFsdWUmJmEudmFsdWUubGVuZ3RofHwoYS52YWx1ZT1bXSksMj09KDcmcikpZm9yKHZhciBwPXMudWludDMyKCkrcy5wb3M7cy5wb3M8cDspYS52YWx1ZS5wdXNoKHMuaW50NjQoKSk7ZWxzZSBhLnZhbHVlLnB1c2gocy5pbnQ2NCgpKTticmVhaztkZWZhdWx0OnMuc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksYS5GbG9hdExpc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4pe2lmKHRoaXMudmFsdWU9W10sbilmb3IodmFyIGU9T2JqZWN0LmtleXMobiksdD0wO3Q8ZS5sZW5ndGg7Kyt0KW51bGwhPW5bZVt0XV0mJih0aGlzW2VbdF1dPW5bZVt0XV0pfXJldHVybiB0LnByb3RvdHlwZS52YWx1ZT0kdXRpbC5lbXB0eUFycmF5LHQuZGVjb2RlPWZ1bmN0aW9uKHMsaSl7cyBpbnN0YW5jZW9mICRSZWFkZXJ8fChzPSRSZWFkZXIuY3JlYXRlKHMpKTtmb3IodmFyIHQ9dm9pZCAwPT09aT9zLmxlbjpzLnBvcytpLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5GbG9hdExpc3QscjtzLnBvczx0Oylzd2l0Y2gocj1zLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6aWYoYS52YWx1ZSYmYS52YWx1ZS5sZW5ndGh8fChhLnZhbHVlPVtdKSwyPT0oNyZyKSlmb3IodmFyIHA9cy51aW50MzIoKStzLnBvcztzLnBvczxwOylhLnZhbHVlLnB1c2gocy5mbG9hdCgpKTtlbHNlIGEudmFsdWUucHVzaChzLmZsb2F0KCkpO2JyZWFrO2RlZmF1bHQ6cy5za2lwVHlwZSg3JnIpO31yZXR1cm4gYX0sdH0oKSxhLkFueUxpc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4pe2lmKHRoaXMudmFsdWU9W10sbilmb3IodmFyIGU9T2JqZWN0LmtleXMobiksdD0wO3Q8ZS5sZW5ndGg7Kyt0KW51bGwhPW5bZVt0XV0mJih0aGlzW2VbdF1dPW5bZVt0XV0pfXJldHVybiB0LnByb3RvdHlwZS52YWx1ZT0kdXRpbC5lbXB0eUFycmF5LHQuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5BbnlMaXN0LHI7by5wb3M8dDspc3dpdGNoKHI9by51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmEudmFsdWUmJmEudmFsdWUubGVuZ3RofHwoYS52YWx1ZT1bXSksYS52YWx1ZS5wdXNoKCRyb290LnRlbnNvcmZsb3cuQW55LmRlY29kZShvLG8udWludDMyKCkpKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksYX0oKSxuLlNhdmVyRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuKXtpZihuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9dmFyIGUscjtyZXR1cm4gbi5wcm90b3R5cGUuZmlsZW5hbWVUZW5zb3JOYW1lPVwiXCIsbi5wcm90b3R5cGUuc2F2ZVRlbnNvck5hbWU9XCJcIixuLnByb3RvdHlwZS5yZXN0b3JlT3BOYW1lPVwiXCIsbi5wcm90b3R5cGUubWF4VG9LZWVwPTAsbi5wcm90b3R5cGUuc2hhcmRlZD0hMSxuLnByb3RvdHlwZS5rZWVwQ2hlY2twb2ludEV2ZXJ5TkhvdXJzPTAsbi5wcm90b3R5cGUudmVyc2lvbj0wLG4uZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuU2F2ZXJEZWYscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5maWxlbmFtZVRlbnNvck5hbWU9by5zdHJpbmcoKTticmVhaztjYXNlIDI6YS5zYXZlVGVuc29yTmFtZT1vLnN0cmluZygpO2JyZWFrO2Nhc2UgMzphLnJlc3RvcmVPcE5hbWU9by5zdHJpbmcoKTticmVhaztjYXNlIDQ6YS5tYXhUb0tlZXA9by5pbnQzMigpO2JyZWFrO2Nhc2UgNTphLnNoYXJkZWQ9by5ib29sKCk7YnJlYWs7Y2FzZSA2OmEua2VlcENoZWNrcG9pbnRFdmVyeU5Ib3Vycz1vLmZsb2F0KCk7YnJlYWs7Y2FzZSA3OmEudmVyc2lvbj1vLmludDMyKCk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSxuLkNoZWNrcG9pbnRGb3JtYXRWZXJzaW9uPShlPXt9LChyPU9iamVjdC5jcmVhdGUoZSkpW2VbMF09XCJMRUdBQ1lcIl09MCxyW2VbMV09XCJWMVwiXT0xLHJbZVsyXT1cIlYyXCJdPTIsciksbn0oKSxuLlRlbnNvckluZm89ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKG4pe2lmKG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX12YXIgZTtyZXR1cm4gYS5wcm90b3R5cGUubmFtZT1cIlwiLGEucHJvdG90eXBlLmNvb1NwYXJzZT1udWxsLGEucHJvdG90eXBlLmR0eXBlPTAsYS5wcm90b3R5cGUudGVuc29yU2hhcGU9bnVsbCxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJlbmNvZGluZ1wiLHtnZXQ6JHV0aWwub25lT2ZHZXR0ZXIoZT1bXCJuYW1lXCIsXCJjb29TcGFyc2VcIl0pLHNldDokdXRpbC5vbmVPZlNldHRlcihlKX0pLGEuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuVGVuc29ySW5mbyxyO28ucG9zPHQ7KXN3aXRjaChyPW8udWludDMyKCkscj4+PjMpe2Nhc2UgMTphLm5hbWU9by5zdHJpbmcoKTticmVhaztjYXNlIDQ6YS5jb29TcGFyc2U9JHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLkNvb1NwYXJzZS5kZWNvZGUobyxvLnVpbnQzMigpKTticmVhaztjYXNlIDI6YS5kdHlwZT1vLmludDMyKCk7YnJlYWs7Y2FzZSAzOmEudGVuc29yU2hhcGU9JHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5kZWNvZGUobyxvLnVpbnQzMigpKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LGEuQ29vU3BhcnNlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZihuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLnZhbHVlc1RlbnNvck5hbWU9XCJcIix0LnByb3RvdHlwZS5pbmRpY2VzVGVuc29yTmFtZT1cIlwiLHQucHJvdG90eXBlLmRlbnNlU2hhcGVUZW5zb3JOYW1lPVwiXCIsdC5kZWNvZGU9ZnVuY3Rpb24obyxzKXtvIGluc3RhbmNlb2YgJFJlYWRlcnx8KG89JFJlYWRlci5jcmVhdGUobykpO2Zvcih2YXIgdD12b2lkIDA9PT1zP28ubGVuOm8ucG9zK3MsYT1uZXcgJHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLkNvb1NwYXJzZSxyO28ucG9zPHQ7KXN3aXRjaChyPW8udWludDMyKCkscj4+PjMpe2Nhc2UgMTphLnZhbHVlc1RlbnNvck5hbWU9by5zdHJpbmcoKTticmVhaztjYXNlIDI6YS5pbmRpY2VzVGVuc29yTmFtZT1vLnN0cmluZygpO2JyZWFrO2Nhc2UgMzphLmRlbnNlU2hhcGVUZW5zb3JOYW1lPW8uc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSx0fSgpLGF9KCksbi5TaWduYXR1cmVEZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4pe2lmKHRoaXMuaW5wdXRzPXt9LHRoaXMub3V0cHV0cz17fSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLmlucHV0cz0kdXRpbC5lbXB0eU9iamVjdCx0LnByb3RvdHlwZS5vdXRwdXRzPSR1dGlsLmVtcHR5T2JqZWN0LHQucHJvdG90eXBlLm1ldGhvZE5hbWU9XCJcIix0LmRlY29kZT1mdW5jdGlvbihzLGkpe3MgaW5zdGFuY2VvZiAkUmVhZGVyfHwocz0kUmVhZGVyLmNyZWF0ZShzKSk7Zm9yKHZhciB0PXZvaWQgMD09PWk/cy5sZW46cy5wb3MraSxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LlNpZ25hdHVyZURlZixuLHA7cy5wb3M8dDspc3dpdGNoKHA9cy51aW50MzIoKSxwPj4+Myl7Y2FzZSAxOnMuc2tpcCgpLnBvcysrLHIuaW5wdXRzPT09JHV0aWwuZW1wdHlPYmplY3QmJihyLmlucHV0cz17fSksbj1zLnN0cmluZygpLHMucG9zKyssci5pbnB1dHNbbl09JHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLmRlY29kZShzLHMudWludDMyKCkpO2JyZWFrO2Nhc2UgMjpzLnNraXAoKS5wb3MrKyxyLm91dHB1dHM9PT0kdXRpbC5lbXB0eU9iamVjdCYmKHIub3V0cHV0cz17fSksbj1zLnN0cmluZygpLHMucG9zKyssci5vdXRwdXRzW25dPSRyb290LnRlbnNvcmZsb3cuVGVuc29ySW5mby5kZWNvZGUocyxzLnVpbnQzMigpKTticmVhaztjYXNlIDM6ci5tZXRob2ROYW1lPXMuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpzLnNraXBUeXBlKDcmcCk7fXJldHVybiByfSx0fSgpLG4uQXNzZXRGaWxlRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZihuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLnRlbnNvckluZm89bnVsbCx0LnByb3RvdHlwZS5maWxlbmFtZT1cIlwiLHQuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuQXNzZXRGaWxlRGVmLHI7by5wb3M8dDspc3dpdGNoKHI9by51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmEudGVuc29ySW5mbz0kcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8uZGVjb2RlKG8sby51aW50MzIoKSk7YnJlYWs7Y2FzZSAyOmEuZmlsZW5hbWU9by5zdHJpbmcoKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksbi5PcERlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYodGhpcy5pbnB1dEFyZz1bXSx0aGlzLm91dHB1dEFyZz1bXSx0aGlzLmF0dHI9W10sbilmb3IodmFyIGU9T2JqZWN0LmtleXMobiksdD0wO3Q8ZS5sZW5ndGg7Kyt0KW51bGwhPW5bZVt0XV0mJih0aGlzW2VbdF1dPW5bZVt0XV0pfXJldHVybiB0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUuaW5wdXRBcmc9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5vdXRwdXRBcmc9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5hdHRyPSR1dGlsLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGVwcmVjYXRpb249bnVsbCx0LnByb3RvdHlwZS5zdW1tYXJ5PVwiXCIsdC5wcm90b3R5cGUuZGVzY3JpcHRpb249XCJcIix0LnByb3RvdHlwZS5pc0NvbW11dGF0aXZlPSExLHQucHJvdG90eXBlLmlzQWdncmVnYXRlPSExLHQucHJvdG90eXBlLmlzU3RhdGVmdWw9ITEsdC5wcm90b3R5cGUuYWxsb3dzVW5pbml0aWFsaXplZElucHV0PSExLHQuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuT3BEZWYscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5uYW1lPW8uc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOmEuaW5wdXRBcmcmJmEuaW5wdXRBcmcubGVuZ3RofHwoYS5pbnB1dEFyZz1bXSksYS5pbnB1dEFyZy5wdXNoKCRyb290LnRlbnNvcmZsb3cuT3BEZWYuQXJnRGVmLmRlY29kZShvLG8udWludDMyKCkpKTticmVhaztjYXNlIDM6YS5vdXRwdXRBcmcmJmEub3V0cHV0QXJnLmxlbmd0aHx8KGEub3V0cHV0QXJnPVtdKSxhLm91dHB1dEFyZy5wdXNoKCRyb290LnRlbnNvcmZsb3cuT3BEZWYuQXJnRGVmLmRlY29kZShvLG8udWludDMyKCkpKTticmVhaztjYXNlIDQ6YS5hdHRyJiZhLmF0dHIubGVuZ3RofHwoYS5hdHRyPVtdKSxhLmF0dHIucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkF0dHJEZWYuZGVjb2RlKG8sby51aW50MzIoKSkpO2JyZWFrO2Nhc2UgODphLmRlcHJlY2F0aW9uPSRyb290LnRlbnNvcmZsb3cuT3BEZWYuT3BEZXByZWNhdGlvbi5kZWNvZGUobyxvLnVpbnQzMigpKTticmVhaztjYXNlIDU6YS5zdW1tYXJ5PW8uc3RyaW5nKCk7YnJlYWs7Y2FzZSA2OmEuZGVzY3JpcHRpb249by5zdHJpbmcoKTticmVhaztjYXNlIDE4OmEuaXNDb21tdXRhdGl2ZT1vLmJvb2woKTticmVhaztjYXNlIDE2OmEuaXNBZ2dyZWdhdGU9by5ib29sKCk7YnJlYWs7Y2FzZSAxNzphLmlzU3RhdGVmdWw9by5ib29sKCk7YnJlYWs7Y2FzZSAxOTphLmFsbG93c1VuaW5pdGlhbGl6ZWRJbnB1dD1vLmJvb2woKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHQuQXJnRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZihuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5kZXNjcmlwdGlvbj1cIlwiLHQucHJvdG90eXBlLnR5cGU9MCx0LnByb3RvdHlwZS50eXBlQXR0cj1cIlwiLHQucHJvdG90eXBlLm51bWJlckF0dHI9XCJcIix0LnByb3RvdHlwZS50eXBlTGlzdEF0dHI9XCJcIix0LnByb3RvdHlwZS5pc1JlZj0hMSx0LmRlY29kZT1mdW5jdGlvbihvLHMpe28gaW5zdGFuY2VvZiAkUmVhZGVyfHwobz0kUmVhZGVyLmNyZWF0ZShvKSk7Zm9yKHZhciB0PXZvaWQgMD09PXM/by5sZW46by5wb3MrcyxhPW5ldyAkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkFyZ0RlZixyO28ucG9zPHQ7KXN3aXRjaChyPW8udWludDMyKCkscj4+PjMpe2Nhc2UgMTphLm5hbWU9by5zdHJpbmcoKTticmVhaztjYXNlIDI6YS5kZXNjcmlwdGlvbj1vLnN0cmluZygpO2JyZWFrO2Nhc2UgMzphLnR5cGU9by5pbnQzMigpO2JyZWFrO2Nhc2UgNDphLnR5cGVBdHRyPW8uc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OmEubnVtYmVyQXR0cj1vLnN0cmluZygpO2JyZWFrO2Nhc2UgNjphLnR5cGVMaXN0QXR0cj1vLnN0cmluZygpO2JyZWFrO2Nhc2UgMTY6YS5pc1JlZj1vLmJvb2woKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksdC5BdHRyRGVmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZihuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS50eXBlPVwiXCIsdC5wcm90b3R5cGUuZGVmYXVsdFZhbHVlPW51bGwsdC5wcm90b3R5cGUuZGVzY3JpcHRpb249XCJcIix0LnByb3RvdHlwZS5oYXNNaW5pbXVtPSExLHQucHJvdG90eXBlLm1pbmltdW09JHV0aWwuTG9uZz8kdXRpbC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5hbGxvd2VkVmFsdWVzPW51bGwsdC5kZWNvZGU9ZnVuY3Rpb24obyxzKXtvIGluc3RhbmNlb2YgJFJlYWRlcnx8KG89JFJlYWRlci5jcmVhdGUobykpO2Zvcih2YXIgdD12b2lkIDA9PT1zP28ubGVuOm8ucG9zK3MsYT1uZXcgJHJvb3QudGVuc29yZmxvdy5PcERlZi5BdHRyRGVmLHI7by5wb3M8dDspc3dpdGNoKHI9by51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmEubmFtZT1vLnN0cmluZygpO2JyZWFrO2Nhc2UgMjphLnR5cGU9by5zdHJpbmcoKTticmVhaztjYXNlIDM6YS5kZWZhdWx0VmFsdWU9JHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuZGVjb2RlKG8sby51aW50MzIoKSk7YnJlYWs7Y2FzZSA0OmEuZGVzY3JpcHRpb249by5zdHJpbmcoKTticmVhaztjYXNlIDU6YS5oYXNNaW5pbXVtPW8uYm9vbCgpO2JyZWFrO2Nhc2UgNjphLm1pbmltdW09by5pbnQ2NCgpO2JyZWFrO2Nhc2UgNzphLmFsbG93ZWRWYWx1ZXM9JHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuZGVjb2RlKG8sby51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSx0fSgpLHQuT3BEZXByZWNhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYobilmb3IodmFyIGU9T2JqZWN0LmtleXMobiksdD0wO3Q8ZS5sZW5ndGg7Kyt0KW51bGwhPW5bZVt0XV0mJih0aGlzW2VbdF1dPW5bZVt0XV0pfXJldHVybiB0LnByb3RvdHlwZS52ZXJzaW9uPTAsdC5wcm90b3R5cGUuZXhwbGFuYXRpb249XCJcIix0LmRlY29kZT1mdW5jdGlvbihvLHMpe28gaW5zdGFuY2VvZiAkUmVhZGVyfHwobz0kUmVhZGVyLmNyZWF0ZShvKSk7Zm9yKHZhciB0PXZvaWQgMD09PXM/by5sZW46by5wb3MrcyxhPW5ldyAkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLk9wRGVwcmVjYXRpb24scjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS52ZXJzaW9uPW8uaW50MzIoKTticmVhaztjYXNlIDI6YS5leHBsYW5hdGlvbj1vLnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6by5za2lwVHlwZSg3JnIpO31yZXR1cm4gYX0sdH0oKSx0fSgpLG4uT3BMaXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLm9wPVtdLG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUub3A9JHV0aWwuZW1wdHlBcnJheSx0LmRlY29kZT1mdW5jdGlvbihvLHMpe28gaW5zdGFuY2VvZiAkUmVhZGVyfHwobz0kUmVhZGVyLmNyZWF0ZShvKSk7Zm9yKHZhciB0PXZvaWQgMD09PXM/by5sZW46by5wb3MrcyxhPW5ldyAkcm9vdC50ZW5zb3JmbG93Lk9wTGlzdCxyO28ucG9zPHQ7KXN3aXRjaChyPW8udWludDMyKCkscj4+PjMpe2Nhc2UgMTphLm9wJiZhLm9wLmxlbmd0aHx8KGEub3A9W10pLGEub3AucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLmRlY29kZShvLG8udWludDMyKCkpKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksbi5NZXRhR3JhcGhEZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4pe2lmKHRoaXMuY29sbGVjdGlvbkRlZj17fSx0aGlzLnNpZ25hdHVyZURlZj17fSx0aGlzLmFzc2V0RmlsZURlZj1bXSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLm1ldGFJbmZvRGVmPW51bGwsdC5wcm90b3R5cGUuZ3JhcGhEZWY9bnVsbCx0LnByb3RvdHlwZS5zYXZlckRlZj1udWxsLHQucHJvdG90eXBlLmNvbGxlY3Rpb25EZWY9JHV0aWwuZW1wdHlPYmplY3QsdC5wcm90b3R5cGUuc2lnbmF0dXJlRGVmPSR1dGlsLmVtcHR5T2JqZWN0LHQucHJvdG90eXBlLmFzc2V0RmlsZURlZj0kdXRpbC5lbXB0eUFycmF5LHQuZGVjb2RlPWZ1bmN0aW9uKHMsaSl7cyBpbnN0YW5jZW9mICRSZWFkZXJ8fChzPSRSZWFkZXIuY3JlYXRlKHMpKTtmb3IodmFyIHQ9dm9pZCAwPT09aT9zLmxlbjpzLnBvcytpLHI9bmV3ICRyb290LnRlbnNvcmZsb3cuTWV0YUdyYXBoRGVmLG4scDtzLnBvczx0Oylzd2l0Y2gocD1zLnVpbnQzMigpLHA+Pj4zKXtjYXNlIDE6ci5tZXRhSW5mb0RlZj0kcm9vdC50ZW5zb3JmbG93Lk1ldGFHcmFwaERlZi5NZXRhSW5mb0RlZi5kZWNvZGUocyxzLnVpbnQzMigpKTticmVhaztjYXNlIDI6ci5ncmFwaERlZj0kcm9vdC50ZW5zb3JmbG93LkdyYXBoRGVmLmRlY29kZShzLHMudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpyLnNhdmVyRGVmPSRyb290LnRlbnNvcmZsb3cuU2F2ZXJEZWYuZGVjb2RlKHMscy51aW50MzIoKSk7YnJlYWs7Y2FzZSA0OnMuc2tpcCgpLnBvcysrLHIuY29sbGVjdGlvbkRlZj09PSR1dGlsLmVtcHR5T2JqZWN0JiYoci5jb2xsZWN0aW9uRGVmPXt9KSxuPXMuc3RyaW5nKCkscy5wb3MrKyxyLmNvbGxlY3Rpb25EZWZbbl09JHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLmRlY29kZShzLHMudWludDMyKCkpO2JyZWFrO2Nhc2UgNTpzLnNraXAoKS5wb3MrKyxyLnNpZ25hdHVyZURlZj09PSR1dGlsLmVtcHR5T2JqZWN0JiYoci5zaWduYXR1cmVEZWY9e30pLG49cy5zdHJpbmcoKSxzLnBvcysrLHIuc2lnbmF0dXJlRGVmW25dPSRyb290LnRlbnNvcmZsb3cuU2lnbmF0dXJlRGVmLmRlY29kZShzLHMudWludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLmFzc2V0RmlsZURlZiYmci5hc3NldEZpbGVEZWYubGVuZ3RofHwoci5hc3NldEZpbGVEZWY9W10pLHIuYXNzZXRGaWxlRGVmLnB1c2goJHJvb3QudGVuc29yZmxvdy5Bc3NldEZpbGVEZWYuZGVjb2RlKHMscy51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6cy5za2lwVHlwZSg3JnApO31yZXR1cm4gcn0sdC5NZXRhSW5mb0RlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYodGhpcy50YWdzPVtdLG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUubWV0YUdyYXBoVmVyc2lvbj1cIlwiLHQucHJvdG90eXBlLnN0cmlwcGVkT3BMaXN0PW51bGwsdC5wcm90b3R5cGUuYW55SW5mbz1udWxsLHQucHJvdG90eXBlLnRhZ3M9JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS50ZW5zb3JmbG93VmVyc2lvbj1cIlwiLHQucHJvdG90eXBlLnRlbnNvcmZsb3dHaXRWZXJzaW9uPVwiXCIsdC5kZWNvZGU9ZnVuY3Rpb24obyxzKXtvIGluc3RhbmNlb2YgJFJlYWRlcnx8KG89JFJlYWRlci5jcmVhdGUobykpO2Zvcih2YXIgdD12b2lkIDA9PT1zP28ubGVuOm8ucG9zK3MsYT1uZXcgJHJvb3QudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYuTWV0YUluZm9EZWYscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5tZXRhR3JhcGhWZXJzaW9uPW8uc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOmEuc3RyaXBwZWRPcExpc3Q9JHJvb3QudGVuc29yZmxvdy5PcExpc3QuZGVjb2RlKG8sby51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOmEuYW55SW5mbz0kcm9vdC50ZW5zb3JmbG93LkFueS5kZWNvZGUobyxvLnVpbnQzMigpKTticmVhaztjYXNlIDQ6YS50YWdzJiZhLnRhZ3MubGVuZ3RofHwoYS50YWdzPVtdKSxhLnRhZ3MucHVzaChvLnN0cmluZygpKTticmVhaztjYXNlIDU6YS50ZW5zb3JmbG93VmVyc2lvbj1vLnN0cmluZygpO2JyZWFrO2Nhc2UgNjphLnRlbnNvcmZsb3dHaXRWZXJzaW9uPW8uc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpvLnNraXBUeXBlKDcmcik7fXJldHVybiBhfSx0fSgpLHR9KCksbi5TYXZlZE1vZGVsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtpZih0aGlzLm1ldGFHcmFwaHM9W10sbilmb3IodmFyIGU9T2JqZWN0LmtleXMobiksdD0wO3Q8ZS5sZW5ndGg7Kyt0KW51bGwhPW5bZVt0XV0mJih0aGlzW2VbdF1dPW5bZVt0XV0pfXJldHVybiB0LnByb3RvdHlwZS5zYXZlZE1vZGVsU2NoZW1hVmVyc2lvbj0kdXRpbC5Mb25nPyR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLm1ldGFHcmFwaHM9JHV0aWwuZW1wdHlBcnJheSx0LmRlY29kZT1mdW5jdGlvbihvLHMpe28gaW5zdGFuY2VvZiAkUmVhZGVyfHwobz0kUmVhZGVyLmNyZWF0ZShvKSk7Zm9yKHZhciB0PXZvaWQgMD09PXM/by5sZW46by5wb3MrcyxhPW5ldyAkcm9vdC50ZW5zb3JmbG93LlNhdmVkTW9kZWwscjtvLnBvczx0Oylzd2l0Y2gocj1vLnVpbnQzMigpLHI+Pj4zKXtjYXNlIDE6YS5zYXZlZE1vZGVsU2NoZW1hVmVyc2lvbj1vLmludDY0KCk7YnJlYWs7Y2FzZSAyOmEubWV0YUdyYXBocyYmYS5tZXRhR3JhcGhzLmxlbmd0aHx8KGEubWV0YUdyYXBocz1bXSksYS5tZXRhR3JhcGhzLnB1c2goJHJvb3QudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYuZGVjb2RlKG8sby51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6by5za2lwVHlwZSg3JnIpO31yZXR1cm4gYX0sdH0oKSxuLkZ1bmN0aW9uRGVmTGlicmFyeT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYodGhpcy5mdW5jdGlvbj1bXSx0aGlzLmdyYWRpZW50PVtdLG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZnVuY3Rpb249JHV0aWwuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5ncmFkaWVudD0kdXRpbC5lbXB0eUFycmF5LHQuZGVjb2RlPWZ1bmN0aW9uKG8scyl7byBpbnN0YW5jZW9mICRSZWFkZXJ8fChvPSRSZWFkZXIuY3JlYXRlKG8pKTtmb3IodmFyIHQ9dm9pZCAwPT09cz9vLmxlbjpvLnBvcytzLGE9bmV3ICRyb290LnRlbnNvcmZsb3cuRnVuY3Rpb25EZWZMaWJyYXJ5LHI7by5wb3M8dDspc3dpdGNoKHI9by51aW50MzIoKSxyPj4+Myl7Y2FzZSAxOmEuZnVuY3Rpb24mJmEuZnVuY3Rpb24ubGVuZ3RofHwoYS5mdW5jdGlvbj1bXSksYS5mdW5jdGlvbi5wdXNoKCRyb290LnRlbnNvcmZsb3cuRnVuY3Rpb25EZWYuZGVjb2RlKG8sby51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMjphLmdyYWRpZW50JiZhLmdyYWRpZW50Lmxlbmd0aHx8KGEuZ3JhZGllbnQ9W10pLGEuZ3JhZGllbnQucHVzaCgkcm9vdC50ZW5zb3JmbG93LkdyYWRpZW50RGVmLmRlY29kZShvLG8udWludDMyKCkpKTticmVhaztkZWZhdWx0Om8uc2tpcFR5cGUoNyZyKTt9cmV0dXJuIGF9LHR9KCksbi5GdW5jdGlvbkRlZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobil7aWYodGhpcy5hdHRyPXt9LHRoaXMubm9kZURlZj1bXSx0aGlzLnJldD17fSxuKWZvcih2YXIgZT1PYmplY3Qua2V5cyhuKSx0PTA7dDxlLmxlbmd0aDsrK3QpbnVsbCE9bltlW3RdXSYmKHRoaXNbZVt0XV09bltlW3RdXSl9cmV0dXJuIHQucHJvdG90eXBlLnNpZ25hdHVyZT1udWxsLHQucHJvdG90eXBlLmF0dHI9JHV0aWwuZW1wdHlPYmplY3QsdC5wcm90b3R5cGUubm9kZURlZj0kdXRpbC5lbXB0eUFycmF5LHQucHJvdG90eXBlLnJldD0kdXRpbC5lbXB0eU9iamVjdCx0LmRlY29kZT1mdW5jdGlvbihzLGkpe3MgaW5zdGFuY2VvZiAkUmVhZGVyfHwocz0kUmVhZGVyLmNyZWF0ZShzKSk7Zm9yKHZhciB0PXZvaWQgMD09PWk/cy5sZW46cy5wb3MraSxyPW5ldyAkcm9vdC50ZW5zb3JmbG93LkZ1bmN0aW9uRGVmLG4scDtzLnBvczx0Oylzd2l0Y2gocD1zLnVpbnQzMigpLHA+Pj4zKXtjYXNlIDE6ci5zaWduYXR1cmU9JHJvb3QudGVuc29yZmxvdy5PcERlZi5kZWNvZGUocyxzLnVpbnQzMigpKTticmVhaztjYXNlIDU6cy5za2lwKCkucG9zKyssci5hdHRyPT09JHV0aWwuZW1wdHlPYmplY3QmJihyLmF0dHI9e30pLG49cy5zdHJpbmcoKSxzLnBvcysrLHIuYXR0cltuXT0kcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUocyxzLnVpbnQzMigpKTticmVhaztjYXNlIDM6ci5ub2RlRGVmJiZyLm5vZGVEZWYubGVuZ3RofHwoci5ub2RlRGVmPVtdKSxyLm5vZGVEZWYucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk5vZGVEZWYuZGVjb2RlKHMscy51aW50MzIoKSkpO2JyZWFrO2Nhc2UgNDpzLnNraXAoKS5wb3MrKyxyLnJldD09PSR1dGlsLmVtcHR5T2JqZWN0JiYoci5yZXQ9e30pLG49cy5zdHJpbmcoKSxzLnBvcysrLHIucmV0W25dPXMuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpzLnNraXBUeXBlKDcmcCk7fXJldHVybiByfSx0fSgpLG4uR3JhZGllbnREZWY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4pe2lmKG4pZm9yKHZhciBlPU9iamVjdC5rZXlzKG4pLHQ9MDt0PGUubGVuZ3RoOysrdCludWxsIT1uW2VbdF1dJiYodGhpc1tlW3RdXT1uW2VbdF1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZnVuY3Rpb25OYW1lPVwiXCIsdC5wcm90b3R5cGUuZ3JhZGllbnRGdW5jPVwiXCIsdC5kZWNvZGU9ZnVuY3Rpb24obyxzKXtvIGluc3RhbmNlb2YgJFJlYWRlcnx8KG89JFJlYWRlci5jcmVhdGUobykpO2Zvcih2YXIgdD12b2lkIDA9PT1zP28ubGVuOm8ucG9zK3MsYT1uZXcgJHJvb3QudGVuc29yZmxvdy5HcmFkaWVudERlZixyO28ucG9zPHQ7KXN3aXRjaChyPW8udWludDMyKCkscj4+PjMpe2Nhc2UgMTphLmZ1bmN0aW9uTmFtZT1vLnN0cmluZygpO2JyZWFrO2Nhc2UgMjphLmdyYWRpZW50RnVuYz1vLnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6by5za2lwVHlwZSg3JnIpO31yZXR1cm4gYX0sdH0oKSxufSgpO3ZhciBjb21waWxlZF9hcGk9JHJvb3QsY29tcGlsZWRfYXBpXzE9Y29tcGlsZWRfYXBpLnRlbnNvcmZsb3csanNvbj1be3RmT3BOYW1lOlwiQWRkXCIsZGxPcE5hbWU6XCJhZGRcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFkZE5cIixkbE9wTmFtZTpcImFkZE5cIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCx0ZklucHV0UGFyYW1MZW5ndGg6MCxkbFBhcmFtTmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIkJpYXNBZGRcIixkbE9wTmFtZTpcImFkZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3ViXCIsZGxPcE5hbWU6XCJzdWJcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlYWxEaXZcIixkbE9wTmFtZTpcImRpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRGl2XCIsZGxPcE5hbWU6XCJkaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZsb29yRGl2XCIsZGxPcE5hbWU6XCJmbG9vckRpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTXVsXCIsZGxPcE5hbWU6XCJtdWxcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heGltdW1cIixkbE9wTmFtZTpcIm1heGltdW1cIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTWluaW11bVwiLGRsT3BOYW1lOlwibWluaW11bVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJQb3dcIixkbE9wTmFtZTpcInBvd1wiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3F1YXJlZERpZmZlcmVuY2VcIixkbE9wTmFtZTpcInNxdWFyZWREaWZmZXJlbmNlXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNb2RcIixkbE9wTmFtZTpcIm1vZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JNb2RcIixkbE9wTmFtZTpcIm1vZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGFyaXRobWV0aWM9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29ufSksanNvbiQxPVt7dGZPcE5hbWU6XCJBYnNcIixkbE9wTmFtZTpcImFic1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWNvc1wiLGRsT3BOYW1lOlwiYWNvc1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXNpblwiLGRsT3BOYW1lOlwiYXNpblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhblwiLGRsT3BOYW1lOlwiYXRhblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhbjJcIixkbE9wTmFtZTpcImF0YW4yXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJ5XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDZWlsXCIsZGxPcE5hbWU6XCJjZWlsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDbGlwQnlWYWx1ZVwiLGRsT3BOYW1lOlwiY2xpcEJ5VmFsdWVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImNsaXBfdmFsdWVfbWluXCIsZGxQYXJhbU5hbWU6XCJjbGlwVmFsdWVNaW5cIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcImNsaXBfdmFsdWVfbWF4XCIsZGxQYXJhbU5hbWU6XCJjbGlwVmFsdWVNYXhcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiQ29zXCIsZGxPcE5hbWU6XCJjb3NcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNvc2hcIixkbE9wTmFtZTpcImNvc2hcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkVsdVwiLGRsT3BOYW1lOlwiZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFeHBcIixkbE9wTmFtZTpcImV4cFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JcIixkbE9wTmFtZTpcImZsb29yXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2dcIixkbE9wTmFtZTpcImxvZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTmVnXCIsZGxPcE5hbWU6XCJuZWdcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlbHVcIixkbE9wTmFtZTpcInJlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlbHU2XCIsZGxPcE5hbWU6XCJjbGlwQnlWYWx1ZVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHtkbFBhcmFtTmFtZTpcImNsaXBWYWx1ZU1pblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se2RsUGFyYW1OYW1lOlwiY2xpcFZhbHVlTWF4XCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTo2fV19LHt0Zk9wTmFtZTpcIlNlbHVcIixkbE9wTmFtZTpcInNlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpZ21vaWRcIixkbE9wTmFtZTpcInNpZ21vaWRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpblwiLGRsT3BOYW1lOlwic2luXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaW5oXCIsZGxPcE5hbWU6XCJzaW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXJ0XCIsZGxPcE5hbWU6XCJzcXJ0XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSc3FydFwiLGRsT3BOYW1lOlwicnNxcnRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxdWFyZVwiLGRsT3BOYW1lOlwic3F1YXJlXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUYW5cIixkbE9wTmFtZTpcInRhblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGFuaFwiLGRsT3BOYW1lOlwidGFuaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2lnblwiLGRsT3BOYW1lOlwic2lnblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUm91bmRcIixkbE9wTmFtZTpcInJvdW5kXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFeHBtMVwiLGRsT3BOYW1lOlwiZXhwbTFcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZzFwXCIsZGxPcE5hbWU6XCJsb2cxcFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVjaXByb2NhbFwiLGRsT3BOYW1lOlwicmVjaXByb2NhbFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVjaXByb2NhbFwiLGRsT3BOYW1lOlwicmVjaXByb2NhbFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU29mdHBsdXNcIixkbE9wTmFtZTpcInNvZnRwbHVzXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBc2luaFwiLGRsT3BOYW1lOlwiYXNpbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFjb3NoXCIsZGxPcE5hbWU6XCJhY29zaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhbmhcIixkbE9wTmFtZTpcImF0YW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFcmZcIixkbE9wTmFtZTpcImVyZlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUHJvZFwiLGRsT3BOYW1lOlwicHJvZFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJrZWVwX2RpbXNcIixkbFBhcmFtTmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxlYWt5UmVsdVwiLGRsT3BOYW1lOlwibGVha3lSZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJhbHBoYVwiLGRsUGFyYW1OYW1lOlwiYWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4yfSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sYmFzaWNNYXRoPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxfSksanNvbiQyPVt7dGZPcE5hbWU6XCJMb29wQ29uZFwiLGRsT3BOYW1lOlwibG9vcENvbmRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInByZWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3dpdGNoXCIsZGxPcE5hbWU6XCJzd2l0Y2hcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInByZWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTWVyZ2VcIixkbE9wTmFtZTpcIm1lcmdlXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsdGZJbnB1dFBhcmFtTGVuZ3RoOjAsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJFbnRlclwiLGRsT3BOYW1lOlwiZW50ZXJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcImZyYW1lX25hbWVcIixkbFBhcmFtTmFtZTpcImZyYW1lTmFtZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmUGFyYW1OYW1lOlwiaXNfY29uc3RhbnRcIixkbFBhcmFtTmFtZTpcImlzQ29uc3RhbnRcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkV4aXRcIixkbE9wTmFtZTpcImV4aXRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTmV4dEl0ZXJhdGlvblwiLGRsT3BOYW1lOlwibmV4dEl0ZXJhdGlvblwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVYzXCIsZGxPcE5hbWU6XCJ0ZW5zb3JBcnJheVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0ZlBhcmFtTmFtZTpcImVsZW1lbnRfc2hhcGVcIixkbFBhcmFtTmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZQYXJhbU5hbWU6XCJkeW5hbWljX3NpemVcIixkbFBhcmFtTmFtZTpcImR5bmFtaWNTaXplXCIsdHlwZTpcImJvb2xcIn0se3RmUGFyYW1OYW1lOlwiY2xlYXJfYWZ0ZXJfcmVhZFwiLGRsUGFyYW1OYW1lOlwiY2xlYXJBZnRlclJlYWRcIix0eXBlOlwiYm9vbFwifSx7dGZQYXJhbU5hbWU6XCJpZGVudGljYWxfZWxlbWVudF9zaGFwZXNcIixkbFBhcmFtTmFtZTpcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIix0eXBlOlwiYm9vbFwifSx7dGZQYXJhbU5hbWU6XCJ0ZW5zb3JfYXJyYXlfbmFtZVwiLGRsUGFyYW1OYW1lOlwibmFtZVwiLHR5cGU6XCJzdHJpbmdcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVdyaXRlVjNcIixkbE9wTmFtZTpcInRlbnNvckFycmF5V3JpdGVcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImluZGV4XCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlSZWFkVjNcIixkbE9wTmFtZTpcInRlbnNvckFycmF5UmVhZFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5R2F0aGVyVjNcIixkbE9wTmFtZTpcInRlbnNvckFycmF5R2F0aGVyXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0ZlBhcmFtTmFtZTpcImVsZW1lbnRfc2hhcGVcIixkbFBhcmFtTmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5U2NhdHRlclYzXCIsZGxPcE5hbWU6XCJ0ZW5zb3JBcnJheVNjYXR0ZXJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImluZGljZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlDb25jYXRWM1wiLGRsT3BOYW1lOlwidGVuc29yQXJyYXlDb25jYXRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0ZlBhcmFtTmFtZTpcImVsZW1lbnRfc2hhcGVfZXhjZXB0MFwiLGRsUGFyYW1OYW1lOlwiZWxlbWVudFNoYXBlRXhjZXB0MFwiLHR5cGU6XCJzaGFwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNwbGl0VjNcIixkbE9wTmFtZTpcInRlbnNvckFycmF5U3BsaXRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwibGVuZ3Roc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlTaXplVjNcIixkbE9wTmFtZTpcInRlbnNvckFycmF5U2l6ZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5Q2xvc2VWM1wiLGRsT3BOYW1lOlwidGVuc29yQXJyYXlDbG9zZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn1dfV0sY29udHJvbD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMn0pLGpzb24kMz1be3RmT3BOYW1lOlwiQXZnUG9vbFwiLGRsT3BOYW1lOlwiYXZnUG9vbFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcInN0cmlkZXNcIixkbFBhcmFtTmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwicGFkZGluZ1wiLGRsUGFyYW1OYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJkYXRhX2Zvcm1hdFwiLGRsUGFyYW1OYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcImtzaXplXCIsZGxQYXJhbU5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heFBvb2xcIixkbE9wTmFtZTpcIm1heFBvb2xcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJzdHJpZGVzXCIsZGxQYXJhbU5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcInBhZGRpbmdcIixkbFBhcmFtTmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmUGFyYW1OYW1lOlwiZGF0YV9mb3JtYXRcIixkbFBhcmFtTmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZQYXJhbU5hbWU6XCJrc2l6ZVwiLGRsUGFyYW1OYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb252MURcIixkbE9wTmFtZTpcImNvbnYxZFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwic3RyaWRlXCIsZGxQYXJhbU5hbWU6XCJzdHJpZGVcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcInBhZGRpbmdcIixkbFBhcmFtTmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmUGFyYW1OYW1lOlwiZGF0YV9mb3JtYXRcIixkbFBhcmFtTmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTldDXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZQYXJhbU5hbWU6XCJkaWxhdGlvblwiLGRsUGFyYW1OYW1lOlwiZGlsYXRpb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9XX0se3RmT3BOYW1lOlwiQ29udjJEXCIsZGxPcE5hbWU6XCJjb252MmRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZQYXJhbU5hbWU6XCJzdHJpZGVzXCIsZGxQYXJhbU5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcInBhZGRpbmdcIixkbFBhcmFtTmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmUGFyYW1OYW1lOlwidXNlQ3Vkbm5PbkdwdVwiLGRsUGFyYW1OYW1lOlwidXNlQ3Vkbm5PbkdwdVwiLHR5cGU6XCJib29sXCJ9LHt0ZlBhcmFtTmFtZTpcImRhdGFfZm9ybWF0XCIsZGxQYXJhbU5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmUGFyYW1OYW1lOlwiZGlsYXRpb25zXCIsZGxQYXJhbU5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJDb252MkRCYWNrcHJvcElucHV0XCIsZGxPcE5hbWU6XCJjb252MmRUcmFuc3Bvc2VcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcIm91dHB1dFNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcInN0cmlkZXNcIixkbFBhcmFtTmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwicGFkZGluZ1wiLGRsUGFyYW1OYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJkYXRhX2Zvcm1hdFwiLGRsUGFyYW1OYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRGVwdGh3aXNlQ29udjJkXCIsZGxPcE5hbWU6XCJkZXB0aHdpc2VDb252MmRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJzdHJpZGVzXCIsZGxQYXJhbU5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcInBhZGRpbmdcIixkbFBhcmFtTmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmUGFyYW1OYW1lOlwiZGF0YV9mb3JtYXRcIixkbFBhcmFtTmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZQYXJhbU5hbWU6XCJkaWxhdGlvbnNcIixkbFBhcmFtTmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLGRsT3BOYW1lOlwiZGVwdGh3aXNlQ29udjJkXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiaW5wdXRcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwic3RyaWRlc1wiLGRsUGFyYW1OYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJwYWRkaW5nXCIsZGxQYXJhbU5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0ZlBhcmFtTmFtZTpcImRhdGFfZm9ybWF0XCIsZGxQYXJhbU5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmUGFyYW1OYW1lOlwiZGlsYXRpb25zXCIsZGxQYXJhbU5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn1dfV0sY29udm9sdXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDN9KSxqc29uJDQ9W3t0Zk9wTmFtZTpcIkZpbGxcIixkbE9wTmFtZTpcImZpbGxcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJ2YWx1ZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJMaW5TcGFjZVwiLGRsT3BOYW1lOlwibGluc3BhY2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzdGFydFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwic3RvcFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwibnVtXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJPbmVIb3RcIixkbE9wTmFtZTpcIm9uZUhvdFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImRlcHRoXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJvblZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJvZmZWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmUGFyYW1OYW1lOlwiYXhpc1wiLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk9uZXNcIixkbE9wTmFtZTpcIm9uZXNcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIk9uZXNMaWtlXCIsZGxPcE5hbWU6XCJvbmVzTGlrZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImR0eXBlXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlJhbmRvbVVuaWZvcm1cIixkbE9wTmFtZTpcInJhbmRvbVVuaWZvcm1cIixjYXRlZ29yeTpcImNyZWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJtaW52YWxcIixkbFBhcmFtTmFtZTpcIm1pbnZhbFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmUGFyYW1OYW1lOlwibWF4dmFsXCIsZGxQYXJhbU5hbWU6XCJtYXh2YWxcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0ZlBhcmFtTmFtZTpcImR0eXBlXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZQYXJhbU5hbWU6XCJzZWVkXCIsZGxQYXJhbU5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJzZWVkMlwiLGRsUGFyYW1OYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJUXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSYW5nZVwiLGRsT3BOYW1lOlwicmFuZ2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJzdGFydFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwic3RvcFwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwic3RlcFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmUGFyYW1OYW1lOlwiVGlkeFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJ0cnVuY2F0ZWROb3JtYWxcIixkbE9wTmFtZTpcInRydW5jYXRlZE5vcm1hbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIm1lYW5zXCIsZGxQYXJhbU5hbWU6XCJtZWFuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJzdGRkZXZcIixkbFBhcmFtTmFtZTpcInN0ZERldlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmUGFyYW1OYW1lOlwic2VlZFwiLGRsUGFyYW1OYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmUGFyYW1OYW1lOlwic2VlZDJcIixkbFBhcmFtTmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcIlRcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlplcm9zXCIsZGxPcE5hbWU6XCJ6ZXJvc1wiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiWmVyb3NMaWtlXCIsZGxPcE5hbWU6XCJ6ZXJvc0xpa2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19XSxjcmVhdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kNH0pLGpzb24kNT1be3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WMlwiLGRsT3BOYW1lOlwibm9uTWF4U3VwcHJlc3Npb25cIixjYXRlZ29yeTpcImR5bmFtaWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJzY29yZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcIm1heE91dHB1dFNpemVcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblYzXCIsZGxPcE5hbWU6XCJub25NYXhTdXBwcmVzc2lvblwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInNjb3Jlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmSW5wdXRJbmRleDozLGRsUGFyYW1OYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifSx7dGZJbnB1dEluZGV4OjQsZGxQYXJhbU5hbWU6XCJzY29yZVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJXaGVyZVwiLGRsT3BOYW1lOlwid2hlcmVBc3luY1wiLGNhdGVnb3J5OlwiZHluYW1pY1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMaXN0RGlmZlwiLGRsT3BOYW1lOlwic2V0ZGlmZjFkQXN5bmNcIixjYXRlZ29yeTpcImR5bmFtaWNcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxkeW5hbWljPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ1fSksanNvbiQ2PVt7dGZPcE5hbWU6XCJUb3BLVjJcIixkbE9wTmFtZTpcInRvcEtcIixjYXRlZ29yeTpcImV2YWx1YXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImtcIix0eXBlOlwibnVtYmVyXCJ9LHt0ZlBhcmFtTmFtZTpcInNvcnRlZFwiLGRsUGFyYW1OYW1lOlwic29ydGVkXCIsdHlwZTpcImJvb2xcIn1dfV0sZXZhbHVhdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kNn0pLGpzb24kNz1be3RmT3BOYW1lOlwiUGxhY2Vob2xkZXJXaXRoRGVmYXVsdFwiLGRsT3BOYW1lOlwicGxhY2Vob2xkZXJcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJkZWZhdWx0XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJzaGFwZVwiLGRsUGFyYW1OYW1lOlwic2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmUGFyYW1OYW1lOlwiZHR5cGVcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiUGxhY2Vob2xkZXJcIixkbE9wTmFtZTpcInBsYWNlaG9sZGVyXCIsY2F0ZWdvcnk6XCJncmFwaFwiLHBhcmFtczpbe3RmUGFyYW1OYW1lOlwic2hhcGVcIixkbFBhcmFtTmFtZTpcInNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0ZlBhcmFtTmFtZTpcImR0eXBlXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkNvbnN0XCIsZGxPcE5hbWU6XCJjb25zdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIn0se3RmT3BOYW1lOlwiSWRlbnRpdHlcIixkbE9wTmFtZTpcImlkZW50aXR5XCIsY2F0ZWdvcnk6XCJncmFwaFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTbmFwc2hvdFwiLGRsT3BOYW1lOlwic25hcHNob3RcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlJhbmtcIixkbE9wTmFtZTpcInJhbmtcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNpemVcIixkbE9wTmFtZTpcInNpemVcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNoYXBlXCIsZGxPcE5hbWU6XCJzaGFwZVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2hhcGVOXCIsZGxPcE5hbWU6XCJzaGFwZU5cIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsdGZJbnB1dFBhcmFtTGVuZ3RoOjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJQcmludFwiLGRsT3BOYW1lOlwicHJpbnRcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsdGZJbnB1dFBhcmFtTGVuZ3RoOjEsZGxQYXJhbU5hbWU6XCJkYXRhXCIsdHlwZTpcInRlbnNvcnNcIn0se3RmUGFyYW1OYW1lOlwibWVzc2FnZVwiLGRsUGFyYW1OYW1lOlwibWVzc2FnZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmUGFyYW1OYW1lOlwiZmlyc3RfblwiLGRsUGFyYW1OYW1lOlwiZmlyc3ROXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBydGVkOiEwfSx7dGZQYXJhbU5hbWU6XCJzdW1tYXJpemVcIixkbFBhcmFtTmFtZTpcInN1bW1hcml6ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6M31dfSx7dGZPcE5hbWU6XCJOb09wXCIsZGxPcE5hbWU6XCJub29wXCIsY2F0ZWdvcnk6XCJncmFwaFwiLHBhcmFtczpbXX0se3RmT3BOYW1lOlwiU3RvcEdyYWRpZW50XCIsZGxPcE5hbWU6XCJzdG9wR3JhZGllbnRcIixjYXRlZ29yeTpcImdyYXBoXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkZha2VRdWFudFdpdGhNaW5NYXhWYXJzXCIsZGxPcE5hbWU6XCJmYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiLGNhdGVnb3J5OlwiZ3JhcGhcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIm1pblwiLGRsUGFyYW1OYW1lOlwibWluXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJtYXhcIixkbFBhcmFtTmFtZTpcIm1heFwiLHR5cGU6XCJudW1iZXJcIn1dfV0sZ3JhcGg9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDd9KSxqc29uJDg9W3t0Zk9wTmFtZTpcIlJlc2l6ZUJpbGluZWFyXCIsZGxPcE5hbWU6XCJyZXNpemVCaWxpbmVhclwiLGNhdGVnb3J5OlwiaW1hZ2VcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImltYWdlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJhbGlnbl9jb3JuZXJzXCIsZGxQYXJhbU5hbWU6XCJhbGlnbkNvcm5lcnNcIix0eXBlOlwiYm9vbFwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZXNpemVOZWFyZXN0TmVpZ2hib3JcIixkbE9wTmFtZTpcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiLGNhdGVnb3J5OlwiaW1hZ2VcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImltYWdlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJhbGlnbl9jb3JuZXJzXCIsZGxQYXJhbU5hbWU6XCJhbGlnbkNvcm5lcnNcIix0eXBlOlwiYm9vbFwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDcm9wQW5kUmVzaXplXCIsZGxPcE5hbWU6XCJjcm9wQW5kUmVzaXplXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiaW1hZ2VcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJib3hJbmRcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcImNyb3BTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIm1ldGhvZFwiLGRsUGFyYW1OYW1lOlwibWV0aG9kXCIsdHlwZTpcInN0cmluZ1wifSx7dGZQYXJhbU5hbWU6XCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsZGxQYXJhbU5hbWU6XCJleHRyYXBvbGF0aW9uVmFsdWVcIix0eXBlOlwibnVtYmVyXCJ9XX1dLGltYWdlJDE9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDh9KSxqc29uJDk9W3t0Zk9wTmFtZTpcIkVxdWFsXCIsZGxPcE5hbWU6XCJlcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTm90RXF1YWxcIixkbE9wTmFtZTpcIm5vdEVxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJHcmVhdGVyXCIsZGxPcE5hbWU6XCJncmVhdGVyXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJHcmVhdGVyRXF1YWxcIixkbE9wTmFtZTpcImdyZWF0ZXJFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVzc1wiLGRsT3BOYW1lOlwibGVzc1wiLGNhdGVnb3J5OlwibG9naWNhbFwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVzc0VxdWFsXCIsZGxPcE5hbWU6XCJsZXNzRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxBbmRcIixkbE9wTmFtZTpcImxvZ2ljYWxBbmRcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxOb3RcIixkbE9wTmFtZTpcImxvZ2ljYWxOb3RcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxPclwiLGRsT3BOYW1lOlwibG9naWNhbE9yXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTZWxlY3RcIixkbE9wTmFtZTpcIndoZXJlXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJjb25kaXRpb25cIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxsb2dpY2FsPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ5fSksanNvbiQxMD1be3RmT3BOYW1lOlwiTWF0TXVsXCIsZGxPcE5hbWU6XCJtYXRNdWxcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJ0cmFuc3Bvc2VfYVwiLGRsUGFyYW1OYW1lOlwidHJhbnNwb3NlQVwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZQYXJhbU5hbWU6XCJ0cmFuc3Bvc2VfYlwiLGRsUGFyYW1OYW1lOlwidHJhbnNwb3NlQlwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZQYXJhbU5hbWU6XCJUXCIsZGxQYXJhbU5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJCYXRjaE1hdE11bFwiLGRsT3BOYW1lOlwibWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiYWRqX3hcIixkbFBhcmFtTmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmUGFyYW1OYW1lOlwiYWRqX3lcIixkbFBhcmFtTmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmUGFyYW1OYW1lOlwiVFwiLGRsUGFyYW1OYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVHJhbnNwb3NlXCIsZGxPcE5hbWU6XCJ0cmFuc3Bvc2VcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJwZXJtXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcIlRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxtYXRyaWNlcz1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTB9KSxqc29uJDExPVt7dGZPcE5hbWU6XCJGdXNlZEJhdGNoTm9ybVwiLGRsT3BOYW1lOlwiYmF0Y2hOb3JtYWxpemF0aW9uXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJzY2FsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwib2Zmc2V0XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJtZWFuXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjQsZGxQYXJhbU5hbWU6XCJ2YXJpYW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiZXBzaWxvblwiLGRsUGFyYW1OYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjAwMX0se3RmUGFyYW1OYW1lOlwiZGF0YV9mb3JtYXRcIixkbFBhcmFtTmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZ1c2VkQmF0Y2hOb3JtVjJcIixkbE9wTmFtZTpcImJhdGNoTm9ybWFsaXphdGlvblwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwic2NhbGVcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcIm9mZnNldFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDozLGRsUGFyYW1OYW1lOlwibWVhblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDo0LGRsUGFyYW1OYW1lOlwidmFyaWFuY2VcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImVwc2lsb25cIixkbFBhcmFtTmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4wMDF9LHt0ZlBhcmFtTmFtZTpcImRhdGFfZm9ybWF0XCIsZGxQYXJhbU5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMUk5cIixkbE9wTmFtZTpcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJkZXB0aF9yYWRpdXNcIixkbFBhcmFtTmFtZTpcInJhZGl1c1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6NX0se3RmUGFyYW1OYW1lOlwiYmlhc1wiLGRsUGFyYW1OYW1lOlwiYmlhc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmUGFyYW1OYW1lOlwiYWxwaGFcIixkbFBhcmFtTmFtZTpcImFscGhhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZQYXJhbU5hbWU6XCJiZXRhXCIsZGxQYXJhbU5hbWU6XCJiZXRhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouNX1dfSx7dGZPcE5hbWU6XCJTb2Z0bWF4XCIsZGxPcE5hbWU6XCJzb2Z0bWF4XCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkxvZ1NvZnRtYXhcIixkbE9wTmFtZTpcImxvZ1NvZnRtYXhcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3BhcnNlVG9EZW5zZVwiLGRsT3BOYW1lOlwic3BhcnNlVG9EZW5zZVwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwic3BhcnNlSW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwic3BhcnNlVmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJkZWZhdWx0VmFsdWVcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixkbFBhcmFtTmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiEwLG5vdFN1cHBvcnRlZDohMH1dfV0sbm9ybWFsaXphdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTF9KSxqc29uJDEyPVt7dGZPcE5hbWU6XCJNYXhcIixkbE9wTmFtZTpcIm1heFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImtlZXBfZGltc1wiLGRsUGFyYW1OYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk1lYW5cIixkbE9wTmFtZTpcIm1lYW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJrZWVwX2RpbXNcIixkbFBhcmFtTmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJNaW5cIixkbE9wTmFtZTpcIm1pblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImtlZXBfZGltc1wiLGRsUGFyYW1OYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIlN1bVwiLGRsT3BOYW1lOlwic3VtXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwia2VlcF9kaW1zXCIsZGxQYXJhbU5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQWxsXCIsZGxPcE5hbWU6XCJhbGxcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZQYXJhbU5hbWU6XCJrZWVwX2RpbXNcIixkbFBhcmFtTmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBbnlcIixkbE9wTmFtZTpcImFueVwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImtlZXBfZGltc1wiLGRsUGFyYW1OYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFyZ01heFwiLGRsT3BOYW1lOlwiYXJnTWF4XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiQXJnTWluXCIsZGxPcE5hbWU6XCJhcmdNaW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJQcm9kXCIsZGxPcE5hbWU6XCJwcm9kXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwia2VlcF9kaW1zXCIsZGxQYXJhbU5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX1dLHJlZHVjdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTJ9KSxqc29uJDEzPVt7dGZPcE5hbWU6XCJDb25jYXRWMlwiLGRsT3BOYW1lOlwiY29uY2F0XCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsdGZJbnB1dFBhcmFtTGVuZ3RoOjEsZGxQYXJhbU5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn0se3RmSW5wdXRJbmRleDotMSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiQ29uY2F0XCIsZGxPcE5hbWU6XCJjb25jYXRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MSx0ZklucHV0UGFyYW1MZW5ndGg6MSxkbFBhcmFtTmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIkdhdGhlclYyXCIsZGxPcE5hbWU6XCJnYXRoZXJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiR2F0aGVyXCIsZGxPcE5hbWU6XCJnYXRoZXJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImF4aXNcIixkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0ZlBhcmFtTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixkbFBhcmFtTmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJldmVyc2VcIixkbE9wTmFtZTpcInJldmVyc2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImRpbXNcIix0eXBlOlwiYm9vbFwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZXZlcnNlVjJcIixkbE9wTmFtZTpcInJldmVyc2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTbGljZVwiLGRsT3BOYW1lOlwic2xpY2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImJlZ2luXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTdHJpZGVkU2xpY2VcIixkbE9wTmFtZTpcInN0cmlkZWRTbGljZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwiZW5kXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MyxkbFBhcmFtTmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmUGFyYW1OYW1lOlwiYmVnaW5fbWFza1wiLGRsUGFyYW1OYW1lOlwiYmVnaW5NYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJlbmRfbWFza1wiLGRsUGFyYW1OYW1lOlwiZW5kTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmUGFyYW1OYW1lOlwibmV3X2F4aXNfbWFza1wiLGRsUGFyYW1OYW1lOlwibmV3QXhpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0ZlBhcmFtTmFtZTpcImVsbGlwc2lzX21hc2tcIixkbFBhcmFtTmFtZTpcImVsbGlwc2lzTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmUGFyYW1OYW1lOlwic2hyaW5rX2F4aXNfbWFza1wiLGRsUGFyYW1OYW1lOlwic2hyaW5rQXhpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiUGFja1wiLGRsT3BOYW1lOlwic3RhY2tcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCx0ZklucHV0UGFyYW1MZW5ndGg6MCxkbFBhcmFtTmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7dGZQYXJhbU5hbWU6XCJheGlzXCIsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlVucGFja1wiLGRsT3BOYW1lOlwidW5zdGFja1wiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLHRmSW5wdXRQYXJhbUxlbmd0aDowLGRsUGFyYW1OYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJheGlzXCIsZGxQYXJhbU5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZQYXJhbU5hbWU6XCJudW1cIixkbFBhcmFtTmFtZTpcIm51bVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGlsZVwiLGRsT3BOYW1lOlwidGlsZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwicmVwc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNwbGl0XCIsZGxPcE5hbWU6XCJzcGxpdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwibnVtX3NwbGl0XCIsZGxQYXJhbU5hbWU6XCJudW1PclNpemVTcGxpdHNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9XX0se3RmT3BOYW1lOlwiU3BsaXRWXCIsZGxPcE5hbWU6XCJzcGxpdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwibnVtT3JTaXplU3BsaXRzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiU2NhdHRlck5kXCIsZGxPcE5hbWU6XCJzY2F0dGVyTmRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJHYXRoZXJOZFwiLGRsT3BOYW1lOlwiZ2F0aGVyTmRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3BhcnNlVG9EZW5zZVwiLGRsT3BOYW1lOlwic3BhcnNlVG9EZW5zZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwic3BhcnNlSW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmSW5wdXRJbmRleDoyLGRsUGFyYW1OYW1lOlwic3BhcnNlVmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjMsZGxQYXJhbU5hbWU6XCJkZWZhdWx0VmFsdWVcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixkbFBhcmFtTmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExLG5vdFN1cHBvcnRlZDohMH1dfV0sc2xpY2VKb2luPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxM30pLGpzb24kMTQ9W3t0Zk9wTmFtZTpcIkNhc3RcIixkbE9wTmFtZTpcImNhc3RcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZQYXJhbU5hbWU6XCJTcmNUXCIsZGxQYXJhbU5hbWU6XCJzZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0ZlBhcmFtTmFtZTpcIkRzdFRcIixkbFBhcmFtTmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiRXhwYW5kRGltc1wiLGRsT3BOYW1lOlwiZXhwYW5kRGltc1wiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSx0ZlBhcmFtTmFtZURlcHJlY2F0ZWQ6XCJkaW1cIixkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiUGFkXCIsZGxPcE5hbWU6XCJwYWRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJwYWRkaW5nXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZlBhcmFtTmFtZTpcImNvbnN0YW50X3ZhbHVlXCIsZGxQYXJhbU5hbWU6XCJjb25zdGFudFZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlBhZFYyXCIsZGxPcE5hbWU6XCJwYWRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJwYWRkaW5nXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcImNvbnN0YW50VmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiUmVzaGFwZVwiLGRsT3BOYW1lOlwicmVzaGFwZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZklucHV0SW5kZXg6MSxkbFBhcmFtTmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3F1ZWV6ZVwiLGRsT3BOYW1lOlwic3F1ZWV6ZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixwYXJhbXM6W3t0ZklucHV0SW5kZXg6MCxkbFBhcmFtTmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHt0ZlBhcmFtTmFtZTpcImF4aXNcIix0ZlBhcmFtTmFtZURlcHJlY2F0ZWQ6XCJzcXVlZXplX2RpbXNcIixkbFBhcmFtTmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTcGFjZVRvQmF0Y2hORFwiLGRsT3BOYW1lOlwic3BhY2VUb0JhdGNoTkRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIscGFyYW1zOlt7dGZJbnB1dEluZGV4OjAsZGxQYXJhbU5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7dGZJbnB1dEluZGV4OjEsZGxQYXJhbU5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0ZklucHV0SW5kZXg6MixkbFBhcmFtTmFtZTpcInBhZGRpbmdzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiQmF0Y2hUb1NwYWNlTkRcIixkbE9wTmFtZTpcImJhdGNoVG9TcGFjZU5EXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmSW5wdXRJbmRleDoxLGRsUGFyYW1OYW1lOlwiYmxvY2tTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZJbnB1dEluZGV4OjIsZGxQYXJhbU5hbWU6XCJjcm9wc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRoVG9TcGFjZVwiLGRsT3BOYW1lOlwiZGVwdGhUb1NwYWNlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLHBhcmFtczpbe3RmSW5wdXRJbmRleDowLGRsUGFyYW1OYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3RmUGFyYW1OYW1lOlwiYmxvY2tfc2l6ZVwiLGRsUGFyYW1OYW1lOlwiYmxvY2tTaXplXCIsdHlwZTpcIm51bWJlclwifSx7dGZQYXJhbU5hbWU6XCJkYXRhX2Zvcm1hdFwiLGRsUGFyYW1OYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIn1dfV0sdHJhbnNmb3JtYXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDE0fSksQ09OVFJPTF9GTE9XX09QUz1bXCJTd2l0Y2hcIixcIk1lcmdlXCIsXCJFbnRlclwiLFwiRXhpdFwiLFwiTmV4dEl0ZXJhdGlvblwiXSxEWU5BTUlDX1NIQVBFX09QUz1bXCJOb25NYXhTdXBwcmVzc2lvblYyXCIsXCJOb25NYXhTdXBwcmVzc2lvblYzXCIsXCJXaGVyZVwiXSxPcGVyYXRpb25NYXBwZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dmFyIGU9W10uY29uY2F0LmFwcGx5KFtdLFthcml0aG1ldGljLGJhc2ljTWF0aCxjb250cm9sLGNvbnZvbHV0aW9uLGNyZWF0aW9uLGR5bmFtaWMsZXZhbHVhdGlvbixsb2dpY2FsLGltYWdlJDEsZ3JhcGgsbWF0cmljZXMsbm9ybWFsaXphdGlvbixyZWR1Y3Rpb24sc2xpY2VKb2luLHRyYW5zZm9ybWF0aW9uXS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuanNvbn0pKTt0aGlzLm9wTWFwcGVycz1lLnJlZHVjZShmdW5jdGlvbihhLGUpe3JldHVybiBhW2UudGZPcE5hbWVdPWUsYX0se30pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkluc3RhbmNlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnN0YW5jZXx8KHRoaXMuX2luc3RhbmNlPW5ldyB0aGlzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5pc0NvbnRyb2xGbG93PWZ1bmN0aW9uKGEpe3JldHVybiBDT05UUk9MX0ZMT1dfT1BTLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1hLm9wfSl9LHQucHJvdG90eXBlLmlzRHluYW1pY1NoYXBlPWZ1bmN0aW9uKGEpe3JldHVybiBEWU5BTUlDX1NIQVBFX09QUy5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlPT09YS5vcH0pfSx0LnByb3RvdHlwZS50cmFuc2Zvcm1HcmFwaD1mdW5jdGlvbihsKXt2YXIgZD10aGlzLHQ9ITEsdT0hMSxjPVtdLG49W10sbz1sLm5vZGUucmVkdWNlKGZ1bmN0aW9uKGEsZSl7cmV0dXJuIGFbZS5uYW1lXT1kLm1hcE5vZGUoZSksZC5pc0NvbnRyb2xGbG93KGUpJiYodD0hMCksZC5pc0R5bmFtaWNTaGFwZShlKSYmKHU9ITApLFwiUGxhY2Vob2xkZXJcIj09PWUub3AmJmMucHVzaChhW2UubmFtZV0pLFwiQ29uc3RcIj09PWUub3AmJm4ucHVzaChhW2UubmFtZV0pLGF9LHt9KSxzPVtdLGk9W107cmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIG49b1thXTtuLmlucHV0TmFtZXMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT1nZXROb2RlTmFtZUFuZEluZGV4KHQpWzBdO24uaW5wdXRzLnB1c2gob1tlXSksb1tlXS5jaGlsZHJlbi5wdXNoKG4pfSksMD09PW4uaW5wdXRzLmxlbmd0aCYmcy5wdXNoKG4pfSksT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgZT1vW2FdOzA9PT1lLmNoaWxkcmVuLmxlbmd0aCYmaS5wdXNoKGUpfSkse25vZGVzOm8saW5wdXRzOnMsb3V0cHV0czppLHdlaWdodHM6bixwbGFjZWhvbGRlcnM6Yyx3aXRoQ29udHJvbEZsb3c6dCx3aXRoRHluYW1pY1NoYXBlOnV9fSx0LnByb3RvdHlwZS5tYXBOb2RlPWZ1bmN0aW9uKG4pe3ZhciBlPXRoaXMsdD10aGlzLm9wTWFwcGVyc1tuLm9wXTtpZih2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcihcIlRlbnNvcmZsb3cgT3AgaXMgbm90IHN1cHBvcnRlZDogXCIrbi5vcCk7dmFyIGE9e25hbWU6bi5uYW1lLG9wOnQuZGxPcE5hbWUsY2F0ZWdvcnk6dC5jYXRlZ29yeSxpbnB1dE5hbWVzOihuLmlucHV0fHxbXSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0YXJ0c1dpdGgoXCJeXCIpP3Quc3Vic3RyKDEpOnR9KSxpbnB1dHM6W10sY2hpbGRyZW46W10scGFyYW1zOnt9fTtyZXR1cm4gdC5wYXJhbXMmJihhLnBhcmFtcz10LnBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24odCxhKXt2YXIgcj1hLnRmSW5wdXRJbmRleCxwPWEudGZJbnB1dFBhcmFtTGVuZ3RoLG89YS50eXBlLHM7aWYodm9pZCAwPT09cilzd2l0Y2goYS50eXBlKXtjYXNlXCJzdHJpbmdcIjp2b2lkIDA9PT0ocz1lLmdldFN0cmluZ1BhcmFtKG4uYXR0cixhLnRmUGFyYW1OYW1lLGEuZGVmYXVsdFZhbHVlKSkmJmEudGZQYXJhbU5hbWVEZXByZWNhdGVkJiYocz1lLmdldFN0cmluZ1BhcmFtKG4uYXR0cixhLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCxhLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcIm51bWJlclwiOnZvaWQgMD09PShzPWUuZ2V0TnVtYmVyUGFyYW0obi5hdHRyLGEudGZQYXJhbU5hbWUsYS5kZWZhdWx0VmFsdWUpKSYmYS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQmJihzPWUuZ2V0TnVtYmVyUGFyYW0obi5hdHRyLGEudGZQYXJhbU5hbWVEZXByZWNhdGVkLGEuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwibnVtYmVyW11cIjp2b2lkIDA9PT0ocz1lLmdldE51bWVyaWNBcnJheVBhcmFtKG4uYXR0cixhLnRmUGFyYW1OYW1lLGEuZGVmYXVsdFZhbHVlKSkmJmEudGZQYXJhbU5hbWVEZXByZWNhdGVkJiYocz1lLmdldE51bWVyaWNBcnJheVBhcmFtKG4uYXR0cixhLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCxhLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcImJvb2xcIjp2b2lkIDA9PT0ocz1lLmdldEJvb2xQYXJhbShuLmF0dHIsYS50ZlBhcmFtTmFtZSxhLmRlZmF1bHRWYWx1ZSkpJiZhLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCYmKHM9ZS5nZXRCb29sUGFyYW0obi5hdHRyLGEudGZQYXJhbU5hbWVEZXByZWNhdGVkLGEuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwic2hhcGVcIjp2b2lkIDA9PT0ocz1lLmdldFRlbnNvclNoYXBlUGFyYW0obi5hdHRyLGEudGZQYXJhbU5hbWUsYS5kZWZhdWx0VmFsdWUpKSYmYS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQmJihzPWUuZ2V0VGVuc29yU2hhcGVQYXJhbShuLmF0dHIsYS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQsYS5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJkdHlwZVwiOnZvaWQgMD09PShzPWUuZ2V0RHR5cGVQYXJhbShuLmF0dHIsYS50ZlBhcmFtTmFtZSxhLmRlZmF1bHRWYWx1ZSkpJiZhLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCYmKHM9ZS5nZXREdHlwZVBhcmFtKG4uYXR0cixhLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCxhLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInRlbnNvclwiOmNhc2VcInRlbnNvcnNcIjpicmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBhcmFtIHR5cGU6IFwiK2EudHlwZStcIiBmb3Igb3A6IFwiK24ub3ApO31yZXR1cm4gdFthLmRsUGFyYW1OYW1lXT17dmFsdWU6cyxpbnB1dEluZGV4OnIsdHlwZTpvLGlucHV0UGFyYW1MZW5ndGg6cH0sdH0se30pKSxhfSx0LnByb3RvdHlwZS5nZXRTdHJpbmdQYXJhbT1mdW5jdGlvbihzLGUsdCxhKXt2b2lkIDA9PT1hJiYoYT0hMSk7dmFyIGk9c1tlXTtpZih2b2lkIDAhPT1pKXt2YXIgbj1fU3RyaW5nZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsaS5zKTtyZXR1cm4gYT9uOm4udG9Mb3dlckNhc2UoKX1yZXR1cm4gdH0sdC5wcm90b3R5cGUuZ2V0Qm9vbFBhcmFtPWZ1bmN0aW9uKG4sZSx0KXt2YXIgYT1uW2VdO3JldHVybiBhP2EuYjp0fSx0LnByb3RvdHlwZS5nZXROdW1iZXJQYXJhbT1mdW5jdGlvbihvLGUsdCl7dmFyIGE9b1tlXSxyPWE/YVthLnZhbHVlXTp0O3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP3I6ci50b0ludCgpfSx0LnByb3RvdHlwZS5nZXREdHlwZVBhcmFtPWZ1bmN0aW9uKG4sZSx0KXt2YXIgYT1uW2VdO2lmKGEmJmEudHlwZSlzd2l0Y2goYS50eXBlKXtjYXNlIGNvbXBpbGVkX2FwaV8xLkRhdGFUeXBlLkRUX0ZMT0FUOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgY29tcGlsZWRfYXBpXzEuRGF0YVR5cGUuRFRfSU5UMzI6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgY29tcGlsZWRfYXBpXzEuRGF0YVR5cGUuRFRfQk9PTDpyZXR1cm5cImJvb2xcIjtkZWZhdWx0OnJldHVybiB0O31yZXR1cm4gdH0sdC5wcm90b3R5cGUuZ2V0VGVuc29yU2hhcGVQYXJhbT1mdW5jdGlvbihuLGUsdCl7dmFyIGE9bltlXTtyZXR1cm4gYSYmYS5zaGFwZT9hLnNoYXBlLmRpbS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQuc2l6ZT90LnNpemU6dC5zaXplLnRvSW50KCl9KTp0fSx0LnByb3RvdHlwZS5nZXROdW1lcmljQXJyYXlQYXJhbT1mdW5jdGlvbihuLGUsdCl7dmFyIGE9bltlXTtyZXR1cm4gYT8oYS5saXN0LmYmJmEubGlzdC5mLmxlbmd0aD9hLmxpc3QuZjphLmxpc3QuaSkubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P3Q6dC50b0ludCgpfSk6dH0sdH0oKSxleGVjdXRlT3A9ZnVuY3Rpb24obixlLHQpe3N3aXRjaChuLm9wKXtjYXNlXCJhZGRcIjpyZXR1cm5bYWRkKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07Y2FzZVwiYWRkTlwiOnJldHVyblthZGROKGdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JzXCIsbixlLHQpKV07Y2FzZVwibW9kXCI6cmV0dXJuW21vZChnZXRQYXJhbVZhbHVlKFwiYVwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYlwiLG4sZSx0KSldO2Nhc2VcIm11bFwiOnJldHVyblttdWwoZ2V0UGFyYW1WYWx1ZShcImFcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImJcIixuLGUsdCkpXTtjYXNlXCJkaXZcIjpyZXR1cm5bZGl2KGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07Y2FzZVwiZmxvb3JEaXZcIjpyZXR1cm5bZmxvb3JEaXYoZ2V0UGFyYW1WYWx1ZShcImFcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImJcIixuLGUsdCkpXTtjYXNlXCJzdWJcIjpyZXR1cm5bc3ViKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07Y2FzZVwibWluaW11bVwiOnJldHVyblttaW5pbXVtKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07Y2FzZVwibWF4aW11bVwiOnJldHVyblttYXhpbXVtKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07Y2FzZVwicG93XCI6cmV0dXJuW3BvdyhnZXRQYXJhbVZhbHVlKFwiYVwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYlwiLG4sZSx0KSldO2Nhc2VcInNxdWFyZWREaWZmZXJlbmNlXCI6cmV0dXJuW3NxdWFyZWREaWZmZXJlbmNlKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrbi5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7fX0sZXhlY3V0ZU9wJDE9ZnVuY3Rpb24obixlLHQpe3N3aXRjaChuLm9wKXtjYXNlXCJhYnNcIjpyZXR1cm5bYWJzKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwiYWNvc1wiOnJldHVyblthY29zKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwiYWNvc2hcIjpyZXR1cm5bYWNvc2goZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJhc2luXCI6cmV0dXJuW2FzaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJhc2luaFwiOnJldHVyblthc2luaChnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcImF0YW5cIjpyZXR1cm5bYXRhbihnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcImF0YW4yXCI6cmV0dXJuW2F0YW4yKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJ5XCIsbixlLHQpKV07Y2FzZVwiYXRhbmhcIjpyZXR1cm5bYXRhbmgoZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJjZWlsXCI6cmV0dXJuW2NlaWwoZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJjb3NcIjpyZXR1cm5bY29zKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwiY29zaFwiOnJldHVybltjb3NoKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwiZWx1XCI6cmV0dXJuW2VsdShnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcImVyZlwiOnJldHVybltlcmYoZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJleHBcIjpyZXR1cm5bZXhwKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwiZXhwbTFcIjpyZXR1cm5bZXhwbTEoZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJmbG9vclwiOnJldHVybltmbG9vcihnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcImxvZ1wiOnJldHVybltsb2ckMShnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcImxvZzFwXCI6cmV0dXJuW2xvZzFwKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwibmVnXCI6cmV0dXJuW25lZyhnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcInJlY2lwcm9jYWxcIjpyZXR1cm5bcmVjaXByb2NhbChnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcInJlbHVcIjpyZXR1cm5bcmVsdShnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcInJvdW5kXCI6cmV0dXJuW3JvdW5kKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwic2VsdVwiOnJldHVybltzZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwic2lnbW9pZFwiOnJldHVybltzaWdtb2lkKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwic2luXCI6cmV0dXJuW3NpbihnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcInNpZ25cIjpyZXR1cm5bc2lnbihnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcInNpbmhcIjpyZXR1cm5bc2luaChnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcInNvZnRwbHVzXCI6cmV0dXJuW3NvZnRwbHVzKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwic3FydFwiOnJldHVybltzcXJ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwic3F1YXJlXCI6cmV0dXJuW3NxdWFyZShnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcInRhbmhcIjpyZXR1cm5bdGFuaCQxKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpKV07Y2FzZVwidGFuXCI6cmV0dXJuW3RhbihnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSldO2Nhc2VcImNsaXBCeVZhbHVlXCI6cmV0dXJuW2NsaXBCeVZhbHVlKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJjbGlwVmFsdWVNaW5cIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImNsaXBWYWx1ZU1heFwiLG4sZSx0KSldO2Nhc2VcInJzcXJ0XCI6cmV0dXJuW2RpdihzY2FsYXIoMSxcImZsb2F0MzJcIiksc3FydChnZXRUZW5zb3Iobi5pbnB1dE5hbWVzWzBdLGUsdCkpKV07Y2FzZVwicHJvZFwiOnJldHVybltwcm9kKGdldFBhcmFtVmFsdWUoXCJ4XCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJheGVzXCIsbixlLHQpKV07Y2FzZVwibGVha3lSZWx1XCI6cmV0dXJuW2xlYWt5UmVsdShnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYWxwaGFcIixuLGUsdCkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIituLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTt9fSxUZW5zb3JBcnJheT1mdW5jdGlvbigpe2Z1bmN0aW9uIHAoZSx0LGEscixuLG8scyl7dGhpcy5uYW1lPWUsdGhpcy5kdHlwZT10LHRoaXMubWF4U2l6ZT1hLHRoaXMuZWxlbWVudFNoYXBlPXIsdGhpcy5pZGVudGljYWxFbGVtZW50U2hhcGVzPW4sdGhpcy5keW5hbWljU2l6ZT1vLHRoaXMuY2xlYXJBZnRlclJlYWQ9cyx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSExLHRoaXMuaWQ9cC5uZXh0SWQrK31yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHAucHJvdG90eXBlLFwiY2xvc2VkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsb3NlZF99LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSkscC5wcm90b3R5cGUuY2xlYXJBbmRDbG9zZT1mdW5jdGlvbigpe3RoaXMudGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRlbnNvci5kaXNwb3NlKCl9KSx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSEwfSxwLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGVuc29ycy5sZW5ndGh9LHAucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oYSl7aWYodGhpcy5jbG9zZWRfKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIiBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7aWYoMD5hfHxhPj10aGlzLnRlbnNvcnMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHJlYWQgZnJvbSBpbmRleCBcIithK1wiLCBidXQgYXJyYXkgc2l6ZSBpczogXCIrdGhpcy50ZW5zb3JzLmxlbmd0aCk7dmFyIGU9dGhpcy50ZW5zb3JzW2FdO2lmKGUuY2xlYXJlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCByZWFkIGluZGV4IFwiK2ErXCIgdHdpY2UgYmVjYXVzZSBpdCB3YXMgY2xlYXJlZCBhZnRlciBhIHByZXZpb3VzIHJlYWQgKHBlcmhhcHMgdHJ5IHNldHRpbmcgY2xlYXJfYWZ0ZXJfcmVhZCA9IGZhbHNlPykuXCIpO3JldHVybiB0aGlzLmNsZWFyQWZ0ZXJSZWFkJiYoZS5jbGVhcmVkPSEwKSxlLnJlYWQ9ITAsZS50ZW5zb3J9LHAucHJvdG90eXBlLnJlYWRNYW55PWZ1bmN0aW9uKGEpe3ZhciBuPXRoaXM7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuLnJlYWQodCl9KX0scC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24obixlKXtpZih0aGlzLmNsb3NlZF8pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtpZigwPm58fCF0aGlzLmR5bmFtaWNTaXplJiZuPj10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gd3JpdGUgdG8gaW5kZXggXCIrbitcIiwgYnV0IGFycmF5IGlzIG5vdCByZXNpemVhYmxlIGFuZCBzaXplIGlzOiBcIit0aGlzLm1heFNpemUpO3ZhciB0PXRoaXMudGVuc29yc1tuXXx8e307aWYoZS5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrbitcIixcXG4gICAgICAgICAgYmVjYXVzZSB0aGUgdmFsdWUgZHR5cGUgaXMgXCIrZS5kdHlwZStcIiwgYnV0IFRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIuXCIpO2lmKDA9PT10aGlzLnNpemUoKSYmMD09PXRoaXMuZWxlbWVudFNoYXBlLmxlbmd0aCYmKHRoaXMuZWxlbWVudFNoYXBlPWUuc2hhcGUpLHRoaXMuYXNzZXJ0U2hhcGVzTWF0Y2godGhpcy5lbGVtZW50U2hhcGUsZS5zaGFwZSxcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiK24rXCIuXCIpLHQmJnQucmVhZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIituK1wiLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcmVhZC5cIik7aWYodCYmdC53cml0dGVuKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiK24rXCIsIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuLlwiKTt0LnRlbnNvcj1lLHQud3JpdHRlbj0hMCx0aGlzLnRlbnNvcnNbbl09dH0scC5wcm90b3R5cGUud3JpdGVNYW55PWZ1bmN0aW9uKG4sbyl7dmFyIHQ9dGhpcztpZihuLmxlbmd0aCE9PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogY291bGQgbm90IHdyaXRlIG11bHRpcGxlIHRlbnNvcnMsYmVjYXVzZSB0aGUgaW5kZXggc2l6ZTogXCIrbi5sZW5ndGgrXCIgaXMgbm90IHRoZSBzYW1lIGFzIHRlbnNvcnMgc2l6ZTogXCIrby5sZW5ndGgrXCIuXCIpO24uZm9yRWFjaChmdW5jdGlvbihhLGUpe3JldHVybiB0LndyaXRlKGEsb1tlXSl9KX0scC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKG4sbyl7aWYobyYmbyE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgZ2F0aGVyIHJlcXVlc3RlZCBkdHlwZSBcIitvKTtpZighbil7bj1bXTtmb3IodmFyIHQ9MDt0PHRoaXMuc2l6ZSgpO3QrKyluLnB1c2godCl9aWYoMD09PW4ubGVuZ3RoKXJldHVybiB0ZW5zb3IoW10sWzBdLmNvbmNhdCh0aGlzLmVsZW1lbnRTaGFwZSkpO3ZhciBzPXRoaXMucmVhZE1hbnkobik7cmV0dXJuIHRoaXMuYXNzZXJ0U2hhcGVzTWF0Y2godGhpcy5lbGVtZW50U2hhcGUsc1swXS5zaGFwZSxcIlRlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiBcIiksc3RhY2socywwKX0scC5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKG4pe2lmKG4mJm4hPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IGNvbmNhdCByZXF1ZXN0ZWQgZHR5cGUgXCIrbik7aWYoMD09PXRoaXMuc2l6ZSgpKXJldHVybiB0ZW5zb3IoW10sWzBdLmNvbmNhdCh0aGlzLmVsZW1lbnRTaGFwZSkpO2Zvcih2YXIgZT1bXSx0PTA7dDx0aGlzLnNpemUoKTt0KyspZS5wdXNoKHQpO3ZhciBvPXRoaXMucmVhZE1hbnkoZSk7cmV0dXJuIHRoaXMuYXNzZXJ0U2hhcGVzTWF0Y2godGhpcy5lbGVtZW50U2hhcGUsb1swXS5zaGFwZSxcIlRlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiB0ZW5zb3IgYXJyYXkgc2hhcGUgKFwiK3RoaXMuZWxlbWVudFNoYXBlK1wiKSB2cyBmaXJzdCB0ZW5zb3Igc2hhcGUgKFwiK29bMF0uc2hhcGUrXCIpXCIpLGNvbmNhdChvLDApfSxwLnByb3RvdHlwZS5zY2F0dGVyPWZ1bmN0aW9uKG4sZSl7aWYoZS5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgdGVuc29yIGhhcyBkdHlwZSBcIitlLmR0eXBlKTtpZihuLmxlbmd0aCE9PWUuc2hhcGVbMF0pdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbGVuKGluZGljZXMpID09IHRlbnNvci5zaGFwZVswXSwgYnV0IHNhdzogXCIrbi5sZW5ndGgrXCIgdnMuIFwiK2Uuc2hhcGVbMF0pO3ZhciB0PV9NYXRobWF4LmFwcGx5KE1hdGgsbik7aWYoIXRoaXMuZHluYW1pY1NpemUmJnQ+PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJNYXggaW5kZXggbXVzdCBiZSA8IGFycmF5IHNpemUgKFwiK3QrXCIgIHZzLiBcIit0aGlzLm1heFNpemUrXCIpXCIpO3RoaXMud3JpdGVNYW55KG4sdW5zdGFjayhlLDApKX0scC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24obCxlKXt2YXIgZD10aGlzO2lmKGUuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IHRlbnNvciBoYXMgZHR5cGUgXCIrZS5kdHlwZSk7dmFyIGE9MCx1PWwubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBhKz10fSk7aWYoYSE9PWUuc2hhcGVbMF0pdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3VtIG9mIGxlbmd0aHMgdG8gYmUgZXF1YWwgdG9cXG4gICAgICAgICAgdGVuc29yLnNoYXBlWzBdLCBidXQgc3VtIG9mIGxlbmd0aHMgaXNcXG4gICAgICAgIFwiK2ErXCIsIGFuZCB0ZW5zb3IncyBzaGFwZSBpczogXCIrZS5zaGFwZSk7aWYoIXRoaXMuZHluYW1pY1NpemUmJmwubGVuZ3RoIT09dGhpcy5tYXhTaXplKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5J3Mgc2l6ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHNpemUgb2YgbGVuZ3RocyAoXCIrdGhpcy5tYXhTaXplK1wiIHZzLiBcIitsLmxlbmd0aCtcIiksIGFuZCB0aGUgVGVuc29yQXJyYXkgaXMgbm90IG1hcmtlZCBhcyBkeW5hbWljYWxseSByZXNpemVhYmxlXCIpO3ZhciBuPTA9PT1hPzA6ZS5zaXplL2Esbz1bXTt0aWR5KGZ1bmN0aW9uKCl7ZT1lLnJlc2hhcGUoWzEsYSxuXSk7Zm9yKHZhciB0PTA7dDxsLmxlbmd0aDsrK3Qpe3ZhciByPVswLDA9PXQ/MDp1W3QtMV0sMF0scz1bMSxsW3RdLG5dO29bdF09c2xpY2UoZSxyLHMpLnJlc2hhcGUoZC5lbGVtZW50U2hhcGUpfXJldHVybiBvfSk7Zm9yKHZhciBzPVtdLGk9MDtpPGwubGVuZ3RoO2krKylzW2ldPWk7dGhpcy53cml0ZU1hbnkocyxvKX0scC5wcm90b3R5cGUuYXNzZXJ0U2hhcGVzTWF0Y2g9ZnVuY3Rpb24obixlLHQpe3ZvaWQgMD09PXQmJih0PVwiXCIpLHV0aWwuYXNzZXJ0KHRoaXMuYXJyYXlzRXF1YWwobixlKSx0K1wiIFNoYXBlcyBcIituK1wiIGFuZCBcIitlK1wiIG11c3QgbWF0Y2hcIil9LHAucHJvdG90eXBlLmFycmF5c0VxdWFsPWZ1bmN0aW9uKG4sZSl7aWYobi5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIHQ9MDt0PG4ubGVuZ3RoO3QrKylpZigtMSE9PW5bdF0mJi0xIT09ZVt0XSYmblt0XSE9PWVbdF0pcmV0dXJuITE7cmV0dXJuITB9LHAubmV4dElkPTAscH0oKSxleGVjdXRlT3AkMz1mdW5jdGlvbihsLGUsdCl7c3dpdGNoKGwub3Ape2Nhc2VcImNvbnYxZFwiOnZhciBhPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVcIixsLGUsdCksZD1nZXRQYXJhbVZhbHVlKFwicGFkXCIsbCxlLHQpLHU9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixsLGUsdCkudG9VcHBlckNhc2UoKSxjPWdldFBhcmFtVmFsdWUoXCJkaWxhdGlvblwiLGwsZSx0KTtyZXR1cm5bY29udjFkKGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLGdldFBhcmFtVmFsdWUoXCJmaWx0ZXJcIixsLGUsdCksYSxkLHUsYyldO2Nhc2VcImNvbnYyZFwiOmE9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixsLGUsdCksZD1nZXRQYXJhbVZhbHVlKFwicGFkXCIsbCxlLHQpLHU9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixsLGUsdCkudG9VcHBlckNhc2UoKTt2YXIgcz1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25zXCIsbCxlLHQpO3JldHVybltjb252MmQoZ2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGwsZSx0KSxbYVsxXSxhWzJdXSxkLHUsW3NbMF0sc1sxXV0pXTtjYXNlXCJjb252MmRUcmFuc3Bvc2VcIjp2YXIgaD1nZXRQYXJhbVZhbHVlKFwib3V0cHV0U2hhcGVcIixsLGUsdCk7cmV0dXJuIGE9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixsLGUsdCksZD1nZXRQYXJhbVZhbHVlKFwicGFkXCIsbCxlLHQpLFtjb252MmRUcmFuc3Bvc2UoZ2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGwsZSx0KSxoLFthWzFdLGFbMl1dLGQpXTtjYXNlXCJkZXB0aHdpc2VDb252MmRcIjpyZXR1cm4gYT1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGwsZSx0KSxkPWdldFBhcmFtVmFsdWUoXCJwYWRcIixsLGUsdCkscz1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25zXCIsbCxlLHQpLHU9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixsLGUsdCkudG9VcHBlckNhc2UoKSxbZGVwdGh3aXNlQ29udjJkKGdldFBhcmFtVmFsdWUoXCJpbnB1dFwiLGwsZSx0KSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsbCxlLHQpLFthWzFdLGFbMl1dLGQsdSxbc1swXSxzWzFdXSldO2Nhc2VcImF2Z1Bvb2xcIjphPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsbCxlLHQpLGQ9Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGwsZSx0KTt2YXIgcD1nZXRQYXJhbVZhbHVlKFwia2VybmVsU2l6ZVwiLGwsZSx0KTtyZXR1cm5bYXZnUG9vbChnZXRQYXJhbVZhbHVlKFwieFwiLGwsZSx0KSxbcFsxXSxwWzJdXSxbYVsxXSxhWzJdXSxkKV07Y2FzZVwibWF4UG9vbFwiOnJldHVybiBhPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsbCxlLHQpLGQ9Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGwsZSx0KSxwPWdldFBhcmFtVmFsdWUoXCJrZXJuZWxTaXplXCIsbCxlLHQpLFttYXhQb29sKGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLFtwWzFdLHBbMl1dLFthWzFdLGFbMl1dLGQpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitsLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTt9fSxleGVjdXRlT3AkND1mdW5jdGlvbihiLGUsdCl7c3dpdGNoKGIub3Ape2Nhc2VcImZpbGxcIjp2YXIgYT1nZXRQYXJhbVZhbHVlKFwic2hhcGVcIixiLGUsdCkseD1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixiLGUsdCksbj1nZXRQYXJhbVZhbHVlKFwidmFsdWVcIixiLGUsdCk7cmV0dXJuW2ZpbGwoYSxuLHgpXTtjYXNlXCJsaW5zcGFjZVwiOnZhciBvPWdldFBhcmFtVmFsdWUoXCJzdGFydFwiLGIsZSx0KSxOPWdldFBhcmFtVmFsdWUoXCJzdG9wXCIsYixlLHQpLGk9Z2V0UGFyYW1WYWx1ZShcIm51bVwiLGIsZSx0KTtyZXR1cm5bbGluc3BhY2UobyxOLGkpXTtjYXNlXCJvbmVIb3RcIjp2YXIgcD1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGIsZSx0KSxtPWdldFBhcmFtVmFsdWUoXCJkZXB0aFwiLGIsZSx0KSx1PWdldFBhcmFtVmFsdWUoXCJvblZhbHVlXCIsYixlLHQpLGw9Z2V0UGFyYW1WYWx1ZShcIm9mZlZhbHVlXCIsYixlLHQpO3JldHVybltvbmVIb3QocCxtLHUsbCldO2Nhc2VcIm9uZXNcIjpyZXR1cm5bb25lcyQxKGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGIsZSx0KSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixiLGUsdCkpXTtjYXNlXCJvbmVzTGlrZVwiOnJldHVybltvbmVzTGlrZShnZXRQYXJhbVZhbHVlKFwieFwiLGIsZSx0KSldO2Nhc2VcInJhbmRvbVVuaWZvcm1cIjpyZXR1cm5bcmFuZG9tVW5pZm9ybShnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixiLGUsdCksZ2V0UGFyYW1WYWx1ZShcIm1pbnZhbFwiLGIsZSx0KSxnZXRQYXJhbVZhbHVlKFwibWF4dmFsXCIsYixlLHQpLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGIsZSx0KSldO2Nhc2VcInJhbmdlXCI6bz1nZXRQYXJhbVZhbHVlKFwic3RhcnRcIixiLGUsdCk7dmFyIGQ9Z2V0UGFyYW1WYWx1ZShcInN0b3BcIixiLGUsdCksYz1nZXRQYXJhbVZhbHVlKFwic3RlcFwiLGIsZSx0KTtyZXR1cm5bcmFuZ2UobyxkLGMsZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsYixlLHQpKV07Y2FzZVwidHJ1bmNhdGVkTm9ybWFsXCI6YT1nZXRQYXJhbVZhbHVlKFwic2hhcGVcIixiLGUsdCk7dmFyIGY9Z2V0UGFyYW1WYWx1ZShcIm1lYW5cIixiLGUsdCkseT1nZXRQYXJhbVZhbHVlKFwic3RkRGV2XCIsYixlLHQpLGg9Z2V0UGFyYW1WYWx1ZShcInNlZWRcIixiLGUsdCk7cmV0dXJuW3RydW5jYXRlZE5vcm1hbChhLGYseSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixiLGUsdCksaCldO2Nhc2VcInplcm9zXCI6cmV0dXJuW3plcm9zKGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGIsZSx0KSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixiLGUsdCkpXTtjYXNlXCJ6ZXJvc0xpa2VcIjpyZXR1cm5bemVyb3NMaWtlKGdldFBhcmFtVmFsdWUoXCJ4XCIsYixlLHQpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrYi5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7fX0sZXhlY3V0ZU9wJDY9ZnVuY3Rpb24oaSxlLHQpe3N3aXRjaChpLm9wKXtjYXNlXCJ0b3BLXCI6dmFyIGE9Z2V0UGFyYW1WYWx1ZShcInhcIixpLGUsdCkscj1nZXRQYXJhbVZhbHVlKFwia1wiLGksZSx0KSxuPWdldFBhcmFtVmFsdWUoXCJzb3J0ZWRcIixpLGUsdCksbz10b3BrKGEscixuKTtyZXR1cm5bby52YWx1ZXMsby5pbmRpY2VzXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitpLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTt9fSxleGVjdXRlT3AkNz1mdW5jdGlvbihsLGUsdCl7c3dpdGNoKGwub3Ape2Nhc2VcImNvbnN0XCI6cmV0dXJuIGVbbC5uYW1lXTtjYXNlXCJwbGFjZWhvbGRlclwiOnZhciBhPWdldFBhcmFtVmFsdWUoXCJkZWZhdWx0XCIsbCxlLHQpO3JldHVybltnZXRUZW5zb3IobC5uYW1lLGUsdCl8fGFdO2Nhc2VcImlkZW50aXR5XCI6Y2FzZVwic3RvcEdyYWRpZW50XCI6Y2FzZVwiZmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIjpyZXR1cm5bZ2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCkuY2xvbmUoKV07Y2FzZVwic25hcHNob3RcIjpyZXR1cm5bZ2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCkuY2xvbmUoKV07Y2FzZVwic2hhcGVcIjpyZXR1cm5bdGVuc29yMWQoZ2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCkuc2hhcGUsXCJpbnQzMlwiKV07Y2FzZVwic2hhcGVOXCI6cmV0dXJuIGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGVuc29yMWQodC5zaGFwZSl9KTtjYXNlXCJzaXplXCI6cmV0dXJuW3NjYWxhcihnZXRQYXJhbVZhbHVlKFwieFwiLGwsZSx0KS5zaXplLFwiaW50MzJcIildO2Nhc2VcInJhbmtcIjpyZXR1cm5bc2NhbGFyKGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLnJhbmssXCJpbnQzMlwiKV07Y2FzZVwibm9vcFwiOnJldHVybltdO2Nhc2VcInByaW50XCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCksbj1nZXRQYXJhbVZhbHVlKFwiZGF0YVwiLGwsZSx0KSxvPWdldFBhcmFtVmFsdWUoXCJtZXNzYWdlXCIsbCxlLHQpLHM9Z2V0UGFyYW1WYWx1ZShcInN1bW1hcml6ZVwiLGwsZSx0KTtjb25zb2xlLndhcm4oXCJUaGUgZ3JhcGggaGFzIGEgdGYucHJpbnQoKSBvcGVyYXRpb24sdXN1YWxseSB1c2VkIGZvciBkZWJ1Z2dpbmcsIHdoaWNoIHNsb3dzIGRvd24gcGVyZm9ybWFuY2UuXCIpLGNvbnNvbGUubG9nKG8pO2Zvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKWNvbnNvbGUubG9nKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5bMF0uZGF0YVN5bmMoKSkuc2xpY2UoMCxzKSk7cmV0dXJuW3JdO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2wub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO319LGV4ZWN1dGVPcCQ4PWZ1bmN0aW9uKGQsZSx0KXtzd2l0Y2goZC5vcCl7Y2FzZVwicmVzaXplQmlsaW5lYXJcIjp2YXIgYT1nZXRQYXJhbVZhbHVlKFwiaW1hZ2VzXCIsZCxlLHQpLGM9Z2V0UGFyYW1WYWx1ZShcInNpemVcIixkLGUsdCksaD1nZXRQYXJhbVZhbHVlKFwiYWxpZ25Db3JuZXJzXCIsZCxlLHQpO3JldHVybltpbWFnZV9vcHMucmVzaXplQmlsaW5lYXIoYSxbY1swXSxjWzFdXSxoKV07Y2FzZVwicmVzaXplTmVhcmVzdE5laWdoYm9yXCI6cmV0dXJuIGE9Z2V0UGFyYW1WYWx1ZShcImltYWdlc1wiLGQsZSx0KSxjPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZCxlLHQpLGg9Z2V0UGFyYW1WYWx1ZShcImFsaWduQ29ybmVyc1wiLGQsZSx0KSxbaW1hZ2Vfb3BzLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihhLFtjWzBdLGNbMV1dLGgpXTtjYXNlXCJjcm9wQW5kUmVzaXplXCI6dmFyIGc9Z2V0UGFyYW1WYWx1ZShcImltYWdlXCIsZCxlLHQpLHM9Z2V0UGFyYW1WYWx1ZShcImJveGVzXCIsZCxlLHQpLGk9Z2V0UGFyYW1WYWx1ZShcImJveEluZFwiLGQsZSx0KSxwPWdldFBhcmFtVmFsdWUoXCJjcm9wU2l6ZVwiLGQsZSx0KSxtPWdldFBhcmFtVmFsdWUoXCJtZXRob2RcIixkLGUsdCksdT1nZXRQYXJhbVZhbHVlKFwiZXh0cmFwb2xhdGlvblZhbHVlXCIsZCxlLHQpO3JldHVybltpbWFnZV9vcHMuY3JvcEFuZFJlc2l6ZShnLHMsaSxwLG0sdSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Qub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO319LGV4ZWN1dGVPcCQ5PWZ1bmN0aW9uKG4sZSx0KXtzd2l0Y2gobi5vcCl7Y2FzZVwiZXF1YWxcIjpyZXR1cm5bZXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImJcIixuLGUsdCkpXTtjYXNlXCJub3RFcXVhbFwiOnJldHVybltub3RFcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYlwiLG4sZSx0KSldO2Nhc2VcImdyZWF0ZXJcIjpyZXR1cm5bZ3JlYXRlcihnZXRQYXJhbVZhbHVlKFwiYVwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYlwiLG4sZSx0KSldO2Nhc2VcImdyZWF0ZXJFcXVhbFwiOnJldHVybltncmVhdGVyRXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImJcIixuLGUsdCkpXTtjYXNlXCJsZXNzXCI6cmV0dXJuW2xlc3MoZ2V0UGFyYW1WYWx1ZShcImFcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImJcIixuLGUsdCkpXTtjYXNlXCJsZXNzRXF1YWxcIjpyZXR1cm5bbGVzc0VxdWFsKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07Y2FzZVwibG9naWNhbEFuZFwiOnJldHVybltsb2dpY2FsQW5kKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpKV07Y2FzZVwibG9naWNhbE5vdFwiOnJldHVybltsb2dpY2FsTm90KGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpKV07Y2FzZVwibG9naWNhbE9yXCI6cmV0dXJuW2xvZ2ljYWxPcihnZXRQYXJhbVZhbHVlKFwiYVwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYlwiLG4sZSx0KSldO2Nhc2VcIndoZXJlXCI6cmV0dXJuW3doZXJlKGdldFBhcmFtVmFsdWUoXCJjb25kaXRpb25cIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImFcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImJcIixuLGUsdCkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIituLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTt9fSxleGVjdXRlT3AkMTA9ZnVuY3Rpb24obixlLHQpe3N3aXRjaChuLm9wKXtjYXNlXCJtYXRNdWxcIjpyZXR1cm5bbWF0TXVsKGdldFBhcmFtVmFsdWUoXCJhXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJiXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJ0cmFuc3Bvc2VBXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJ0cmFuc3Bvc2VCXCIsbixlLHQpKV07Y2FzZVwidHJhbnNwb3NlXCI6cmV0dXJuW3RyYW5zcG9zZShnZXRQYXJhbVZhbHVlKFwieFwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwicGVybVwiLG4sZSx0KSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK24ub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO319LGV4ZWN1dGVPcCQxMT1mdW5jdGlvbihuLGUsdCl7c3dpdGNoKG4ub3Ape2Nhc2VcImJhdGNoTm9ybWFsaXphdGlvblwiOnJldHVybltiYXRjaE5vcm1hbGl6YXRpb24oZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcIm1lYW5cIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcInZhcmlhbmNlXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJlcHNpbG9uXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJzY2FsZVwiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwib2Zmc2V0XCIsbixlLHQpKV07Y2FzZVwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25cIjpyZXR1cm5bbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24oZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcInJhZGl1c1wiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYmlhc1wiLG4sZSx0KSxnZXRQYXJhbVZhbHVlKFwiYWxwaGFcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImJldGFcIixuLGUsdCkpXTtjYXNlXCJzb2Z0bWF4XCI6cmV0dXJuW3NvZnRtYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJsb2dTb2Z0bWF4XCI6cmV0dXJuW2xvZ1NvZnRtYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixuLGUsdCkpXTtjYXNlXCJzcGFyc2VUb0RlbnNlXCI6cmV0dXJuW3NwYXJzZVRvRGVuc2UoZ2V0UGFyYW1WYWx1ZShcInNwYXJzZUluZGljZXNcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcIm91dHB1dFNoYXBlXCIsbixlLHQpLGdldFBhcmFtVmFsdWUoXCJzcGFyc2VWYWx1ZXNcIixuLGUsdCksZ2V0UGFyYW1WYWx1ZShcImRlZmF1bHRWYWx1ZVwiLG4sZSx0KSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK24ub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO319LGV4ZWN1dGVPcCQxMj1mdW5jdGlvbihvLGUsdCl7c3dpdGNoKG8ub3Ape2Nhc2VcIm1heFwiOnZhciBhPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsbyxlLHQpLHM9Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsbyxlLHQpO3JldHVyblttYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixvLGUsdCksYSxzKV07Y2FzZVwibWVhblwiOnJldHVybiBhPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsbyxlLHQpLHM9Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsbyxlLHQpLFttZWFuKGdldFBhcmFtVmFsdWUoXCJ4XCIsbyxlLHQpLGEscyldO2Nhc2VcIm1pblwiOnJldHVybiBhPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsbyxlLHQpLHM9Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsbyxlLHQpLFttaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixvLGUsdCksYSxzKV07Y2FzZVwic3VtXCI6cmV0dXJuIGE9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixvLGUsdCkscz1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixvLGUsdCksW3N1bSQxKGdldFBhcmFtVmFsdWUoXCJ4XCIsbyxlLHQpLGEscyldO2Nhc2VcImFsbFwiOnJldHVybiBhPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsbyxlLHQpLHM9Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsbyxlLHQpLFthbGwoZ2V0UGFyYW1WYWx1ZShcInhcIixvLGUsdCksYSxzKV07Y2FzZVwiYW55XCI6cmV0dXJuIGE9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixvLGUsdCkscz1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixvLGUsdCksW2FueShnZXRQYXJhbVZhbHVlKFwieFwiLG8sZSx0KSxhLHMpXTtjYXNlXCJhcmdNYXhcIjpyZXR1cm4gYT1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLG8sZSx0KSxbYXJnTWF4KGdldFBhcmFtVmFsdWUoXCJ4XCIsbyxlLHQpLGEpXTtjYXNlXCJhcmdNaW5cIjpyZXR1cm4gYT1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLG8sZSx0KSxbYXJnTWluKGdldFBhcmFtVmFsdWUoXCJ4XCIsbyxlLHQpLGEpXTtjYXNlXCJwcm9kXCI6cmV0dXJuIGE9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixvLGUsdCkscz1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixvLGUsdCksW3Byb2QoZ2V0UGFyYW1WYWx1ZShcInhcIixvLGUsdCksYSxzKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrby5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7fX0sZXhlY3V0ZU9wJDEzPWZ1bmN0aW9uKFMsZSx0KXtzd2l0Y2goUy5vcCl7Y2FzZVwiY29uY2F0XCI6dmFyIGE9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixTLGUsdCksQz1nZXRQYXJhbVZhbHVlKFwidGVuc29yc1wiLFMsZSx0KTtyZXR1cm5bY29uY2F0KEMsYSldO2Nhc2VcImdhdGhlclwiOmE9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixTLGUsdCk7dmFyIG49Z2V0UGFyYW1WYWx1ZShcInhcIixTLGUsdCksaz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLFMsZSx0KTtyZXR1cm5bZ2F0aGVyKG4sayxhKV07Y2FzZVwicmV2ZXJzZVwiOnJldHVybiBhPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsUyxlLHQpLG49Z2V0UGFyYW1WYWx1ZShcInhcIixTLGUsdCksW3JldmVyc2UobixhKV07Y2FzZVwic2xpY2VcIjp2YXIgVD1nZXRQYXJhbVZhbHVlKFwiYmVnaW5cIixTLGUsdCksRT1nZXRQYXJhbVZhbHVlKFwic2l6ZVwiLFMsZSx0KTtyZXR1cm5bc2xpY2UoZ2V0UGFyYW1WYWx1ZShcInhcIixTLGUsdCksVCxFKV07Y2FzZVwic3RyaWRlZFNsaWNlXCI6VD1nZXRQYXJhbVZhbHVlKFwiYmVnaW5cIixTLGUsdCk7dmFyIHA9Z2V0UGFyYW1WYWx1ZShcImVuZFwiLFMsZSx0KSxtPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsUyxlLHQpLHU9Z2V0UGFyYW1WYWx1ZShcImJlZ2luTWFza1wiLFMsZSx0KSxsPWdldFBhcmFtVmFsdWUoXCJlbmRNYXNrXCIsUyxlLHQpLGQ9Z2V0UGFyYW1WYWx1ZShcImVsbGlwc2lzTWFza1wiLFMsZSx0KSxjPWdldFBhcmFtVmFsdWUoXCJuZXdBeGlzTWFza1wiLFMsZSx0KSxmPWdldFBhcmFtVmFsdWUoXCJzaHJpbmtBeGlzTWFza1wiLFMsZSx0KSx5PWdldFBhcmFtVmFsdWUoXCJ4XCIsUyxlLHQpO2lmKDE9PT1ULmxlbmd0aCYmMTx5LnNoYXBlLmxlbmd0aClmb3IodmFyIGg9MTtoPHkuc2hhcGUubGVuZ3RoO2grKylULnB1c2goMCkscC5wdXNoKHkuc2hhcGVbaF0pLG0ucHVzaChtWzBdKTtyZXR1cm5bc3RyaWRlZFNsaWNlKHksVCxwLG0sdSxsLGQsYyxmKV07Y2FzZVwic3RhY2tcIjpyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBhPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsUyxlLHQpLHI9Z2V0UGFyYW1WYWx1ZShcInRlbnNvcnNcIixTLGUsdCksbj1yWzBdLnNoYXBlLG89clswXS5zcXVlZXplKCkuc2hhcGUscz1yLm1hcChmdW5jdGlvbihhKXt2YXIgZT11dGlsLmFycmF5c0VxdWFsKGEuc2hhcGUsbik7aWYoIWUmJiF1dGlsLmFycmF5c0VxdWFsKGEuc3F1ZWV6ZSgpLnNoYXBlLG8pKXRocm93IG5ldyBFcnJvcihcInRoZSBpbnB1dCB0ZW5zb3JzIHNoYXBlIGRvZXMgbm90IG1hdGNoXCIpO3JldHVybiBlP2E6YS5yZXNoYXBlKG4pfSk7cmV0dXJuW3N0YWNrKHMsYSldfSk7Y2FzZVwidW5zdGFja1wiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIGE9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixTLGUsdCkscj1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsUyxlLHQpO3JldHVybiB1bnN0YWNrKHIsYSl9KTtjYXNlXCJ0aWxlXCI6dmFyIFI9Z2V0UGFyYW1WYWx1ZShcInJlcHNcIixTLGUsdCk7cmV0dXJuW3RpbGUoZ2V0UGFyYW1WYWx1ZShcInhcIixTLGUsdCksUildO2Nhc2VcInNwbGl0XCI6YT1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLFMsZSx0KTt2YXIgTj1nZXRQYXJhbVZhbHVlKFwibnVtT3JTaXplU3BsaXRzXCIsUyxlLHQpO3JldHVybiBzcGxpdCQxKGdldFBhcmFtVmFsdWUoXCJ4XCIsUyxlLHQpLE4sYSk7Y2FzZVwic2NhdHRlck5kXCI6az1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLFMsZSx0KTt2YXIgRD1nZXRQYXJhbVZhbHVlKFwidmFsdWVzXCIsUyxlLHQpLHg9Z2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsUyxlLHQpO3JldHVybltzY2F0dGVyTkQoayxELHgpXTtjYXNlXCJnYXRoZXJOZFwiOnZhciB3PWdldFBhcmFtVmFsdWUoXCJ4XCIsUyxlLHQpO3JldHVybiBrPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsUyxlLHQpLFtnYXRoZXJORCh3LGspXTtjYXNlXCJzcGFyc2VUb0RlbnNlXCI6az1nZXRQYXJhbVZhbHVlKFwic3BhcnNlSW5kaWNlc1wiLFMsZSx0KSx4PWdldFBhcmFtVmFsdWUoXCJvdXRwdXRTaGFwZVwiLFMsZSx0KTt2YXIgST1nZXRQYXJhbVZhbHVlKFwic3BhcnNlVmFsdWVzXCIsUyxlLHQpLHY9Z2V0UGFyYW1WYWx1ZShcImRlZmF1bHRWYWx1ZVwiLFMsZSx0KTtyZXR1cm5bc3BhcnNlVG9EZW5zZShrLEkseCx2KV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrUy5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7fX0sZXhlY3V0ZU9wJDE0PWZ1bmN0aW9uKGwsZSx0KXtzd2l0Y2gobC5vcCl7Y2FzZVwiY2FzdFwiOnJldHVybltjYXN0KGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGwsZSx0KSldO2Nhc2VcImV4cGFuZERpbXNcIjp2YXIgYT1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGwsZSx0KTtyZXR1cm5bZXhwYW5kRGltcyhnZXRQYXJhbVZhbHVlKFwieFwiLGwsZSx0KSxhKV07Y2FzZVwic3F1ZWV6ZVwiOnJldHVybiBhPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsbCxlLHQpLFtzcXVlZXplKGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLGEpXTtjYXNlXCJyZXNoYXBlXCI6cmV0dXJuW3Jlc2hhcGUoZ2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCksZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsbCxlLHQpKV07Y2FzZVwicGFkXCI6cmV0dXJuW3BhZChnZXRQYXJhbVZhbHVlKFwieFwiLGwsZSx0KSxzcGxpdCQxJDEoZ2V0UGFyYW1WYWx1ZShcInBhZGRpbmdcIixsLGUsdCksMiksZ2V0UGFyYW1WYWx1ZShcImNvbnN0YW50VmFsdWVcIixsLGUsdCkpXTtjYXNlXCJzcGFjZVRvQmF0Y2hORFwiOnZhciBkPWdldFBhcmFtVmFsdWUoXCJibG9ja1NoYXBlXCIsbCxlLHQpLHU9c3BsaXQkMSQxKGdldFBhcmFtVmFsdWUoXCJwYWRkaW5nc1wiLGwsZSx0KSwyKTtyZXR1cm5bc3BhY2VUb0JhdGNoTkQoZ2V0UGFyYW1WYWx1ZShcInhcIixsLGUsdCksZCx1KV07Y2FzZVwiYmF0Y2hUb1NwYWNlTkRcIjpkPWdldFBhcmFtVmFsdWUoXCJibG9ja1NoYXBlXCIsbCxlLHQpO3ZhciBvPXNwbGl0JDEkMShnZXRQYXJhbVZhbHVlKFwiY3JvcHNcIixsLGUsdCksMik7cmV0dXJuW2JhdGNoVG9TcGFjZU5EKGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLGQsbyldO2Nhc2VcImRlcHRoVG9TcGFjZVwiOnZhciBzPWdldFBhcmFtVmFsdWUoXCJibG9ja1NpemVcIixsLGUsdCksaT1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGwsZSx0KTtyZXR1cm5bZGVwdGhUb1NwYWNlKGdldFBhcmFtVmFsdWUoXCJ4XCIsbCxlLHQpLHMsaSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2wub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO319LEV4ZWN1dGlvbkNvbnRleHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGEsZSl7dGhpcy53ZWlnaHRNYXA9YSx0aGlzLnRlbnNvckFycmF5TWFwPWUsdGhpcy5yb290Q29udGV4dD17aWQ6MCxmcmFtZU5hbWU6XCJcIixpdGVyYXRpb25JZDowfSx0aGlzLmNvbnRleHRzPVt0aGlzLnJvb3RDb250ZXh0XSx0aGlzLmxhc3RJZD0wLHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpfXJldHVybiB0LnByb3RvdHlwZS5uZXdGcmFtZT1mdW5jdGlvbihhLGUpe3JldHVybntpZDphLGZyYW1lTmFtZTplLGl0ZXJhdGlvbklkOjB9fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZXh0c30sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY29udGV4dHMhPT10JiYodGhpcy5jb250ZXh0cz10LHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dElkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc1swXX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dElkc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudENvbnRleHRJZHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcz1mdW5jdGlvbigpe2Zvcih2YXIgbj1bXSxlPTAscjtlPHRoaXMuY29udGV4dHMubGVuZ3RoLTE7ZSsrKXI9dGhpcy5jb250ZXh0cy5zbGljZSgwLHRoaXMuY29udGV4dHMubGVuZ3RoLWUpLG4ucHVzaCh0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHIpKTtuLnB1c2goXCJcIiksdGhpcy5fY3VycmVudENvbnRleHRJZHM9bn0sdC5wcm90b3R5cGUuY29udGV4dElkZm9yQ29udGV4dHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10LmlkJiYwPT09dC5pdGVyYXRpb25JZD9cIlwiOnQuZnJhbWVOYW1lK1wiLVwiK3QuaXRlcmF0aW9uSWR9KS5qb2luKFwiL1wiKTpcIlwifSx0LnByb3RvdHlwZS5lbnRlckZyYW1lPWZ1bmN0aW9uKHQpe3RoaXMuY29udGV4dHMmJih0aGlzLmxhc3RJZCsrLHRoaXMuY29udGV4dHM9dGhpcy5jb250ZXh0cy5zbGljZSgpLHRoaXMuY29udGV4dHMucHVzaCh0aGlzLm5ld0ZyYW1lKHRoaXMubGFzdElkLHQpKSx0aGlzLl9jdXJyZW50Q29udGV4dElkcy51bnNoaWZ0KHRoaXMuY29udGV4dElkZm9yQ29udGV4dHModGhpcy5jb250ZXh0cykpKX0sdC5wcm90b3R5cGUuZXhpdEZyYW1lPWZ1bmN0aW9uKCl7aWYoISh0aGlzLmNvbnRleHRzJiYxPHRoaXMuY29udGV4dHMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXhpdCBmcmFtZSwgdGhlIGNvbnRleHQgaXMgZW1wdHlcIik7dGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5jb250ZXh0cy5zcGxpY2UoLTEpLHRoaXMuY3VycmVudENvbnRleHRJZHMuc2hpZnQoKX0sdC5wcm90b3R5cGUubmV4dEl0ZXJhdGlvbj1mdW5jdGlvbigpe2lmKCEodGhpcy5jb250ZXh0cyYmMDx0aGlzLmNvbnRleHRzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluY3JlYXNlIGZyYW1lIGl0ZXJhdGlvbiwgdGhlIGNvbnRleHQgaXMgZW1wdHlcIik7dGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5sYXN0SWQrKzt2YXIgdD1PYmplY3QuYXNzaWduKHt9LHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGgtMV0pO3QuaXRlcmF0aW9uSWQrPTEsdC5pZD10aGlzLmxhc3RJZCx0aGlzLmNvbnRleHRzLnNwbGljZSgtMSwxLHQpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnNwbGljZSgwLDEsdGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSl9LHQucHJvdG90eXBlLmdldFdlaWdodD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy53ZWlnaHRNYXBbdF19LHQucHJvdG90eXBlLmFkZFRlbnNvckFycmF5PWZ1bmN0aW9uKHQpe3RoaXMudGVuc29yQXJyYXlNYXBbdC5pZF09dH0sdC5wcm90b3R5cGUuZ2V0VGVuc29yQXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGVuc29yQXJyYXlNYXBbdF19LHR9KCksR3JhcGhFeGVjdXRvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5ncmFwaD10LHRoaXMuY29tcGlsZWRNYXA9bmV3IE1hcCx0aGlzLl93ZWlnaHRNYXA9e30sdGhpcy5TRVBFUkFUT1I9XCIsXCIsdGhpcy5wbGFjZWhvbGRlcnM9dC5wbGFjZWhvbGRlcnMsdGhpcy5fb3V0cHV0cz10Lm91dHB1dHMsdGhpcy5jb21waWxlKCl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIndlaWdodE1hcFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd2VpZ2h0TWFwfSxzZXQ6ZnVuY3Rpb24oYSl7dmFyIGU9T2JqZWN0LmtleXMoYSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBhW2VdLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZH0pfSk7dGhpcy53ZWlnaHRJZHM9W10uY29uY2F0LmFwcGx5KFtdLGUpLHRoaXMuX3dlaWdodE1hcD1hfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGFjZWhvbGRlcnMubWFwKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQubmFtZSxzaGFwZTp0LnBhcmFtcy5zaGFwZT90LnBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6dC5wYXJhbXMuZHR5cGU/dC5wYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm91dHB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX291dHB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQubmFtZSxzaGFwZTp0LnBhcmFtcy5zaGFwZT90LnBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6dC5wYXJhbXMuZHR5cGU/dC5wYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlucHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxhY2Vob2xkZXJzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3V0cHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlzQ29udHJvbEZsb3dNb2RlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC53aXRoQ29udHJvbEZsb3d9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaXNEeW5hbWljU2hhcGVNb2RlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC53aXRoRHluYW1pY1NoYXBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmNvbXBpbGU9ZnVuY3Rpb24oaSl7aWYoIXRoaXMuZ3JhcGgud2l0aENvbnRyb2xGbG93JiYhdGhpcy5ncmFwaC53aXRoRHluYW1pY1NoYXBlKXt2YXIgZT1bXSx0PWl8fHRoaXMuZ3JhcGgucGxhY2Vob2xkZXJzLGE9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pLnNvcnQoKS5qb2luKHRoaXMuU0VQRVJBVE9SKTtpZighdGhpcy5jb21waWxlZE1hcC5nZXQoYSkpe2Zvcih2YXIgcj10LmNvbmNhdCh0aGlzLmdyYXBoLndlaWdodHMpLG49e30sbzswPHIubGVuZ3RoOylvPXIucG9wKCksbltvLm5hbWVdPSEwLGUucHVzaChvKSxvLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24odCl7IW5bdC5uYW1lXSYmdC5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGEpe3ZhciBlPWdldE5vZGVOYW1lQW5kSW5kZXgoYSlbMF07cmV0dXJuIG5bZV19KSYmci5wdXNoKHQpfSk7dGhpcy5jb21waWxlZE1hcC5zZXQoYSxlKX19fSx0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGQsZSxpKXt2YXIgYz10aGlzO3ZvaWQgMD09PWUmJihlPSEwKTt2YXIgcj1PYmplY3Qua2V5cyhkKS5zb3J0KCk7dGhpcy5jaGVja0lucHV0KGQsZSksdGhpcy5jaGVja0lucHV0U2hhcGVBbmRUeXBlKGQsZSksdGhpcy5jb21waWxlKHIubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBjLmdyYXBoLm5vZGVzW3RdfSkpO3ZhciBuPXRoaXMuY2FsY3VsYXRlT3V0cHV0cyhpKTt0aGlzLmNoZWNrT3V0cHV0KHRoaXMuY29tcGlsZWRNYXAuZ2V0KHIuam9pbih0aGlzLlNFUEVSQVRPUikpLG4pO3ZhciBvPXt9O3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciBlPW5ldyBFeGVjdXRpb25Db250ZXh0KGMuX3dlaWdodE1hcCxvKSx0PV9fYXNzaWduJDIoe30sYy53ZWlnaHRNYXAsZCksYT1jLmdldEZyb3plblRlbnNvcklkcyh0KSxzPXt9LGk9Yy5jb21waWxlZE1hcC5nZXQoci5qb2luKGMuU0VQRVJBVE9SKSkscD0wLG07cDxpLmxlbmd0aCYmKG09aVtwXSx0W20ubmFtZV18fCh0W20ubmFtZV09ZXhlY3V0ZU9wJDE1KG0sdCxlKSxjLmNoZWNrVGVuc29yRm9yRGlzcG9zYWwobS5uYW1lLG0sdCxlLGEscykpLCFuLmV2ZXJ5KGZ1bmN0aW9uKGEpe3JldHVybiEhdFthXX0pKTtwKyspO3JldHVybiBjLmZpbmRPdXRwdXRzKHQsZSxuKX0pfSx0LnByb3RvdHlwZS5nZXRGcm96ZW5UZW5zb3JJZHM9ZnVuY3Rpb24oYSl7dmFyIGU9W10uY29uY2F0LmFwcGx5KFtdLE9iamVjdC5rZXlzKGEpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gYVtlXX0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWR9KX0pKTtyZXR1cm4gbmV3IFNldChlKX0sdC5wcm90b3R5cGUuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbD1mdW5jdGlvbihzLGkscCxhLHIsbil7XCJjb250cm9sXCIhPT1pLmNhdGVnb3J5JiYocFtzXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe251bGwhPXQmJihuW3QuaWRdPShuW3QuaWRdfHwwKStpLmNoaWxkcmVuLmxlbmd0aCl9KSxpLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKG8pe2lmKFwiY29udHJvbFwiIT09by5jYXRlZ29yeSl7dmFyIGU9Z2V0VGVuc29yc0ZvckN1cnJlbnRDb250ZW54dChvLm5hbWUscCxhKTtudWxsIT1lJiZlLmZvckVhY2goZnVuY3Rpb24oYSl7aWYoYSYmIXIuaGFzKGEuaWQpKXt2YXIgZT1uW2EuaWRdOzE9PT1lPyhhLmRpc3Bvc2UoKSxkZWxldGUgblthLmlkXSk6bnVsbCE9ZSYmblthLmlkXS0tfX0pfX0pKX0sdC5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jPWZ1bmN0aW9uKGwsZSl7cmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXMsZCxjLG0saCxnLGYseTtyZXR1cm4gX19nZW5lcmF0b3IkMih0aGlzLGZ1bmN0aW9uKGEpe3N3aXRjaChhLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuY2hlY2tJbnB1dChsLCExKSx0aGlzLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGUobCwhMSksZD17fSxjPW5ldyBFeGVjdXRpb25Db250ZXh0KHRoaXMuX3dlaWdodE1hcCxkKSxbNCx0aGlzLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3cobCxjKV07Y2FzZSAxOnJldHVybiBtPWEuc2VudCgpLGg9dGhpcy5maW5kT3V0cHV0cyhtLGMsZSksZz1PYmplY3Qua2V5cyhoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGhbdF0uaWR9KSxmPU9iamVjdC5rZXlzKGwpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbFtlXS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWR9KX0pLHk9W10uY29uY2F0LmFwcGx5KFtdLGYpLE9iamVjdC5rZXlzKG0pLmZvckVhY2goZnVuY3Rpb24oYSl7bVthXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EmJi0xPT09Zy5pbmRleE9mKGEuaWQpJiYtMT09PXkuaW5kZXhPZihhLmlkKSYmLTE9PT10LndlaWdodElkcy5pbmRleE9mKGEuaWQpJiZhLmRpc3Bvc2UoKX0pfSksWzIsaF07fX0pfSl9LHQucHJvdG90eXBlLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3c9ZnVuY3Rpb24oZCxjKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlLHUsaCxnLGYseSxiLHg7cmV0dXJuIF9fZ2VuZXJhdG9yJDIodGhpcyxmdW5jdGlvbihhKXtzd2l0Y2goYS5sYWJlbCl7Y2FzZSAwOmU9T2JqZWN0LmtleXMoZCksdT1lLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gdC5ncmFwaC5ub2Rlc1thXX0pLGg9dS5jb25jYXQodGhpcy5ncmFwaC53ZWlnaHRzKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJue25vZGU6dCxjb250ZXh0czpjLmN1cnJlbnRDb250ZXh0fX0pLGc9X19hc3NpZ24kMih7fSx0aGlzLndlaWdodE1hcCxkKSxmPXt9LHk9dGhpcy5nZXRGcm96ZW5UZW5zb3JJZHMoZyksYj17fSxhLmxhYmVsPTE7Y2FzZSAxOnJldHVybiAwPGgubGVuZ3RoPyh4PXRoaXMucHJvY2Vzc1N0YWNrKHUsaCxjLGcsYix5LGYpLFs0LFByb21pc2UuYWxsKHgpXSk6WzMsM107Y2FzZSAyOnJldHVybiBhLnNlbnQoKSxbMywxXTtjYXNlIDM6cmV0dXJuWzIsZ107fX0pfSl9LHQucHJvdG90eXBlLnByb2Nlc3NTdGFjaz1mdW5jdGlvbihoLGcsdCxhLHIsbixvKXtmb3IodmFyIHM9dGhpcyxlPVtdLGk9ZnVuY3Rpb24oKXt2YXIgaT1nLnBvcCgpO3QuY3VycmVudENvbnRleHQ9aS5jb250ZXh0czt2YXIgdT1cIlwiO2lmKFwiZW50ZXJcIj09PWkubm9kZS5vcCYmZ2V0UGFyYW1WYWx1ZShcImlzQ29uc3RhbnRcIixpLm5vZGUsYSx0KSYmKHU9Z2V0Tm9kZU5hbWVBbmRJbmRleChpLm5vZGUubmFtZSx0KVswXSksLTE9PT1oLmluZGV4T2YoaS5ub2RlKSl7dmFyIG09ZXhlY3V0ZU9wJDE1KGkubm9kZSxhLHQpO3V8fCh1PWdldE5vZGVOYW1lQW5kSW5kZXgoaS5ub2RlLm5hbWUsdClbMF0pO3ZhciBkPXQuY3VycmVudENvbnRleHQ7bSBpbnN0YW5jZW9mIFByb21pc2U/ZS5wdXNoKG0udGhlbihmdW5jdGlvbihwKXtyZXR1cm4gYVt1XT1wLHQuY3VycmVudENvbnRleHQ9ZCxzLmNoZWNrVGVuc29yRm9yRGlzcG9zYWwodSxpLm5vZGUsYSx0LG4sbykscy5wcm9jZXNzQ2hpbGROb2RlcyhpLm5vZGUsZyx0LGEscikscH0pKTooYVt1XT1tLHAuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbCh1LGkubm9kZSxhLHQsbixvKSxwLnByb2Nlc3NDaGlsZE5vZGVzKGkubm9kZSxnLHQsYSxyKSl9ZWxzZSBwLnByb2Nlc3NDaGlsZE5vZGVzKGkubm9kZSxnLHQsYSxyKX0scD10aGlzOzA8Zy5sZW5ndGg7KWkoKTtyZXR1cm4gZX0sdC5wcm90b3R5cGUucHJvY2Vzc0NoaWxkTm9kZXM9ZnVuY3Rpb24obyxzLHQsYSxyKXtvLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24obil7dmFyIGU9Z2V0Tm9kZU5hbWVBbmRJbmRleChuLm5hbWUsdClbMF07cltlXXx8KFwibWVyZ2VcIj09PW4ub3A/bi5pbnB1dE5hbWVzLnNvbWUoZnVuY3Rpb24obil7cmV0dXJuISFnZXRUZW5zb3IobixhLHQpfSkmJihyW2VdPSEwLHMucHVzaCh7Y29udGV4dHM6dC5jdXJyZW50Q29udGV4dCxub2RlOm59KSk6bi5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKG4pe3JldHVybiEhZ2V0VGVuc29yKG4sYSx0KX0pJiYocltlXT0hMCxzLnB1c2goe2NvbnRleHRzOnQuY3VycmVudENvbnRleHQsbm9kZTpufSkpKX0pfSx0LnByb3RvdHlwZS5jYWxjdWxhdGVPdXRwdXRzPWZ1bmN0aW9uKHQpe3JldHVybiF0fHx0IGluc3RhbmNlb2YgQXJyYXl8fCh0PVt0XSksdHx8dGhpcy5ncmFwaC5vdXRwdXRzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSl9LHQucHJvdG90eXBlLmZpbmRPdXRwdXRzPWZ1bmN0aW9uKG4sZSx0KXtyZXR1cm4gdGhpcy5jYWxjdWxhdGVPdXRwdXRzKHQpLnJlZHVjZShmdW5jdGlvbih0LGEpe3JldHVybiB0W2FdPWdldFRlbnNvcihhLG4sZSksdH0se30pfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztPYmplY3Qua2V5cyh0aGlzLndlaWdodE1hcCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gYS53ZWlnaHRNYXBbZV0uZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5kaXNwb3NlKCl9KX0pfSx0LnByb3RvdHlwZS5jaGVja0lucHV0U2hhcGVBbmRUeXBlPWZ1bmN0aW9uKGksZSl7dm9pZCAwPT09ZSYmKGU9ITApLHRoaXMucGxhY2Vob2xkZXJzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGE9aVt0Lm5hbWVdO2lmKGV8fGEpe3ZhciByPWFbMF07aWYodC5wYXJhbXMuc2hhcGUmJnQucGFyYW1zLnNoYXBlLnZhbHVlKXt2YXIgbj10LnBhcmFtcy5zaGFwZS52YWx1ZSxvPW4ubGVuZ3RoPT09ci5zaGFwZS5sZW5ndGgmJnIuc2hhcGUuZXZlcnkoZnVuY3Rpb24oYSxlKXtyZXR1cm4tMT09PW5bZV18fG5bZV09PT1hfSk7dXRpbC5hc3NlcnQobyxcIlRoZSBzaGFwZSBvZiBkaWN0WydcIit0Lm5hbWUrXCInXSBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIG11c3QgYmUgW1wiK24rXCJdLCBidXQgd2FzIFtcIityLnNoYXBlK1wiXVwiKX10LnBhcmFtcy5kdHlwZSYmdC5wYXJhbXMuZHR5cGUudmFsdWUmJnV0aWwuYXNzZXJ0KHIuZHR5cGU9PT10LnBhcmFtcy5kdHlwZS52YWx1ZSxcIlRoZSBkdHlwZSBvZiBkaWN0WydcIit0Lm5hbWUrXCInXSBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIG11c3QgYmUgXCIrdC5wYXJhbXMuZHR5cGUudmFsdWUrXCIsIGJ1dCB3YXMgXCIrci5kdHlwZSl9fSl9LHQucHJvdG90eXBlLmNoZWNrSW5wdXQ9ZnVuY3Rpb24oaSxlKXt2YXIgcD10aGlzO3ZvaWQgMD09PWUmJihlPSEwKTt2YXIgYT1PYmplY3Qua2V5cyhpKSxyPVtdLG49W107dGhpcy5pbnB1dE5vZGVzLmZvckVhY2goZnVuY3Rpb24odCl7LTE9PT1hLmluZGV4T2YodCkmJnIucHVzaCh0KX0pLGEuZm9yRWFjaChmdW5jdGlvbih0KXstMT09PXAuaW5wdXROb2Rlcy5pbmRleE9mKHQpJiZuLnB1c2godCl9KTt2YXIgbz1uLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hcC5ncmFwaC5ub2Rlc1t0XX0pO2lmKDA8ci5sZW5ndGgmJmUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMgdGhlIGtleXMgW1wiK2ErXCJdLCBidXQgaXMgbWlzc2luZyB0aGUgcmVxdWlyZWQga2V5czogW1wiK3IrXCJdLlwiKTtpZigwPG4ubGVuZ3RoJiZlKXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWN0IHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgaGFzIHVudXNlZCBrZXlzOiBbXS4gUGxlYXNlIHByb3ZpZGUgb25seSB0aGUgZm9sbG93aW5nIGtleXM6IFtcIit0aGlzLmlucHV0Tm9kZXMrXCJdLlwiKTtpZigwPG8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWN0IHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgaGFzIGtleXM6IFtcIitvK1wiXSBub3QgcGFydCBvZiBtb2RlbCBncmFwaC5cIil9LHQucHJvdG90eXBlLmNoZWNrT3V0cHV0PWZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pLGE9W107aWYoZS5mb3JFYWNoKGZ1bmN0aW9uKG4pey0xPT09dC5pbmRleE9mKG4pJiZhLnB1c2gobil9KSwwPGEubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBmb2xsb3dpbmcgb3V0cHV0cyBhcmUgbm90IGJlIGdlbmVyYXRlZCBieSB0aGUgZXhlY3V0aW9uOiBbXS5cIil9LHR9KCksRnJvemVuTW9kZWw9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4sZSx0KXt0aGlzLm1vZGVsVXJsPW4sdGhpcy53ZWlnaHRNYW5pZmVzdFVybD1lLHRoaXMucmVxdWVzdE9wdGlvbj10LHRoaXMudmVyc2lvbj1cIm4vYVwifXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJtb2RlbFZlcnNpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVyc2lvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpbnB1dE5vZGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLmlucHV0Tm9kZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3V0cHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iub3V0cHV0Tm9kZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW5wdXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLmlucHV0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJvdXRwdXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwid2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci53ZWlnaHRNYXB9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZmluZElPSGFuZGxlcj1mdW5jdGlvbigpe3ZhciBhPVt0aGlzLm1vZGVsVXJsLHRoaXMud2VpZ2h0TWFuaWZlc3RVcmxdO2lmKHRoaXMucmVxdWVzdE9wdGlvbil0aGlzLmhhbmRsZXI9aW8uYnJvd3NlckhUVFBSZXF1ZXN0KGEsdGhpcy5yZXF1ZXN0T3B0aW9uKTtlbHNle3ZhciBlPWlvLmdldExvYWRIYW5kbGVycyhhKTtpZigwPT09ZS5sZW5ndGgpZS5wdXNoKGlvLmJyb3dzZXJIVFRQUmVxdWVzdChhLHRoaXMucmVxdWVzdE9wdGlvbikpO2Vsc2UgaWYoMTxlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBtb3JlIHRoYW4gb25lIChcIitlLmxlbmd0aCtcIikgbG9hZCBoYW5kbGVycyBmb3IgVVJMICdcIitbYV0rXCInXCIpO3RoaXMuaGFuZGxlcj1lWzBdfX0sdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIkMih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixvLHM7cmV0dXJuIF9fZ2VuZXJhdG9yJDIodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMuZmluZElPSGFuZGxlcigpLG51bGw9PXRoaXMuaGFuZGxlci5sb2FkKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYGxvYWRgIG1ldGhvZCBpbXBsZW1lbnRlZC5cIik7cmV0dXJuWzQsdGhpcy5oYW5kbGVyLmxvYWQoKV07Y2FzZSAxOnJldHVybiBuPWUuc2VudCgpLG89Y29tcGlsZWRfYXBpXzEuR3JhcGhEZWYuZGVjb2RlKG5ldyBVaW50OEFycmF5KG4ubW9kZWxUb3BvbG9neSkpLHRoaXMudmVyc2lvbj1vLnZlcnNpb25zLnByb2R1Y2VyK1wiLlwiK28udmVyc2lvbnMubWluQ29uc3VtZXIscz1pby5kZWNvZGVXZWlnaHRzKG4ud2VpZ2h0RGF0YSxuLndlaWdodFNwZWNzKSx0aGlzLmV4ZWN1dG9yPW5ldyBHcmFwaEV4ZWN1dG9yKE9wZXJhdGlvbk1hcHBlci5JbnN0YW5jZS50cmFuc2Zvcm1HcmFwaChvKSksdGhpcy5leGVjdXRvci53ZWlnaHRNYXA9dGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKHMpLFsyLCEwXTt9fSl9KX0sdC5wcm90b3R5cGUucHJlZGljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5leGVjdXRlXyh0LCEwLHRoaXMub3V0cHV0Tm9kZXMpfSx0LnByb3RvdHlwZS5jb25zdHJ1Y3RUZW5zb3JNYXA9ZnVuY3Rpb24oYSl7dmFyIG49YSBpbnN0YW5jZW9mIFRlbnNvcj9bYV06YTtpZihuLmxlbmd0aCE9PXRoaXMuaW5wdXROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdGVuc29yIGNvdW50IG1pc21hdGNoLHRoZSBmcm96ZW4gbW9kZWwgaGFzIFwiK3RoaXMuaW5wdXROb2Rlcy5sZW5ndGgrXCIgcGxhY2Vob2xkZXJzLCB3aGlsZSB0aGVyZSBhcmUgXCIrbi5sZW5ndGgrXCIgaW5wdXQgdGVuc29ycy5cIik7cmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoZnVuY3Rpb24odCxlLGEpe3JldHVybiB0W2VdPW5bYV0sdH0se30pfSx0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHRoaXMuZXhlY3V0ZV8oYSwhMSxlKX0sdC5wcm90b3R5cGUuZXhlY3V0ZV89ZnVuY3Rpb24obyxzLGkpe2lmKHZvaWQgMD09PXMmJihzPSEwKSxpPWl8fHRoaXMub3V0cHV0Tm9kZXMsKG8gaW5zdGFuY2VvZiBUZW5zb3J8fEFycmF5LmlzQXJyYXkobykpJiYobz10aGlzLmNvbnN0cnVjdFRlbnNvck1hcChvKSksdGhpcy5leGVjdXRvci5pc0NvbnRyb2xGbG93TW9kZWx8fHRoaXMuZXhlY3V0b3IuaXNEeW5hbWljU2hhcGVNb2RlbCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbW9kZWwgY29udGFpbnMgY29udHJvbCBmbG93IG9yIGR5bmFtaWMgc2hhcGUgb3BzLCBwbGVhc2UgdXNlIGV4ZWN1dGVBc3luYyBtZXRob2RcIik7dmFyIHA9dGhpcy5leGVjdXRvci5leGVjdXRlKHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChvKSxzLGkpLHI9T2JqZWN0LmtleXMocCk7cmV0dXJuIEFycmF5LmlzQXJyYXkoaSkmJjE8aS5sZW5ndGg/aS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHBbdF19KTpwW3JbMF1dfSx0LnByb3RvdHlwZS5leGVjdXRlQXN5bmM9ZnVuY3Rpb24obyxzKXtyZXR1cm4gX19hd2FpdGVyJDIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gX19nZW5lcmF0b3IkMih0aGlzLGZ1bmN0aW9uKGEpe3N3aXRjaChhLmxhYmVsKXtjYXNlIDA6aWYoIXRoaXMuZXhlY3V0b3IuaXNDb250cm9sRmxvd01vZGVsJiYhdGhpcy5leGVjdXRvci5pc0R5bmFtaWNTaGFwZU1vZGVsKXRocm93IG5ldyBFcnJvcihcIlRoZSBtb2RlbCBkb2VzIG5vdCBjb250YWluIGNvbnRyb2wgZmxvdyBvciBkeW5hbWljIHNoYXBlIG9wcywgcGxlYXNlIHVzZSBleGVjdXRlIG1ldGhvZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKTtyZXR1cm4gcz1zfHx0aGlzLm91dHB1dE5vZGVzLChvIGluc3RhbmNlb2YgVGVuc29yfHxBcnJheS5pc0FycmF5KG8pKSYmKG89dGhpcy5jb25zdHJ1Y3RUZW5zb3JNYXAobykpLFs0LHRoaXMuZXhlY3V0b3IuZXhlY3V0ZUFzeW5jKHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChvKSxzKV07Y2FzZSAxOnJldHVybiB0PWEuc2VudCgpLGU9T2JqZWN0LmtleXModCksWzIsQXJyYXkuaXNBcnJheShzKSYmMTxzLmxlbmd0aD9zLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gdFthXX0pOnRbZVswXV1dO319KX0pfSx0LnByb3RvdHlwZS5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwPWZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3Qua2V5cyhuKS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVt0XT1bblt0XV0sZX0se30pfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5leGVjdXRvci5kaXNwb3NlKCl9LHR9KCk7Y29uc3QgYmFzZVBhdGg9XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2hhbmR0cmFja2pzL21vZGVscy93ZWIvXCIsZGVmYXVsdFBhcmFtcz17ZmxpcEhvcml6b250YWw6ITAsb3V0cHV0U3RyaWRlOjE2LGltYWdlU2NhbGVGYWN0b3I6LjcsbWF4TnVtQm94ZXM6MjAsaW91VGhyZXNob2xkOi41LHNjb3JlVGhyZXNob2xkOi45OSxtb2RlbFR5cGU6XCJzc2RsaXRlbW9iaWxlbmV0djJcIn07Y2xhc3MgT2JqZWN0RGV0ZWN0aW9ue2NvbnN0cnVjdG9yKGUpe3RoaXMubW9kZWxQYXRoPWJhc2VQYXRoK2UubW9kZWxUeXBlK1wiL3RlbnNvcmZsb3dqc19tb2RlbC5wYlwiLHRoaXMud2VpZ2h0UGF0aD1iYXNlUGF0aCtlLm1vZGVsVHlwZStcIi93ZWlnaHRzX21hbmlmZXN0Lmpzb25cIix0aGlzLm1vZGVsUGFyYW1zPWV9YXN5bmMgbG9hZCgpe3RoaXMuZnBzPTAsdGhpcy5tb2RlbD1hd2FpdCBsb2FkRnJvemVuTW9kZWwodGhpcy5tb2RlbFBhdGgsdGhpcy53ZWlnaHRQYXRoKTsvLyBXYXJtdXAgdGhlIG1vZGVsLlxuY29uc3QgZT1hd2FpdCB0aGlzLm1vZGVsLmV4ZWN1dGVBc3luYyh6ZXJvcyhbMSwzMDAsMzAwLDNdKSk7ZS5tYXAoYXN5bmMgZT0+YXdhaXQgZS5kYXRhKCkpLGUubWFwKGFzeW5jIGU9PmUuZGlzcG9zZSgpKX1hc3luYyBkZXRlY3QoZSl7bGV0IHQ9RGF0ZS5ub3coKTtjb25zdFthLG5dPWdldElucHV0VGVuc29yRGltZW5zaW9ucyhlKSxyPWdldFZhbGlkUmVzb2x1dGlvbih0aGlzLm1vZGVsUGFyYW1zLmltYWdlU2NhbGVGYWN0b3IsYSx0aGlzLm1vZGVsUGFyYW1zLm91dHB1dFN0cmlkZSksbz1nZXRWYWxpZFJlc29sdXRpb24odGhpcy5tb2RlbFBhcmFtcy5pbWFnZVNjYWxlRmFjdG9yLG4sdGhpcy5tb2RlbFBhcmFtcy5vdXRwdXRTdHJpZGUpLHM9dGlkeSgoKT0+e2NvbnN0IHQ9ZnJvbVBpeGVscyhlKTtyZXR1cm4gdGhpcy5tb2RlbFBhcmFtcy5mbGlwSG9yaXpvbnRhbD90LnJldmVyc2UoMSkucmVzaXplQmlsaW5lYXIoW3Isb10pLmV4cGFuZERpbXMoMCk6dC5yZXNpemVCaWxpbmVhcihbcixvXSkuZXhwYW5kRGltcygwKX0pO3JldHVybiBzZWxmPXRoaXMsdGhpcy5tb2RlbC5leGVjdXRlQXN5bmMocykudGhlbihmdW5jdGlvbihlKXtjb25zdCByPWVbMF0uZGF0YVN5bmMoKSxvPWVbMV0uZGF0YVN5bmMoKTtzLmRpc3Bvc2UoKSxkaXNwb3NlKGUpOy8vIGNvbnNvbGUubG9nKFwic2NvcmVzIHJlc3VsdFwiLHNjb3JlcywgYm94ZXMpXG5jb25zdFtpLHBdPWNhbGN1bGF0ZU1heFNjb3JlcyhyLGVbMF0uc2hhcGVbMV0sZVswXS5zaGFwZVsyXSksbD1nZXRCYWNrZW5kKCk7c2V0QmFja2VuZChcImNwdVwiKTtjb25zdCBkPXRpZHkoKCk9Pntjb25zdCB0PXRlbnNvcjJkKG8sW2VbMV0uc2hhcGVbMV0sZVsxXS5zaGFwZVszXV0pO3JldHVybiBpbWFnZV9vcHMubm9uTWF4U3VwcHJlc3Npb24odCxyLHNlbGYubW9kZWxQYXJhbXMubWF4TnVtQm94ZXMsLy8gbWF4TnVtQm94ZXNcbnNlbGYubW9kZWxQYXJhbXMuaW91VGhyZXNob2xkLC8vIGlvdV90aHJlc2hvbGRcbnNlbGYubW9kZWxQYXJhbXMuc2NvcmVUaHJlc2hvbGQvLyBzY29yZV90aHJlc2hvbGRcbil9KSx1PWQuZGF0YVN5bmMoKTtkLmRpc3Bvc2UoKSxzZXRCYWNrZW5kKGwpO2NvbnN0IGM9c2VsZi5idWlsZERldGVjdGVkT2JqZWN0cyhuLGEsbyxyLHUscCk7bGV0IG09RGF0ZS5ub3coKTtyZXR1cm4gc2VsZi5mcHM9X01hdGhyb3VuZCgxZTMvKG0tdCkpLGN9KX1idWlsZERldGVjdGVkT2JqZWN0cyhlLHQsYSxuLHIsbyl7Y29uc3Qgcz1yLmxlbmd0aCxwPVtdO2ZvcihsZXQgbD0wO2w8cztsKyspe2NvbnN0IHM9W107Zm9yKGxldCBlPTA7ND5lO2UrKylzW2VdPWFbNCpyW2xdK2VdO2NvbnN0IGk9c1swXSp0LGQ9c1sxXSplLHU9c1syXSp0LGM9c1szXSplO3NbMF09ZCxzWzFdPWksc1syXT1jLWQsc1szXT11LWkscC5wdXNoKHtiYm94OnMsY2xhc3M6b1tyW2xdXSxzY29yZTpuW3JbbF1dfSl9cmV0dXJuIHB9Z2V0RlBTKCl7cmV0dXJuIHRoaXMuZnBzfXNldE1vZGVsUGFyYW1ldGVycyhlKXt0aGlzLm1vZGVsUGFyYW1zPU9iamVjdC5hc3NpZ24oe30sdGhpcy5tb2RlbFBhcmFtcyxlKX1nZXRNb2RlbFBhcmFtZXRlcnMoKXtyZXR1cm4gdGhpcy5tb2RlbFBhcmFtc31yZW5kZXJQcmVkaWN0aW9ucyhlLHQsYSxuKXthLmNsZWFyUmVjdCgwLDAsdC53aWR0aCx0LmhlaWdodCksdC53aWR0aD1uLndpZHRoLHQuaGVpZ2h0PW4uaGVpZ2h0LGEuc2F2ZSgpLHRoaXMubW9kZWxQYXJhbXMuZmxpcEhvcml6b250YWwmJihhLnNjYWxlKC0xLDEpLGEudHJhbnNsYXRlKC1uLndpZHRoLDApKSxhLmRyYXdJbWFnZShuLDAsMCxuLndpZHRoLG4uaGVpZ2h0KSxhLnJlc3RvcmUoKSxhLmZvbnQ9XCIxMHB4IEFyaWFsXCI7Ly8gY29uc29sZS5sb2coJ251bWJlciBvZiBkZXRlY3Rpb25zOiAnLCBwcmVkaWN0aW9ucy5sZW5ndGgpO1xuZm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspLy8gZHJhdyBhIGRvdCBhdCB0aGUgY2VudGVyIG9mIGJvdW5kaW5nIGJveFxuLy8gXCJyZ2JhKDI0NCwyNDcsMjUxLDEpXCI7XG5hLmJlZ2luUGF0aCgpLGEuZmlsbFN0eWxlPVwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjYpXCIsYS5maWxsUmVjdChlW3JdLmJib3hbMF0sZVtyXS5iYm94WzFdLTE3LGVbcl0uYmJveFsyXSwxNyksYS5yZWN0KC4uLmVbcl0uYmJveCksYS5saW5lV2lkdGg9MSxhLnN0cm9rZVN0eWxlPVwiIzAwNjNGRlwiLGEuZmlsbFN0eWxlPVwiIzAwNjNGRlwiLGEuZmlsbFJlY3QoZVtyXS5iYm94WzBdK2Vbcl0uYmJveFsyXS8yLGVbcl0uYmJveFsxXStlW3JdLmJib3hbM10vMiw1LDUpLGEuc3Ryb2tlKCksYS5maWxsVGV4dChlW3JdLnNjb3JlLnRvRml4ZWQoMykrXCIgIHwgaGFuZFwiLGVbcl0uYmJveFswXSs1LDEwPGVbcl0uYmJveFsxXT9lW3JdLmJib3hbMV0tNToxMCk7Ly8gV3JpdGUgRlBTIHRvIHRvcCBsZWZ0XG5hLmZvbnQ9XCJib2xkIDEycHggQXJpYWxcIixhLmZpbGxUZXh0KFwiW0ZQU106IFwiK3RoaXMuZnBzLDEwLDIwKX1kaXNwb3NlKCl7dGhpcy5tb2RlbCYmdGhpcy5tb2RlbC5kaXNwb3NlKCl9fWV4cG9ydHMubG9hZD1sb2FkLGV4cG9ydHMuc3RhcnRWaWRlbz1zdGFydFZpZGVvLGV4cG9ydHMuc3RvcFZpZGVvPXN0b3BWaWRlbyxleHBvcnRzLk9iamVjdERldGVjdGlvbj1PYmplY3REZXRlY3Rpb24sT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwuanMnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3Q7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGw7XG5mdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgX1N5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChfU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0X1N5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59OyIsImltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG5jb25zdCBOTyA9IHt9O1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGNwPFQ+KGE6IEFycmF5PFQ+KTogQXJyYXk8VD4ge1xuICBjb25zdCBsID0gYS5sZW5ndGg7XG4gIGNvbnN0IGIgPSBBcnJheShsKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIGJbaV0gPSBhW2ldO1xuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gYW5kPFQ+KGYxOiAodDogVCkgPT4gYm9vbGVhbiwgZjI6ICh0OiBUKSA9PiBib29sZWFuKTogKHQ6IFQpID0+IGJvb2xlYW4ge1xuICByZXR1cm4gZnVuY3Rpb24gYW5kRm4odDogVCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmMSh0KSAmJiBmMih0KTtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIEZDb250YWluZXI8VCwgUj4ge1xuICBmKHQ6IFQpOiBSO1xufVxuXG5mdW5jdGlvbiBfdHJ5PFQsIFI+KGM6IEZDb250YWluZXI8VCwgUj4sIHQ6IFQsIHU6IFN0cmVhbTxhbnk+KTogUiB8IHt9IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYy5mKHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdS5fZShlKTtcbiAgICByZXR1cm4gTk87XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnRlcm5hbExpc3RlbmVyPFQ+IHtcbiAgX246ICh2OiBUKSA9PiB2b2lkO1xuICBfZTogKGVycjogYW55KSA9PiB2b2lkO1xuICBfYzogKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgTk9fSUw6IEludGVybmFsTGlzdGVuZXI8YW55PiA9IHtcbiAgX246IG5vb3AsXG4gIF9lOiBub29wLFxuICBfYzogbm9vcCxcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJuYWxQcm9kdWNlcjxUPiB7XG4gIF9zdGFydChsaXN0ZW5lcjogSW50ZXJuYWxMaXN0ZW5lcjxUPik6IHZvaWQ7XG4gIF9zdG9wOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dFNlbmRlcjxUPiB7XG4gIG91dDogU3RyZWFtPFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdG9yPFQsIFI+IGV4dGVuZHMgSW50ZXJuYWxQcm9kdWNlcjxSPiwgSW50ZXJuYWxMaXN0ZW5lcjxUPiwgT3V0U2VuZGVyPFI+IHtcbiAgdHlwZTogc3RyaW5nO1xuICBpbnM6IFN0cmVhbTxUPjtcbiAgX3N0YXJ0KG91dDogU3RyZWFtPFI+KTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZ2dyZWdhdG9yPFQsIFU+IGV4dGVuZHMgSW50ZXJuYWxQcm9kdWNlcjxVPiwgT3V0U2VuZGVyPFU+IHtcbiAgdHlwZTogc3RyaW5nO1xuICBpbnNBcnI6IEFycmF5PFN0cmVhbTxUPj47XG4gIF9zdGFydChvdXQ6IFN0cmVhbTxVPik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZHVjZXI8VD4ge1xuICBzdGFydDogKGxpc3RlbmVyOiBMaXN0ZW5lcjxUPikgPT4gdm9pZDtcbiAgc3RvcDogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5lcjxUPiB7XG4gIG5leHQ6ICh4OiBUKSA9PiB2b2lkO1xuICBlcnJvcjogKGVycjogYW55KSA9PiB2b2lkO1xuICBjb21wbGV0ZTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICB1bnN1YnNjcmliZSgpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICBzdWJzY3JpYmUobGlzdGVuZXI6IExpc3RlbmVyPFQ+KTogU3Vic2NyaXB0aW9uO1xufVxuXG4vLyBtdXRhdGVzIHRoZSBpbnB1dFxuZnVuY3Rpb24gaW50ZXJuYWxpemVQcm9kdWNlcjxUPihwcm9kdWNlcjogUHJvZHVjZXI8VD4gJiBQYXJ0aWFsPEludGVybmFsUHJvZHVjZXI8VD4+KSB7XG4gIHByb2R1Y2VyLl9zdGFydCA9IGZ1bmN0aW9uIF9zdGFydChpbDogSW50ZXJuYWxMaXN0ZW5lcjxUPiAmIFBhcnRpYWw8TGlzdGVuZXI8VD4+KSB7XG4gICAgaWwubmV4dCA9IGlsLl9uO1xuICAgIGlsLmVycm9yID0gaWwuX2U7XG4gICAgaWwuY29tcGxldGUgPSBpbC5fYztcbiAgICB0aGlzLnN0YXJ0KGlsIGFzIExpc3RlbmVyPFQ+KTtcbiAgfTtcbiAgcHJvZHVjZXIuX3N0b3AgPSBwcm9kdWNlci5zdG9wO1xufVxuXG5jbGFzcyBTdHJlYW1TdWI8VD4gaW1wbGVtZW50cyBTdWJzY3JpcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zdHJlYW06IFN0cmVhbTxUPiwgcHJpdmF0ZSBfbGlzdGVuZXI6IEludGVybmFsTGlzdGVuZXI8VD4pIHt9XG5cbiAgdW5zdWJzY3JpYmUoKTogdm9pZCB7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmUodGhpcy5fbGlzdGVuZXIpO1xuICB9XG59XG5cbmNsYXNzIE9ic2VydmVyPFQ+IGltcGxlbWVudHMgTGlzdGVuZXI8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9saXN0ZW5lcjogSW50ZXJuYWxMaXN0ZW5lcjxUPikge31cblxuICBuZXh0KHZhbHVlOiBUKSB7XG4gICAgdGhpcy5fbGlzdGVuZXIuX24odmFsdWUpO1xuICB9XG5cbiAgZXJyb3IoZXJyOiBhbnkpIHtcbiAgICB0aGlzLl9saXN0ZW5lci5fZShlcnIpO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy5fbGlzdGVuZXIuX2MoKTtcbiAgfVxufVxuXG5jbGFzcyBGcm9tT2JzZXJ2YWJsZTxUPiBpbXBsZW1lbnRzIEludGVybmFsUHJvZHVjZXI8VD4ge1xuICBwdWJsaWMgdHlwZSA9ICdmcm9tT2JzZXJ2YWJsZSc7XG4gIHB1YmxpYyBpbnM6IE9ic2VydmFibGU8VD47XG4gIHB1YmxpYyBvdXQ/OiBTdHJlYW08VD47XG4gIHByaXZhdGUgYWN0aXZlOiBib29sZWFuO1xuICBwcml2YXRlIF9zdWI6IFN1YnNjcmlwdGlvbiB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPFQ+KSB7XG4gICAgdGhpcy5pbnMgPSBvYnNlcnZhYmxlO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08VD4pIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fc3ViID0gdGhpcy5pbnMuc3Vic2NyaWJlKG5ldyBPYnNlcnZlcihvdXQpKTtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB0aGlzLl9zdWIudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIF9zdG9wKCkge1xuICAgIGlmICh0aGlzLl9zdWIpIHRoaXMuX3N1Yi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXJnZVNpZ25hdHVyZSB7XG4gICgpOiBTdHJlYW08YW55PjtcbiAgPFQxPihzMTogU3RyZWFtPFQxPik6IFN0cmVhbTxUMT47XG4gIDxUMSwgVDI+KFxuICAgIHMxOiBTdHJlYW08VDE+LFxuICAgIHMyOiBTdHJlYW08VDI+KTogU3RyZWFtPFQxIHwgVDI+O1xuICA8VDEsIFQyLCBUMz4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4pOiBTdHJlYW08VDEgfCBUMiB8IFQzPjtcbiAgPFQxLCBUMiwgVDMsIFQ0PihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPixcbiAgICBzNDogU3RyZWFtPFQ0Pik6IFN0cmVhbTxUMSB8IFQyIHwgVDMgfCBUND47XG4gIDxUMSwgVDIsIFQzLCBUNCwgVDU+KFxuICAgIHMxOiBTdHJlYW08VDE+LFxuICAgIHMyOiBTdHJlYW08VDI+LFxuICAgIHMzOiBTdHJlYW08VDM+LFxuICAgIHM0OiBTdHJlYW08VDQ+LFxuICAgIHM1OiBTdHJlYW08VDU+KTogU3RyZWFtPFQxIHwgVDIgfCBUMyB8IFQ0IHwgVDU+O1xuICA8VDEsIFQyLCBUMywgVDQsIFQ1LCBUNj4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4sXG4gICAgczY6IFN0cmVhbTxUNj4pOiBTdHJlYW08VDEgfCBUMiB8IFQzIHwgVDQgfCBUNSB8IFQ2PjtcbiAgPFQxLCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFQ3PihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPixcbiAgICBzNDogU3RyZWFtPFQ0PixcbiAgICBzNTogU3RyZWFtPFQ1PixcbiAgICBzNjogU3RyZWFtPFQ2PixcbiAgICBzNzogU3RyZWFtPFQ3Pik6IFN0cmVhbTxUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1IHwgVDYgfCBUNz47XG4gIDxUMSwgVDIsIFQzLCBUNCwgVDUsIFQ2LCBUNywgVDg+KFxuICAgIHMxOiBTdHJlYW08VDE+LFxuICAgIHMyOiBTdHJlYW08VDI+LFxuICAgIHMzOiBTdHJlYW08VDM+LFxuICAgIHM0OiBTdHJlYW08VDQ+LFxuICAgIHM1OiBTdHJlYW08VDU+LFxuICAgIHM2OiBTdHJlYW08VDY+LFxuICAgIHM3OiBTdHJlYW08VDc+LFxuICAgIHM4OiBTdHJlYW08VDg+KTogU3RyZWFtPFQxIHwgVDIgfCBUMyB8IFQ0IHwgVDUgfCBUNiB8IFQ3IHwgVDg+O1xuICA8VDEsIFQyLCBUMywgVDQsIFQ1LCBUNiwgVDcsIFQ4LCBUOT4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4sXG4gICAgczY6IFN0cmVhbTxUNj4sXG4gICAgczc6IFN0cmVhbTxUNz4sXG4gICAgczg6IFN0cmVhbTxUOD4sXG4gICAgczk6IFN0cmVhbTxUOT4pOiBTdHJlYW08VDEgfCBUMiB8IFQzIHwgVDQgfCBUNSB8IFQ2IHwgVDcgfCBUOCB8IFQ5PjtcbiAgPFQxLCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFQ3LCBUOCwgVDksIFQxMD4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4sXG4gICAgczY6IFN0cmVhbTxUNj4sXG4gICAgczc6IFN0cmVhbTxUNz4sXG4gICAgczg6IFN0cmVhbTxUOD4sXG4gICAgczk6IFN0cmVhbTxUOT4sXG4gICAgczEwOiBTdHJlYW08VDEwPik6IFN0cmVhbTxUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1IHwgVDYgfCBUNyB8IFQ4IHwgVDkgfCBUMTA+O1xuICA8VD4oLi4uc3RyZWFtOiBBcnJheTxTdHJlYW08VD4+KTogU3RyZWFtPFQ+O1xufVxuXG5jbGFzcyBNZXJnZTxUPiBpbXBsZW1lbnRzIEFnZ3JlZ2F0b3I8VCwgVD4sIEludGVybmFsTGlzdGVuZXI8VD4ge1xuICBwdWJsaWMgdHlwZSA9ICdtZXJnZSc7XG4gIHB1YmxpYyBpbnNBcnI6IEFycmF5PFN0cmVhbTxUPj47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxUPjtcbiAgcHJpdmF0ZSBhYzogbnVtYmVyOyAvLyBhYyBpcyBhY3RpdmVDb3VudFxuXG4gIGNvbnN0cnVjdG9yKGluc0FycjogQXJyYXk8U3RyZWFtPFQ+Pikge1xuICAgIHRoaXMuaW5zQXJyID0gaW5zQXJyO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICAgIHRoaXMuYWMgPSAwO1xuICB9XG5cbiAgX3N0YXJ0KG91dDogU3RyZWFtPFQ+KTogdm9pZCB7XG4gICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgY29uc3QgcyA9IHRoaXMuaW5zQXJyO1xuICAgIGNvbnN0IEwgPSBzLmxlbmd0aDtcbiAgICB0aGlzLmFjID0gTDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IEw7IGkrKykgc1tpXS5fYWRkKHRoaXMpO1xuICB9XG5cbiAgX3N0b3AoKTogdm9pZCB7XG4gICAgY29uc3QgcyA9IHRoaXMuaW5zQXJyO1xuICAgIGNvbnN0IEwgPSBzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IEw7IGkrKykgc1tpXS5fcmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICB9XG5cbiAgX24odDogVCkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICB1Ll9uKHQpO1xuICB9XG5cbiAgX2UoZXJyOiBhbnkpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgdS5fZShlcnIpO1xuICB9XG5cbiAgX2MoKSB7XG4gICAgaWYgKC0tdGhpcy5hYyA8PSAwKSB7XG4gICAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICAgIHUuX2MoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21iaW5lU2lnbmF0dXJlIHtcbiAgKCk6IFN0cmVhbTxBcnJheTxhbnk+PjtcbiAgPFQxPihzMTogU3RyZWFtPFQxPik6IFN0cmVhbTxbVDFdPjtcbiAgPFQxLCBUMj4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4pOiBTdHJlYW08W1QxLCBUMl0+O1xuICA8VDEsIFQyLCBUMz4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4pOiBTdHJlYW08W1QxLCBUMiwgVDNdPjtcbiAgPFQxLCBUMiwgVDMsIFQ0PihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPixcbiAgICBzNDogU3RyZWFtPFQ0Pik6IFN0cmVhbTxbVDEsIFQyLCBUMywgVDRdPjtcbiAgPFQxLCBUMiwgVDMsIFQ0LCBUNT4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4pOiBTdHJlYW08W1QxLCBUMiwgVDMsIFQ0LCBUNV0+O1xuICA8VDEsIFQyLCBUMywgVDQsIFQ1LCBUNj4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4sXG4gICAgczY6IFN0cmVhbTxUNj4pOiBTdHJlYW08W1QxLCBUMiwgVDMsIFQ0LCBUNSwgVDZdPjtcbiAgPFQxLCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFQ3PihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPixcbiAgICBzNDogU3RyZWFtPFQ0PixcbiAgICBzNTogU3RyZWFtPFQ1PixcbiAgICBzNjogU3RyZWFtPFQ2PixcbiAgICBzNzogU3RyZWFtPFQ3Pik6IFN0cmVhbTxbVDEsIFQyLCBUMywgVDQsIFQ1LCBUNiwgVDddPjtcbiAgPFQxLCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFQ3LCBUOD4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4sXG4gICAgczY6IFN0cmVhbTxUNj4sXG4gICAgczc6IFN0cmVhbTxUNz4sXG4gICAgczg6IFN0cmVhbTxUOD4pOiBTdHJlYW08W1QxLCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFQ3LCBUOF0+O1xuICA8VDEsIFQyLCBUMywgVDQsIFQ1LCBUNiwgVDcsIFQ4LCBUOT4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4sXG4gICAgczY6IFN0cmVhbTxUNj4sXG4gICAgczc6IFN0cmVhbTxUNz4sXG4gICAgczg6IFN0cmVhbTxUOD4sXG4gICAgczk6IFN0cmVhbTxUOT4pOiBTdHJlYW08W1QxLCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFQ3LCBUOCwgVDldPjtcbiAgPFQxLCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFQ3LCBUOCwgVDksIFQxMD4oXG4gICAgczE6IFN0cmVhbTxUMT4sXG4gICAgczI6IFN0cmVhbTxUMj4sXG4gICAgczM6IFN0cmVhbTxUMz4sXG4gICAgczQ6IFN0cmVhbTxUND4sXG4gICAgczU6IFN0cmVhbTxUNT4sXG4gICAgczY6IFN0cmVhbTxUNj4sXG4gICAgczc6IFN0cmVhbTxUNz4sXG4gICAgczg6IFN0cmVhbTxUOD4sXG4gICAgczk6IFN0cmVhbTxUOT4sXG4gICAgczEwOiBTdHJlYW08VDEwPik6IFN0cmVhbTxbVDEsIFQyLCBUMywgVDQsIFQ1LCBUNiwgVDcsIFQ4LCBUOSwgVDEwXT47XG4gICguLi5zdHJlYW06IEFycmF5PFN0cmVhbTxhbnk+Pik6IFN0cmVhbTxBcnJheTxhbnk+Pjtcbn1cblxuY2xhc3MgQ29tYmluZUxpc3RlbmVyPFQ+IGltcGxlbWVudHMgSW50ZXJuYWxMaXN0ZW5lcjxUPiwgT3V0U2VuZGVyPEFycmF5PFQ+PiB7XG4gIHByaXZhdGUgaTogbnVtYmVyO1xuICBwdWJsaWMgb3V0OiBTdHJlYW08QXJyYXk8VD4+O1xuICBwcml2YXRlIHA6IENvbWJpbmU8VD47XG5cbiAgY29uc3RydWN0b3IoaTogbnVtYmVyLCBvdXQ6IFN0cmVhbTxBcnJheTxUPj4sIHA6IENvbWJpbmU8VD4pIHtcbiAgICB0aGlzLmkgPSBpO1xuICAgIHRoaXMub3V0ID0gb3V0O1xuICAgIHRoaXMucCA9IHA7XG4gICAgcC5pbHMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIF9uKHQ6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBwID0gdGhpcy5wLCBvdXQgPSB0aGlzLm91dDtcbiAgICBpZiAob3V0ID09PSBOTykgcmV0dXJuO1xuICAgIGlmIChwLnVwKHQsIHRoaXMuaSkpIHtcbiAgICAgIGNvbnN0IGEgPSBwLnZhbHM7XG4gICAgICBjb25zdCBsID0gYS5sZW5ndGg7XG4gICAgICBjb25zdCBiID0gQXJyYXkobCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkgYltpXSA9IGFbaV07XG4gICAgICBvdXQuX24oYik7XG4gICAgfVxuICB9XG5cbiAgX2UoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBvdXQgPSB0aGlzLm91dDtcbiAgICBpZiAob3V0ID09PSBOTykgcmV0dXJuO1xuICAgIG91dC5fZShlcnIpO1xuICB9XG5cbiAgX2MoKTogdm9pZCB7XG4gICAgY29uc3QgcCA9IHRoaXMucDtcbiAgICBpZiAocC5vdXQgPT09IE5PKSByZXR1cm47XG4gICAgaWYgKC0tcC5OYyA9PT0gMCkgcC5vdXQuX2MoKTtcbiAgfVxufVxuXG5jbGFzcyBDb21iaW5lPFI+IGltcGxlbWVudHMgQWdncmVnYXRvcjxhbnksIEFycmF5PFI+PiB7XG4gIHB1YmxpYyB0eXBlID0gJ2NvbWJpbmUnO1xuICBwdWJsaWMgaW5zQXJyOiBBcnJheTxTdHJlYW08YW55Pj47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxBcnJheTxSPj47XG4gIHB1YmxpYyBpbHM6IEFycmF5PENvbWJpbmVMaXN0ZW5lcjxhbnk+PjtcbiAgcHVibGljIE5jOiBudW1iZXI7IC8vICpOKnVtYmVyIG9mIHN0cmVhbXMgc3RpbGwgdG8gc2VuZCAqYypvbXBsZXRlXG4gIHB1YmxpYyBObjogbnVtYmVyOyAvLyAqTip1bWJlciBvZiBzdHJlYW1zIHN0aWxsIHRvIHNlbmQgKm4qZXh0XG4gIHB1YmxpYyB2YWxzOiBBcnJheTxSPjtcblxuICBjb25zdHJ1Y3RvcihpbnNBcnI6IEFycmF5PFN0cmVhbTxhbnk+Pikge1xuICAgIHRoaXMuaW5zQXJyID0gaW5zQXJyO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPEFycmF5PFI+PjtcbiAgICB0aGlzLmlscyA9IFtdO1xuICAgIHRoaXMuTmMgPSB0aGlzLk5uID0gMDtcbiAgICB0aGlzLnZhbHMgPSBbXTtcbiAgfVxuXG4gIHVwKHQ6IGFueSwgaTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdiA9IHRoaXMudmFsc1tpXTtcbiAgICBjb25zdCBObiA9ICF0aGlzLk5uID8gMCA6IHYgPT09IE5PID8gLS10aGlzLk5uIDogdGhpcy5ObjtcbiAgICB0aGlzLnZhbHNbaV0gPSB0O1xuICAgIHJldHVybiBObiA9PT0gMDtcbiAgfVxuXG4gIF9zdGFydChvdXQ6IFN0cmVhbTxBcnJheTxSPj4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICBjb25zdCBzID0gdGhpcy5pbnNBcnI7XG4gICAgY29uc3QgbiA9IHRoaXMuTmMgPSB0aGlzLk5uID0gcy5sZW5ndGg7XG4gICAgY29uc3QgdmFscyA9IHRoaXMudmFscyA9IG5ldyBBcnJheShuKTtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgb3V0Ll9uKFtdKTtcbiAgICAgIG91dC5fYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YWxzW2ldID0gTk87XG4gICAgICAgIHNbaV0uX2FkZChuZXcgQ29tYmluZUxpc3RlbmVyKGksIG91dCwgdGhpcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIGNvbnN0IHMgPSB0aGlzLmluc0FycjtcbiAgICBjb25zdCBuID0gcy5sZW5ndGg7XG4gICAgY29uc3QgaWxzID0gdGhpcy5pbHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHNbaV0uX3JlbW92ZShpbHNbaV0pO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPEFycmF5PFI+PjtcbiAgICB0aGlzLmlscyA9IFtdO1xuICAgIHRoaXMudmFscyA9IFtdO1xuICB9XG59XG5cbmNsYXNzIEZyb21BcnJheTxUPiBpbXBsZW1lbnRzIEludGVybmFsUHJvZHVjZXI8VD4ge1xuICBwdWJsaWMgdHlwZSA9ICdmcm9tQXJyYXknO1xuICBwdWJsaWMgYTogQXJyYXk8VD47XG5cbiAgY29uc3RydWN0b3IoYTogQXJyYXk8VD4pIHtcbiAgICB0aGlzLmEgPSBhO1xuICB9XG5cbiAgX3N0YXJ0KG91dDogSW50ZXJuYWxMaXN0ZW5lcjxUPik6IHZvaWQge1xuICAgIGNvbnN0IGEgPSB0aGlzLmE7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkrKykgb3V0Ll9uKGFbaV0pO1xuICAgIG91dC5fYygpO1xuICB9XG5cbiAgX3N0b3AoKTogdm9pZCB7XG4gIH1cbn1cblxuY2xhc3MgRnJvbVByb21pc2U8VD4gaW1wbGVtZW50cyBJbnRlcm5hbFByb2R1Y2VyPFQ+IHtcbiAgcHVibGljIHR5cGUgPSAnZnJvbVByb21pc2UnO1xuICBwdWJsaWMgb246IGJvb2xlYW47XG4gIHB1YmxpYyBwOiBQcm9taXNlTGlrZTxUPjtcblxuICBjb25zdHJ1Y3RvcihwOiBQcm9taXNlTGlrZTxUPikge1xuICAgIHRoaXMub24gPSBmYWxzZTtcbiAgICB0aGlzLnAgPSBwO1xuICB9XG5cbiAgX3N0YXJ0KG91dDogSW50ZXJuYWxMaXN0ZW5lcjxUPik6IHZvaWQge1xuICAgIGNvbnN0IHByb2QgPSB0aGlzO1xuICAgIHRoaXMub24gPSB0cnVlO1xuICAgIHRoaXMucC50aGVuKFxuICAgICAgKHY6IFQpID0+IHtcbiAgICAgICAgaWYgKHByb2Qub24pIHtcbiAgICAgICAgICBvdXQuX24odik7XG4gICAgICAgICAgb3V0Ll9jKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoZTogYW55KSA9PiB7XG4gICAgICAgIG91dC5fZShlKTtcbiAgICAgIH0sXG4gICAgKS50aGVuKG5vb3AsIChlcnI6IGFueSkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLm9uID0gZmFsc2U7XG4gIH1cbn1cblxuY2xhc3MgUGVyaW9kaWMgaW1wbGVtZW50cyBJbnRlcm5hbFByb2R1Y2VyPG51bWJlcj4ge1xuICBwdWJsaWMgdHlwZSA9ICdwZXJpb2RpYyc7XG4gIHB1YmxpYyBwZXJpb2Q6IG51bWJlcjtcbiAgcHJpdmF0ZSBpbnRlcnZhbElEOiBhbnk7XG4gIHByaXZhdGUgaTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHBlcmlvZDogbnVtYmVyKSB7XG4gICAgdGhpcy5wZXJpb2QgPSBwZXJpb2Q7XG4gICAgdGhpcy5pbnRlcnZhbElEID0gLTE7XG4gICAgdGhpcy5pID0gMDtcbiAgfVxuXG4gIF9zdGFydChvdXQ6IEludGVybmFsTGlzdGVuZXI8bnVtYmVyPik6IHZvaWQge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGludGVydmFsSGFuZGxlcigpIHsgb3V0Ll9uKHNlbGYuaSsrKTsgfVxuICAgIHRoaXMuaW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGludGVydmFsSGFuZGxlciwgdGhpcy5wZXJpb2QpO1xuICB9XG5cbiAgX3N0b3AoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWxJRCAhPT0gLTEpIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElEKTtcbiAgICB0aGlzLmludGVydmFsSUQgPSAtMTtcbiAgICB0aGlzLmkgPSAwO1xuICB9XG59XG5cbmNsYXNzIERlYnVnPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBwdWJsaWMgdHlwZSA9ICdkZWJ1Zyc7XG4gIHB1YmxpYyBpbnM6IFN0cmVhbTxUPjtcbiAgcHVibGljIG91dDogU3RyZWFtPFQ+O1xuICBwcml2YXRlIHM6ICh0OiBUKSA9PiBhbnk7IC8vIHNweVxuICBwcml2YXRlIGw6IHN0cmluZzsgLy8gbGFiZWxcblxuICBjb25zdHJ1Y3RvcihpbnM6IFN0cmVhbTxUPik7XG4gIGNvbnN0cnVjdG9yKGluczogU3RyZWFtPFQ+LCBhcmc/OiBzdHJpbmcpO1xuICBjb25zdHJ1Y3RvcihpbnM6IFN0cmVhbTxUPiwgYXJnPzogKHQ6IFQpID0+IGFueSk7XG4gIGNvbnN0cnVjdG9yKGluczogU3RyZWFtPFQ+LCBhcmc/OiBzdHJpbmcgfCAoKHQ6IFQpID0+IGFueSkpO1xuICBjb25zdHJ1Y3RvcihpbnM6IFN0cmVhbTxUPiwgYXJnPzogc3RyaW5nIHwgKCh0OiBUKSA9PiBhbnkpIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gICAgdGhpcy5zID0gbm9vcDtcbiAgICB0aGlzLmwgPSAnJztcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHRoaXMubCA9IGFyZzsgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5zID0gYXJnO1xuICB9XG5cbiAgX3N0YXJ0KG91dDogU3RyZWFtPFQ+KTogdm9pZCB7XG4gICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gIH1cblxuICBfbih0OiBUKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMsIGwgPSB0aGlzLmw7XG4gICAgaWYgKHMgIT09IG5vb3ApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHModCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHUuX2UoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsKSBjb25zb2xlLmxvZyhsICsgJzonLCB0KTsgZWxzZSBjb25zb2xlLmxvZyh0KTtcbiAgICB1Ll9uKHQpO1xuICB9XG5cbiAgX2UoZXJyOiBhbnkpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgdS5fZShlcnIpO1xuICB9XG5cbiAgX2MoKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2MoKTtcbiAgfVxufVxuXG5jbGFzcyBEcm9wPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBwdWJsaWMgdHlwZSA9ICdkcm9wJztcbiAgcHVibGljIGluczogU3RyZWFtPFQ+O1xuICBwdWJsaWMgb3V0OiBTdHJlYW08VD47XG4gIHB1YmxpYyBtYXg6IG51bWJlcjtcbiAgcHJpdmF0ZSBkcm9wcGVkOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IobWF4OiBudW1iZXIsIGluczogU3RyZWFtPFQ+KSB7XG4gICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy5kcm9wcGVkID0gMDtcbiAgfVxuXG4gIF9zdGFydChvdXQ6IFN0cmVhbTxUPik6IHZvaWQge1xuICAgIHRoaXMub3V0ID0gb3V0O1xuICAgIHRoaXMuZHJvcHBlZCA9IDA7XG4gICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gIH1cblxuICBfbih0OiBUKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIGlmICh0aGlzLmRyb3BwZWQrKyA+PSB0aGlzLm1heCkgdS5fbih0KTtcbiAgfVxuXG4gIF9lKGVycjogYW55KSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2UoZXJyKTtcbiAgfVxuXG4gIF9jKCkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICB1Ll9jKCk7XG4gIH1cbn1cblxuY2xhc3MgRW5kV2hlbkxpc3RlbmVyPFQ+IGltcGxlbWVudHMgSW50ZXJuYWxMaXN0ZW5lcjxhbnk+IHtcbiAgcHJpdmF0ZSBvdXQ6IFN0cmVhbTxUPjtcbiAgcHJpdmF0ZSBvcDogRW5kV2hlbjxUPjtcblxuICBjb25zdHJ1Y3RvcihvdXQ6IFN0cmVhbTxUPiwgb3A6IEVuZFdoZW48VD4pIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLm9wID0gb3A7XG4gIH1cblxuICBfbigpIHtcbiAgICB0aGlzLm9wLmVuZCgpO1xuICB9XG5cbiAgX2UoZXJyOiBhbnkpIHtcbiAgICB0aGlzLm91dC5fZShlcnIpO1xuICB9XG5cbiAgX2MoKSB7XG4gICAgdGhpcy5vcC5lbmQoKTtcbiAgfVxufVxuXG5jbGFzcyBFbmRXaGVuPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBwdWJsaWMgdHlwZSA9ICdlbmRXaGVuJztcbiAgcHVibGljIGluczogU3RyZWFtPFQ+O1xuICBwdWJsaWMgb3V0OiBTdHJlYW08VD47XG4gIHB1YmxpYyBvOiBTdHJlYW08YW55PjsgLy8gbyA9IG90aGVyXG4gIHByaXZhdGUgb2lsOiBJbnRlcm5hbExpc3RlbmVyPGFueT47IC8vIG9pbCA9IG90aGVyIEludGVybmFsTGlzdGVuZXJcblxuICBjb25zdHJ1Y3RvcihvOiBTdHJlYW08YW55PiwgaW5zOiBTdHJlYW08VD4pIHtcbiAgICB0aGlzLmlucyA9IGlucztcbiAgICB0aGlzLm91dCA9IE5PIGFzIFN0cmVhbTxUPjtcbiAgICB0aGlzLm8gPSBvO1xuICAgIHRoaXMub2lsID0gTk9fSUw7XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08VD4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLm8uX2FkZCh0aGlzLm9pbCA9IG5ldyBFbmRXaGVuTGlzdGVuZXIob3V0LCB0aGlzKSk7XG4gICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5vLl9yZW1vdmUodGhpcy5vaWwpO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICAgIHRoaXMub2lsID0gTk9fSUw7XG4gIH1cblxuICBlbmQoKTogdm9pZCB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2MoKTtcbiAgfVxuXG4gIF9uKHQ6IFQpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgdS5fbih0KTtcbiAgfVxuXG4gIF9lKGVycjogYW55KSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2UoZXJyKTtcbiAgfVxuXG4gIF9jKCkge1xuICAgIHRoaXMuZW5kKCk7XG4gIH1cbn1cblxuY2xhc3MgRmlsdGVyPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBwdWJsaWMgdHlwZSA9ICdmaWx0ZXInO1xuICBwdWJsaWMgaW5zOiBTdHJlYW08VD47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxUPjtcbiAgcHVibGljIGY6ICh0OiBUKSA9PiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHBhc3NlczogKHQ6IFQpID0+IGJvb2xlYW4sIGluczogU3RyZWFtPFQ+KSB7XG4gICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gICAgdGhpcy5mID0gcGFzc2VzO1xuICB9XG5cbiAgX3N0YXJ0KG91dDogU3RyZWFtPFQ+KTogdm9pZCB7XG4gICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gIH1cblxuICBfbih0OiBUKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBfdHJ5KHRoaXMsIHQsIHUpO1xuICAgIGlmIChyID09PSBOTyB8fCAhcikgcmV0dXJuO1xuICAgIHUuX24odCk7XG4gIH1cblxuICBfZShlcnI6IGFueSkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICB1Ll9lKGVycik7XG4gIH1cblxuICBfYygpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgdS5fYygpO1xuICB9XG59XG5cbmNsYXNzIEZsYXR0ZW5MaXN0ZW5lcjxUPiBpbXBsZW1lbnRzIEludGVybmFsTGlzdGVuZXI8VD4ge1xuICBwcml2YXRlIG91dDogU3RyZWFtPFQ+O1xuICBwcml2YXRlIG9wOiBGbGF0dGVuPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKG91dDogU3RyZWFtPFQ+LCBvcDogRmxhdHRlbjxUPikge1xuICAgIHRoaXMub3V0ID0gb3V0O1xuICAgIHRoaXMub3AgPSBvcDtcbiAgfVxuXG4gIF9uKHQ6IFQpIHtcbiAgICB0aGlzLm91dC5fbih0KTtcbiAgfVxuXG4gIF9lKGVycjogYW55KSB7XG4gICAgdGhpcy5vdXQuX2UoZXJyKTtcbiAgfVxuXG4gIF9jKCkge1xuICAgIHRoaXMub3AuaW5uZXIgPSBOTyBhcyBTdHJlYW08VD47XG4gICAgdGhpcy5vcC5sZXNzKCk7XG4gIH1cbn1cblxuY2xhc3MgRmxhdHRlbjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFN0cmVhbTxUPiwgVD4ge1xuICBwdWJsaWMgdHlwZSA9ICdmbGF0dGVuJztcbiAgcHVibGljIGluczogU3RyZWFtPFN0cmVhbTxUPj47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxUPjtcbiAgcHJpdmF0ZSBvcGVuOiBib29sZWFuO1xuICBwdWJsaWMgaW5uZXI6IFN0cmVhbTxUPjsgLy8gQ3VycmVudCBpbm5lciBTdHJlYW1cbiAgcHJpdmF0ZSBpbDogSW50ZXJuYWxMaXN0ZW5lcjxUPjsgLy8gQ3VycmVudCBpbm5lciBJbnRlcm5hbExpc3RlbmVyXG5cbiAgY29uc3RydWN0b3IoaW5zOiBTdHJlYW08U3RyZWFtPFQ+Pikge1xuICAgIHRoaXMuaW5zID0gaW5zO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgdGhpcy5pbm5lciA9IE5PIGFzIFN0cmVhbTxUPjtcbiAgICB0aGlzLmlsID0gTk9fSUw7XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08VD4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgIHRoaXMuaW5uZXIgPSBOTyBhcyBTdHJlYW08VD47XG4gICAgdGhpcy5pbCA9IE5PX0lMO1xuICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gIH1cblxuICBfc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgIGlmICh0aGlzLmlubmVyICE9PSBOTykgdGhpcy5pbm5lci5fcmVtb3ZlKHRoaXMuaWwpO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgdGhpcy5pbm5lciA9IE5PIGFzIFN0cmVhbTxUPjtcbiAgICB0aGlzLmlsID0gTk9fSUw7XG4gIH1cblxuICBsZXNzKCk6IHZvaWQge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICBpZiAoIXRoaXMub3BlbiAmJiB0aGlzLmlubmVyID09PSBOTykgdS5fYygpO1xuICB9XG5cbiAgX24oczogU3RyZWFtPFQ+KSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIGNvbnN0IHtpbm5lciwgaWx9ID0gdGhpcztcbiAgICBpZiAoaW5uZXIgIT09IE5PICYmIGlsICE9PSBOT19JTCkgaW5uZXIuX3JlbW92ZShpbCk7XG4gICAgKHRoaXMuaW5uZXIgPSBzKS5fYWRkKHRoaXMuaWwgPSBuZXcgRmxhdHRlbkxpc3RlbmVyKHUsIHRoaXMpKTtcbiAgfVxuXG4gIF9lKGVycjogYW55KSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2UoZXJyKTtcbiAgfVxuXG4gIF9jKCkge1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgIHRoaXMubGVzcygpO1xuICB9XG59XG5cbmNsYXNzIEZvbGQ8VCwgUj4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBSPiB7XG4gIHB1YmxpYyB0eXBlID0gJ2ZvbGQnO1xuICBwdWJsaWMgaW5zOiBTdHJlYW08VD47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxSPjtcbiAgcHVibGljIGY6ICh0OiBUKSA9PiBSO1xuICBwdWJsaWMgc2VlZDogUjtcbiAgcHJpdmF0ZSBhY2M6IFI7IC8vIGluaXRpYWxpemVkIGFzIHNlZWRcblxuICBjb25zdHJ1Y3RvcihmOiAoYWNjOiBSLCB0OiBUKSA9PiBSLCBzZWVkOiBSLCBpbnM6IFN0cmVhbTxUPikge1xuICAgIHRoaXMuaW5zID0gaW5zO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFI+O1xuICAgIHRoaXMuZiA9ICh0OiBUKSA9PiBmKHRoaXMuYWNjLCB0KTtcbiAgICB0aGlzLmFjYyA9IHRoaXMuc2VlZCA9IHNlZWQ7XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08Uj4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLmFjYyA9IHRoaXMuc2VlZDtcbiAgICBvdXQuX24odGhpcy5hY2MpO1xuICAgIHRoaXMuaW5zLl9hZGQodGhpcyk7XG4gIH1cblxuICBfc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFI+O1xuICAgIHRoaXMuYWNjID0gdGhpcy5zZWVkO1xuICB9XG5cbiAgX24odDogVCkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICBjb25zdCByID0gX3RyeSh0aGlzLCB0LCB1KTtcbiAgICBpZiAociA9PT0gTk8pIHJldHVybjtcbiAgICB1Ll9uKHRoaXMuYWNjID0gciBhcyBSKTtcbiAgfVxuXG4gIF9lKGVycjogYW55KSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2UoZXJyKTtcbiAgfVxuXG4gIF9jKCkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICB1Ll9jKCk7XG4gIH1cbn1cblxuY2xhc3MgTGFzdDxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgcHVibGljIHR5cGUgPSAnbGFzdCc7XG4gIHB1YmxpYyBpbnM6IFN0cmVhbTxUPjtcbiAgcHVibGljIG91dDogU3RyZWFtPFQ+O1xuICBwcml2YXRlIGhhczogYm9vbGVhbjtcbiAgcHJpdmF0ZSB2YWw6IFQ7XG5cbiAgY29uc3RydWN0b3IoaW5zOiBTdHJlYW08VD4pIHtcbiAgICB0aGlzLmlucyA9IGlucztcbiAgICB0aGlzLm91dCA9IE5PIGFzIFN0cmVhbTxUPjtcbiAgICB0aGlzLmhhcyA9IGZhbHNlO1xuICAgIHRoaXMudmFsID0gTk8gYXMgVDtcbiAgfVxuXG4gIF9zdGFydChvdXQ6IFN0cmVhbTxUPik6IHZvaWQge1xuICAgIHRoaXMub3V0ID0gb3V0O1xuICAgIHRoaXMuaGFzID0gZmFsc2U7XG4gICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gICAgdGhpcy52YWwgPSBOTyBhcyBUO1xuICB9XG5cbiAgX24odDogVCkge1xuICAgIHRoaXMuaGFzID0gdHJ1ZTtcbiAgICB0aGlzLnZhbCA9IHQ7XG4gIH1cblxuICBfZShlcnI6IGFueSkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICB1Ll9lKGVycik7XG4gIH1cblxuICBfYygpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgaWYgKHRoaXMuaGFzKSB7XG4gICAgICB1Ll9uKHRoaXMudmFsKTtcbiAgICAgIHUuX2MoKTtcbiAgICB9IGVsc2UgdS5fZShuZXcgRXJyb3IoJ2xhc3QoKSBmYWlsZWQgYmVjYXVzZSBpbnB1dCBzdHJlYW0gY29tcGxldGVkJykpO1xuICB9XG59XG5cbmNsYXNzIE1hcE9wPFQsIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgUj4ge1xuICBwdWJsaWMgdHlwZSA9ICdtYXAnO1xuICBwdWJsaWMgaW5zOiBTdHJlYW08VD47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxSPjtcbiAgcHVibGljIGY6ICh0OiBUKSA9PiBSO1xuXG4gIGNvbnN0cnVjdG9yKHByb2plY3Q6ICh0OiBUKSA9PiBSLCBpbnM6IFN0cmVhbTxUPikge1xuICAgIHRoaXMuaW5zID0gaW5zO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFI+O1xuICAgIHRoaXMuZiA9IHByb2plY3Q7XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08Uj4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLmlucy5fYWRkKHRoaXMpO1xuICB9XG5cbiAgX3N0b3AoKTogdm9pZCB7XG4gICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICB0aGlzLm91dCA9IE5PIGFzIFN0cmVhbTxSPjtcbiAgfVxuXG4gIF9uKHQ6IFQpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgY29uc3QgciA9IF90cnkodGhpcywgdCwgdSk7XG4gICAgaWYgKHIgPT09IE5PKSByZXR1cm47XG4gICAgdS5fbihyIGFzIFIpO1xuICB9XG5cbiAgX2UoZXJyOiBhbnkpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgdS5fZShlcnIpO1xuICB9XG5cbiAgX2MoKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2MoKTtcbiAgfVxufVxuXG5jbGFzcyBSZW1lbWJlcjxUPiBpbXBsZW1lbnRzIEludGVybmFsUHJvZHVjZXI8VD4ge1xuICBwdWJsaWMgdHlwZSA9ICdyZW1lbWJlcic7XG4gIHB1YmxpYyBpbnM6IFN0cmVhbTxUPjtcbiAgcHVibGljIG91dDogU3RyZWFtPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKGluczogU3RyZWFtPFQ+KSB7XG4gICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08VD4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLmlucy5fYWRkKG91dCk7XG4gIH1cblxuICBfc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLmlucy5fcmVtb3ZlKHRoaXMub3V0KTtcbiAgICB0aGlzLm91dCA9IE5PIGFzIFN0cmVhbTxUPjtcbiAgfVxufVxuXG5jbGFzcyBSZXBsYWNlRXJyb3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIHB1YmxpYyB0eXBlID0gJ3JlcGxhY2VFcnJvcic7XG4gIHB1YmxpYyBpbnM6IFN0cmVhbTxUPjtcbiAgcHVibGljIG91dDogU3RyZWFtPFQ+O1xuICBwdWJsaWMgZjogKGVycjogYW55KSA9PiBTdHJlYW08VD47XG5cbiAgY29uc3RydWN0b3IocmVwbGFjZXI6IChlcnI6IGFueSkgPT4gU3RyZWFtPFQ+LCBpbnM6IFN0cmVhbTxUPikge1xuICAgIHRoaXMuaW5zID0gaW5zO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICAgIHRoaXMuZiA9IHJlcGxhY2VyO1xuICB9XG5cbiAgX3N0YXJ0KG91dDogU3RyZWFtPFQ+KTogdm9pZCB7XG4gICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gIH1cblxuICBfbih0OiBUKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX24odCk7XG4gIH1cblxuICBfZShlcnI6IGFueSkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAodSA9PT0gTk8pIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICAgICh0aGlzLmlucyA9IHRoaXMuZihlcnIpKS5fYWRkKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHUuX2UoZSk7XG4gICAgfVxuICB9XG5cbiAgX2MoKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2MoKTtcbiAgfVxufVxuXG5jbGFzcyBTdGFydFdpdGg8VD4gaW1wbGVtZW50cyBJbnRlcm5hbFByb2R1Y2VyPFQ+IHtcbiAgcHVibGljIHR5cGUgPSAnc3RhcnRXaXRoJztcbiAgcHVibGljIGluczogU3RyZWFtPFQ+O1xuICBwdWJsaWMgb3V0OiBTdHJlYW08VD47XG4gIHB1YmxpYyB2YWw6IFQ7XG5cbiAgY29uc3RydWN0b3IoaW5zOiBTdHJlYW08VD4sIHZhbDogVCkge1xuICAgIHRoaXMuaW5zID0gaW5zO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICAgIHRoaXMudmFsID0gdmFsO1xuICB9XG5cbiAgX3N0YXJ0KG91dDogU3RyZWFtPFQ+KTogdm9pZCB7XG4gICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgdGhpcy5vdXQuX24odGhpcy52YWwpO1xuICAgIHRoaXMuaW5zLl9hZGQob3V0KTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcy5vdXQpO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPFQ+O1xuICB9XG59XG5cbmNsYXNzIFRha2U8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIHB1YmxpYyB0eXBlID0gJ3Rha2UnO1xuICBwdWJsaWMgaW5zOiBTdHJlYW08VD47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxUPjtcbiAgcHVibGljIG1heDogbnVtYmVyO1xuICBwcml2YXRlIHRha2VuOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IobWF4OiBudW1iZXIsIGluczogU3RyZWFtPFQ+KSB7XG4gICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy50YWtlbiA9IDA7XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08VD4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICB0aGlzLnRha2VuID0gMDtcbiAgICBpZiAodGhpcy5tYXggPD0gMCkgb3V0Ll9jKCk7IGVsc2UgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIHRoaXMuaW5zLl9yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5vdXQgPSBOTyBhcyBTdHJlYW08VD47XG4gIH1cblxuICBfbih0OiBUKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIGNvbnN0IG0gPSArK3RoaXMudGFrZW47XG4gICAgaWYgKG0gPCB0aGlzLm1heCkgdS5fbih0KTsgZWxzZSBpZiAobSA9PT0gdGhpcy5tYXgpIHtcbiAgICAgIHUuX24odCk7XG4gICAgICB1Ll9jKCk7XG4gICAgfVxuICB9XG5cbiAgX2UoZXJyOiBhbnkpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKHUgPT09IE5PKSByZXR1cm47XG4gICAgdS5fZShlcnIpO1xuICB9XG5cbiAgX2MoKSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICh1ID09PSBOTykgcmV0dXJuO1xuICAgIHUuX2MoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3RyZWFtPFQ+IGltcGxlbWVudHMgSW50ZXJuYWxMaXN0ZW5lcjxUPiB7XG4gIHB1YmxpYyBfcHJvZDogSW50ZXJuYWxQcm9kdWNlcjxUPjtcbiAgcHJvdGVjdGVkIF9pbHM6IEFycmF5PEludGVybmFsTGlzdGVuZXI8VD4+OyAvLyAnaWxzJyA9IEludGVybmFsIGxpc3RlbmVyc1xuICBwcm90ZWN0ZWQgX3N0b3BJRDogYW55O1xuICBwcm90ZWN0ZWQgX2RsOiBJbnRlcm5hbExpc3RlbmVyPFQ+OyAvLyB0aGUgZGVidWcgbGlzdGVuZXJcbiAgcHJvdGVjdGVkIF9kOiBib29sZWFuOyAvLyBmbGFnIGluZGljYXRpbmcgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZGVidWcgbGlzdGVuZXJcbiAgcHJvdGVjdGVkIF90YXJnZXQ6IFN0cmVhbTxUPjsgLy8gaW1pdGF0aW9uIHRhcmdldCBpZiB0aGlzIFN0cmVhbSB3aWxsIGltaXRhdGVcbiAgcHJvdGVjdGVkIF9lcnI6IGFueTtcblxuICBjb25zdHJ1Y3Rvcihwcm9kdWNlcj86IEludGVybmFsUHJvZHVjZXI8VD4pIHtcbiAgICB0aGlzLl9wcm9kID0gcHJvZHVjZXIgfHwgTk8gYXMgSW50ZXJuYWxQcm9kdWNlcjxUPjtcbiAgICB0aGlzLl9pbHMgPSBbXTtcbiAgICB0aGlzLl9zdG9wSUQgPSBOTztcbiAgICB0aGlzLl9kbCA9IE5PIGFzIEludGVybmFsTGlzdGVuZXI8VD47XG4gICAgdGhpcy5fZCA9IGZhbHNlO1xuICAgIHRoaXMuX3RhcmdldCA9IE5PIGFzIFN0cmVhbTxUPjtcbiAgICB0aGlzLl9lcnIgPSBOTztcbiAgfVxuXG4gIF9uKHQ6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBhID0gdGhpcy5faWxzO1xuICAgIGNvbnN0IEwgPSBhLmxlbmd0aDtcbiAgICBpZiAodGhpcy5fZCkgdGhpcy5fZGwuX24odCk7XG4gICAgaWYgKEwgPT0gMSkgYVswXS5fbih0KTsgZWxzZSBpZiAoTCA9PSAwKSByZXR1cm47IGVsc2Uge1xuICAgICAgY29uc3QgYiA9IGNwKGEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBMOyBpKyspIGJbaV0uX24odCk7XG4gICAgfVxuICB9XG5cbiAgX2UoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZXJyICE9PSBOTykgcmV0dXJuO1xuICAgIHRoaXMuX2VyciA9IGVycjtcbiAgICBjb25zdCBhID0gdGhpcy5faWxzO1xuICAgIGNvbnN0IEwgPSBhLmxlbmd0aDtcbiAgICB0aGlzLl94KCk7XG4gICAgaWYgKHRoaXMuX2QpIHRoaXMuX2RsLl9lKGVycik7XG4gICAgaWYgKEwgPT0gMSkgYVswXS5fZShlcnIpOyBlbHNlIGlmIChMID09IDApIHJldHVybjsgZWxzZSB7XG4gICAgICBjb25zdCBiID0gY3AoYSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEw7IGkrKykgYltpXS5fZShlcnIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2QgJiYgTCA9PSAwKSB0aHJvdyB0aGlzLl9lcnI7XG4gIH1cblxuICBfYygpOiB2b2lkIHtcbiAgICBjb25zdCBhID0gdGhpcy5faWxzO1xuICAgIGNvbnN0IEwgPSBhLmxlbmd0aDtcbiAgICB0aGlzLl94KCk7XG4gICAgaWYgKHRoaXMuX2QpIHRoaXMuX2RsLl9jKCk7XG4gICAgaWYgKEwgPT0gMSkgYVswXS5fYygpOyBlbHNlIGlmIChMID09IDApIHJldHVybjsgZWxzZSB7XG4gICAgICBjb25zdCBiID0gY3AoYSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEw7IGkrKykgYltpXS5fYygpO1xuICAgIH1cbiAgfVxuXG4gIF94KCk6IHZvaWQgeyAvLyB0ZWFyIGRvd24gbG9naWMsIGFmdGVyIGVycm9yIG9yIGNvbXBsZXRlXG4gICAgaWYgKHRoaXMuX2lscy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBpZiAodGhpcy5fcHJvZCAhPT0gTk8pIHRoaXMuX3Byb2QuX3N0b3AoKTtcbiAgICB0aGlzLl9lcnIgPSBOTztcbiAgICB0aGlzLl9pbHMgPSBbXTtcbiAgfVxuXG4gIF9zdG9wTm93KCkge1xuICAgIC8vIFdBUk5JTkc6IGNvZGUgdGhhdCBjYWxscyB0aGlzIG1ldGhvZCBzaG91bGRcbiAgICAvLyBmaXJzdCBjaGVjayBpZiB0aGlzLl9wcm9kIGlzIHZhbGlkIChub3QgYE5PYClcbiAgICB0aGlzLl9wcm9kLl9zdG9wKCk7XG4gICAgdGhpcy5fZXJyID0gTk87XG4gICAgdGhpcy5fc3RvcElEID0gTk87XG4gIH1cblxuICBfYWRkKGlsOiBJbnRlcm5hbExpc3RlbmVyPFQ+KTogdm9pZCB7XG4gICAgY29uc3QgdGEgPSB0aGlzLl90YXJnZXQ7XG4gICAgaWYgKHRhICE9PSBOTykgcmV0dXJuIHRhLl9hZGQoaWwpO1xuICAgIGNvbnN0IGEgPSB0aGlzLl9pbHM7XG4gICAgYS5wdXNoKGlsKTtcbiAgICBpZiAoYS5sZW5ndGggPiAxKSByZXR1cm47XG4gICAgaWYgKHRoaXMuX3N0b3BJRCAhPT0gTk8pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdG9wSUQpO1xuICAgICAgdGhpcy5fc3RvcElEID0gTk87XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLl9wcm9kO1xuICAgICAgaWYgKHAgIT09IE5PKSBwLl9zdGFydCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBfcmVtb3ZlKGlsOiBJbnRlcm5hbExpc3RlbmVyPFQ+KTogdm9pZCB7XG4gICAgY29uc3QgdGEgPSB0aGlzLl90YXJnZXQ7XG4gICAgaWYgKHRhICE9PSBOTykgcmV0dXJuIHRhLl9yZW1vdmUoaWwpO1xuICAgIGNvbnN0IGEgPSB0aGlzLl9pbHM7XG4gICAgY29uc3QgaSA9IGEuaW5kZXhPZihpbCk7XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICBpZiAodGhpcy5fcHJvZCAhPT0gTk8gJiYgYS5sZW5ndGggPD0gMCkge1xuICAgICAgICB0aGlzLl9lcnIgPSBOTztcbiAgICAgICAgdGhpcy5fc3RvcElEID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zdG9wTm93KCkpO1xuICAgICAgfSBlbHNlIGlmIChhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl9wcnVuZUN5Y2xlcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIGFsbCBwYXRocyBzdGVtbWluZyBmcm9tIGB0aGlzYCBzdHJlYW0gZXZlbnR1YWxseSBlbmQgYXQgYHRoaXNgXG4gIC8vIHN0cmVhbSwgdGhlbiB3ZSByZW1vdmUgdGhlIHNpbmdsZSBsaXN0ZW5lciBvZiBgdGhpc2Agc3RyZWFtLCB0b1xuICAvLyBmb3JjZSBpdCB0byBlbmQgaXRzIGV4ZWN1dGlvbiBhbmQgZGlzcG9zZSByZXNvdXJjZXMuIFRoaXMgbWV0aG9kXG4gIC8vIGFzc3VtZXMgYXMgYSBwcmVjb25kaXRpb24gdGhhdCB0aGlzLl9pbHMgaGFzIGp1c3Qgb25lIGxpc3RlbmVyLlxuICBfcHJ1bmVDeWNsZXMoKSB7XG4gICAgaWYgKHRoaXMuX2hhc05vU2lua3ModGhpcywgW10pKSB0aGlzLl9yZW1vdmUodGhpcy5faWxzWzBdKTtcbiAgfVxuXG4gIC8vIENoZWNrcyB3aGV0aGVyICp0aGVyZSBpcyBubyogcGF0aCBzdGFydGluZyBmcm9tIGB4YCB0aGF0IGxlYWRzIHRvIGFuIGVuZFxuICAvLyBsaXN0ZW5lciAoc2luaykgaW4gdGhlIHN0cmVhbSBncmFwaCwgZm9sbG93aW5nIGVkZ2VzIEEtPkIgd2hlcmUgQiBpcyBhXG4gIC8vIGxpc3RlbmVyIG9mIEEuIFRoaXMgbWVhbnMgdGhlc2UgcGF0aHMgY29uc3RpdHV0ZSBhIGN5Y2xlIHNvbWVob3cuIElzIGdpdmVuXG4gIC8vIGEgdHJhY2Ugb2YgYWxsIHZpc2l0ZWQgbm9kZXMgc28gZmFyLlxuICBfaGFzTm9TaW5rcyh4OiBJbnRlcm5hbExpc3RlbmVyPGFueT4sIHRyYWNlOiBBcnJheTxhbnk+KTogYm9vbGVhbiB7XG4gICAgaWYgKHRyYWNlLmluZGV4T2YoeCkgIT09IC0xKVxuICAgICAgcmV0dXJuIHRydWU7IGVsc2VcbiAgICBpZiAoKHggYXMgYW55IGFzIE91dFNlbmRlcjxhbnk+KS5vdXQgPT09IHRoaXMpXG4gICAgICByZXR1cm4gdHJ1ZTsgZWxzZVxuICAgIGlmICgoeCBhcyBhbnkgYXMgT3V0U2VuZGVyPGFueT4pLm91dCAmJiAoeCBhcyBhbnkgYXMgT3V0U2VuZGVyPGFueT4pLm91dCAhPT0gTk8pXG4gICAgICByZXR1cm4gdGhpcy5faGFzTm9TaW5rcygoeCBhcyBhbnkgYXMgT3V0U2VuZGVyPGFueT4pLm91dCwgdHJhY2UuY29uY2F0KHgpKTsgZWxzZVxuICAgIGlmICgoeCBhcyBTdHJlYW08YW55PikuX2lscykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIE4gPSAoeCBhcyBTdHJlYW08YW55PikuX2lscy5sZW5ndGg7IGkgPCBOOyBpKyspXG4gICAgICAgIGlmICghdGhpcy5faGFzTm9TaW5rcygoeCBhcyBTdHJlYW08YW55PikuX2lsc1tpXSwgdHJhY2UuY29uY2F0KHgpKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBjdG9yKCk6IHR5cGVvZiBTdHJlYW0ge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgTWVtb3J5U3RyZWFtID8gTWVtb3J5U3RyZWFtIDogU3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBMaXN0ZW5lciB0byB0aGUgU3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgKi9cbiAgYWRkTGlzdGVuZXIobGlzdGVuZXI6IFBhcnRpYWw8TGlzdGVuZXI8VD4+KTogdm9pZCB7XG4gICAgKGxpc3RlbmVyIGFzIEludGVybmFsTGlzdGVuZXI8VD4pLl9uID0gbGlzdGVuZXIubmV4dCB8fCBub29wO1xuICAgIChsaXN0ZW5lciBhcyBJbnRlcm5hbExpc3RlbmVyPFQ+KS5fZSA9IGxpc3RlbmVyLmVycm9yIHx8IG5vb3A7XG4gICAgKGxpc3RlbmVyIGFzIEludGVybmFsTGlzdGVuZXI8VD4pLl9jID0gbGlzdGVuZXIuY29tcGxldGUgfHwgbm9vcDtcbiAgICB0aGlzLl9hZGQobGlzdGVuZXIgYXMgSW50ZXJuYWxMaXN0ZW5lcjxUPik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIExpc3RlbmVyIGZyb20gdGhlIFN0cmVhbSwgYXNzdW1pbmcgdGhlIExpc3RlbmVyIHdhcyBhZGRlZCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtMaXN0ZW5lcjxUPn0gbGlzdGVuZXJcbiAgICovXG4gIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyOiBQYXJ0aWFsPExpc3RlbmVyPFQ+Pik6IHZvaWQge1xuICAgIHRoaXMuX3JlbW92ZShsaXN0ZW5lciBhcyBJbnRlcm5hbExpc3RlbmVyPFQ+KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgTGlzdGVuZXIgdG8gdGhlIFN0cmVhbSByZXR1cm5pbmcgYSBTdWJzY3JpcHRpb24gdG8gcmVtb3ZlIHRoYXRcbiAgICogbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TGlzdGVuZXJ9IGxpc3RlbmVyXG4gICAqIEByZXR1cm5zIHtTdWJzY3JpcHRpb259XG4gICAqL1xuICBzdWJzY3JpYmUobGlzdGVuZXI6IFBhcnRpYWw8TGlzdGVuZXI8VD4+KTogU3Vic2NyaXB0aW9uIHtcbiAgICB0aGlzLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN1YjxUPih0aGlzLCBsaXN0ZW5lciBhcyBJbnRlcm5hbExpc3RlbmVyPFQ+KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgaW50ZXJvcCBiZXR3ZWVuIG1vc3QuanMgYW5kIFJ4SlMgNVxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyZWFtfVxuICAgKi9cbiAgWyQkb2JzZXJ2YWJsZV0oKTogU3RyZWFtPFQ+IHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFN0cmVhbSBnaXZlbiBhIFByb2R1Y2VyLlxuICAgKlxuICAgKiBAZmFjdG9yeSB0cnVlXG4gICAqIEBwYXJhbSB7UHJvZHVjZXJ9IHByb2R1Y2VyIEFuIG9wdGlvbmFsIFByb2R1Y2VyIHRoYXQgZGljdGF0ZXMgaG93IHRvXG4gICAqIHN0YXJ0LCBnZW5lcmF0ZSBldmVudHMsIGFuZCBzdG9wIHRoZSBTdHJlYW0uXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGU8VD4ocHJvZHVjZXI/OiBQcm9kdWNlcjxUPik6IFN0cmVhbTxUPiB7XG4gICAgaWYgKHByb2R1Y2VyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb2R1Y2VyLnN0YXJ0ICE9PSAnZnVuY3Rpb24nXG4gICAgICB8fCB0eXBlb2YgcHJvZHVjZXIuc3RvcCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9kdWNlciByZXF1aXJlcyBib3RoIHN0YXJ0IGFuZCBzdG9wIGZ1bmN0aW9ucycpO1xuICAgICAgaW50ZXJuYWxpemVQcm9kdWNlcihwcm9kdWNlcik7IC8vIG11dGF0ZXMgdGhlIGlucHV0XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtKHByb2R1Y2VyIGFzIEludGVybmFsUHJvZHVjZXI8VD4gJiBQcm9kdWNlcjxUPik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBNZW1vcnlTdHJlYW0gZ2l2ZW4gYSBQcm9kdWNlci5cbiAgICpcbiAgICogQGZhY3RvcnkgdHJ1ZVxuICAgKiBAcGFyYW0ge1Byb2R1Y2VyfSBwcm9kdWNlciBBbiBvcHRpb25hbCBQcm9kdWNlciB0aGF0IGRpY3RhdGVzIGhvdyB0b1xuICAgKiBzdGFydCwgZ2VuZXJhdGUgZXZlbnRzLCBhbmQgc3RvcCB0aGUgU3RyZWFtLlxuICAgKiBAcmV0dXJuIHtNZW1vcnlTdHJlYW19XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlV2l0aE1lbW9yeTxUPihwcm9kdWNlcj86IFByb2R1Y2VyPFQ+KTogTWVtb3J5U3RyZWFtPFQ+IHtcbiAgICBpZiAocHJvZHVjZXIpIGludGVybmFsaXplUHJvZHVjZXIocHJvZHVjZXIpOyAvLyBtdXRhdGVzIHRoZSBpbnB1dFxuICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtPFQ+KHByb2R1Y2VyIGFzIEludGVybmFsUHJvZHVjZXI8VD4gJiBQcm9kdWNlcjxUPik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyB3aGVuIHN0YXJ0ZWQuIEl0IG5ldmVyIGVtaXRzIGFueSBldmVudC5cbiAgICpcbiAgICogTWFyYmxlIGRpYWdyYW06XG4gICAqXG4gICAqIGBgYHRleHRcbiAgICogICAgICAgICAgbmV2ZXJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogYGBgXG4gICAqXG4gICAqIEBmYWN0b3J5IHRydWVcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgc3RhdGljIG5ldmVyKCk6IFN0cmVhbTxhbnk+IHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbTxhbnk+KHtfc3RhcnQ6IG5vb3AsIF9zdG9wOiBub29wfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFN0cmVhbSB0aGF0IGltbWVkaWF0ZWx5IGVtaXRzIHRoZSBcImNvbXBsZXRlXCIgbm90aWZpY2F0aW9uIHdoZW5cbiAgICogc3RhcnRlZCwgYW5kIHRoYXQncyBpdC5cbiAgICpcbiAgICogTWFyYmxlIGRpYWdyYW06XG4gICAqXG4gICAqIGBgYHRleHRcbiAgICogZW1wdHlcbiAgICogLXxcbiAgICogYGBgXG4gICAqXG4gICAqIEBmYWN0b3J5IHRydWVcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgc3RhdGljIGVtcHR5KCk6IFN0cmVhbTxhbnk+IHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbTxhbnk+KHtcbiAgICAgIF9zdGFydChpbDogSW50ZXJuYWxMaXN0ZW5lcjxhbnk+KSB7IGlsLl9jKCk7IH0sXG4gICAgICBfc3RvcDogbm9vcCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgZW1pdHMgYW4gXCJlcnJvclwiIG5vdGlmaWNhdGlvbiB3aXRoIHRoZVxuICAgKiB2YWx1ZSB5b3UgcGFzc2VkIGFzIHRoZSBgZXJyb3JgIGFyZ3VtZW50IHdoZW4gdGhlIHN0cmVhbSBzdGFydHMsIGFuZCB0aGF0J3NcbiAgICogaXQuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIHRocm93KFgpXG4gICAqIC1YXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZmFjdG9yeSB0cnVlXG4gICAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3IgZXZlbnQgdG8gZW1pdCBvbiB0aGUgY3JlYXRlZCBzdHJlYW0uXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHN0YXRpYyB0aHJvdyhlcnJvcjogYW55KTogU3RyZWFtPGFueT4ge1xuICAgIHJldHVybiBuZXcgU3RyZWFtPGFueT4oe1xuICAgICAgX3N0YXJ0KGlsOiBJbnRlcm5hbExpc3RlbmVyPGFueT4pIHsgaWwuX2UoZXJyb3IpOyB9LFxuICAgICAgX3N0b3A6IG5vb3AsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0cmVhbSBmcm9tIGFuIEFycmF5LCBQcm9taXNlLCBvciBhbiBPYnNlcnZhYmxlLlxuICAgKlxuICAgKiBAZmFjdG9yeSB0cnVlXG4gICAqIEBwYXJhbSB7QXJyYXl8UHJvbWlzZUxpa2V8T2JzZXJ2YWJsZX0gaW5wdXQgVGhlIGlucHV0IHRvIG1ha2UgYSBzdHJlYW0gZnJvbS5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgc3RhdGljIGZyb208VD4oaW5wdXQ6IFByb21pc2VMaWtlPFQ+IHwgU3RyZWFtPFQ+IHwgQXJyYXk8VD4gfCBPYnNlcnZhYmxlPFQ+KTogU3RyZWFtPFQ+IHtcbiAgICBpZiAodHlwZW9mIGlucHV0WyQkb2JzZXJ2YWJsZV0gPT09ICdmdW5jdGlvbicpXG4gICAgICByZXR1cm4gU3RyZWFtLmZyb21PYnNlcnZhYmxlPFQ+KGlucHV0IGFzIE9ic2VydmFibGU8VD4pOyBlbHNlXG4gICAgaWYgKHR5cGVvZiAoaW5wdXQgYXMgUHJvbWlzZUxpa2U8VD4pLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgICByZXR1cm4gU3RyZWFtLmZyb21Qcm9taXNlPFQ+KGlucHV0IGFzIFByb21pc2VMaWtlPFQ+KTsgZWxzZVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICAgIHJldHVybiBTdHJlYW0uZnJvbUFycmF5PFQ+KGlucHV0KTtcblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFR5cGUgb2YgaW5wdXQgdG8gZnJvbSgpIG11c3QgYmUgYW4gQXJyYXksIFByb21pc2UsIG9yIE9ic2VydmFibGVgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgZW1pdHMgdGhlIGFyZ3VtZW50cyB0aGF0IHlvdSBnaXZlIHRvXG4gICAqICpvZiosIHRoZW4gY29tcGxldGVzLlxuICAgKlxuICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICpcbiAgICogYGBgdGV4dFxuICAgKiBvZigxLDIsMylcbiAgICogMTIzfFxuICAgKiBgYGBcbiAgICpcbiAgICogQGZhY3RvcnkgdHJ1ZVxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgeW91IHdhbnQgdG8gZW1pdCBhcyBhbiBldmVudCBvbiB0aGUgc3RyZWFtLlxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHlvdSB3YW50IHRvIGVtaXQgYXMgYW4gZXZlbnQgb24gdGhlIHN0cmVhbS4gT25lXG4gICAqIG9yIG1vcmUgb2YgdGhlc2UgdmFsdWVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudHMuXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHN0YXRpYyBvZjxUPiguLi5pdGVtczogQXJyYXk8VD4pOiBTdHJlYW08VD4ge1xuICAgIHJldHVybiBTdHJlYW0uZnJvbUFycmF5PFQ+KGl0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBhcnJheSB0byBhIHN0cmVhbS4gVGhlIHJldHVybmVkIHN0cmVhbSB3aWxsIGVtaXQgc3luY2hyb25vdXNseVxuICAgKiBhbGwgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSwgYW5kIHRoZW4gY29tcGxldGUuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIGZyb21BcnJheShbMSwyLDNdKVxuICAgKiAxMjN8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZmFjdG9yeSB0cnVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBiZSBjb252ZXJ0ZWQgYXMgYSBzdHJlYW0uXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHN0YXRpYyBmcm9tQXJyYXk8VD4oYXJyYXk6IEFycmF5PFQ+KTogU3RyZWFtPFQ+IHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbTxUPihuZXcgRnJvbUFycmF5PFQ+KGFycmF5KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBwcm9taXNlIHRvIGEgc3RyZWFtLiBUaGUgcmV0dXJuZWQgc3RyZWFtIHdpbGwgZW1pdCB0aGUgcmVzb2x2ZWRcbiAgICogdmFsdWUgb2YgdGhlIHByb21pc2UsIGFuZCB0aGVuIGNvbXBsZXRlLiBIb3dldmVyLCBpZiB0aGUgcHJvbWlzZSBpc1xuICAgKiByZWplY3RlZCwgdGhlIHN0cmVhbSB3aWxsIGVtaXQgdGhlIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIGZyb21Qcm9taXNlKCAtLS0tNDIgKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLTQyfFxuICAgKiBgYGBcbiAgICpcbiAgICogQGZhY3RvcnkgdHJ1ZVxuICAgKiBAcGFyYW0ge1Byb21pc2VMaWtlfSBwcm9taXNlIFRoZSBwcm9taXNlIHRvIGJlIGNvbnZlcnRlZCBhcyBhIHN0cmVhbS5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgc3RhdGljIGZyb21Qcm9taXNlPFQ+KHByb21pc2U6IFByb21pc2VMaWtlPFQ+KTogU3RyZWFtPFQ+IHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbTxUPihuZXcgRnJvbVByb21pc2U8VD4ocHJvbWlzZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIE9ic2VydmFibGUgaW50byBhIFN0cmVhbS5cbiAgICpcbiAgICogQGZhY3RvcnkgdHJ1ZVxuICAgKiBAcGFyYW0ge2FueX0gb2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSB0byBiZSBjb252ZXJ0ZWQgYXMgYSBzdHJlYW0uXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JzZXJ2YWJsZTxUPihvYnM6IHtzdWJzY3JpYmU6IGFueX0pOiBTdHJlYW08VD4ge1xuICAgIGlmICgob2JzIGFzIFN0cmVhbTxUPikuZW5kV2hlbikgcmV0dXJuIG9icyBhcyBTdHJlYW08VD47XG4gICAgY29uc3QgbyA9IHR5cGVvZiBvYnNbJCRvYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJyA/IG9ic1skJG9ic2VydmFibGVdKCkgOiBvYnM7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW08VD4obmV3IEZyb21PYnNlcnZhYmxlKG8pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RyZWFtIHRoYXQgcGVyaW9kaWNhbGx5IGVtaXRzIGluY3JlbWVudGFsIG51bWJlcnMsIGV2ZXJ5XG4gICAqIGBwZXJpb2RgIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogTWFyYmxlIGRpYWdyYW06XG4gICAqXG4gICAqIGBgYHRleHRcbiAgICogICAgIHBlcmlvZGljKDEwMDApXG4gICAqIC0tLTAtLS0xLS0tMi0tLTMtLS00LS0tLi4uXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZmFjdG9yeSB0cnVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2QgVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byB1c2UgYXMgYSByYXRlIG9mXG4gICAqIGVtaXNzaW9uLlxuICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAqL1xuICBzdGF0aWMgcGVyaW9kaWMocGVyaW9kOiBudW1iZXIpOiBTdHJlYW08bnVtYmVyPiB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW08bnVtYmVyPihuZXcgUGVyaW9kaWMocGVyaW9kKSk7XG4gIH1cblxuICAvKipcbiAgICogQmxlbmRzIG11bHRpcGxlIHN0cmVhbXMgdG9nZXRoZXIsIGVtaXR0aW5nIGV2ZW50cyBmcm9tIGFsbCBvZiB0aGVtXG4gICAqIGNvbmN1cnJlbnRseS5cbiAgICpcbiAgICogKm1lcmdlKiB0YWtlcyBtdWx0aXBsZSBzdHJlYW1zIGFzIGFyZ3VtZW50cywgYW5kIGNyZWF0ZXMgYSBzdHJlYW0gdGhhdFxuICAgKiBiZWhhdmVzIGxpa2UgZWFjaCBvZiB0aGUgYXJndW1lbnQgc3RyZWFtcywgaW4gcGFyYWxsZWwuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIC0tMS0tLS0yLS0tLS0zLS0tLS0tLS00LS0tXG4gICAqIC0tLS1hLS0tLS1iLS0tLWMtLS1kLS0tLS0tXG4gICAqICAgICAgICAgICAgbWVyZ2VcbiAgICogLS0xLWEtLTItLWItLTMtYy0tLWQtLTQtLS1cbiAgICogYGBgXG4gICAqXG4gICAqIEBmYWN0b3J5IHRydWVcbiAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTEgQSBzdHJlYW0gdG8gbWVyZ2UgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMiBBIHN0cmVhbSB0byBtZXJnZSB0b2dldGhlciB3aXRoIG90aGVyIHN0cmVhbXMuIFR3b1xuICAgKiBvciBtb3JlIHN0cmVhbXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50cy5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgc3RhdGljIG1lcmdlOiBNZXJnZVNpZ25hdHVyZSA9IGZ1bmN0aW9uIG1lcmdlKC4uLnN0cmVhbXM6IEFycmF5PFN0cmVhbTxhbnk+Pikge1xuICAgIHJldHVybiBuZXcgU3RyZWFtPGFueT4obmV3IE1lcmdlKHN0cmVhbXMpKTtcbiAgfSBhcyBNZXJnZVNpZ25hdHVyZTtcblxuICAvKipcbiAgICogQ29tYmluZXMgbXVsdGlwbGUgaW5wdXQgc3RyZWFtcyB0b2dldGhlciB0byByZXR1cm4gYSBzdHJlYW0gd2hvc2UgZXZlbnRzXG4gICAqIGFyZSBhcnJheXMgdGhhdCBjb2xsZWN0IHRoZSBsYXRlc3QgZXZlbnRzIGZyb20gZWFjaCBpbnB1dCBzdHJlYW0uXG4gICAqXG4gICAqICpjb21iaW5lKiBpbnRlcm5hbGx5IHJlbWVtYmVycyB0aGUgbW9zdCByZWNlbnQgZXZlbnQgZnJvbSBlYWNoIG9mIHRoZSBpbnB1dFxuICAgKiBzdHJlYW1zLiBXaGVuIGFueSBvZiB0aGUgaW5wdXQgc3RyZWFtcyBlbWl0cyBhbiBldmVudCwgdGhhdCBldmVudCB0b2dldGhlclxuICAgKiB3aXRoIGFsbCB0aGUgb3RoZXIgc2F2ZWQgZXZlbnRzIGFyZSBjb21iaW5lZCBpbnRvIGFuIGFycmF5LiBUaGF0IGFycmF5IHdpbGxcbiAgICogYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IHN0cmVhbS4gSXQncyBlc3NlbnRpYWxseSBhIHdheSBvZiBqb2luaW5nIHRvZ2V0aGVyXG4gICAqIHRoZSBldmVudHMgZnJvbSBtdWx0aXBsZSBzdHJlYW1zLlxuICAgKlxuICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICpcbiAgICogYGBgdGV4dFxuICAgKiAtLTEtLS0tMi0tLS0tMy0tLS0tLS0tNC0tLVxuICAgKiAtLS0tYS0tLS0tYi0tLS0tYy0tZC0tLS0tLVxuICAgKiAgICAgICAgICBjb21iaW5lXG4gICAqIC0tLS0xYS0yYS0yYi0zYi0zYy0zZC00ZC0tXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZmFjdG9yeSB0cnVlXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0xIEEgc3RyZWFtIHRvIGNvbWJpbmUgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtMiBBIHN0cmVhbSB0byBjb21iaW5lIHRvZ2V0aGVyIHdpdGggb3RoZXIgc3RyZWFtcy5cbiAgICogTXVsdGlwbGUgc3RyZWFtcywgbm90IGp1c3QgdHdvLCBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnRzLlxuICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAqL1xuICBzdGF0aWMgY29tYmluZTogQ29tYmluZVNpZ25hdHVyZSA9IGZ1bmN0aW9uIGNvbWJpbmUoLi4uc3RyZWFtczogQXJyYXk8U3RyZWFtPGFueT4+KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW08QXJyYXk8YW55Pj4obmV3IENvbWJpbmU8YW55PihzdHJlYW1zKSk7XG4gIH0gYXMgQ29tYmluZVNpZ25hdHVyZTtcblxuICBwcm90ZWN0ZWQgX21hcDxVPihwcm9qZWN0OiAodDogVCkgPT4gVSk6IFN0cmVhbTxVPiB8IE1lbW9yeVN0cmVhbTxVPiB7XG4gICAgcmV0dXJuIG5ldyAodGhpcy5jdG9yKCkpPFU+KG5ldyBNYXBPcDxULCBVPihwcm9qZWN0LCB0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBlYWNoIGV2ZW50IGZyb20gdGhlIGlucHV0IFN0cmVhbSB0aHJvdWdoIGEgYHByb2plY3RgIGZ1bmN0aW9uLFxuICAgKiB0byBnZXQgYSBTdHJlYW0gdGhhdCBlbWl0cyB0aG9zZSB0cmFuc2Zvcm1lZCBldmVudHMuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIC0tMS0tLTMtLTUtLS0tLTctLS0tLS1cbiAgICogICAgbWFwKGkgPT4gaSAqIDEwKVxuICAgKiAtLTEwLS0zMC01MC0tLS03MC0tLS0tXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9qZWN0IEEgZnVuY3Rpb24gb2YgdHlwZSBgKHQ6IFQpID0+IFVgIHRoYXQgdGFrZXMgZXZlbnRcbiAgICogYHRgIG9mIHR5cGUgYFRgIGZyb20gdGhlIGlucHV0IFN0cmVhbSBhbmQgcHJvZHVjZXMgYW4gZXZlbnQgb2YgdHlwZSBgVWAsIHRvXG4gICAqIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBTdHJlYW0uXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIG1hcDxVPihwcm9qZWN0OiAodDogVCkgPT4gVSk6IFN0cmVhbTxVPiB7XG4gICAgcmV0dXJuIHRoaXMuX21hcChwcm9qZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCdzIGxpa2UgYG1hcGAsIGJ1dCB0cmFuc2Zvcm1zIGVhY2ggaW5wdXQgZXZlbnQgdG8gYWx3YXlzIHRoZSBzYW1lXG4gICAqIGNvbnN0YW50IHZhbHVlIG9uIHRoZSBvdXRwdXQgU3RyZWFtLlxuICAgKlxuICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICpcbiAgICogYGBgdGV4dFxuICAgKiAtLTEtLS0zLS01LS0tLS03LS0tLS1cbiAgICogICAgICAgbWFwVG8oMTApXG4gICAqIC0tMTAtLTEwLTEwLS0tLTEwLS0tLVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHByb2plY3RlZFZhbHVlIEEgdmFsdWUgdG8gZW1pdCBvbiB0aGUgb3V0cHV0IFN0cmVhbSB3aGVuZXZlciB0aGVcbiAgICogaW5wdXQgU3RyZWFtIGVtaXRzIGFueSB2YWx1ZS5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgbWFwVG88VT4ocHJvamVjdGVkVmFsdWU6IFUpOiBTdHJlYW08VT4ge1xuICAgIGNvbnN0IHMgPSB0aGlzLm1hcCgoKSA9PiBwcm9qZWN0ZWRWYWx1ZSk7XG4gICAgY29uc3Qgb3A6IE9wZXJhdG9yPFQsIFU+ID0gcy5fcHJvZCBhcyBPcGVyYXRvcjxULCBVPjtcbiAgICBvcC50eXBlID0gJ21hcFRvJztcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGZpbHRlcjxTIGV4dGVuZHMgVD4ocGFzc2VzOiAodDogVCkgPT4gdCBpcyBTKTogU3RyZWFtPFM+O1xuICBmaWx0ZXIocGFzc2VzOiAodDogVCkgPT4gYm9vbGVhbik6IFN0cmVhbTxUPjtcbiAgLyoqXG4gICAqIE9ubHkgYWxsb3dzIGV2ZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgZ2l2ZW4gYnkgdGhlIGBwYXNzZXNgIGFyZ3VtZW50LlxuICAgKlxuICAgKiBFYWNoIGV2ZW50IGZyb20gdGhlIGlucHV0IHN0cmVhbSBpcyBnaXZlbiB0byB0aGUgYHBhc3Nlc2AgZnVuY3Rpb24uIElmIHRoZVxuICAgKiBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCwgdGhlIGV2ZW50IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IHN0cmVhbSxcbiAgICogb3RoZXJ3aXNlIGl0IGlzIGlnbm9yZWQgYW5kIG5vdCBmb3J3YXJkZWQuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIC0tMS0tLTItLTMtLS0tLTQtLS0tLTUtLS02LS03LTgtLVxuICAgKiAgICAgZmlsdGVyKGkgPT4gaSAlIDIgPT09IDApXG4gICAqIC0tLS0tLTItLS0tLS0tLTQtLS0tLS0tLS02LS0tLTgtLVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFzc2VzIEEgZnVuY3Rpb24gb2YgdHlwZSBgKHQ6IFQpID0+IGJvb2xlYW5gIHRoYXQgdGFrZXNcbiAgICogYW4gZXZlbnQgZnJvbSB0aGUgaW5wdXQgc3RyZWFtIGFuZCBjaGVja3MgaWYgaXQgcGFzc2VzLCBieSByZXR1cm5pbmcgYVxuICAgKiBib29sZWFuLlxuICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAqL1xuICBmaWx0ZXIocGFzc2VzOiAodDogVCkgPT4gYm9vbGVhbik6IFN0cmVhbTxUPiB7XG4gICAgY29uc3QgcCA9IHRoaXMuX3Byb2Q7XG4gICAgaWYgKHAgaW5zdGFuY2VvZiBGaWx0ZXIpXG4gICAgICByZXR1cm4gbmV3IFN0cmVhbTxUPihuZXcgRmlsdGVyPFQ+KFxuICAgICAgICBhbmQoKHAgYXMgRmlsdGVyPFQ+KS5mLCBwYXNzZXMpLFxuICAgICAgICAocCBhcyBGaWx0ZXI8VD4pLmluc1xuICAgICAgKSk7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW08VD4obmV3IEZpbHRlcjxUPihwYXNzZXMsIHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXRzIHRoZSBmaXJzdCBgYW1vdW50YCBtYW55IGV2ZW50cyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gcGFzcyB0byB0aGVcbiAgICogb3V0cHV0IHN0cmVhbSwgdGhlbiBtYWtlcyB0aGUgb3V0cHV0IHN0cmVhbSBjb21wbGV0ZS5cbiAgICpcbiAgICogTWFyYmxlIGRpYWdyYW06XG4gICAqXG4gICAqIGBgYHRleHRcbiAgICogLS1hLS0tYi0tYy0tLS1kLS0tZS0tXG4gICAqICAgIHRha2UoMylcbiAgICogLS1hLS0tYi0tY3xcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgSG93IG1hbnkgZXZlbnRzIHRvIGFsbG93IGZyb20gdGhlIGlucHV0IHN0cmVhbVxuICAgKiBiZWZvcmUgY29tcGxldGluZyB0aGUgb3V0cHV0IHN0cmVhbS5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgdGFrZShhbW91bnQ6IG51bWJlcik6IFN0cmVhbTxUPiB7XG4gICAgcmV0dXJuIG5ldyAodGhpcy5jdG9yKCkpPFQ+KG5ldyBUYWtlPFQ+KGFtb3VudCwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIElnbm9yZXMgdGhlIGZpcnN0IGBhbW91bnRgIG1hbnkgZXZlbnRzIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgYW5kIHRoZW5cbiAgICogYWZ0ZXIgdGhhdCBzdGFydHMgZm9yd2FyZGluZyBldmVudHMgZnJvbSB0aGUgaW5wdXQgc3RyZWFtIHRvIHRoZSBvdXRwdXRcbiAgICogc3RyZWFtLlxuICAgKlxuICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICpcbiAgICogYGBgdGV4dFxuICAgKiAtLWEtLS1iLS1jLS0tLWQtLS1lLS1cbiAgICogICAgICAgZHJvcCgzKVxuICAgKiAtLS0tLS0tLS0tLS0tLWQtLS1lLS1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgSG93IG1hbnkgZXZlbnRzIHRvIGlnbm9yZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW1cbiAgICogYmVmb3JlIGZvcndhcmRpbmcgYWxsIGV2ZW50cyBmcm9tIHRoZSBpbnB1dCBzdHJlYW0gdG8gdGhlIG91dHB1dCBzdHJlYW0uXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIGRyb3AoYW1vdW50OiBudW1iZXIpOiBTdHJlYW08VD4ge1xuICAgIHJldHVybiBuZXcgU3RyZWFtPFQ+KG5ldyBEcm9wPFQ+KGFtb3VudCwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGlucHV0IHN0cmVhbSBjb21wbGV0ZXMsIHRoZSBvdXRwdXQgc3RyZWFtIHdpbGwgZW1pdCB0aGUgbGFzdCBldmVudFxuICAgKiBlbWl0dGVkIGJ5IHRoZSBpbnB1dCBzdHJlYW0sIGFuZCB0aGVuIHdpbGwgYWxzbyBjb21wbGV0ZS5cbiAgICpcbiAgICogTWFyYmxlIGRpYWdyYW06XG4gICAqXG4gICAqIGBgYHRleHRcbiAgICogLS1hLS0tYi0tYy0tZC0tLS18XG4gICAqICAgICAgIGxhc3QoKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLWR8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAqL1xuICBsYXN0KCk6IFN0cmVhbTxUPiB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW08VD4obmV3IExhc3Q8VD4odGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmRzIHRoZSBnaXZlbiBgaW5pdGlhbGAgdmFsdWUgdG8gdGhlIHNlcXVlbmNlIG9mIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZVxuICAgKiBpbnB1dCBzdHJlYW0uIFRoZSByZXR1cm5lZCBzdHJlYW0gaXMgYSBNZW1vcnlTdHJlYW0sIHdoaWNoIG1lYW5zIGl0IGlzXG4gICAqIGFscmVhZHkgYHJlbWVtYmVyKClgJ2QuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIC0tLTEtLS0yLS0tLS0zLS0tXG4gICAqICAgc3RhcnRXaXRoKDApXG4gICAqIDAtLTEtLS0yLS0tLS0zLS0tXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaW5pdGlhbCBUaGUgdmFsdWUgb3IgZXZlbnQgdG8gcHJlcGVuZC5cbiAgICogQHJldHVybiB7TWVtb3J5U3RyZWFtfVxuICAgKi9cbiAgc3RhcnRXaXRoKGluaXRpYWw6IFQpOiBNZW1vcnlTdHJlYW08VD4ge1xuICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtPFQ+KG5ldyBTdGFydFdpdGg8VD4odGhpcywgaW5pdGlhbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZXMgYW5vdGhlciBzdHJlYW0gdG8gZGV0ZXJtaW5lIHdoZW4gdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgc3RyZWFtLlxuICAgKlxuICAgKiBXaGVuIHRoZSBnaXZlbiBgb3RoZXJgIHN0cmVhbSBlbWl0cyBhbiBldmVudCBvciBjb21wbGV0ZXMsIHRoZSBvdXRwdXRcbiAgICogc3RyZWFtIHdpbGwgY29tcGxldGUuIEJlZm9yZSB0aGF0IGhhcHBlbnMsIHRoZSBvdXRwdXQgc3RyZWFtIHdpbGwgYmVoYXZlc1xuICAgKiBsaWtlIHRoZSBpbnB1dCBzdHJlYW0uXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIC0tLTEtLS0yLS0tLS0zLS00LS0tLTUtLS0tNi0tLVxuICAgKiAgIGVuZFdoZW4oIC0tLS0tLS0tYS0tYi0tfCApXG4gICAqIC0tLTEtLS0yLS0tLS0zLS00LS18XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gb3RoZXIgU29tZSBvdGhlciBzdHJlYW0gdGhhdCBpcyB1c2VkIHRvIGtub3cgd2hlbiBzaG91bGQgdGhlIG91dHB1dFxuICAgKiBzdHJlYW0gb2YgdGhpcyBvcGVyYXRvciBjb21wbGV0ZS5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgZW5kV2hlbihvdGhlcjogU3RyZWFtPGFueT4pOiBTdHJlYW08VD4ge1xuICAgIHJldHVybiBuZXcgKHRoaXMuY3RvcigpKTxUPihuZXcgRW5kV2hlbjxUPihvdGhlciwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiRm9sZHNcIiB0aGUgc3RyZWFtIG9udG8gaXRzZWxmLlxuICAgKlxuICAgKiBDb21iaW5lcyBldmVudHMgZnJvbSB0aGUgcGFzdCB0aHJvdWdob3V0XG4gICAqIHRoZSBlbnRpcmUgZXhlY3V0aW9uIG9mIHRoZSBpbnB1dCBzdHJlYW0sIGFsbG93aW5nIHlvdSB0byBhY2N1bXVsYXRlIHRoZW1cbiAgICogdG9nZXRoZXIuIEl0J3MgZXNzZW50aWFsbHkgbGlrZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAuIFRoZSByZXR1cm5lZFxuICAgKiBzdHJlYW0gaXMgYSBNZW1vcnlTdHJlYW0sIHdoaWNoIG1lYW5zIGl0IGlzIGFscmVhZHkgYHJlbWVtYmVyKClgJ2QuXG4gICAqXG4gICAqIFRoZSBvdXRwdXQgc3RyZWFtIHN0YXJ0cyBieSBlbWl0dGluZyB0aGUgYHNlZWRgIHdoaWNoIHlvdSBnaXZlIGFzIGFyZ3VtZW50LlxuICAgKiBUaGVuLCB3aGVuIGFuIGV2ZW50IGhhcHBlbnMgb24gdGhlIGlucHV0IHN0cmVhbSwgaXQgaXMgY29tYmluZWQgd2l0aCB0aGF0XG4gICAqIHNlZWQgdmFsdWUgdGhyb3VnaCB0aGUgYGFjY3VtdWxhdGVgIGZ1bmN0aW9uLCBhbmQgdGhlIG91dHB1dCB2YWx1ZSBpc1xuICAgKiBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgc3RyZWFtLiBgZm9sZGAgcmVtZW1iZXJzIHRoYXQgb3V0cHV0IHZhbHVlIGFzIGBhY2NgXG4gICAqIChcImFjY3VtdWxhdG9yXCIpLCBhbmQgdGhlbiB3aGVuIGEgbmV3IGlucHV0IGV2ZW50IGB0YCBoYXBwZW5zLCBgYWNjYCB3aWxsIGJlXG4gICAqIGNvbWJpbmVkIHdpdGggdGhhdCB0byBwcm9kdWNlIHRoZSBuZXcgYGFjY2AgYW5kIHNvIGZvcnRoLlxuICAgKlxuICAgKiBNYXJibGUgZGlhZ3JhbTpcbiAgICpcbiAgICogYGBgdGV4dFxuICAgKiAtLS0tLS0xLS0tLS0xLS0yLS0tLTEtLS0tMS0tLS0tLVxuICAgKiAgIGZvbGQoKGFjYywgeCkgPT4gYWNjICsgeCwgMylcbiAgICogMy0tLS0tNC0tLS0tNS0tNy0tLS04LS0tLTktLS0tLS1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjY3VtdWxhdGUgQSBmdW5jdGlvbiBvZiB0eXBlIGAoYWNjOiBSLCB0OiBUKSA9PiBSYCB0aGF0XG4gICAqIHRha2VzIHRoZSBwcmV2aW91cyBhY2N1bXVsYXRlZCB2YWx1ZSBgYWNjYCBhbmQgdGhlIGluY29taW5nIGV2ZW50IGZyb20gdGhlXG4gICAqIGlucHV0IHN0cmVhbSBhbmQgcHJvZHVjZXMgdGhlIG5ldyBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHNlZWQgVGhlIGluaXRpYWwgYWNjdW11bGF0ZWQgdmFsdWUsIG9mIHR5cGUgYFJgLlxuICAgKiBAcmV0dXJuIHtNZW1vcnlTdHJlYW19XG4gICAqL1xuICBmb2xkPFI+KGFjY3VtdWxhdGU6IChhY2M6IFIsIHQ6IFQpID0+IFIsIHNlZWQ6IFIpOiBNZW1vcnlTdHJlYW08Uj4ge1xuICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtPFI+KG5ldyBGb2xkPFQsIFI+KGFjY3VtdWxhdGUsIHNlZWQsIHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbiBlcnJvciB3aXRoIGFub3RoZXIgc3RyZWFtLlxuICAgKlxuICAgKiBXaGVuIChhbmQgaWYpIGFuIGVycm9yIGhhcHBlbnMgb24gdGhlIGlucHV0IHN0cmVhbSwgaW5zdGVhZCBvZiBmb3J3YXJkaW5nXG4gICAqIHRoYXQgZXJyb3IgdG8gdGhlIG91dHB1dCBzdHJlYW0sICpyZXBsYWNlRXJyb3IqIHdpbGwgY2FsbCB0aGUgYHJlcGxhY2VgXG4gICAqIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHN0cmVhbSB0aGF0IHRoZSBvdXRwdXQgc3RyZWFtIHdpbGwgcmVwbGljYXRlLlxuICAgKiBBbmQsIGluIGNhc2UgdGhhdCBuZXcgc3RyZWFtIGFsc28gZW1pdHMgYW4gZXJyb3IsIGByZXBsYWNlYCB3aWxsIGJlIGNhbGxlZFxuICAgKiBhZ2FpbiB0byBnZXQgYW5vdGhlciBzdHJlYW0gdG8gc3RhcnQgcmVwbGljYXRpbmcuXG4gICAqXG4gICAqIE1hcmJsZSBkaWFncmFtOlxuICAgKlxuICAgKiBgYGB0ZXh0XG4gICAqIC0tMS0tLTItLS0tLTMtLTQtLS0tLVhcbiAgICogICByZXBsYWNlRXJyb3IoICgpID0+IC0tMTAtLXwgKVxuICAgKiAtLTEtLS0yLS0tLS0zLS00LS0tLS0tLS0xMC0tfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVwbGFjZSBBIGZ1bmN0aW9uIG9mIHR5cGUgYChlcnIpID0+IFN0cmVhbWAgdGhhdCB0YWtlc1xuICAgKiB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCBvbiB0aGUgaW5wdXQgc3RyZWFtIG9yIG9uIHRoZSBwcmV2aW91cyByZXBsYWNlbWVudFxuICAgKiBzdHJlYW0gYW5kIHJldHVybnMgYSBuZXcgc3RyZWFtLiBUaGUgb3V0cHV0IHN0cmVhbSB3aWxsIGJlaGF2ZSBsaWtlIHRoZVxuICAgKiBzdHJlYW0gdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMuXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHJlcGxhY2VFcnJvcihyZXBsYWNlOiAoZXJyOiBhbnkpID0+IFN0cmVhbTxUPik6IFN0cmVhbTxUPiB7XG4gICAgcmV0dXJuIG5ldyAodGhpcy5jdG9yKCkpPFQ+KG5ldyBSZXBsYWNlRXJyb3I8VD4ocmVwbGFjZSwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYXR0ZW5zIGEgXCJzdHJlYW0gb2Ygc3RyZWFtc1wiLCBoYW5kbGluZyBvbmx5IG9uZSBuZXN0ZWQgc3RyZWFtIGF0IGEgdGltZVxuICAgKiAobm8gY29uY3VycmVuY3kpLlxuICAgKlxuICAgKiBJZiB0aGUgaW5wdXQgc3RyZWFtIGlzIGEgc3RyZWFtIHRoYXQgZW1pdHMgc3RyZWFtcywgdGhlbiB0aGlzIG9wZXJhdG9yIHdpbGxcbiAgICogcmV0dXJuIGFuIG91dHB1dCBzdHJlYW0gd2hpY2ggaXMgYSBmbGF0IHN0cmVhbTogZW1pdHMgcmVndWxhciBldmVudHMuIFRoZVxuICAgKiBmbGF0dGVuaW5nIGhhcHBlbnMgd2l0aG91dCBjb25jdXJyZW5jeS4gSXQgd29ya3MgbGlrZSB0aGlzOiB3aGVuIHRoZSBpbnB1dFxuICAgKiBzdHJlYW0gZW1pdHMgYSBuZXN0ZWQgc3RyZWFtLCAqZmxhdHRlbiogd2lsbCBzdGFydCBpbWl0YXRpbmcgdGhhdCBuZXN0ZWRcbiAgICogb25lLiBIb3dldmVyLCBhcyBzb29uIGFzIHRoZSBuZXh0IG5lc3RlZCBzdHJlYW0gaXMgZW1pdHRlZCBvbiB0aGUgaW5wdXRcbiAgICogc3RyZWFtLCAqZmxhdHRlbiogd2lsbCBmb3JnZXQgdGhlIHByZXZpb3VzIG5lc3RlZCBvbmUgaXQgd2FzIGltaXRhdGluZywgYW5kXG4gICAqIHdpbGwgc3RhcnQgaW1pdGF0aW5nIHRoZSBuZXcgbmVzdGVkIG9uZS5cbiAgICpcbiAgICogTWFyYmxlIGRpYWdyYW06XG4gICAqXG4gICAqIGBgYHRleHRcbiAgICogLS0rLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tXG4gICAqICAgXFwgICAgICAgIFxcXG4gICAqICAgIFxcICAgICAgIC0tLS0xLS0tLTItLS0zLS1cbiAgICogICAgLS1hLS1iLS0tLWMtLS0tZC0tLS0tLS0tXG4gICAqICAgICAgICAgICBmbGF0dGVuXG4gICAqIC0tLS0tYS0tYi0tLS0tLTEtLS0tMi0tLTMtLVxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgZmxhdHRlbjxSPih0aGlzOiBTdHJlYW08U3RyZWFtPFI+Pik6IFN0cmVhbTxSPiB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW08Uj4obmV3IEZsYXR0ZW4odGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3NlcyB0aGUgaW5wdXQgc3RyZWFtIHRvIGEgY3VzdG9tIG9wZXJhdG9yLCB0byBwcm9kdWNlIGFuIG91dHB1dCBzdHJlYW0uXG4gICAqXG4gICAqICpjb21wb3NlKiBpcyBhIGhhbmR5IHdheSBvZiB1c2luZyBhbiBleGlzdGluZyBmdW5jdGlvbiBpbiBhIGNoYWluZWQgc3R5bGUuXG4gICAqIEluc3RlYWQgb2Ygd3JpdGluZyBgb3V0U3RyZWFtID0gZihpblN0cmVhbSlgIHlvdSBjYW4gd3JpdGVcbiAgICogYG91dFN0cmVhbSA9IGluU3RyZWFtLmNvbXBvc2UoZilgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcGVyYXRvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzdHJlYW0gYXMgaW5wdXQgYW5kXG4gICAqIHJldHVybnMgYSBzdHJlYW0gYXMgd2VsbC5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgY29tcG9zZTxVPihvcGVyYXRvcjogKHN0cmVhbTogU3RyZWFtPFQ+KSA9PiBVKTogVSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb3V0cHV0IHN0cmVhbSB0aGF0IGJlaGF2ZXMgbGlrZSB0aGUgaW5wdXQgc3RyZWFtLCBidXQgYWxzb1xuICAgKiByZW1lbWJlcnMgdGhlIG1vc3QgcmVjZW50IGV2ZW50IHRoYXQgaGFwcGVucyBvbiB0aGUgaW5wdXQgc3RyZWFtLCBzbyB0aGF0IGFcbiAgICogbmV3bHkgYWRkZWQgbGlzdGVuZXIgd2lsbCBpbW1lZGlhdGVseSByZWNlaXZlIHRoYXQgbWVtb3Jpc2VkIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtNZW1vcnlTdHJlYW19XG4gICAqL1xuICByZW1lbWJlcigpOiBNZW1vcnlTdHJlYW08VD4ge1xuICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtPFQ+KG5ldyBSZW1lbWJlcjxUPih0aGlzKSk7XG4gIH1cblxuICBkZWJ1ZygpOiBTdHJlYW08VD47XG4gIGRlYnVnKGxhYmVsT3JTcHk6IHN0cmluZyk6IFN0cmVhbTxUPjtcbiAgZGVidWcobGFiZWxPclNweTogKHQ6IFQpID0+IGFueSk6IFN0cmVhbTxUPjtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb3V0cHV0IHN0cmVhbSB0aGF0IGlkZW50aWNhbGx5IGJlaGF2ZXMgbGlrZSB0aGUgaW5wdXQgc3RyZWFtLFxuICAgKiBidXQgYWxzbyBydW5zIGEgYHNweWAgZnVuY3Rpb24gZm9yIGVhY2ggZXZlbnQsIHRvIGhlbHAgeW91IGRlYnVnIHlvdXIgYXBwLlxuICAgKlxuICAgKiAqZGVidWcqIHRha2VzIGEgYHNweWAgZnVuY3Rpb24gYXMgYXJndW1lbnQsIGFuZCBydW5zIHRoYXQgZm9yIGVhY2ggZXZlbnRcbiAgICogaGFwcGVuaW5nIG9uIHRoZSBpbnB1dCBzdHJlYW0uIElmIHlvdSBkb24ndCBwcm92aWRlIHRoZSBgc3B5YCBhcmd1bWVudCxcbiAgICogdGhlbiAqZGVidWcqIHdpbGwganVzdCBgY29uc29sZS5sb2dgIGVhY2ggZXZlbnQuIFRoaXMgaGVscHMgeW91IHRvXG4gICAqIHVuZGVyc3RhbmQgdGhlIGZsb3cgb2YgZXZlbnRzIHRocm91Z2ggc29tZSBvcGVyYXRvciBjaGFpbi5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCBpZiB0aGUgb3V0cHV0IHN0cmVhbSBoYXMgbm8gbGlzdGVuZXJzLCB0aGVuIGl0IHdpbGwgbm90XG4gICAqIHN0YXJ0LCB3aGljaCBtZWFucyBgc3B5YCB3aWxsIG5ldmVyIHJ1biBiZWNhdXNlIG5vIGFjdHVhbCBldmVudCBoYXBwZW5zIGluXG4gICAqIHRoYXQgY2FzZS5cbiAgICpcbiAgICogTWFyYmxlIGRpYWdyYW06XG4gICAqXG4gICAqIGBgYHRleHRcbiAgICogLS0xLS0tLTItLS0tLTMtLS0tLTQtLVxuICAgKiAgICAgICAgIGRlYnVnXG4gICAqIC0tMS0tLS0yLS0tLS0zLS0tLS00LS1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxhYmVsT3JTcHkgQSBzdHJpbmcgdG8gdXNlIGFzIHRoZSBsYWJlbCB3aGVuIHByaW50aW5nXG4gICAqIGRlYnVnIGluZm9ybWF0aW9uIG9uIHRoZSBjb25zb2xlLCBvciBhICdzcHknIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZXZlbnRcbiAgICogYXMgYXJndW1lbnQsIGFuZCBkb2VzIG5vdCBuZWVkIHRvIHJldHVybiBhbnl0aGluZy5cbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgZGVidWcobGFiZWxPclNweT86IHN0cmluZyB8ICgodDogVCkgPT4gYW55KSk6IFN0cmVhbTxUPiB7XG4gICAgcmV0dXJuIG5ldyAodGhpcy5jdG9yKCkpPFQ+KG5ldyBEZWJ1ZzxUPih0aGlzLCBsYWJlbE9yU3B5KSk7XG4gIH1cblxuICAvKipcbiAgICogKmltaXRhdGUqIGNoYW5nZXMgdGhpcyBjdXJyZW50IFN0cmVhbSB0byBlbWl0IHRoZSBzYW1lIGV2ZW50cyB0aGF0IHRoZVxuICAgKiBgb3RoZXJgIGdpdmVuIFN0cmVhbSBkb2VzLiBUaGlzIG1ldGhvZCByZXR1cm5zIG5vdGhpbmcuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGV4aXN0cyB0byBhbGxvdyBvbmUgdGhpbmc6ICoqY2lyY3VsYXIgZGVwZW5kZW5jeSBvZiBzdHJlYW1zKiouXG4gICAqIEZvciBpbnN0YW5jZSwgbGV0J3MgaW1hZ2luZSB0aGF0IGZvciBzb21lIHJlYXNvbiB5b3UgbmVlZCB0byBjcmVhdGUgYVxuICAgKiBjaXJjdWxhciBkZXBlbmRlbmN5IHdoZXJlIHN0cmVhbSBgZmlyc3QkYCBkZXBlbmRzIG9uIHN0cmVhbSBgc2Vjb25kJGBcbiAgICogd2hpY2ggaW4gdHVybiBkZXBlbmRzIG9uIGBmaXJzdCRgOlxuICAgKlxuICAgKiA8IS0tIHNraXAtZXhhbXBsZSAtLT5cbiAgICogYGBganNcbiAgICogaW1wb3J0IGRlbGF5IGZyb20gJ3hzdHJlYW0vZXh0cmEvZGVsYXknXG4gICAqXG4gICAqIHZhciBmaXJzdCQgPSBzZWNvbmQkLm1hcCh4ID0+IHggKiAxMCkudGFrZSgzKTtcbiAgICogdmFyIHNlY29uZCQgPSBmaXJzdCQubWFwKHggPT4geCArIDEpLnN0YXJ0V2l0aCgxKS5jb21wb3NlKGRlbGF5KDEwMCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogSG93ZXZlciwgdGhhdCBpcyBpbnZhbGlkIEphdmFTY3JpcHQsIGJlY2F1c2UgYHNlY29uZCRgIGlzIHVuZGVmaW5lZFxuICAgKiBvbiB0aGUgZmlyc3QgbGluZS4gVGhpcyBpcyBob3cgKmltaXRhdGUqIGNhbiBoZWxwIHNvbHZlIGl0OlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgZGVsYXkgZnJvbSAneHN0cmVhbS9leHRyYS9kZWxheSdcbiAgICpcbiAgICogdmFyIHNlY29uZFByb3h5JCA9IHhzLmNyZWF0ZSgpO1xuICAgKiB2YXIgZmlyc3QkID0gc2Vjb25kUHJveHkkLm1hcCh4ID0+IHggKiAxMCkudGFrZSgzKTtcbiAgICogdmFyIHNlY29uZCQgPSBmaXJzdCQubWFwKHggPT4geCArIDEpLnN0YXJ0V2l0aCgxKS5jb21wb3NlKGRlbGF5KDEwMCkpO1xuICAgKiBzZWNvbmRQcm94eSQuaW1pdGF0ZShzZWNvbmQkKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFdlIGNyZWF0ZSBgc2Vjb25kUHJveHkkYCBiZWZvcmUgdGhlIG90aGVycywgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlXG4gICAqIGRlY2xhcmF0aW9uIG9mIGBmaXJzdCRgLiBUaGVuLCBhZnRlciBib3RoIGBmaXJzdCRgIGFuZCBgc2Vjb25kJGAgYXJlXG4gICAqIGRlZmluZWQsIHdlIGhvb2sgYHNlY29uZFByb3h5JGAgd2l0aCBgc2Vjb25kJGAgd2l0aCBgaW1pdGF0ZSgpYCB0byB0ZWxsXG4gICAqIHRoYXQgdGhleSBhcmUgXCJ0aGUgc2FtZVwiLiBgaW1pdGF0ZWAgd2lsbCBub3QgdHJpZ2dlciB0aGUgc3RhcnQgb2YgYW55XG4gICAqIHN0cmVhbSwgaXQganVzdCBiaW5kcyBgc2Vjb25kUHJveHkkYCBhbmQgYHNlY29uZCRgIHRvZ2V0aGVyLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgd2hlcmUgYGltaXRhdGUoKWAgaXMgaW1wb3J0YW50IGluIEN5Y2xlLmpzXG4gICAqIGFwcGxpY2F0aW9ucy4gQSBwYXJlbnQgY29tcG9uZW50IGNvbnRhaW5zIHNvbWUgY2hpbGQgY29tcG9uZW50cy4gQSBjaGlsZFxuICAgKiBoYXMgYW4gYWN0aW9uIHN0cmVhbSB3aGljaCBpcyBnaXZlbiB0byB0aGUgcGFyZW50IHRvIGRlZmluZSBpdHMgc3RhdGU6XG4gICAqXG4gICAqIDwhLS0gc2tpcC1leGFtcGxlIC0tPlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGlsZEFjdGlvblByb3h5JCA9IHhzLmNyZWF0ZSgpO1xuICAgKiBjb25zdCBwYXJlbnQgPSBQYXJlbnQoey4uLnNvdXJjZXMsIGNoaWxkQWN0aW9uJDogY2hpbGRBY3Rpb25Qcm94eSR9KTtcbiAgICogY29uc3QgY2hpbGRBY3Rpb24kID0gcGFyZW50LnN0YXRlJC5tYXAocyA9PiBzLmNoaWxkLmFjdGlvbiQpLmZsYXR0ZW4oKTtcbiAgICogY2hpbGRBY3Rpb25Qcm94eSQuaW1pdGF0ZShjaGlsZEFjdGlvbiQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSwgdGhvdWdoLCB0aGF0ICoqYGltaXRhdGUoKWAgZG9lcyBub3Qgc3VwcG9ydCBNZW1vcnlTdHJlYW1zKiouIElmIHdlXG4gICAqIHdvdWxkIGF0dGVtcHQgdG8gaW1pdGF0ZSBhIE1lbW9yeVN0cmVhbSBpbiBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHdlIHdvdWxkXG4gICAqIGVpdGhlciBnZXQgYSByYWNlIGNvbmRpdGlvbiAod2hlcmUgdGhlIHN5bXB0b20gd291bGQgYmUgXCJub3RoaW5nIGhhcHBlbnNcIilcbiAgICogb3IgYW4gaW5maW5pdGUgY3ljbGljIGVtaXNzaW9uIG9mIHZhbHVlcy4gSXQncyB1c2VmdWwgdG8gdGhpbmsgYWJvdXRcbiAgICogTWVtb3J5U3RyZWFtcyBhcyBjZWxscyBpbiBhIHNwcmVhZHNoZWV0LiBJdCBkb2Vzbid0IG1ha2UgYW55IHNlbnNlIHRvXG4gICAqIGRlZmluZSBhIHNwcmVhZHNoZWV0IGNlbGwgYEExYCB3aXRoIGEgZm9ybXVsYSB0aGF0IGRlcGVuZHMgb24gYEIxYCBhbmRcbiAgICogY2VsbCBgQjFgIGRlZmluZWQgd2l0aCBhIGZvcm11bGEgdGhhdCBkZXBlbmRzIG9uIGBBMWAuXG4gICAqXG4gICAqIElmIHlvdSBmaW5kIHlvdXJzZWxmIHdhbnRpbmcgdG8gdXNlIGBpbWl0YXRlKClgIHdpdGggYVxuICAgKiBNZW1vcnlTdHJlYW0sIHlvdSBzaG91bGQgcmV3b3JrIHlvdXIgY29kZSBhcm91bmQgYGltaXRhdGUoKWAgdG8gdXNlIGFcbiAgICogU3RyZWFtIGluc3RlYWQuIExvb2sgZm9yIHRoZSBzdHJlYW0gaW4gdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kgdGhhdFxuICAgKiByZXByZXNlbnRzIGFuIGV2ZW50IHN0cmVhbSwgYW5kIHRoYXQgd291bGQgYmUgYSBjYW5kaWRhdGUgZm9yIGNyZWF0aW5nIGFcbiAgICogcHJveHkgU3RyZWFtIHdoaWNoIHRoZW4gaW1pdGF0ZXMgdGhlIHRhcmdldCBTdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyZWFtfSB0YXJnZXQgVGhlIG90aGVyIHN0cmVhbSB0byBpbWl0YXRlIG9uIHRoZSBjdXJyZW50IG9uZS4gTXVzdFxuICAgKiBub3QgYmUgYSBNZW1vcnlTdHJlYW0uXG4gICAqL1xuICBpbWl0YXRlKHRhcmdldDogU3RyZWFtPFQ+KTogdm9pZCB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE1lbW9yeVN0cmVhbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBNZW1vcnlTdHJlYW0gd2FzIGdpdmVuIHRvIGltaXRhdGUoKSwgYnV0IGl0IG9ubHkgJyArXG4gICAgICAnc3VwcG9ydHMgYSBTdHJlYW0uIFJlYWQgbW9yZSBhYm91dCB0aGlzIHJlc3RyaWN0aW9uIGhlcmU6ICcgK1xuICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9zdGFsdHoveHN0cmVhbSNmYXEnKTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgZm9yIChsZXQgaWxzID0gdGhpcy5faWxzLCBOID0gaWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBOOyBpKyspIHRhcmdldC5fYWRkKGlsc1tpXSk7XG4gICAgdGhpcy5faWxzID0gW107XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHRoZSBTdHJlYW0gdG8gZW1pdCB0aGUgZ2l2ZW4gdmFsdWUgdG8gaXRzIGxpc3RlbmVycy5cbiAgICpcbiAgICogQXMgdGhlIG5hbWUgaW5kaWNhdGVzLCBpZiB5b3UgdXNlIHRoaXMsIHlvdSBhcmUgbW9zdCBsaWtlbHkgZG9pbmcgc29tZXRoaW5nXG4gICAqIFRoZSBXcm9uZyBXYXkuIFBsZWFzZSB0cnkgdG8gdW5kZXJzdGFuZCB0aGUgcmVhY3RpdmUgd2F5IGJlZm9yZSB1c2luZyB0aGlzXG4gICAqIG1ldGhvZC4gVXNlIGl0IG9ubHkgd2hlbiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgXCJuZXh0XCIgdmFsdWUgeW91IHdhbnQgdG8gYnJvYWRjYXN0IHRvIGFsbCBsaXN0ZW5lcnMgb2ZcbiAgICogdGhpcyBTdHJlYW0uXG4gICAqL1xuICBzaGFtZWZ1bGx5U2VuZE5leHQodmFsdWU6IFQpIHtcbiAgICB0aGlzLl9uKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdGhlIFN0cmVhbSB0byBlbWl0IHRoZSBnaXZlbiBlcnJvciB0byBpdHMgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBBcyB0aGUgbmFtZSBpbmRpY2F0ZXMsIGlmIHlvdSB1c2UgdGhpcywgeW91IGFyZSBtb3N0IGxpa2VseSBkb2luZyBzb21ldGhpbmdcbiAgICogVGhlIFdyb25nIFdheS4gUGxlYXNlIHRyeSB0byB1bmRlcnN0YW5kIHRoZSByZWFjdGl2ZSB3YXkgYmVmb3JlIHVzaW5nIHRoaXNcbiAgICogbWV0aG9kLiBVc2UgaXQgb25seSB3aGVuIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVycm9yIFRoZSBlcnJvciB5b3Ugd2FudCB0byBicm9hZGNhc3QgdG8gYWxsIHRoZSBsaXN0ZW5lcnMgb2ZcbiAgICogdGhpcyBTdHJlYW0uXG4gICAqL1xuICBzaGFtZWZ1bGx5U2VuZEVycm9yKGVycm9yOiBhbnkpIHtcbiAgICB0aGlzLl9lKGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdGhlIFN0cmVhbSB0byBlbWl0IHRoZSBcImNvbXBsZXRlZFwiIGV2ZW50IHRvIGl0cyBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEFzIHRoZSBuYW1lIGluZGljYXRlcywgaWYgeW91IHVzZSB0aGlzLCB5b3UgYXJlIG1vc3QgbGlrZWx5IGRvaW5nIHNvbWV0aGluZ1xuICAgKiBUaGUgV3JvbmcgV2F5LiBQbGVhc2UgdHJ5IHRvIHVuZGVyc3RhbmQgdGhlIHJlYWN0aXZlIHdheSBiZWZvcmUgdXNpbmcgdGhpc1xuICAgKiBtZXRob2QuIFVzZSBpdCBvbmx5IHdoZW4geW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgKi9cbiAgc2hhbWVmdWxseVNlbmRDb21wbGV0ZSgpIHtcbiAgICB0aGlzLl9jKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIFwiZGVidWdcIiBsaXN0ZW5lciB0byB0aGUgc3RyZWFtLiBUaGVyZSBjYW4gb25seSBiZSBvbmUgZGVidWdcbiAgICogbGlzdGVuZXIsIHRoYXQncyB3aHkgdGhpcyBpcyAnc2V0RGVidWdMaXN0ZW5lcicuIFRvIHJlbW92ZSB0aGUgZGVidWdcbiAgICogbGlzdGVuZXIsIGp1c3QgY2FsbCBzZXREZWJ1Z0xpc3RlbmVyKG51bGwpLlxuICAgKlxuICAgKiBBIGRlYnVnIGxpc3RlbmVyIGlzIGxpa2UgYW55IG90aGVyIGxpc3RlbmVyLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgYVxuICAgKiBkZWJ1ZyBsaXN0ZW5lciBpcyBcInN0ZWFsdGh5XCI6IGl0cyBwcmVzZW5jZS9hYnNlbmNlIGRvZXMgbm90IHRyaWdnZXIgdGhlXG4gICAqIHN0YXJ0L3N0b3Agb2YgdGhlIHN0cmVhbSAob3IgdGhlIHByb2R1Y2VyIGluc2lkZSB0aGUgc3RyZWFtKS4gVGhpcyBpc1xuICAgKiB1c2VmdWwgc28geW91IGNhbiBpbnNwZWN0IHdoYXQgaXMgZ29pbmcgb24gd2l0aG91dCBjaGFuZ2luZyB0aGUgYmVoYXZpb3JcbiAgICogb2YgdGhlIHByb2dyYW0uIElmIHlvdSBoYXZlIGFuIGlkbGUgc3RyZWFtIGFuZCB5b3UgYWRkIGEgbm9ybWFsIGxpc3RlbmVyIHRvXG4gICAqIGl0LCB0aGUgc3RyZWFtIHdpbGwgc3RhcnQgZXhlY3V0aW5nLiBCdXQgaWYgeW91IHNldCBhIGRlYnVnIGxpc3RlbmVyIG9uIGFuXG4gICAqIGlkbGUgc3RyZWFtLCBpdCB3b24ndCBzdGFydCBleGVjdXRpbmcgKG5vdCB1bnRpbCB0aGUgZmlyc3Qgbm9ybWFsIGxpc3RlbmVyXG4gICAqIGlzIGFkZGVkKS5cbiAgICpcbiAgICogQXMgdGhlIG5hbWUgaW5kaWNhdGVzLCB3ZSBkb24ndCByZWNvbW1lbmQgdXNpbmcgdGhpcyBtZXRob2QgdG8gYnVpbGQgYXBwXG4gICAqIGxvZ2ljLiBJbiBmYWN0LCBpbiBtb3N0IGNhc2VzIHRoZSBkZWJ1ZyBvcGVyYXRvciB3b3JrcyBqdXN0IGZpbmUuIE9ubHkgdXNlXG4gICAqIHRoaXMgb25lIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0xpc3RlbmVyPFQ+fSBsaXN0ZW5lclxuICAgKi9cbiAgc2V0RGVidWdMaXN0ZW5lcihsaXN0ZW5lcjogUGFydGlhbDxMaXN0ZW5lcjxUPj4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZGwgPSBOTyBhcyBJbnRlcm5hbExpc3RlbmVyPFQ+O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kID0gdHJ1ZTtcbiAgICAgIChsaXN0ZW5lciBhcyBJbnRlcm5hbExpc3RlbmVyPFQ+KS5fbiA9IGxpc3RlbmVyLm5leHQgfHwgbm9vcDtcbiAgICAgIChsaXN0ZW5lciBhcyBJbnRlcm5hbExpc3RlbmVyPFQ+KS5fZSA9IGxpc3RlbmVyLmVycm9yIHx8IG5vb3A7XG4gICAgICAobGlzdGVuZXIgYXMgSW50ZXJuYWxMaXN0ZW5lcjxUPikuX2MgPSBsaXN0ZW5lci5jb21wbGV0ZSB8fCBub29wO1xuICAgICAgdGhpcy5fZGwgPSBsaXN0ZW5lciBhcyBJbnRlcm5hbExpc3RlbmVyPFQ+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVtb3J5U3RyZWFtPFQ+IGV4dGVuZHMgU3RyZWFtPFQ+IHtcbiAgcHJpdmF0ZSBfdj86IFQ7XG4gIHByaXZhdGUgX2hhcz86IGJvb2xlYW4gPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocHJvZHVjZXI6IEludGVybmFsUHJvZHVjZXI8VD4pIHtcbiAgICBzdXBlcihwcm9kdWNlcik7XG4gIH1cblxuICBfbih4OiBUKSB7XG4gICAgdGhpcy5fdiA9IHg7XG4gICAgdGhpcy5faGFzID0gdHJ1ZTtcbiAgICBzdXBlci5fbih4KTtcbiAgfVxuXG4gIF9hZGQoaWw6IEludGVybmFsTGlzdGVuZXI8VD4pOiB2b2lkIHtcbiAgICBjb25zdCB0YSA9IHRoaXMuX3RhcmdldDtcbiAgICBpZiAodGEgIT09IE5PKSByZXR1cm4gdGEuX2FkZChpbCk7XG4gICAgY29uc3QgYSA9IHRoaXMuX2lscztcbiAgICBhLnB1c2goaWwpO1xuICAgIGlmIChhLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICh0aGlzLl9oYXMpIGlsLl9uKHRoaXMuX3YhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3BJRCAhPT0gTk8pIHtcbiAgICAgIGlmICh0aGlzLl9oYXMpIGlsLl9uKHRoaXMuX3YhKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdG9wSUQpO1xuICAgICAgdGhpcy5fc3RvcElEID0gTk87XG4gICAgfSBlbHNlIGlmICh0aGlzLl9oYXMpIGlsLl9uKHRoaXMuX3YhKTsgZWxzZSB7XG4gICAgICBjb25zdCBwID0gdGhpcy5fcHJvZDtcbiAgICAgIGlmIChwICE9PSBOTykgcC5fc3RhcnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgX3N0b3BOb3coKSB7XG4gICAgdGhpcy5faGFzID0gZmFsc2U7XG4gICAgc3VwZXIuX3N0b3BOb3coKTtcbiAgfVxuXG4gIF94KCk6IHZvaWQge1xuICAgIHRoaXMuX2hhcyA9IGZhbHNlO1xuICAgIHN1cGVyLl94KCk7XG4gIH1cblxuICBtYXA8VT4ocHJvamVjdDogKHQ6IFQpID0+IFUpOiBNZW1vcnlTdHJlYW08VT4ge1xuICAgIHJldHVybiB0aGlzLl9tYXAocHJvamVjdCkgYXMgTWVtb3J5U3RyZWFtPFU+O1xuICB9XG5cbiAgbWFwVG88VT4ocHJvamVjdGVkVmFsdWU6IFUpOiBNZW1vcnlTdHJlYW08VT4ge1xuICAgIHJldHVybiBzdXBlci5tYXBUbyhwcm9qZWN0ZWRWYWx1ZSkgYXMgTWVtb3J5U3RyZWFtPFU+O1xuICB9XG5cbiAgdGFrZShhbW91bnQ6IG51bWJlcik6IE1lbW9yeVN0cmVhbTxUPiB7XG4gICAgcmV0dXJuIHN1cGVyLnRha2UoYW1vdW50KSBhcyBNZW1vcnlTdHJlYW08VD47XG4gIH1cblxuICBlbmRXaGVuKG90aGVyOiBTdHJlYW08YW55Pik6IE1lbW9yeVN0cmVhbTxUPiB7XG4gICAgcmV0dXJuIHN1cGVyLmVuZFdoZW4ob3RoZXIpIGFzIE1lbW9yeVN0cmVhbTxUPjtcbiAgfVxuXG4gIHJlcGxhY2VFcnJvcihyZXBsYWNlOiAoZXJyOiBhbnkpID0+IFN0cmVhbTxUPik6IE1lbW9yeVN0cmVhbTxUPiB7XG4gICAgcmV0dXJuIHN1cGVyLnJlcGxhY2VFcnJvcihyZXBsYWNlKSBhcyBNZW1vcnlTdHJlYW08VD47XG4gIH1cblxuICByZW1lbWJlcigpOiBNZW1vcnlTdHJlYW08VD4ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVidWcoKTogTWVtb3J5U3RyZWFtPFQ+O1xuICBkZWJ1ZyhsYWJlbE9yU3B5OiBzdHJpbmcpOiBNZW1vcnlTdHJlYW08VD47XG4gIGRlYnVnKGxhYmVsT3JTcHk6ICh0OiBUKSA9PiBhbnkpOiBNZW1vcnlTdHJlYW08VD47XG4gIGRlYnVnKGxhYmVsT3JTcHk/OiBzdHJpbmcgfCAoKHQ6IFQpID0+IGFueSkgfCB1bmRlZmluZWQpOiBNZW1vcnlTdHJlYW08VD4ge1xuICAgIHJldHVybiBzdXBlci5kZWJ1ZyhsYWJlbE9yU3B5IGFzIGFueSkgYXMgTWVtb3J5U3RyZWFtPFQ+O1xuICB9XG59XG5cbmV4cG9ydCB7Tk8sIE5PX0lMfTtcbmNvbnN0IHhzID0gU3RyZWFtO1xudHlwZSB4czxUPiA9IFN0cmVhbTxUPjtcbmV4cG9ydCBkZWZhdWx0IHhzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZShcInhzdHJlYW1cIik7XG52YXIgYWRhcHRfMSA9IHJlcXVpcmUoXCJAY3ljbGUvcnVuL2xpYi9hZGFwdFwiKTtcbnZhciBmcm9tRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2Zyb21FdmVudFwiKTtcbnZhciBCb2R5RE9NU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvZHlET01Tb3VyY2UoX25hbWUpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICAgIH1cbiAgICBCb2R5RE9NU291cmNlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbmFsaXR5IGlzIHN0aWxsIHVuZGVmaW5lZC91bmRlY2lkZWQuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQm9keURPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBhZGFwdF8xLmFkYXB0KHhzdHJlYW1fMS5kZWZhdWx0Lm9mKFtkb2N1bWVudC5ib2R5XSkpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQm9keURPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IGFkYXB0XzEuYWRhcHQoeHN0cmVhbV8xLmRlZmF1bHQub2YoZG9jdW1lbnQuYm9keSkpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQm9keURPTVNvdXJjZS5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgb3B0aW9ucywgYnViYmxlcykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgc3RyZWFtO1xuICAgICAgICBzdHJlYW0gPSBmcm9tRXZlbnRfMS5mcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgZXZlbnRUeXBlLCBvcHRpb25zLnVzZUNhcHR1cmUsIG9wdGlvbnMucHJldmVudERlZmF1bHQpO1xuICAgICAgICB2YXIgb3V0ID0gYWRhcHRfMS5hZGFwdChzdHJlYW0pO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIEJvZHlET01Tb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5Cb2R5RE9NU291cmNlID0gQm9keURPTVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvZHlET01Tb3VyY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZShcInhzdHJlYW1cIik7XG52YXIgYWRhcHRfMSA9IHJlcXVpcmUoXCJAY3ljbGUvcnVuL2xpYi9hZGFwdFwiKTtcbnZhciBmcm9tRXZlbnRfMSA9IHJlcXVpcmUoXCIuL2Zyb21FdmVudFwiKTtcbnZhciBEb2N1bWVudERPTVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2N1bWVudERPTVNvdXJjZShfbmFtZSkge1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgfVxuICAgIERvY3VtZW50RE9NU291cmNlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbmFsaXR5IGlzIHN0aWxsIHVuZGVmaW5lZC91bmRlY2lkZWQuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRG9jdW1lbnRET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gYWRhcHRfMS5hZGFwdCh4c3RyZWFtXzEuZGVmYXVsdC5vZihbZG9jdW1lbnRdKSk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBEb2N1bWVudERPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IGFkYXB0XzEuYWRhcHQoeHN0cmVhbV8xLmRlZmF1bHQub2YoZG9jdW1lbnQpKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gdGhpcy5fbmFtZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIERvY3VtZW50RE9NU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zLCBidWJibGVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgIHN0cmVhbSA9IGZyb21FdmVudF8xLmZyb21FdmVudChkb2N1bWVudCwgZXZlbnRUeXBlLCBvcHRpb25zLnVzZUNhcHR1cmUsIG9wdGlvbnMucHJldmVudERlZmF1bHQpO1xuICAgICAgICB2YXIgb3V0ID0gYWRhcHRfMS5hZGFwdChzdHJlYW0pO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIERvY3VtZW50RE9NU291cmNlO1xufSgpKTtcbmV4cG9ydHMuRG9jdW1lbnRET01Tb3VyY2UgPSBEb2N1bWVudERPTVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURvY3VtZW50RE9NU291cmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNjb3BlQ2hlY2tlcl8xID0gcmVxdWlyZShcIi4vU2NvcGVDaGVja2VyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIHRvRWxBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbnB1dCk7XG59XG52YXIgRWxlbWVudEZpbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50RmluZGVyKG5hbWVzcGFjZSwgaXNvbGF0ZU1vZHVsZSkge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5pc29sYXRlTW9kdWxlID0gaXNvbGF0ZU1vZHVsZTtcbiAgICB9XG4gICAgRWxlbWVudEZpbmRlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB1dGlsc18xLmdldFNlbGVjdG9ycyhuYW1lc3BhY2UpO1xuICAgICAgICB2YXIgc2NvcGVDaGVja2VyID0gbmV3IFNjb3BlQ2hlY2tlcl8xLlNjb3BlQ2hlY2tlcihuYW1lc3BhY2UsIHRoaXMuaXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgIHZhciB0b3BOb2RlID0gdGhpcy5pc29sYXRlTW9kdWxlLmdldEVsZW1lbnQobmFtZXNwYWNlLmZpbHRlcihmdW5jdGlvbiAobikgeyByZXR1cm4gbi50eXBlICE9PSAnc2VsZWN0b3InOyB9KSk7XG4gICAgICAgIGlmICh0b3BOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RvcE5vZGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0VsQXJyYXkodG9wTm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAgICAgICAgIC5maWx0ZXIoc2NvcGVDaGVja2VyLmlzRGlyZWN0bHlJblNjb3BlLCBzY29wZUNoZWNrZXIpXG4gICAgICAgICAgICAuY29uY2F0KHRvcE5vZGUubWF0Y2hlcyhzZWxlY3RvcikgPyBbdG9wTm9kZV0gOiBbXSk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudEZpbmRlcjtcbn0oKSk7XG5leHBvcnRzLkVsZW1lbnRGaW5kZXIgPSBFbGVtZW50RmluZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxlbWVudEZpbmRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZShcInhzdHJlYW1cIik7XG52YXIgU2NvcGVDaGVja2VyXzEgPSByZXF1aXJlKFwiLi9TY29wZUNoZWNrZXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEVsZW1lbnRGaW5kZXJfMSA9IHJlcXVpcmUoXCIuL0VsZW1lbnRGaW5kZXJcIik7XG52YXIgU3ltYm9sVHJlZV8xID0gcmVxdWlyZShcIi4vU3ltYm9sVHJlZVwiKTtcbnZhciBSZW1vdmFsU2V0XzEgPSByZXF1aXJlKFwiLi9SZW1vdmFsU2V0XCIpO1xudmFyIFByaW9yaXR5UXVldWVfMSA9IHJlcXVpcmUoXCIuL1ByaW9yaXR5UXVldWVcIik7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKFwiLi9mcm9tRXZlbnRcIik7XG5leHBvcnRzLmV2ZW50VHlwZXNUaGF0RG9udEJ1YmJsZSA9IFtcbiAgICBcImJsdXJcIixcbiAgICBcImNhbnBsYXlcIixcbiAgICBcImNhbnBsYXl0aHJvdWdoXCIsXG4gICAgXCJkdXJhdGlvbmNoYW5nZVwiLFxuICAgIFwiZW1wdGllZFwiLFxuICAgIFwiZW5kZWRcIixcbiAgICBcImZvY3VzXCIsXG4gICAgXCJsb2FkXCIsXG4gICAgXCJsb2FkZWRkYXRhXCIsXG4gICAgXCJsb2FkZWRtZXRhZGF0YVwiLFxuICAgIFwibW91c2VlbnRlclwiLFxuICAgIFwibW91c2VsZWF2ZVwiLFxuICAgIFwicGF1c2VcIixcbiAgICBcInBsYXlcIixcbiAgICBcInBsYXlpbmdcIixcbiAgICBcInJhdGVjaGFuZ2VcIixcbiAgICBcInJlc2V0XCIsXG4gICAgXCJzY3JvbGxcIixcbiAgICBcInNlZWtlZFwiLFxuICAgIFwic2Vla2luZ1wiLFxuICAgIFwic3RhbGxlZFwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJzdXNwZW5kXCIsXG4gICAgXCJ0aW1ldXBkYXRlXCIsXG4gICAgXCJ1bmxvYWRcIixcbiAgICBcInZvbHVtZWNoYW5nZVwiLFxuICAgIFwid2FpdGluZ1wiLFxuXTtcbi8qKlxuICogTWFuYWdlcyBcIkV2ZW50IGRlbGVnYXRpb25cIiwgYnkgY29ubmVjdGluZyBhbiBvcmlnaW4gd2l0aCBtdWx0aXBsZVxuICogZGVzdGluYXRpb25zLlxuICpcbiAqIEF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBET00gZWxlbWVudCBjYWxsZWQgdGhlIFwib3JpZ2luXCIsXG4gKiBhbmQgZGVsZWdhdGVzIGV2ZW50cyB0byBcImRlc3RpbmF0aW9uc1wiLCB3aGljaCBhcmUgc3ViamVjdHMgYXMgb3V0cHV0c1xuICogZm9yIHRoZSBET01Tb3VyY2UuIFNpbXVsYXRlcyBidWJibGluZyBvciBjYXB0dXJpbmcsIHdpdGggcmVnYXJkcyB0b1xuICogaXNvbGF0aW9uIGJvdW5kYXJpZXMgdG9vLlxuICovXG52YXIgRXZlbnREZWxlZ2F0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnREZWxlZ2F0b3Iocm9vdEVsZW1lbnQkLCBpc29sYXRlTW9kdWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQkID0gcm9vdEVsZW1lbnQkO1xuICAgICAgICB0aGlzLmlzb2xhdGVNb2R1bGUgPSBpc29sYXRlTW9kdWxlO1xuICAgICAgICB0aGlzLnZpcnR1YWxMaXN0ZW5lcnMgPSBuZXcgU3ltYm9sVHJlZV8xLmRlZmF1bHQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2NvcGU7IH0pO1xuICAgICAgICB0aGlzLm5vbkJ1YmJsaW5nTGlzdGVuZXJzVG9BZGQgPSBuZXcgUmVtb3ZhbFNldF8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy52aXJ0dWFsTm9uQnViYmxpbmdMaXN0ZW5lciA9IFtdO1xuICAgICAgICB0aGlzLmlzb2xhdGVNb2R1bGUuc2V0RXZlbnREZWxlZ2F0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRvbUxpc3RlbmVyc1RvQWRkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5vbkJ1YmJsaW5nTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICByb290RWxlbWVudCQuYWRkTGlzdGVuZXIoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9yaWdpbiAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3JpZ2luID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9tTGlzdGVuZXJzVG9BZGQuZm9yRWFjaChmdW5jdGlvbiAocGFzc2l2ZSwgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldHVwRE9NTGlzdGVuZXIodHlwZSwgcGFzc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb21MaXN0ZW5lcnNUb0FkZC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNldE5vbkJ1YmJsaW5nTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9uQnViYmxpbmdMaXN0ZW5lcnNUb0FkZC5mb3JFYWNoKGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0dXBOb25CdWJibGluZ0xpc3RlbmVyKGFycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBuYW1lc3BhY2UsIG9wdGlvbnMsIGJ1YmJsZXMpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB4c3RyZWFtXzEuZGVmYXVsdC5uZXZlcigpO1xuICAgICAgICB2YXIgc2NvcGVDaGVja2VyID0gbmV3IFNjb3BlQ2hlY2tlcl8xLlNjb3BlQ2hlY2tlcihuYW1lc3BhY2UsIHRoaXMuaXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgIHZhciBkZXN0ID0gdGhpcy5pbnNlcnRMaXN0ZW5lcihzdWJqZWN0LCBzY29wZUNoZWNrZXIsIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBzaG91bGRCdWJibGUgPSBidWJibGVzID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZXhwb3J0cy5ldmVudFR5cGVzVGhhdERvbnRCdWJibGUuaW5kZXhPZihldmVudFR5cGUpID09PSAtMVxuICAgICAgICAgICAgOiBidWJibGVzO1xuICAgICAgICBpZiAoc2hvdWxkQnViYmxlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9tTGlzdGVuZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cERPTUxpc3RlbmVyKGV2ZW50VHlwZSwgISFvcHRpb25zLnBhc3NpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpbmRlciA9IG5ldyBFbGVtZW50RmluZGVyXzEuRWxlbWVudEZpbmRlcihuYW1lc3BhY2UsIHRoaXMuaXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgICAgICB0aGlzLnNldHVwTm9uQnViYmxpbmdMaXN0ZW5lcihbZXZlbnRUeXBlLCBmaW5kZXIsIGRlc3RdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAobmFtZXNwYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlydHVhbExpc3RlbmVycy5kZWxldGUobmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgICAgdGhpcy5ub25CdWJibGluZ0xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChtYXAsIHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaChbdHlwZSwgZWxlbWVudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMubm9uQnViYmxpbmdMaXN0ZW5lcnMuZ2V0KHRvUmVtb3ZlW2ldWzBdKTtcbiAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXAuZGVsZXRlKHRvUmVtb3ZlW2ldWzFdKTtcbiAgICAgICAgICAgIGlmIChtYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9uQnViYmxpbmdMaXN0ZW5lcnMuZGVsZXRlKHRvUmVtb3ZlW2ldWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubm9uQnViYmxpbmdMaXN0ZW5lcnMuc2V0KHRvUmVtb3ZlW2ldWzBdLCBtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUuaW5zZXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiAoc3ViamVjdCwgc2NvcGVDaGVja2VyLCBldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlbGV2YW50U2V0cyA9IFtdO1xuICAgICAgICB2YXIgbiA9IHNjb3BlQ2hlY2tlci5fbmFtZXNwYWNlO1xuICAgICAgICB2YXIgbWF4ID0gbi5sZW5ndGg7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlbGV2YW50U2V0cy5wdXNoKHRoaXMuZ2V0VmlydHVhbExpc3RlbmVycyhldmVudFR5cGUsIG4sIHRydWUsIG1heCkpO1xuICAgICAgICAgICAgbWF4LS07XG4gICAgICAgIH0gd2hpbGUgKG1heCA+PSAwICYmIG5bbWF4XS50eXBlICE9PSAndG90YWwnKTtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gX19hc3NpZ24oe30sIG9wdGlvbnMsIHsgc2NvcGVDaGVja2VyOiBzY29wZUNoZWNrZXIsXG4gICAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0LCBidWJibGVzOiAhIW9wdGlvbnMuYnViYmxlcywgdXNlQ2FwdHVyZTogISFvcHRpb25zLnVzZUNhcHR1cmUsIHBhc3NpdmU6ICEhb3B0aW9ucy5wYXNzaXZlIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbGV2YW50U2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVsZXZhbnRTZXRzW2ldLmFkZChkZXN0aW5hdGlvbiwgbi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzZXQgb2YgYWxsIHZpcnR1YWwgbGlzdGVuZXJzIGluIHRoZSBzY29wZSBvZiB0aGUgbmFtZXNwYWNlXG4gICAgICogU2V0IGBleGFjdGAgdG8gdHJ1ZSB0byB0cmVhdCBzaWJpbGluZyBpc29sYXRlZCBzY29wZXMgYXMgdG90YWwgc2NvcGVzXG4gICAgICovXG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLmdldFZpcnR1YWxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBuYW1lc3BhY2UsIGV4YWN0LCBtYXgpIHtcbiAgICAgICAgaWYgKGV4YWN0ID09PSB2b2lkIDApIHsgZXhhY3QgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX21heCA9IG1heCAhPT0gdW5kZWZpbmVkID8gbWF4IDogbmFtZXNwYWNlLmxlbmd0aDtcbiAgICAgICAgaWYgKCFleGFjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IF9tYXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VbaV0udHlwZSA9PT0gJ3RvdGFsJykge1xuICAgICAgICAgICAgICAgICAgICBfbWF4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbWF4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwID0gdGhpcy52aXJ0dWFsTGlzdGVuZXJzLmdldERlZmF1bHQobmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwKCk7IH0sIF9tYXgpO1xuICAgICAgICBpZiAoIW1hcC5oYXMoZXZlbnRUeXBlKSkge1xuICAgICAgICAgICAgbWFwLnNldChldmVudFR5cGUsIG5ldyBQcmlvcml0eVF1ZXVlXzEuZGVmYXVsdCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwLmdldChldmVudFR5cGUpO1xuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLnNldHVwRE9NTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBwYXNzaXZlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICAgICAgdmFyIHN1YiA9IGZyb21FdmVudF8xLmZyb21FdmVudCh0aGlzLm9yaWdpbiwgZXZlbnRUeXBlLCBmYWxzZSwgZmFsc2UsIHBhc3NpdmUpLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5vbkV2ZW50KGV2ZW50VHlwZSwgZXZlbnQsIHBhc3NpdmUpOyB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kb21MaXN0ZW5lcnMuc2V0KGV2ZW50VHlwZSwgeyBzdWI6IHN1YiwgcGFzc2l2ZTogcGFzc2l2ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9tTGlzdGVuZXJzVG9BZGQuc2V0KGV2ZW50VHlwZSwgcGFzc2l2ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5zZXR1cE5vbkJ1YmJsaW5nTGlzdGVuZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0WzBdLCBlbGVtZW50RmluZGVyID0gaW5wdXRbMV0sIGRlc3RpbmF0aW9uID0gaW5wdXRbMl07XG4gICAgICAgIGlmICghdGhpcy5vcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMubm9uQnViYmxpbmdMaXN0ZW5lcnNUb0FkZC5hZGQoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudEZpbmRlci5jYWxsKClbMF07XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm5vbkJ1YmJsaW5nTGlzdGVuZXJzVG9BZGQuZGVsZXRlKGlucHV0KTtcbiAgICAgICAgICAgIHZhciBzdWIgPSBmcm9tRXZlbnRfMS5mcm9tRXZlbnQoZWxlbWVudCwgZXZlbnRUeXBlLCBmYWxzZSwgZmFsc2UsIGRlc3RpbmF0aW9uLnBhc3NpdmUpLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5vbkV2ZW50KGV2ZW50VHlwZSwgZXYsICEhZGVzdGluYXRpb24ucGFzc2l2ZSwgZmFsc2UpOyB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vbkJ1YmJsaW5nTGlzdGVuZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub25CdWJibGluZ0xpc3RlbmVycy5zZXQoZXZlbnRUeXBlLCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMubm9uQnViYmxpbmdMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcC5zZXQoZWxlbWVudCwgeyBzdWI6IHN1YiwgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub25CdWJibGluZ0xpc3RlbmVyc1RvQWRkLmFkZChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5yZXNldEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlciA9IHRoaXMuZG9tTGlzdGVuZXJzLmVudHJpZXMoKTtcbiAgICAgICAgdmFyIGN1cnIgPSBpdGVyLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFjdXJyLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGN1cnIudmFsdWUsIHR5cGUgPSBfYVswXSwgX2IgPSBfYVsxXSwgc3ViID0gX2Iuc3ViLCBwYXNzaXZlID0gX2IucGFzc2l2ZTtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXR1cERPTUxpc3RlbmVyKHR5cGUsIHBhc3NpdmUpO1xuICAgICAgICAgICAgY3VyciA9IGl0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUucmVzZXROb25CdWJibGluZ0xpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5ld01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGluc2VydCA9IHV0aWxzXzEubWFrZUluc2VydChuZXdNYXApO1xuICAgICAgICB0aGlzLm5vbkJ1YmJsaW5nTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hcCwgdHlwZSkge1xuICAgICAgICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBlbG0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZWxtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViID0gdmFsdWUuc3ViLCBkZXN0aW5hdGlvbl8xID0gdmFsdWUuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50RmluZGVyID0gbmV3IEVsZW1lbnRGaW5kZXJfMS5FbGVtZW50RmluZGVyKGRlc3RpbmF0aW9uXzEuc2NvcGVDaGVja2VyLm5hbWVzcGFjZSwgX3RoaXMuaXNvbGF0ZU1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbG0gPSBlbGVtZW50RmluZGVyLmNhbGwoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1N1YiA9IGZyb21FdmVudF8xLmZyb21FdmVudChuZXdFbG0sIHR5cGUsIGZhbHNlLCBmYWxzZSwgZGVzdGluYXRpb25fMS5wYXNzaXZlKS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uRXZlbnQodHlwZSwgZXZlbnQsICEhZGVzdGluYXRpb25fMS5wYXNzaXZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQodHlwZSwgbmV3RWxtLCB7IHN1YjogbmV3U3ViLCBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25fMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCh0eXBlLCBlbG0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLm5vbkJ1YmJsaW5nTGlzdGVuZXJzID0gbmV3TWFwO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5wdXROb25CdWJibGluZ0xpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZWxtLCB1c2VDYXB0dXJlLCBwYXNzaXZlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm5vbkJ1YmJsaW5nTGlzdGVuZXJzLmdldChldmVudFR5cGUpO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IG1hcC5nZXQoZWxtKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyICYmXG4gICAgICAgICAgICBsaXN0ZW5lci5kZXN0aW5hdGlvbi5wYXNzaXZlID09PSBwYXNzaXZlICYmXG4gICAgICAgICAgICBsaXN0ZW5lci5kZXN0aW5hdGlvbi51c2VDYXB0dXJlID09PSB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxOb25CdWJibGluZ0xpc3RlbmVyWzBdID0gbGlzdGVuZXIuZGVzdGluYXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5vbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZXZlbnQsIHBhc3NpdmUsIGJ1YmJsZXMpIHtcbiAgICAgICAgaWYgKGJ1YmJsZXMgPT09IHZvaWQgMCkgeyBidWJibGVzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgY3ljbGVFdmVudCA9IHRoaXMucGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuaXNvbGF0ZU1vZHVsZS5nZXRSb290RWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoYnViYmxlcykge1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMuaXNvbGF0ZU1vZHVsZS5nZXROYW1lc3BhY2UoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0VmlydHVhbExpc3RlbmVycyhldmVudFR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB0aGlzLmJ1YmJsZShldmVudFR5cGUsIGV2ZW50LnRhcmdldCwgcm9vdEVsZW1lbnQsIGN5Y2xlRXZlbnQsIGxpc3RlbmVycywgbmFtZXNwYWNlLCBuYW1lc3BhY2UubGVuZ3RoIC0gMSwgdHJ1ZSwgcGFzc2l2ZSk7XG4gICAgICAgICAgICB0aGlzLmJ1YmJsZShldmVudFR5cGUsIGV2ZW50LnRhcmdldCwgcm9vdEVsZW1lbnQsIGN5Y2xlRXZlbnQsIGxpc3RlbmVycywgbmFtZXNwYWNlLCBuYW1lc3BhY2UubGVuZ3RoIC0gMSwgZmFsc2UsIHBhc3NpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXROb25CdWJibGluZ0xpc3RlbmVyKGV2ZW50VHlwZSwgZXZlbnQudGFyZ2V0LCB0cnVlLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIHRoaXMuZG9CdWJibGVTdGVwKGV2ZW50VHlwZSwgZXZlbnQudGFyZ2V0LCByb290RWxlbWVudCwgY3ljbGVFdmVudCwgdGhpcy52aXJ0dWFsTm9uQnViYmxpbmdMaXN0ZW5lciwgdHJ1ZSwgcGFzc2l2ZSk7XG4gICAgICAgICAgICB0aGlzLnB1dE5vbkJ1YmJsaW5nTGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudC50YXJnZXQsIGZhbHNlLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIHRoaXMuZG9CdWJibGVTdGVwKGV2ZW50VHlwZSwgZXZlbnQudGFyZ2V0LCByb290RWxlbWVudCwgY3ljbGVFdmVudCwgdGhpcy52aXJ0dWFsTm9uQnViYmxpbmdMaXN0ZW5lciwgZmFsc2UsIHBhc3NpdmUpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vZml4IHJlc2V0IGV2ZW50IChzcGVjJ2VkIGFzIG5vbi1idWJibGluZywgYnV0IGJ1YmJsZXMgaW4gcmVhbGl0eVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZWxtLCByb290RWxlbWVudCwgZXZlbnQsIGxpc3RlbmVycywgbmFtZXNwYWNlLCBpbmRleCwgdXNlQ2FwdHVyZSwgcGFzc2l2ZSkge1xuICAgICAgICBpZiAoIXVzZUNhcHR1cmUgJiYgIWV2ZW50LnByb3BhZ2F0aW9uSGFzQmVlblN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9CdWJibGVTdGVwKGV2ZW50VHlwZSwgZWxtLCByb290RWxlbWVudCwgZXZlbnQsIGxpc3RlbmVycywgdXNlQ2FwdHVyZSwgcGFzc2l2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1Jvb3QgPSByb290RWxlbWVudDtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmIChlbG0gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBuYW1lc3BhY2VbaW5kZXhdLnR5cGUgPT09ICdzaWJsaW5nJykge1xuICAgICAgICAgICAgICAgIG5ld1Jvb3QgPSB0aGlzLmlzb2xhdGVNb2R1bGUuZ2V0RWxlbWVudChuYW1lc3BhY2UsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbG0ucGFyZW50Tm9kZSAmJiBuZXdSb290KSB7XG4gICAgICAgICAgICB0aGlzLmJ1YmJsZShldmVudFR5cGUsIGVsbS5wYXJlbnROb2RlLCBuZXdSb290LCBldmVudCwgbGlzdGVuZXJzLCBuYW1lc3BhY2UsIG5ld0luZGV4LCB1c2VDYXB0dXJlLCBwYXNzaXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQ2FwdHVyZSAmJiAhZXZlbnQucHJvcGFnYXRpb25IYXNCZWVuU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5kb0J1YmJsZVN0ZXAoZXZlbnRUeXBlLCBlbG0sIHJvb3RFbGVtZW50LCBldmVudCwgbGlzdGVuZXJzLCB1c2VDYXB0dXJlLCBwYXNzaXZlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnREZWxlZ2F0b3IucHJvdG90eXBlLmRvQnViYmxlU3RlcCA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGVsbSwgcm9vdEVsZW1lbnQsIGV2ZW50LCBsaXN0ZW5lcnMsIHVzZUNhcHR1cmUsIHBhc3NpdmUpIHtcbiAgICAgICAgaWYgKCFyb290RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0YXRlRXZlbnRDdXJyZW50VGFyZ2V0KGV2ZW50LCBlbG0pO1xuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICAgICAgaWYgKGRlc3QucGFzc2l2ZSA9PT0gcGFzc2l2ZSAmJiBkZXN0LnVzZUNhcHR1cmUgPT09IHVzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsID0gdXRpbHNfMS5nZXRTZWxlY3RvcnMoZGVzdC5zY29wZUNoZWNrZXIubmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LnByb3BhZ2F0aW9uSGFzQmVlblN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZGVzdC5zY29wZUNoZWNrZXIuaXNEaXJlY3RseUluU2NvcGUoZWxtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKHNlbCAhPT0gJycgJiYgZWxtLm1hdGNoZXMoc2VsKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWwgPT09ICcnICYmIGVsbSA9PT0gcm9vdEVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnRfMS5wcmV2ZW50RGVmYXVsdENvbmRpdGlvbmFsKGV2ZW50LCBkZXN0LnByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdC5zdWJqZWN0LnNoYW1lZnVsbHlTZW5kTmV4dChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50RGVsZWdhdG9yLnByb3RvdHlwZS5wYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBwRXZlbnQgPSBldmVudDtcbiAgICAgICAgcEV2ZW50LnByb3BhZ2F0aW9uSGFzQmVlblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9sZFN0b3BQcm9wYWdhdGlvbiA9IHBFdmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgIHBFdmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICBvbGRTdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRpb25IYXNCZWVuU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwRXZlbnQ7XG4gICAgfTtcbiAgICBFdmVudERlbGVnYXRvci5wcm90b3R5cGUubXV0YXRlRXZlbnRDdXJyZW50VGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50LCBjdXJyZW50VGFyZ2V0RWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50VGFyZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsZWFzZSB1c2UgZXZlbnQub3duZXJUYXJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQub3duZXJUYXJnZXQgPSBjdXJyZW50VGFyZ2V0RWxlbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudERlbGVnYXRvcjtcbn0oKSk7XG5leHBvcnRzLkV2ZW50RGVsZWdhdG9yID0gRXZlbnREZWxlZ2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudERlbGVnYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgU3ltYm9sVHJlZV8xID0gcmVxdWlyZShcIi4vU3ltYm9sVHJlZVwiKTtcbnZhciBJc29sYXRlTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElzb2xhdGVNb2R1bGUoKSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlVHJlZSA9IG5ldyBTeW1ib2xUcmVlXzEuZGVmYXVsdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zY29wZTsgfSk7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlQnlFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZub2Rlc0JlaW5nUmVtb3ZlZCA9IFtdO1xuICAgIH1cbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5zZXRFdmVudERlbGVnYXRvciA9IGZ1bmN0aW9uIChkZWwpIHtcbiAgICAgICAgdGhpcy5ldmVudERlbGVnYXRvciA9IGRlbDtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLmluc2VydEVsZW1lbnQgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBlbCkge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZUJ5RWxlbWVudC5zZXQoZWwsIG5hbWVzcGFjZSk7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlVHJlZS5zZXQobmFtZXNwYWNlLCBlbCk7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsbSkge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZUJ5RWxlbWVudC5kZWxldGUoZWxtKTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMuZ2V0TmFtZXNwYWNlKGVsbSk7XG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlVHJlZS5kZWxldGUobmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1heCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VUcmVlLmdldChuYW1lc3BhY2UsIHVuZGVmaW5lZCwgbWF4KTtcbiAgICB9O1xuICAgIElzb2xhdGVNb2R1bGUucHJvdG90eXBlLmdldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKGVsbSkge1xuICAgICAgICBpZiAodGhpcy5uYW1lc3BhY2VCeUVsZW1lbnQuaGFzKGVsbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbG07XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBBZGQgcXVpY2stbHJ1IG9yIHNpbWlsYXIgYXMgYWRkaXRpb25hbCBPKDEpIGNhY2hlXG4gICAgICAgIHZhciBjdXJyID0gZWxtO1xuICAgICAgICB3aGlsZSAoIXRoaXMubmFtZXNwYWNlQnlFbGVtZW50LmhhcyhjdXJyKSkge1xuICAgICAgICAgICAgY3VyciA9IGN1cnIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghY3Vycikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyLnRhZ05hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcm9vdCBlbGVtZW50IGZvdW5kLCB0aGlzIHNob3VsZCBub3QgaGFwcGVuIGF0IGFsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyO1xuICAgIH07XG4gICAgSXNvbGF0ZU1vZHVsZS5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gKGVsbSkge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLmdldFJvb3RFbGVtZW50KGVsbSk7XG4gICAgICAgIGlmICghcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlQnlFbGVtZW50LmdldChyb290RWxlbWVudCk7XG4gICAgfTtcbiAgICBJc29sYXRlTW9kdWxlLnByb3RvdHlwZS5jcmVhdGVNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGVtcHR5Vk5vZGUsIHZOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsbSA9IHZOb2RlLmVsbSwgX2EgPSB2Tm9kZS5kYXRhLCBkYXRhID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2E7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGRhdGEuaXNvbGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5zZXJ0RWxlbWVudChuYW1lc3BhY2UsIGVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9sZFZOb2RlLCB2Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRFbG0gPSBvbGRWTm9kZS5lbG0sIF9hID0gb2xkVk5vZGUuZGF0YSwgb2xkRGF0YSA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hO1xuICAgICAgICAgICAgICAgIHZhciBlbG0gPSB2Tm9kZS5lbG0sIF9iID0gdk5vZGUuZGF0YSwgZGF0YSA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iO1xuICAgICAgICAgICAgICAgIHZhciBvbGROYW1lc3BhY2UgPSBvbGREYXRhLmlzb2xhdGU7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGRhdGEuaXNvbGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuaXNFcXVhbE5hbWVzcGFjZShvbGROYW1lc3BhY2UsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2xkTmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVFbGVtZW50KG9sZEVsbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluc2VydEVsZW1lbnQobmFtZXNwYWNlLCBlbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAodk5vZGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnZub2Rlc0JlaW5nUmVtb3ZlZC5wdXNoKHZOb2RlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICh2Tm9kZSwgY2IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnZub2Rlc0JlaW5nUmVtb3ZlZC5wdXNoKHZOb2RlKTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdm5vZGVzQmVpbmdSZW1vdmVkID0gc2VsZi52bm9kZXNCZWluZ1JlbW92ZWQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHZub2Rlc0JlaW5nUmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdm5vZGUgPSB2bm9kZXNCZWluZ1JlbW92ZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSB2bm9kZS5kYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdm5vZGUuZGF0YS5pc29sYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRWxlbWVudChuYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXZlbnREZWxlZ2F0b3IucmVtb3ZlRWxlbWVudCh2bm9kZS5lbG0sIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYudm5vZGVzQmVpbmdSZW1vdmVkID0gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIElzb2xhdGVNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5Jc29sYXRlTW9kdWxlID0gSXNvbGF0ZU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlzb2xhdGVNb2R1bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYWRhcHRfMSA9IHJlcXVpcmUoXCJAY3ljbGUvcnVuL2xpYi9hZGFwdFwiKTtcbnZhciBEb2N1bWVudERPTVNvdXJjZV8xID0gcmVxdWlyZShcIi4vRG9jdW1lbnRET01Tb3VyY2VcIik7XG52YXIgQm9keURPTVNvdXJjZV8xID0gcmVxdWlyZShcIi4vQm9keURPTVNvdXJjZVwiKTtcbnZhciBFbGVtZW50RmluZGVyXzEgPSByZXF1aXJlKFwiLi9FbGVtZW50RmluZGVyXCIpO1xudmFyIGlzb2xhdGVfMSA9IHJlcXVpcmUoXCIuL2lzb2xhdGVcIik7XG52YXIgTWFpbkRPTVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWluRE9NU291cmNlKF9yb290RWxlbWVudCQsIF9zYW5pdGF0aW9uJCwgX25hbWVzcGFjZSwgX2lzb2xhdGVNb2R1bGUsIF9ldmVudERlbGVnYXRvciwgX25hbWUpIHtcbiAgICAgICAgaWYgKF9uYW1lc3BhY2UgPT09IHZvaWQgMCkgeyBfbmFtZXNwYWNlID0gW107IH1cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQkID0gX3Jvb3RFbGVtZW50JDtcbiAgICAgICAgdGhpcy5fc2FuaXRhdGlvbiQgPSBfc2FuaXRhdGlvbiQ7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IF9uYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuX2lzb2xhdGVNb2R1bGUgPSBfaXNvbGF0ZU1vZHVsZTtcbiAgICAgICAgdGhpcy5fZXZlbnREZWxlZ2F0b3IgPSBfZXZlbnREZWxlZ2F0b3I7XG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICAgICAgdGhpcy5pc29sYXRlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFpbkRPTVNvdXJjZShzb3VyY2UuX3Jvb3RFbGVtZW50JCwgc291cmNlLl9zYW5pdGF0aW9uJCwgc291cmNlLl9uYW1lc3BhY2UuY29uY2F0KGlzb2xhdGVfMS5nZXRTY29wZU9iaihzY29wZSkpLCBzb3VyY2UuX2lzb2xhdGVNb2R1bGUsIHNvdXJjZS5fZXZlbnREZWxlZ2F0b3IsIHNvdXJjZS5fbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNvbGF0ZVNpbmsgPSBpc29sYXRlXzEubWFrZUlzb2xhdGVTaW5rKHRoaXMuX25hbWVzcGFjZSk7XG4gICAgfVxuICAgIE1haW5ET01Tb3VyY2UucHJvdG90eXBlLl9lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudCQubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBbeF07IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRGaW5kZXJfMSA9IG5ldyBFbGVtZW50RmluZGVyXzEuRWxlbWVudEZpbmRlcih0aGlzLl9uYW1lc3BhY2UsIHRoaXMuX2lzb2xhdGVNb2R1bGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50JC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudEZpbmRlcl8xLmNhbGwoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1haW5ET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gYWRhcHRfMS5hZGFwdCh0aGlzLl9lbGVtZW50cygpLnJlbWVtYmVyKCkpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IGFkYXB0XzEuYWRhcHQodGhpcy5fZWxlbWVudHMoKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIubGVuZ3RoID4gMDsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyWzBdOyB9KVxuICAgICAgICAgICAgLnJlbWVtYmVyKCkpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1haW5ET01Tb3VyY2UucHJvdG90eXBlLCBcIm5hbWVzcGFjZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVzcGFjZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJET00gZHJpdmVyJ3Mgc2VsZWN0KCkgZXhwZWN0cyB0aGUgYXJndW1lbnQgdG8gYmUgYSBcIiArXG4gICAgICAgICAgICAgICAgXCJzdHJpbmcgYXMgYSBDU1Mgc2VsZWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50RE9NU291cmNlXzEuRG9jdW1lbnRET01Tb3VyY2UodGhpcy5fbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9keURPTVNvdXJjZV8xLkJvZHlET01Tb3VyY2UodGhpcy5fbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHNlbGVjdG9yID09PSAnOnJvb3QnXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IHRoaXMuX25hbWVzcGFjZS5jb25jYXQoeyB0eXBlOiAnc2VsZWN0b3InLCBzY29wZTogc2VsZWN0b3IudHJpbSgpIH0pO1xuICAgICAgICByZXR1cm4gbmV3IE1haW5ET01Tb3VyY2UodGhpcy5fcm9vdEVsZW1lbnQkLCB0aGlzLl9zYW5pdGF0aW9uJCwgbmFtZXNwYWNlLCB0aGlzLl9pc29sYXRlTW9kdWxlLCB0aGlzLl9ldmVudERlbGVnYXRvciwgdGhpcy5fbmFtZSk7XG4gICAgfTtcbiAgICBNYWluRE9NU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zLCBidWJibGVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJET00gZHJpdmVyJ3MgZXZlbnRzKCkgZXhwZWN0cyBhcmd1bWVudCB0byBiZSBhIFwiICtcbiAgICAgICAgICAgICAgICBcInN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50JCA9IHRoaXMuX2V2ZW50RGVsZWdhdG9yLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB0aGlzLl9uYW1lc3BhY2UsIG9wdGlvbnMsIGJ1YmJsZXMpO1xuICAgICAgICB2YXIgb3V0ID0gYWRhcHRfMS5hZGFwdChldmVudCQpO1xuICAgICAgICBvdXQuX2lzQ3ljbGVTb3VyY2UgPSB0aGlzLl9uYW1lO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTWFpbkRPTVNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2FuaXRhdGlvbiQuc2hhbWVmdWxseVNlbmROZXh0KG51bGwpO1xuICAgICAgICAvL3RoaXMuX2lzb2xhdGVNb2R1bGUucmVzZXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBNYWluRE9NU291cmNlO1xufSgpKTtcbmV4cG9ydHMuTWFpbkRPTVNvdXJjZSA9IE1haW5ET01Tb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYWluRE9NU291cmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFByaW9yaXR5UXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5hcnIgPSBbXTtcbiAgICAgICAgdGhpcy5wcmlvcyA9IFtdO1xuICAgIH1cbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCwgcHJpbykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmlvc1tpXSA8IHByaW8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyci5zcGxpY2UoaSwgMCwgdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcy5zcGxpY2UoaSwgMCwgcHJpbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJyLnB1c2godCk7XG4gICAgICAgIHRoaXMucHJpb3MucHVzaChwcmlvKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmKHRoaXMuYXJyW2ldLCBpLCB0aGlzLmFycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFycltpXSA9PT0gdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW9zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0eVF1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlbW92YWxTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVtb3ZhbFNldCgpIHtcbiAgICAgICAgdGhpcy50b0RlbGV0ZSA9IFtdO1xuICAgICAgICB0aGlzLnRvRGVsZXRlU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3NldCA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgUmVtb3ZhbFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc2V0LmFkZCh0KTtcbiAgICB9O1xuICAgIFJlbW92YWxTZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB0aGlzLl9zZXQuZm9yRWFjaChmKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH07XG4gICAgUmVtb3ZhbFNldC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMudG9EZWxldGUubGVuZ3RoID09PSB0aGlzLnRvRGVsZXRlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy50b0RlbGV0ZS5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b0RlbGV0ZVt0aGlzLnRvRGVsZXRlU2l6ZV0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9EZWxldGVTaXplKys7XG4gICAgfTtcbiAgICBSZW1vdmFsU2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvRGVsZXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IHRoaXMudG9EZWxldGVTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0LmRlbGV0ZSh0aGlzLnRvRGVsZXRlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG9EZWxldGVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b0RlbGV0ZVNpemUgPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW92YWxTZXQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVtb3ZhbFNldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbW92YWxTZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIFNjb3BlQ2hlY2tlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY29wZUNoZWNrZXIobmFtZXNwYWNlLCBpc29sYXRlTW9kdWxlKSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLmlzb2xhdGVNb2R1bGUgPSBpc29sYXRlTW9kdWxlO1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBuYW1lc3BhY2UuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnR5cGUgIT09ICdzZWxlY3Rvcic7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBpcyAqZGlyZWN0bHkqIGluIHRoZSBzY29wZSBvZiB0aGlzXG4gICAgICogc2NvcGUgY2hlY2tlci4gQmVpbmcgY29udGFpbmVkICppbmRpcmVjdGx5KiB0aHJvdWdoIG90aGVyIHNjb3Blc1xuICAgICAqIGlzIG5vdCB2YWxpZC4gVGhpcyBpcyBjcnVjaWFsIGZvciBpbXBsZW1lbnRpbmcgcGFyZW50LWNoaWxkIGlzb2xhdGlvbixcbiAgICAgKiBzbyB0aGF0IHRoZSBwYXJlbnQgc2VsZWN0b3JzIGRvbid0IHNlYXJjaCBpbnNpZGUgYSBjaGlsZCBzY29wZS5cbiAgICAgKi9cbiAgICBTY29wZUNoZWNrZXIucHJvdG90eXBlLmlzRGlyZWN0bHlJblNjb3BlID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMuaXNvbGF0ZU1vZHVsZS5nZXROYW1lc3BhY2UobGVhZik7XG4gICAgICAgIGlmICghbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZS5sZW5ndGggPiBuYW1lc3BhY2UubGVuZ3RoIHx8XG4gICAgICAgICAgICAhdXRpbHNfMS5pc0VxdWFsTmFtZXNwYWNlKHRoaXMuX25hbWVzcGFjZSwgbmFtZXNwYWNlLnNsaWNlKDAsIHRoaXMuX25hbWVzcGFjZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9uYW1lc3BhY2UubGVuZ3RoOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlW2ldLnR5cGUgPT09ICd0b3RhbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gU2NvcGVDaGVja2VyO1xufSgpKTtcbmV4cG9ydHMuU2NvcGVDaGVja2VyID0gU2NvcGVDaGVja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NvcGVDaGVja2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN5bWJvbFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3ltYm9sVHJlZShtYXBwZXIpIHtcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBtYXBwZXI7XG4gICAgICAgIHRoaXMudHJlZSA9IFt1bmRlZmluZWQsIHt9XTtcbiAgICB9XG4gICAgU3ltYm9sVHJlZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhdGgsIGVsZW1lbnQsIG1heCkge1xuICAgICAgICB2YXIgY3VyciA9IHRoaXMudHJlZTtcbiAgICAgICAgdmFyIF9tYXggPSBtYXggIT09IHVuZGVmaW5lZCA/IG1heCA6IHBhdGgubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9tYXg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm1hcHBlcihwYXRoW2ldKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGN1cnJbMV1bbl07XG4gICAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBbdW5kZWZpbmVkLCB7fV07XG4gICAgICAgICAgICAgICAgY3VyclsxXVtuXSA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyciA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJbMF0gPSBlbGVtZW50O1xuICAgIH07XG4gICAgU3ltYm9sVHJlZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uIChwYXRoLCBta0RlZmF1bHRFbGVtZW50LCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHBhdGgsIG1rRGVmYXVsdEVsZW1lbnQsIG1heCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXlsb2FkIG9mIHRoZSBwYXRoXG4gICAgICogSWYgYSBkZWZhdWx0IGVsZW1lbnQgY3JlYXRvciBpcyBnaXZlbiwgaXQgd2lsbCBpbnNlcnQgaXQgYXQgdGhlIHBhdGhcbiAgICAgKi9cbiAgICBTeW1ib2xUcmVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCwgbWtEZWZhdWx0RWxlbWVudCwgbWF4KSB7XG4gICAgICAgIHZhciBjdXJyID0gdGhpcy50cmVlO1xuICAgICAgICB2YXIgX21heCA9IG1heCAhPT0gdW5kZWZpbmVkID8gbWF4IDogcGF0aC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX21heDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMubWFwcGVyKHBhdGhbaV0pO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY3VyclsxXVtuXTtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWtEZWZhdWx0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IFt1bmRlZmluZWQsIHt9XTtcbiAgICAgICAgICAgICAgICAgICAgY3VyclsxXVtuXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1rRGVmYXVsdEVsZW1lbnQgJiYgIWN1cnJbMF0pIHtcbiAgICAgICAgICAgIGN1cnJbMF0gPSBta0RlZmF1bHRFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJbMF07XG4gICAgfTtcbiAgICBTeW1ib2xUcmVlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgY3VyciA9IHRoaXMudHJlZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY3VyclsxXVt0aGlzLm1hcHBlcihwYXRoW2ldKV07XG4gICAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyciA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjdXJyWzFdW3RoaXMubWFwcGVyKHBhdGhbcGF0aC5sZW5ndGggLSAxXSldO1xuICAgIH07XG4gICAgcmV0dXJuIFN5bWJvbFRyZWU7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3ltYm9sVHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5bWJvbFRyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdm5vZGVfMSA9IHJlcXVpcmUoXCJzbmFiYmRvbS92bm9kZVwiKTtcbnZhciBoXzEgPSByZXF1aXJlKFwic25hYmJkb20vaFwiKTtcbnZhciBzbmFiYmRvbV9zZWxlY3Rvcl8xID0gcmVxdWlyZShcInNuYWJiZG9tLXNlbGVjdG9yXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBWTm9kZVdyYXBwZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVk5vZGVXcmFwcGVyKHJvb3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcbiAgICB9XG4gICAgVk5vZGVXcmFwcGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICAgIGlmICh1dGlsc18xLmlzRG9jRnJhZyh0aGlzLnJvb3RFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcERvY0ZyYWcodm5vZGUgPT09IG51bGwgPyBbXSA6IFt2bm9kZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gc25hYmJkb21fc2VsZWN0b3JfMS5zZWxlY3RvclBhcnNlcih2bm9kZSksIHNlbFRhZ05hbWUgPSBfYS50YWdOYW1lLCBzZWxJZCA9IF9hLmlkO1xuICAgICAgICB2YXIgdk5vZGVDbGFzc05hbWUgPSBzbmFiYmRvbV9zZWxlY3Rvcl8xLmNsYXNzTmFtZUZyb21WTm9kZSh2bm9kZSk7XG4gICAgICAgIHZhciB2Tm9kZURhdGEgPSB2bm9kZS5kYXRhIHx8IHt9O1xuICAgICAgICB2YXIgdk5vZGVEYXRhUHJvcHMgPSB2Tm9kZURhdGEucHJvcHMgfHwge307XG4gICAgICAgIHZhciBfYiA9IHZOb2RlRGF0YVByb3BzLmlkLCB2Tm9kZUlkID0gX2IgPT09IHZvaWQgMCA/IHNlbElkIDogX2I7XG4gICAgICAgIHZhciBpc1ZOb2RlQW5kUm9vdEVsZW1lbnRJZGVudGljYWwgPSB0eXBlb2Ygdk5vZGVJZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHZOb2RlSWQudG9VcHBlckNhc2UoKSA9PT0gdGhpcy5yb290RWxlbWVudC5pZC50b1VwcGVyQ2FzZSgpICYmXG4gICAgICAgICAgICBzZWxUYWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHRoaXMucm9vdEVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpICYmXG4gICAgICAgICAgICB2Tm9kZUNsYXNzTmFtZS50b1VwcGVyQ2FzZSgpID09PSB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoaXNWTm9kZUFuZFJvb3RFbGVtZW50SWRlbnRpY2FsKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChbdm5vZGVdKTtcbiAgICB9O1xuICAgIFZOb2RlV3JhcHBlci5wcm90b3R5cGUud3JhcERvY0ZyYWcgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXzEudm5vZGUoJycsIHsgaXNvbGF0ZTogW10gfSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgdGhpc1xuICAgICAgICAgICAgLnJvb3RFbGVtZW50KTtcbiAgICB9O1xuICAgIFZOb2RlV3JhcHBlci5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnJvb3RFbGVtZW50LCB0YWdOYW1lID0gX2EudGFnTmFtZSwgaWQgPSBfYS5pZCwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgICAgICB2YXIgc2VsSWQgPSBpZCA/IFwiI1wiICsgaWQgOiAnJztcbiAgICAgICAgdmFyIHNlbENsYXNzID0gY2xhc3NOYW1lID8gXCIuXCIgKyBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLmpvaW4oXCIuXCIpIDogJyc7XG4gICAgICAgIHZhciB2bm9kZSA9IGhfMS5oKFwiXCIgKyB0YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyBzZWxJZCArIHNlbENsYXNzLCB7fSwgY2hpbGRyZW4pO1xuICAgICAgICB2bm9kZS5kYXRhID0gdm5vZGUuZGF0YSB8fCB7fTtcbiAgICAgICAgdm5vZGUuZGF0YS5pc29sYXRlID0gdm5vZGUuZGF0YS5pc29sYXRlIHx8IFtdO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfTtcbiAgICByZXR1cm4gVk5vZGVXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuVk5vZGVXcmFwcGVyID0gVk5vZGVXcmFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vk5vZGVXcmFwcGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoXCJ4c3RyZWFtXCIpO1xuZnVuY3Rpb24gZnJvbUV2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSwgdXNlQ2FwdHVyZSwgcHJldmVudERlZmF1bHQsIHBhc3NpdmUpIHtcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdm9pZCAwKSB7IHVzZUNhcHR1cmUgPSBmYWxzZTsgfVxuICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PT0gdm9pZCAwKSB7IHByZXZlbnREZWZhdWx0ID0gZmFsc2U7IH1cbiAgICBpZiAocGFzc2l2ZSA9PT0gdm9pZCAwKSB7IHBhc3NpdmUgPSBmYWxzZTsgfVxuICAgIHZhciBuZXh0ID0gbnVsbDtcbiAgICByZXR1cm4geHN0cmVhbV8xLlN0cmVhbS5jcmVhdGUoe1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBfbmV4dChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdENvbmRpdGlvbmFsKGV2ZW50LCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLm5leHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gX25leHQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubmV4dChldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG5leHQsIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiB1c2VDYXB0dXJlLFxuICAgICAgICAgICAgICAgIHBhc3NpdmU6IHBhc3NpdmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG5leHQsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmZyb21FdmVudCA9IGZyb21FdmVudDtcbmZ1bmN0aW9uIG1hdGNoT2JqZWN0KG1hdGNoZXIsIG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobWF0Y2hlcik7XG4gICAgdmFyIG4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlcltrXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9ialtrXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2hPYmplY3QobWF0Y2hlcltrXSwgb2JqW2tdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaGVyW2tdICE9PSBvYmpba10pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0Q29uZGl0aW9uYWwoZXZlbnQsIHByZXZlbnREZWZhdWx0KSB7XG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJldmVudERlZmF1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByZWRpY2F0ZShwcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwcmV2ZW50RGVmYXVsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaE9iamVjdChwcmV2ZW50RGVmYXVsdCwgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJldmVudERlZmF1bHQgaGFzIHRvIGJlIGVpdGhlciBhIGJvb2xlYW4sIHByZWRpY2F0ZSBmdW5jdGlvbiBvciBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMucHJldmVudERlZmF1bHRDb25kaXRpb25hbCA9IHByZXZlbnREZWZhdWx0Q29uZGl0aW9uYWw7XG5mdW5jdGlvbiBpc1ByZWRpY2F0ZShmbikge1xuICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtZmlsZS1saW5lLWNvdW50XG52YXIgaF8xID0gcmVxdWlyZShcInNuYWJiZG9tL2hcIik7XG5mdW5jdGlvbiBpc1ZhbGlkU3RyaW5nKHBhcmFtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgJiYgcGFyYW0ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0b3IocGFyYW0pIHtcbiAgICByZXR1cm4gaXNWYWxpZFN0cmluZyhwYXJhbSkgJiYgKHBhcmFtWzBdID09PSAnLicgfHwgcGFyYW1bMF0gPT09ICcjJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWdGdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh5cGVyc2NyaXB0KGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIGhhc0EgPSB0eXBlb2YgYSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIHZhciBoYXNCID0gdHlwZW9mIGIgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB2YXIgaGFzQyA9IHR5cGVvZiBjICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKGlzU2VsZWN0b3IoYSkpIHtcbiAgICAgICAgICAgIGlmIChoYXNCICYmIGhhc0MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaF8xLmgodGFnTmFtZSArIGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQikge1xuICAgICAgICAgICAgICAgIHJldHVybiBoXzEuaCh0YWdOYW1lICsgYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaF8xLmgodGFnTmFtZSArIGEsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNDKSB7XG4gICAgICAgICAgICByZXR1cm4gaF8xLmgodGFnTmFtZSArIGEsIGIsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc0IpIHtcbiAgICAgICAgICAgIHJldHVybiBoXzEuaCh0YWdOYW1lLCBhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNBKSB7XG4gICAgICAgICAgICByZXR1cm4gaF8xLmgodGFnTmFtZSwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaF8xLmgodGFnTmFtZSwge30pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBTVkdfVEFHX05BTUVTID0gW1xuICAgICdhJyxcbiAgICAnYWx0R2x5cGgnLFxuICAgICdhbHRHbHlwaERlZicsXG4gICAgJ2FsdEdseXBoSXRlbScsXG4gICAgJ2FuaW1hdGUnLFxuICAgICdhbmltYXRlQ29sb3InLFxuICAgICdhbmltYXRlTW90aW9uJyxcbiAgICAnYW5pbWF0ZVRyYW5zZm9ybScsXG4gICAgJ2NpcmNsZScsXG4gICAgJ2NsaXBQYXRoJyxcbiAgICAnY29sb3JQcm9maWxlJyxcbiAgICAnY3Vyc29yJyxcbiAgICAnZGVmcycsXG4gICAgJ2Rlc2MnLFxuICAgICdlbGxpcHNlJyxcbiAgICAnZmVCbGVuZCcsXG4gICAgJ2ZlQ29sb3JNYXRyaXgnLFxuICAgICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcbiAgICAnZmVDb21wb3NpdGUnLFxuICAgICdmZUNvbnZvbHZlTWF0cml4JyxcbiAgICAnZmVEaWZmdXNlTGlnaHRpbmcnLFxuICAgICdmZURpc3BsYWNlbWVudE1hcCcsXG4gICAgJ2ZlRGlzdGFudExpZ2h0JyxcbiAgICAnZmVGbG9vZCcsXG4gICAgJ2ZlRnVuY0EnLFxuICAgICdmZUZ1bmNCJyxcbiAgICAnZmVGdW5jRycsXG4gICAgJ2ZlRnVuY1InLFxuICAgICdmZUdhdXNzaWFuQmx1cicsXG4gICAgJ2ZlSW1hZ2UnLFxuICAgICdmZU1lcmdlJyxcbiAgICAnZmVNZXJnZU5vZGUnLFxuICAgICdmZU1vcnBob2xvZ3knLFxuICAgICdmZU9mZnNldCcsXG4gICAgJ2ZlUG9pbnRMaWdodCcsXG4gICAgJ2ZlU3BlY3VsYXJMaWdodGluZycsXG4gICAgJ2ZlU3BvdGxpZ2h0JyxcbiAgICAnZmVUaWxlJyxcbiAgICAnZmVUdXJidWxlbmNlJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnZm9udCcsXG4gICAgJ2ZvbnRGYWNlJyxcbiAgICAnZm9udEZhY2VGb3JtYXQnLFxuICAgICdmb250RmFjZU5hbWUnLFxuICAgICdmb250RmFjZVNyYycsXG4gICAgJ2ZvbnRGYWNlVXJpJyxcbiAgICAnZm9yZWlnbk9iamVjdCcsXG4gICAgJ2cnLFxuICAgICdnbHlwaCcsXG4gICAgJ2dseXBoUmVmJyxcbiAgICAnaGtlcm4nLFxuICAgICdpbWFnZScsXG4gICAgJ2xpbmUnLFxuICAgICdsaW5lYXJHcmFkaWVudCcsXG4gICAgJ21hcmtlcicsXG4gICAgJ21hc2snLFxuICAgICdtZXRhZGF0YScsXG4gICAgJ21pc3NpbmdHbHlwaCcsXG4gICAgJ21wYXRoJyxcbiAgICAncGF0aCcsXG4gICAgJ3BhdHRlcm4nLFxuICAgICdwb2x5Z29uJyxcbiAgICAncG9seWxpbmUnLFxuICAgICdyYWRpYWxHcmFkaWVudCcsXG4gICAgJ3JlY3QnLFxuICAgICdzY3JpcHQnLFxuICAgICdzZXQnLFxuICAgICdzdG9wJyxcbiAgICAnc3R5bGUnLFxuICAgICdzd2l0Y2gnLFxuICAgICdzeW1ib2wnLFxuICAgICd0ZXh0JyxcbiAgICAndGV4dFBhdGgnLFxuICAgICd0aXRsZScsXG4gICAgJ3RyZWYnLFxuICAgICd0c3BhbicsXG4gICAgJ3VzZScsXG4gICAgJ3ZpZXcnLFxuICAgICd2a2VybicsXG5dO1xudmFyIHN2ZyA9IGNyZWF0ZVRhZ0Z1bmN0aW9uKCdzdmcnKTtcblNWR19UQUdfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgc3ZnW3RhZ10gPSBjcmVhdGVUYWdGdW5jdGlvbih0YWcpO1xufSk7XG52YXIgVEFHX05BTUVTID0gW1xuICAgICdhJyxcbiAgICAnYWJicicsXG4gICAgJ2FkZHJlc3MnLFxuICAgICdhcmVhJyxcbiAgICAnYXJ0aWNsZScsXG4gICAgJ2FzaWRlJyxcbiAgICAnYXVkaW8nLFxuICAgICdiJyxcbiAgICAnYmFzZScsXG4gICAgJ2JkaScsXG4gICAgJ2JkbycsXG4gICAgJ2Jsb2NrcXVvdGUnLFxuICAgICdib2R5JyxcbiAgICAnYnInLFxuICAgICdidXR0b24nLFxuICAgICdjYW52YXMnLFxuICAgICdjYXB0aW9uJyxcbiAgICAnY2l0ZScsXG4gICAgJ2NvZGUnLFxuICAgICdjb2wnLFxuICAgICdjb2xncm91cCcsXG4gICAgJ2RkJyxcbiAgICAnZGVsJyxcbiAgICAnZGV0YWlscycsXG4gICAgJ2RmbicsXG4gICAgJ2RpcicsXG4gICAgJ2RpdicsXG4gICAgJ2RsJyxcbiAgICAnZHQnLFxuICAgICdlbScsXG4gICAgJ2VtYmVkJyxcbiAgICAnZmllbGRzZXQnLFxuICAgICdmaWdjYXB0aW9uJyxcbiAgICAnZmlndXJlJyxcbiAgICAnZm9vdGVyJyxcbiAgICAnZm9ybScsXG4gICAgJ2gxJyxcbiAgICAnaDInLFxuICAgICdoMycsXG4gICAgJ2g0JyxcbiAgICAnaDUnLFxuICAgICdoNicsXG4gICAgJ2hlYWQnLFxuICAgICdoZWFkZXInLFxuICAgICdoZ3JvdXAnLFxuICAgICdocicsXG4gICAgJ2h0bWwnLFxuICAgICdpJyxcbiAgICAnaWZyYW1lJyxcbiAgICAnaW1nJyxcbiAgICAnaW5wdXQnLFxuICAgICdpbnMnLFxuICAgICdrYmQnLFxuICAgICdrZXlnZW4nLFxuICAgICdsYWJlbCcsXG4gICAgJ2xlZ2VuZCcsXG4gICAgJ2xpJyxcbiAgICAnbGluaycsXG4gICAgJ21haW4nLFxuICAgICdtYXAnLFxuICAgICdtYXJrJyxcbiAgICAnbWVudScsXG4gICAgJ21ldGEnLFxuICAgICduYXYnLFxuICAgICdub3NjcmlwdCcsXG4gICAgJ29iamVjdCcsXG4gICAgJ29sJyxcbiAgICAnb3B0Z3JvdXAnLFxuICAgICdvcHRpb24nLFxuICAgICdwJyxcbiAgICAncGFyYW0nLFxuICAgICdwcmUnLFxuICAgICdwcm9ncmVzcycsXG4gICAgJ3EnLFxuICAgICdycCcsXG4gICAgJ3J0JyxcbiAgICAncnVieScsXG4gICAgJ3MnLFxuICAgICdzYW1wJyxcbiAgICAnc2NyaXB0JyxcbiAgICAnc2VjdGlvbicsXG4gICAgJ3NlbGVjdCcsXG4gICAgJ3NtYWxsJyxcbiAgICAnc291cmNlJyxcbiAgICAnc3BhbicsXG4gICAgJ3N0cm9uZycsXG4gICAgJ3N0eWxlJyxcbiAgICAnc3ViJyxcbiAgICAnc3VtbWFyeScsXG4gICAgJ3N1cCcsXG4gICAgJ3RhYmxlJyxcbiAgICAndGJvZHknLFxuICAgICd0ZCcsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAndGZvb3QnLFxuICAgICd0aCcsXG4gICAgJ3RoZWFkJyxcbiAgICAndGltZScsXG4gICAgJ3RpdGxlJyxcbiAgICAndHInLFxuICAgICd1JyxcbiAgICAndWwnLFxuICAgICd2aWRlbycsXG5dO1xudmFyIGV4cG9ydGVkID0ge1xuICAgIFNWR19UQUdfTkFNRVM6IFNWR19UQUdfTkFNRVMsXG4gICAgVEFHX05BTUVTOiBUQUdfTkFNRVMsXG4gICAgc3ZnOiBzdmcsXG4gICAgaXNTZWxlY3RvcjogaXNTZWxlY3RvcixcbiAgICBjcmVhdGVUYWdGdW5jdGlvbjogY3JlYXRlVGFnRnVuY3Rpb24sXG59O1xuVEFHX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICBleHBvcnRlZFtuXSA9IGNyZWF0ZVRhZ0Z1bmN0aW9uKG4pO1xufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh5cGVyc2NyaXB0LWhlbHBlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGh1bmtfMSA9IHJlcXVpcmUoXCIuL3RodW5rXCIpO1xuZXhwb3J0cy50aHVuayA9IHRodW5rXzEudGh1bms7XG52YXIgTWFpbkRPTVNvdXJjZV8xID0gcmVxdWlyZShcIi4vTWFpbkRPTVNvdXJjZVwiKTtcbmV4cG9ydHMuTWFpbkRPTVNvdXJjZSA9IE1haW5ET01Tb3VyY2VfMS5NYWluRE9NU291cmNlO1xuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIHRoZSBET00gZHJpdmVyIGZ1bmN0aW9uLlxuICpcbiAqIFRha2VzIGEgYGNvbnRhaW5lcmAgdG8gZGVmaW5lIHRoZSB0YXJnZXQgb24gdGhlIGV4aXN0aW5nIERPTSB3aGljaCB0aGlzXG4gKiBkcml2ZXIgd2lsbCBvcGVyYXRlIG9uLCBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBUaGVcbiAqIGlucHV0IHRvIHRoaXMgZHJpdmVyIGlzIGEgc3RyZWFtIG9mIHZpcnR1YWwgRE9NIG9iamVjdHMsIG9yIGluIG90aGVyIHdvcmRzLFxuICogU25hYmJkb20gXCJWTm9kZVwiIG9iamVjdHMuIFRoZSBvdXRwdXQgb2YgdGhpcyBkcml2ZXIgaXMgYSBcIkRPTVNvdXJjZVwiOiBhXG4gKiBjb2xsZWN0aW9uIG9mIE9ic2VydmFibGVzIHF1ZXJpZWQgd2l0aCB0aGUgbWV0aG9kcyBgc2VsZWN0KClgIGFuZCBgZXZlbnRzKClgLlxuICpcbiAqICoqYERPTVNvdXJjZS5zZWxlY3Qoc2VsZWN0b3IpYCoqIHJldHVybnMgYSBuZXcgRE9NU291cmNlIHdpdGggc2NvcGVcbiAqIHJlc3RyaWN0ZWQgdG8gdGhlIGVsZW1lbnQocykgdGhhdCBtYXRjaGVzIHRoZSBDU1MgYHNlbGVjdG9yYCBnaXZlbi4gVG8gc2VsZWN0XG4gKiB0aGUgcGFnZSdzIGBkb2N1bWVudGAsIHVzZSBgLnNlbGVjdCgnZG9jdW1lbnQnKWAuIFRvIHNlbGVjdCB0aGUgY29udGFpbmVyXG4gKiBlbGVtZW50IGZvciB0aGlzIGFwcCwgdXNlIGAuc2VsZWN0KCc6cm9vdCcpYC5cbiAqXG4gKiAqKmBET01Tb3VyY2UuZXZlbnRzKGV2ZW50VHlwZSwgb3B0aW9ucylgKiogcmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgb2ZcbiAqIGBldmVudFR5cGVgIGhhcHBlbmluZyBvbiB0aGUgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgY3VycmVudCBET01Tb3VyY2UuIFRoZVxuICogZXZlbnQgb2JqZWN0IGNvbnRhaW5zIHRoZSBgb3duZXJUYXJnZXRgIHByb3BlcnR5IHRoYXQgYmVoYXZlcyBleGFjdGx5IGxpa2VcbiAqIGBjdXJyZW50VGFyZ2V0YC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHNvbWUgYnJvd3NlcnMgZG9lc24ndCBhbGxvd1xuICogYGN1cnJlbnRUYXJnZXRgIHByb3BlcnR5IHRvIGJlIG11dGF0ZWQsIGhlbmNlIGEgbmV3IHByb3BlcnR5IGlzIGNyZWF0ZWQuIFRoZVxuICogcmV0dXJuZWQgc3RyZWFtIGlzIGFuICp4c3RyZWFtKiBTdHJlYW0gaWYgeW91IHVzZSBgQGN5Y2xlL3hzdHJlYW0tcnVuYCB0byBydW5cbiAqIHlvdXIgYXBwIHdpdGggdGhpcyBkcml2ZXIsIG9yIGl0IGlzIGFuIFJ4SlMgT2JzZXJ2YWJsZSBpZiB5b3UgdXNlXG4gKiBgQGN5Y2xlL3J4anMtcnVuYCwgYW5kIHNvIGZvcnRoLlxuICpcbiAqICoqb3B0aW9ucyBmb3IgRE9NU291cmNlLmV2ZW50cyoqXG4gKlxuICogVGhlIGBvcHRpb25zYCBwYXJhbWV0ZXIgb24gYERPTVNvdXJjZS5ldmVudHMoZXZlbnRUeXBlLCBvcHRpb25zKWAgaXMgYW5cbiAqIChvcHRpb25hbCkgb2JqZWN0IHdpdGggdHdvIG9wdGlvbmFsIGZpZWxkczogYHVzZUNhcHR1cmVgIGFuZFxuICogYHByZXZlbnREZWZhdWx0YC5cbiAqXG4gKiBgdXNlQ2FwdHVyZWAgaXMgYnkgZGVmYXVsdCBgZmFsc2VgLCBleGNlcHQgaXQgaXMgYHRydWVgIGZvciBldmVudCB0eXBlcyB0aGF0XG4gKiBkbyBub3QgYnViYmxlLiBSZWFkIG1vcmUgaGVyZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcbiAqIGFib3V0IHRoZSBgdXNlQ2FwdHVyZWAgYW5kIGl0cyBwdXJwb3NlLlxuICpcbiAqIGBwcmV2ZW50RGVmYXVsdGAgaXMgYnkgZGVmYXVsdCBgZmFsc2VgLCBhbmQgaW5kaWNhdGVzIHRvIHRoZSBkcml2ZXIgd2hldGhlclxuICogYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIHNob3VsZCBiZSBpbnZva2VkLiBUaGlzIG9wdGlvbiBjYW4gYmUgY29uZmlndXJlZCBpblxuICogdGhyZWUgd2F5czpcbiAqXG4gKiAtIGB7cHJldmVudERlZmF1bHQ6IGJvb2xlYW59YCB0byBpbnZva2UgcHJldmVudERlZmF1bHQgaWYgYHRydWVgLCBhbmQgbm90XG4gKiBpbnZva2Ugb3RoZXJ3aXNlLlxuICogLSBge3ByZXZlbnREZWZhdWx0OiAoZXY6IEV2ZW50KSA9PiBib29sZWFufWAgZm9yIGNvbmRpdGlvbmFsIGludm9jYXRpb24uXG4gKiAtIGB7cHJldmVudERlZmF1bHQ6IE5lc3RlZE9iamVjdH1gIHVzZXMgYW4gb2JqZWN0IHRvIGJlIHJlY3Vyc2l2ZWx5IGNvbXBhcmVkXG4gKiB0byB0aGUgYEV2ZW50YCBvYmplY3QuIGBwcmV2ZW50RGVmYXVsdGAgaXMgaW52b2tlZCB3aGVuIGFsbCBwcm9wZXJ0aWVzIG9uIHRoZVxuICogbmVzdGVkIG9iamVjdCBtYXRjaCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSBldmVudCBvYmplY3QuXG4gKlxuICogSGVyZSBhcmUgc29tZSBleGFtcGxlczpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIGFsd2F5cyBwcmV2ZW50IGRlZmF1bHRcbiAqIERPTVNvdXJjZS5zZWxlY3QoJ2lucHV0JykuZXZlbnRzKCdrZXlkb3duJywge1xuICogICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICogfSlcbiAqXG4gKiAvLyBwcmV2ZW50IGRlZmF1bHQgb25seSB3aGVuIGBFTlRFUmAgaXMgcHJlc3NlZFxuICogRE9NU291cmNlLnNlbGVjdCgnaW5wdXQnKS5ldmVudHMoJ2tleWRvd24nLCB7XG4gKiAgIHByZXZlbnREZWZhdWx0OiBlID0+IGUua2V5Q29kZSA9PT0gMTNcbiAqIH0pXG4gKlxuICogLy8gcHJldmVudCBkZWZ1YWx0IHdoZW4gYEVOVEVSYCBpcyBwcmVzc2VkIEFORCB0YXJnZXQudmFsdWUgaXMgJ0hFTExPJ1xuICogRE9NU291cmNlLnNlbGVjdCgnaW5wdXQnKS5ldmVudHMoJ2tleWRvd24nLCB7XG4gKiAgIHByZXZlbnREZWZhdWx0OiB7IGtleUNvZGU6IDEzLCBvd25lclRhcmdldDogeyB2YWx1ZTogJ0hFTExPJyB9IH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogKipgRE9NU291cmNlLmVsZW1lbnRzKClgKiogcmV0dXJucyBhIHN0cmVhbSBvZiBhcnJheXMgY29udGFpbmluZyB0aGUgRE9NXG4gKiBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBzZWxlY3RvcnMgaW4gdGhlIERPTVNvdXJjZSAoZS5nLiBmcm9tIHByZXZpb3VzXG4gKiBgc2VsZWN0KHgpYCBjYWxscykuXG4gKlxuICogKipgRE9NU291cmNlLmVsZW1lbnQoKWAqKiByZXR1cm5zIGEgc3RyZWFtIG9mIERPTSBlbGVtZW50cy4gTm90aWNlIHRoYXQgdGhpc1xuICogaXMgdGhlIHNpbmd1bGFyIHZlcnNpb24gb2YgYC5lbGVtZW50cygpYCwgc28gdGhlIHN0cmVhbSB3aWxsIGVtaXQgYW4gZWxlbWVudCxcbiAqIG5vdCBhbiBhcnJheS4gSWYgdGhlcmUgaXMgbm8gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdGVkIERPTVNvdXJjZSxcbiAqIHRoZW4gdGhlIHJldHVybmVkIHN0cmVhbSB3aWxsIG5vdCBlbWl0IGFueXRoaW5nLlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xIVE1MRWxlbWVudCl9IGNvbnRhaW5lciB0aGUgRE9NIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudFxuICogKG9yIHRoZSBlbGVtZW50IGl0c2VsZikgdG8gY29udGFpbiB0aGUgcmVuZGVyaW5nIG9mIHRoZSBWVHJlZXMuXG4gKiBAcGFyYW0ge0RPTURyaXZlck9wdGlvbnN9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggdHdvIG9wdGlvbmFsIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBtb2R1bGVzOiBhcnJheWAgb3ZlcnJpZGVzIGBAY3ljbGUvZG9tYCdzIGRlZmF1bHQgU25hYmJkb20gbW9kdWxlcyBhc1xuICogICAgIGFzIGRlZmluZWQgaW4gW2BzcmMvbW9kdWxlcy50c2BdKC4vc3JjL21vZHVsZXMudHMpLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBET00gZHJpdmVyIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gZXhwZWN0cyBhIHN0cmVhbSBvZlxuICogVk5vZGUgYXMgaW5wdXQsIGFuZCBvdXRwdXRzIHRoZSBET01Tb3VyY2Ugb2JqZWN0LlxuICogQGZ1bmN0aW9uIG1ha2VET01Ecml2ZXJcbiAqL1xudmFyIG1ha2VET01Ecml2ZXJfMSA9IHJlcXVpcmUoXCIuL21ha2VET01Ecml2ZXJcIik7XG5leHBvcnRzLm1ha2VET01Ecml2ZXIgPSBtYWtlRE9NRHJpdmVyXzEubWFrZURPTURyaXZlcjtcbi8qKlxuICogQSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBtb2NrZWQgRE9NU291cmNlIG9iamVjdHMsIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICpcbiAqIFRha2VzIGEgYG1vY2tDb25maWdgIG9iamVjdCBhcyBhcmd1bWVudCwgYW5kIHJldHVybnNcbiAqIGEgRE9NU291cmNlIHRoYXQgY2FuIGJlIGdpdmVuIHRvIGFueSBDeWNsZS5qcyBhcHAgdGhhdCBleHBlY3RzIGEgRE9NU291cmNlIGluXG4gKiB0aGUgc291cmNlcywgZm9yIHRlc3RpbmcuXG4gKlxuICogVGhlIGBtb2NrQ29uZmlnYCBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHNwZWNpZnlpbmcgc2VsZWN0b3JzLCBldmVudFR5cGVzIGFuZFxuICogdGhlaXIgc3RyZWFtcy4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZG9tU291cmNlID0gbW9ja0RPTVNvdXJjZSh7XG4gKiAgICcuZm9vJzoge1xuICogICAgICdjbGljayc6IHhzLm9mKHt0YXJnZXQ6IHt9fSksXG4gKiAgICAgJ21vdXNlb3Zlcic6IHhzLm9mKHt0YXJnZXQ6IHt9fSksXG4gKiAgIH0sXG4gKiAgICcuYmFyJzoge1xuICogICAgICdzY3JvbGwnOiB4cy5vZih7dGFyZ2V0OiB7fX0pLFxuICogICAgIGVsZW1lbnRzOiB4cy5vZih7dGFnTmFtZTogJ2Rpdid9KSxcbiAqICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNhZ2VcbiAqIGNvbnN0IGNsaWNrJCA9IGRvbVNvdXJjZS5zZWxlY3QoJy5mb28nKS5ldmVudHMoJ2NsaWNrJyk7XG4gKiBjb25zdCBlbGVtZW50JCA9IGRvbVNvdXJjZS5zZWxlY3QoJy5iYXInKS5lbGVtZW50cygpO1xuICogYGBgXG4gKlxuICogVGhlIG1vY2tlZCBET00gU291cmNlIHN1cHBvcnRzIGlzb2xhdGlvbi4gSXQgaGFzIHRoZSBmdW5jdGlvbnMgYGlzb2xhdGVTaW5rYFxuICogYW5kIGBpc29sYXRlU291cmNlYCBhdHRhY2hlZCB0byBpdCwgYW5kIHBlcmZvcm1zIHNpbXBsZSBpc29sYXRpb24gdXNpbmdcbiAqIGNsYXNzTmFtZXMuICppc29sYXRlU2luayogd2l0aCBzY29wZSBgZm9vYCB3aWxsIGFwcGVuZCB0aGUgY2xhc3MgYF9fX2Zvb2AgdG9cbiAqIHRoZSBzdHJlYW0gb2YgdmlydHVhbCBET00gbm9kZXMsIGFuZCAqaXNvbGF0ZVNvdXJjZSogd2l0aCBzY29wZSBgZm9vYCB3aWxsXG4gKiBwZXJmb3JtIGEgY29udmVudGlvbmFsIGBtb2NrZWRET01Tb3VyY2Uuc2VsZWN0KCcuX19mb28nKWAgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbW9ja0NvbmZpZyBhbiBvYmplY3Qgd2hlcmUga2V5cyBhcmUgc2VsZWN0b3Igc3RyaW5nc1xuICogYW5kIHZhbHVlcyBhcmUgb2JqZWN0cy4gVGhvc2UgbmVzdGVkIG9iamVjdHMgaGF2ZSBgZXZlbnRUeXBlYCBzdHJpbmdzIGFzIGtleXNcbiAqIGFuZCB2YWx1ZXMgYXJlIHN0cmVhbXMgeW91IGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGZha2UgRE9NIHNvdXJjZSBvYmplY3QsIHdpdGggYW4gQVBJIGNvbnRhaW5pbmcgYHNlbGVjdCgpYFxuICogYW5kIGBldmVudHMoKWAgYW5kIGBlbGVtZW50cygpYCB3aGljaCBjYW4gYmUgdXNlZCBqdXN0IGxpa2UgdGhlIERPTSBEcml2ZXInc1xuICogRE9NU291cmNlLlxuICpcbiAqIEBmdW5jdGlvbiBtb2NrRE9NU291cmNlXG4gKi9cbnZhciBtb2NrRE9NU291cmNlXzEgPSByZXF1aXJlKFwiLi9tb2NrRE9NU291cmNlXCIpO1xuZXhwb3J0cy5tb2NrRE9NU291cmNlID0gbW9ja0RPTVNvdXJjZV8xLm1vY2tET01Tb3VyY2U7XG5leHBvcnRzLk1vY2tlZERPTVNvdXJjZSA9IG1vY2tET01Tb3VyY2VfMS5Nb2NrZWRET01Tb3VyY2U7XG4vKipcbiAqIFRoZSBoeXBlcnNjcmlwdCBmdW5jdGlvbiBgaCgpYCBpcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSB2aXJ0dWFsIERPTSBvYmplY3RzLFxuICogYWxzbyBrbm93biBhcyBWTm9kZXMuIENhbGxcbiAqXG4gKiBgYGBqc1xuICogaCgnZGl2Lm15Q2xhc3MnLCB7c3R5bGU6IHtjb2xvcjogJ3JlZCd9fSwgW10pXG4gKiBgYGBcbiAqXG4gKiB0byBjcmVhdGUgYSBWTm9kZSB0aGF0IHJlcHJlc2VudHMgYSBgRElWYCBlbGVtZW50IHdpdGggY2xhc3NOYW1lIGBteUNsYXNzYCxcbiAqIHN0eWxlZCB3aXRoIHJlZCBjb2xvciwgYW5kIG5vIGNoaWxkcmVuIGJlY2F1c2UgdGhlIGBbXWAgYXJyYXkgd2FzIHBhc3NlZC4gVGhlXG4gKiBBUEkgaXMgYGgodGFnT3JTZWxlY3Rvciwgb3B0aW9uYWxEYXRhLCBvcHRpb25hbENoaWxkcmVuT3JUZXh0KWAuXG4gKlxuICogSG93ZXZlciwgdXN1YWxseSB5b3Ugc2hvdWxkIHVzZSBcImh5cGVyc2NyaXB0IGhlbHBlcnNcIiwgd2hpY2ggYXJlIHNob3J0Y3V0XG4gKiBmdW5jdGlvbnMgYmFzZWQgb24gaHlwZXJzY3JpcHQuIFRoZXJlIGlzIG9uZSBoeXBlcnNjcmlwdCBoZWxwZXIgZnVuY3Rpb24gZm9yXG4gKiBlYWNoIERPTSB0YWdOYW1lLCBzdWNoIGFzIGBoMSgpYCwgYGgyKClgLCBgZGl2KClgLCBgc3BhbigpYCwgYGxhYmVsKClgLFxuICogYGlucHV0KClgLiBGb3IgaW5zdGFuY2UsIHRoZSBwcmV2aW91cyBleGFtcGxlIGNvdWxkIGhhdmUgYmVlbiB3cml0dGVuXG4gKiBhczpcbiAqXG4gKiBgYGBqc1xuICogZGl2KCcubXlDbGFzcycsIHtzdHlsZToge2NvbG9yOiAncmVkJ319LCBbXSlcbiAqIGBgYFxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIFNWRyBoZWxwZXIgZnVuY3Rpb25zLCB3aGljaCBhcHBseSB0aGUgYXBwcm9wcmlhdGUgU1ZHXG4gKiBuYW1lc3BhY2UgdG8gdGhlIHJlc3VsdGluZyBlbGVtZW50cy4gYHN2ZygpYCBmdW5jdGlvbiBjcmVhdGVzIHRoZSB0b3AtbW9zdFxuICogU1ZHIGVsZW1lbnQsIGFuZCBgc3ZnLmdgLCBgc3ZnLnBvbHlnb25gLCBgc3ZnLmNpcmNsZWAsIGBzdmcucGF0aGAgYXJlIGZvclxuICogU1ZHLXNwZWNpZmljIGNoaWxkIGVsZW1lbnRzLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBzdmcoe2F0dHJzOiB7d2lkdGg6IDE1MCwgaGVpZ2h0OiAxNTB9fSwgW1xuICogICBzdmcucG9seWdvbih7XG4gKiAgICAgYXR0cnM6IHtcbiAqICAgICAgIGNsYXNzOiAndHJpYW5nbGUnLFxuICogICAgICAgcG9pbnRzOiAnMjAgMCAyMCAxNTAgMTUwIDIwJ1xuICogICAgIH1cbiAqICAgfSlcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb24gaFxuICovXG52YXIgaF8xID0gcmVxdWlyZShcInNuYWJiZG9tL2hcIik7XG5leHBvcnRzLmggPSBoXzEuaDtcbnZhciBoeXBlcnNjcmlwdF9oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oeXBlcnNjcmlwdC1oZWxwZXJzXCIpO1xuZXhwb3J0cy5zdmcgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdmc7XG5leHBvcnRzLmEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hO1xuZXhwb3J0cy5hYmJyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYWJicjtcbmV4cG9ydHMuYWRkcmVzcyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmFkZHJlc3M7XG5leHBvcnRzLmFyZWEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hcmVhO1xuZXhwb3J0cy5hcnRpY2xlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuYXJ0aWNsZTtcbmV4cG9ydHMuYXNpZGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hc2lkZTtcbmV4cG9ydHMuYXVkaW8gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5hdWRpbztcbmV4cG9ydHMuYiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmI7XG5leHBvcnRzLmJhc2UgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iYXNlO1xuZXhwb3J0cy5iZGkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5iZGk7XG5leHBvcnRzLmJkbyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJkbztcbmV4cG9ydHMuYmxvY2txdW90ZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJsb2NrcXVvdGU7XG5leHBvcnRzLmJvZHkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ib2R5O1xuZXhwb3J0cy5iciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmJyO1xuZXhwb3J0cy5idXR0b24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5idXR0b247XG5leHBvcnRzLmNhbnZhcyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNhbnZhcztcbmV4cG9ydHMuY2FwdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNhcHRpb247XG5leHBvcnRzLmNpdGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5jaXRlO1xuZXhwb3J0cy5jb2RlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuY29kZTtcbmV4cG9ydHMuY29sID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuY29sO1xuZXhwb3J0cy5jb2xncm91cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmNvbGdyb3VwO1xuZXhwb3J0cy5kZCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRkO1xuZXhwb3J0cy5kZWwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kZWw7XG5leHBvcnRzLmRmbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmRmbjtcbmV4cG9ydHMuZGlyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGlyO1xuZXhwb3J0cy5kaXYgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5kaXY7XG5leHBvcnRzLmRsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZGw7XG5leHBvcnRzLmR0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZHQ7XG5leHBvcnRzLmVtID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZW07XG5leHBvcnRzLmVtYmVkID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZW1iZWQ7XG5leHBvcnRzLmZpZWxkc2V0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuZmllbGRzZXQ7XG5leHBvcnRzLmZpZ2NhcHRpb24gPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5maWdjYXB0aW9uO1xuZXhwb3J0cy5maWd1cmUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5maWd1cmU7XG5leHBvcnRzLmZvb3RlciA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmZvb3RlcjtcbmV4cG9ydHMuZm9ybSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmZvcm07XG5leHBvcnRzLmgxID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDE7XG5leHBvcnRzLmgyID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDI7XG5leHBvcnRzLmgzID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDM7XG5leHBvcnRzLmg0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDQ7XG5leHBvcnRzLmg1ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDU7XG5leHBvcnRzLmg2ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaDY7XG5leHBvcnRzLmhlYWQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5oZWFkO1xuZXhwb3J0cy5oZWFkZXIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5oZWFkZXI7XG5leHBvcnRzLmhncm91cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmhncm91cDtcbmV4cG9ydHMuaHIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ocjtcbmV4cG9ydHMuaHRtbCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lmh0bWw7XG5leHBvcnRzLmkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pO1xuZXhwb3J0cy5pZnJhbWUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pZnJhbWU7XG5leHBvcnRzLmltZyA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmltZztcbmV4cG9ydHMuaW5wdXQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5pbnB1dDtcbmV4cG9ydHMuaW5zID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuaW5zO1xuZXhwb3J0cy5rYmQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5rYmQ7XG5leHBvcnRzLmtleWdlbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmtleWdlbjtcbmV4cG9ydHMubGFiZWwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5sYWJlbDtcbmV4cG9ydHMubGVnZW5kID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubGVnZW5kO1xuZXhwb3J0cy5saSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LmxpO1xuZXhwb3J0cy5saW5rID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubGluaztcbmV4cG9ydHMubWFpbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1haW47XG5leHBvcnRzLm1hcCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1hcDtcbmV4cG9ydHMubWFyayA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm1hcms7XG5leHBvcnRzLm1lbnUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5tZW51O1xuZXhwb3J0cy5tZXRhID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubWV0YTtcbmV4cG9ydHMubmF2ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQubmF2O1xuZXhwb3J0cy5ub3NjcmlwdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm5vc2NyaXB0O1xuZXhwb3J0cy5vYmplY3QgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5vYmplY3Q7XG5leHBvcnRzLm9sID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQub2w7XG5leHBvcnRzLm9wdGdyb3VwID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQub3B0Z3JvdXA7XG5leHBvcnRzLm9wdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0Lm9wdGlvbjtcbmV4cG9ydHMucCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnA7XG5leHBvcnRzLnBhcmFtID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucGFyYW07XG5leHBvcnRzLnByZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnByZTtcbmV4cG9ydHMucHJvZ3Jlc3MgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5wcm9ncmVzcztcbmV4cG9ydHMucSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnE7XG5leHBvcnRzLnJwID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucnA7XG5leHBvcnRzLnJ0ID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucnQ7XG5leHBvcnRzLnJ1YnkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5ydWJ5O1xuZXhwb3J0cy5zID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQucztcbmV4cG9ydHMuc2FtcCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNhbXA7XG5leHBvcnRzLnNjcmlwdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNjcmlwdDtcbmV4cG9ydHMuc2VjdGlvbiA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNlY3Rpb247XG5leHBvcnRzLnNlbGVjdCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnNlbGVjdDtcbmV4cG9ydHMuc21hbGwgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zbWFsbDtcbmV4cG9ydHMuc291cmNlID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc291cmNlO1xuZXhwb3J0cy5zcGFuID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3BhbjtcbmV4cG9ydHMuc3Ryb25nID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQuc3Ryb25nO1xuZXhwb3J0cy5zdHlsZSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnN0eWxlO1xuZXhwb3J0cy5zdWIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC5zdWI7XG5leHBvcnRzLnN1cCA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnN1cDtcbmV4cG9ydHMudGFibGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50YWJsZTtcbmV4cG9ydHMudGJvZHkgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50Ym9keTtcbmV4cG9ydHMudGQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50ZDtcbmV4cG9ydHMudGV4dGFyZWEgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50ZXh0YXJlYTtcbmV4cG9ydHMudGZvb3QgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50Zm9vdDtcbmV4cG9ydHMudGggPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aDtcbmV4cG9ydHMudGhlYWQgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aGVhZDtcbmV4cG9ydHMudGl0bGUgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50aXRsZTtcbmV4cG9ydHMudHIgPSBoeXBlcnNjcmlwdF9oZWxwZXJzXzEuZGVmYXVsdC50cjtcbmV4cG9ydHMudSA9IGh5cGVyc2NyaXB0X2hlbHBlcnNfMS5kZWZhdWx0LnU7XG5leHBvcnRzLnVsID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudWw7XG5leHBvcnRzLnZpZGVvID0gaHlwZXJzY3JpcHRfaGVscGVyc18xLmRlZmF1bHQudmlkZW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gbWFrZUlzb2xhdGVTaW5rKG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2luaywgc2NvcGUpIHtcbiAgICAgICAgaWYgKHNjb3BlID09PSAnOnJvb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luay5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb3BlT2JqID0gZ2V0U2NvcGVPYmooc2NvcGUpO1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBfX2Fzc2lnbih7fSwgbm9kZSwgeyBkYXRhOiBfX2Fzc2lnbih7fSwgbm9kZS5kYXRhLCB7IGlzb2xhdGU6ICFub2RlLmRhdGEgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5kYXRhLmlzb2xhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5hbWVzcGFjZS5jb25jYXQoW3Njb3BlT2JqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9kZS5kYXRhLmlzb2xhdGUgfSkgfSk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIG5ld05vZGUsIHsga2V5OiBuZXdOb2RlLmtleSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gbmV3Tm9kZS5rZXlcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShuZXdOb2RlLmRhdGEuaXNvbGF0ZSkgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLm1ha2VJc29sYXRlU2luayA9IG1ha2VJc29sYXRlU2luaztcbmZ1bmN0aW9uIGdldFNjb3BlT2JqKHNjb3BlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdXRpbHNfMS5pc0NsYXNzT3JJZChzY29wZSkgPyAnc2libGluZycgOiAndG90YWwnLFxuICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0U2NvcGVPYmogPSBnZXRTY29wZU9iajtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzb2xhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc25hYmJkb21fMSA9IHJlcXVpcmUoXCJzbmFiYmRvbVwiKTtcbnZhciB4c3RyZWFtXzEgPSByZXF1aXJlKFwieHN0cmVhbVwiKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoXCJ4c3RyZWFtL2V4dHJhL2NvbmNhdFwiKTtcbnZhciBzYW1wbGVDb21iaW5lXzEgPSByZXF1aXJlKFwieHN0cmVhbS9leHRyYS9zYW1wbGVDb21iaW5lXCIpO1xudmFyIE1haW5ET01Tb3VyY2VfMSA9IHJlcXVpcmUoXCIuL01haW5ET01Tb3VyY2VcIik7XG52YXIgdG92bm9kZV8xID0gcmVxdWlyZShcInNuYWJiZG9tL3Rvdm5vZGVcIik7XG52YXIgVk5vZGVXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi9WTm9kZVdyYXBwZXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIG1vZHVsZXNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXNcIik7XG52YXIgSXNvbGF0ZU1vZHVsZV8xID0gcmVxdWlyZShcIi4vSXNvbGF0ZU1vZHVsZVwiKTtcbnZhciBFdmVudERlbGVnYXRvcl8xID0gcmVxdWlyZShcIi4vRXZlbnREZWxlZ2F0b3JcIik7XG5mdW5jdGlvbiBtYWtlRE9NRHJpdmVySW5wdXRHdWFyZChtb2R1bGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbmFsIG1vZHVsZXMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXkgZm9yIHNuYWJiZG9tIG1vZHVsZXNcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9tRHJpdmVySW5wdXRHdWFyZCh2aWV3JCkge1xuICAgIGlmICghdmlldyQgfHxcbiAgICAgICAgdHlwZW9mIHZpZXckLmFkZExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgdHlwZW9mIHZpZXckLmZvbGQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRE9NIGRyaXZlciBmdW5jdGlvbiBleHBlY3RzIGFzIGlucHV0IGEgU3RyZWFtIG9mIFwiICtcbiAgICAgICAgICAgIFwidmlydHVhbCBET00gZWxlbWVudHNcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJvcENvbXBsZXRpb24oaW5wdXQpIHtcbiAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQubWVyZ2UoaW5wdXQsIHhzdHJlYW1fMS5kZWZhdWx0Lm5ldmVyKCkpO1xufVxuZnVuY3Rpb24gdW53cmFwRWxlbWVudEZyb21WTm9kZSh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5lbG07XG59XG5mdW5jdGlvbiByZXBvcnRTbmFiYmRvbUVycm9yKGVycikge1xuICAgIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShlcnIpO1xufVxuZnVuY3Rpb24gbWFrZURPTVJlYWR5JCgpIHtcbiAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQuY3JlYXRlKHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChsaXMpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgc3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpcy5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpcy5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgIGxpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRSb290U2NvcGUodm5vZGUpIHtcbiAgICB2bm9kZS5kYXRhID0gdm5vZGUuZGF0YSB8fCB7fTtcbiAgICB2bm9kZS5kYXRhLmlzb2xhdGUgPSBbXTtcbiAgICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBtYWtlRE9NRHJpdmVyKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHV0aWxzXzEuY2hlY2tWYWxpZENvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IG1vZHVsZXNfMS5kZWZhdWx0O1xuICAgIG1ha2VET01Ecml2ZXJJbnB1dEd1YXJkKG1vZHVsZXMpO1xuICAgIHZhciBpc29sYXRlTW9kdWxlID0gbmV3IElzb2xhdGVNb2R1bGVfMS5Jc29sYXRlTW9kdWxlKCk7XG4gICAgdmFyIHBhdGNoID0gc25hYmJkb21fMS5pbml0KFtpc29sYXRlTW9kdWxlLmNyZWF0ZU1vZHVsZSgpXS5jb25jYXQobW9kdWxlcykpO1xuICAgIHZhciBkb21SZWFkeSQgPSBtYWtlRE9NUmVhZHkkKCk7XG4gICAgdmFyIHZub2RlV3JhcHBlcjtcbiAgICB2YXIgbXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgbXV0YXRpb25Db25maXJtZWQkID0geHN0cmVhbV8xLmRlZmF1bHQuY3JlYXRlKHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpc3RlbmVyLm5leHQobnVsbCk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBET01Ecml2ZXIodm5vZGUkLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9ICdET00nOyB9XG4gICAgICAgIGRvbURyaXZlcklucHV0R3VhcmQodm5vZGUkKTtcbiAgICAgICAgdmFyIHNhbml0YXRpb24kID0geHN0cmVhbV8xLmRlZmF1bHQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBmaXJzdFJvb3QkID0gZG9tUmVhZHkkLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RSb290ID0gdXRpbHNfMS5nZXRWYWxpZE5vZGUoY29udGFpbmVyKSB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgdm5vZGVXcmFwcGVyID0gbmV3IFZOb2RlV3JhcHBlcl8xLlZOb2RlV3JhcHBlcihmaXJzdFJvb3QpO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Um9vdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc3Vic2NyaWJlIHRvIHRoZSBzaW5rIChpLmUuIHZub2RlJCkgc3luY2hyb25vdXNseSBpbnNpZGUgdGhpc1xuICAgICAgICAvLyBkcml2ZXIsIGFuZCBub3QgbGF0ZXIgaW4gdGhlIG1hcCgpLmZsYXR0ZW4oKSBiZWNhdXNlIHRoaXMgc2luayBpcyBpblxuICAgICAgICAvLyByZWFsaXR5IGEgU2lua1Byb3h5IGZyb20gQGN5Y2xlL3J1biwgYW5kIHdlIGRvbid0IHdhbnQgdG8gbWlzcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gZW1pc3Npb24gd2hlbiB0aGUgbWFpbigpIGlzIGNvbm5lY3RlZCB0byB0aGUgZHJpdmVycy5cbiAgICAgICAgLy8gUmVhZCBtb3JlIGluIGlzc3VlICM3MzkuXG4gICAgICAgIHZhciByZW1lbWJlcmVkVk5vZGUkID0gdm5vZGUkLnJlbWVtYmVyKCk7XG4gICAgICAgIHJlbWVtYmVyZWRWTm9kZSQuYWRkTGlzdGVuZXIoe30pO1xuICAgICAgICAvLyBUaGUgbXV0YXRpb24gb2JzZXJ2ZXIgaW50ZXJuYWwgdG8gbXV0YXRpb25Db25maXJtZWQkIHNob3VsZFxuICAgICAgICAvLyBleGlzdCBiZWZvcmUgZWxlbWVudEFmdGVyUGF0Y2gkIGNhbGxzIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSgpXG4gICAgICAgIG11dGF0aW9uQ29uZmlybWVkJC5hZGRMaXN0ZW5lcih7fSk7XG4gICAgICAgIHZhciBlbGVtZW50QWZ0ZXJQYXRjaCQgPSBmaXJzdFJvb3QkXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmaXJzdFJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiB4c3RyZWFtXzEuZGVmYXVsdFxuICAgICAgICAgICAgICAgIC5tZXJnZShyZW1lbWJlcmVkVk5vZGUkLmVuZFdoZW4oc2FuaXRhdGlvbiQpLCBzYW5pdGF0aW9uJClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2bm9kZSkgeyByZXR1cm4gdm5vZGVXcmFwcGVyLmNhbGwodm5vZGUpOyB9KVxuICAgICAgICAgICAgICAgIC5zdGFydFdpdGgoYWRkUm9vdFNjb3BlKHRvdm5vZGVfMS50b1ZOb2RlKGZpcnN0Um9vdCkpKVxuICAgICAgICAgICAgICAgIC5mb2xkKHBhdGNoLCB0b3Zub2RlXzEudG9WTm9kZShmaXJzdFJvb3QpKVxuICAgICAgICAgICAgICAgIC5kcm9wKDEpXG4gICAgICAgICAgICAgICAgLm1hcCh1bndyYXBFbGVtZW50RnJvbVZOb2RlKVxuICAgICAgICAgICAgICAgIC5zdGFydFdpdGgoZmlyc3RSb290KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jb21wb3NlKGRyb3BDb21wbGV0aW9uKTtcbiAgICAgICAgfSAvLyBkb24ndCBjb21wbGV0ZSB0aGlzIHN0cmVhbVxuICAgICAgICApXG4gICAgICAgICAgICAuZmxhdHRlbigpO1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnQkID0gY29uY2F0XzEuZGVmYXVsdChkb21SZWFkeSQsIG11dGF0aW9uQ29uZmlybWVkJClcbiAgICAgICAgICAgIC5lbmRXaGVuKHNhbml0YXRpb24kKVxuICAgICAgICAgICAgLmNvbXBvc2Uoc2FtcGxlQ29tYmluZV8xLmRlZmF1bHQoZWxlbWVudEFmdGVyUGF0Y2gkKSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyWzFdOyB9KVxuICAgICAgICAgICAgLnJlbWVtYmVyKCk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBzbmFiYmRvbSBwYXRjaGluZywgb3ZlciB0aW1lXG4gICAgICAgIHJvb3RFbGVtZW50JC5hZGRMaXN0ZW5lcih7IGVycm9yOiByZXBvcnRTbmFiYmRvbUVycm9yIH0pO1xuICAgICAgICB2YXIgZGVsZWdhdG9yID0gbmV3IEV2ZW50RGVsZWdhdG9yXzEuRXZlbnREZWxlZ2F0b3Iocm9vdEVsZW1lbnQkLCBpc29sYXRlTW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYWluRE9NU291cmNlXzEuTWFpbkRPTVNvdXJjZShyb290RWxlbWVudCQsIHNhbml0YXRpb24kLCBbXSwgaXNvbGF0ZU1vZHVsZSwgZGVsZWdhdG9yLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIERPTURyaXZlcjtcbn1cbmV4cG9ydHMubWFrZURPTURyaXZlciA9IG1ha2VET01Ecml2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlRE9NRHJpdmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhzdHJlYW1fMSA9IHJlcXVpcmUoXCJ4c3RyZWFtXCIpO1xudmFyIGFkYXB0XzEgPSByZXF1aXJlKFwiQGN5Y2xlL3J1bi9saWIvYWRhcHRcIik7XG52YXIgU0NPUEVfUFJFRklYID0gJ19fXyc7XG52YXIgTW9ja2VkRE9NU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vY2tlZERPTVNvdXJjZShfbW9ja0NvbmZpZykge1xuICAgICAgICB0aGlzLl9tb2NrQ29uZmlnID0gX21vY2tDb25maWc7XG4gICAgICAgIGlmIChfbW9ja0NvbmZpZy5lbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfbW9ja0NvbmZpZy5lbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID0gYWRhcHRfMS5hZGFwdCh4c3RyZWFtXzEuZGVmYXVsdC5lbXB0eSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gdGhpc1xuICAgICAgICAgICAgLl9lbGVtZW50cztcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gJ01vY2tlZERPTSc7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRwdXQkID0gdGhpcy5lbGVtZW50cygpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5sZW5ndGggPiAwOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnJbMF07IH0pXG4gICAgICAgICAgICAucmVtZW1iZXIoKTtcbiAgICAgICAgdmFyIG91dCA9IGFkYXB0XzEuYWRhcHQob3V0cHV0JCk7XG4gICAgICAgIG91dC5faXNDeWNsZVNvdXJjZSA9ICdNb2NrZWRET00nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTW9ja2VkRE9NU291cmNlLnByb3RvdHlwZS5ldmVudHMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBvcHRpb25zLCBidWJibGVzKSB7XG4gICAgICAgIHZhciBzdHJlYW1Gb3JFdmVudFR5cGUgPSB0aGlzLl9tb2NrQ29uZmlnW2V2ZW50VHlwZV07XG4gICAgICAgIHZhciBvdXQgPSBhZGFwdF8xLmFkYXB0KHN0cmVhbUZvckV2ZW50VHlwZSB8fCB4c3RyZWFtXzEuZGVmYXVsdC5lbXB0eSgpKTtcbiAgICAgICAgb3V0Ll9pc0N5Y2xlU291cmNlID0gJ01vY2tlZERPTSc7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgbW9ja0NvbmZpZ0ZvclNlbGVjdG9yID0gdGhpcy5fbW9ja0NvbmZpZ1tzZWxlY3Rvcl0gfHwge307XG4gICAgICAgIHJldHVybiBuZXcgTW9ja2VkRE9NU291cmNlKG1vY2tDb25maWdGb3JTZWxlY3Rvcik7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmlzb2xhdGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCBzY29wZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnNlbGVjdCgnLicgKyBTQ09QRV9QUkVGSVggKyBzY29wZSk7XG4gICAgfTtcbiAgICBNb2NrZWRET01Tb3VyY2UucHJvdG90eXBlLmlzb2xhdGVTaW5rID0gZnVuY3Rpb24gKHNpbmssIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBhZGFwdF8xLmFkYXB0KHhzdHJlYW1fMS5kZWZhdWx0LmZyb21PYnNlcnZhYmxlKHNpbmspLm1hcChmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5zZWwgJiYgdm5vZGUuc2VsLmluZGV4T2YoU0NPUEVfUFJFRklYICsgc2NvcGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlLnNlbCArPSBcIi5cIiArIFNDT1BFX1BSRUZJWCArIHNjb3BlO1xuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vY2tlZERPTVNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLk1vY2tlZERPTVNvdXJjZSA9IE1vY2tlZERPTVNvdXJjZTtcbmZ1bmN0aW9uIG1vY2tET01Tb3VyY2UobW9ja0NvbmZpZykge1xuICAgIHJldHVybiBuZXcgTW9ja2VkRE9NU291cmNlKG1vY2tDb25maWcpO1xufVxuZXhwb3J0cy5tb2NrRE9NU291cmNlID0gbW9ja0RPTVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vY2tET01Tb3VyY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2xhc3NfMSA9IHJlcXVpcmUoXCJzbmFiYmRvbS9tb2R1bGVzL2NsYXNzXCIpO1xuZXhwb3J0cy5DbGFzc01vZHVsZSA9IGNsYXNzXzEuZGVmYXVsdDtcbnZhciBwcm9wc18xID0gcmVxdWlyZShcInNuYWJiZG9tL21vZHVsZXMvcHJvcHNcIik7XG5leHBvcnRzLlByb3BzTW9kdWxlID0gcHJvcHNfMS5kZWZhdWx0O1xudmFyIGF0dHJpYnV0ZXNfMSA9IHJlcXVpcmUoXCJzbmFiYmRvbS9tb2R1bGVzL2F0dHJpYnV0ZXNcIik7XG5leHBvcnRzLkF0dHJzTW9kdWxlID0gYXR0cmlidXRlc18xLmRlZmF1bHQ7XG52YXIgc3R5bGVfMSA9IHJlcXVpcmUoXCJzbmFiYmRvbS9tb2R1bGVzL3N0eWxlXCIpO1xuZXhwb3J0cy5TdHlsZU1vZHVsZSA9IHN0eWxlXzEuZGVmYXVsdDtcbnZhciBkYXRhc2V0XzEgPSByZXF1aXJlKFwic25hYmJkb20vbW9kdWxlcy9kYXRhc2V0XCIpO1xuZXhwb3J0cy5EYXRhc2V0TW9kdWxlID0gZGF0YXNldF8xLmRlZmF1bHQ7XG52YXIgbW9kdWxlcyA9IFtcbiAgICBzdHlsZV8xLmRlZmF1bHQsXG4gICAgY2xhc3NfMS5kZWZhdWx0LFxuICAgIHByb3BzXzEuZGVmYXVsdCxcbiAgICBhdHRyaWJ1dGVzXzEuZGVmYXVsdCxcbiAgICBkYXRhc2V0XzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoXzEgPSByZXF1aXJlKFwic25hYmJkb20vaFwiKTtcbmZ1bmN0aW9uIGNvcHlUb1RodW5rKHZub2RlLCB0aHVua1ZOb2RlKSB7XG4gICAgdGh1bmtWTm9kZS5lbG0gPSB2bm9kZS5lbG07XG4gICAgdm5vZGUuZGF0YS5mbiA9IHRodW5rVk5vZGUuZGF0YS5mbjtcbiAgICB2bm9kZS5kYXRhLmFyZ3MgPSB0aHVua1ZOb2RlLmRhdGEuYXJncztcbiAgICB2bm9kZS5kYXRhLmlzb2xhdGUgPSB0aHVua1ZOb2RlLmRhdGEuaXNvbGF0ZTtcbiAgICB0aHVua1ZOb2RlLmRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHRodW5rVk5vZGUuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB0aHVua1ZOb2RlLnRleHQgPSB2bm9kZS50ZXh0O1xuICAgIHRodW5rVk5vZGUuZWxtID0gdm5vZGUuZWxtO1xufVxuZnVuY3Rpb24gaW5pdCh0aHVua1ZOb2RlKSB7XG4gICAgdmFyIGN1ciA9IHRodW5rVk5vZGUuZGF0YTtcbiAgICB2YXIgdm5vZGUgPSBjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBjdXIuYXJncyk7XG4gICAgY29weVRvVGh1bmsodm5vZGUsIHRodW5rVk5vZGUpO1xufVxuZnVuY3Rpb24gcHJlcGF0Y2gob2xkVm5vZGUsIHRodW5rVk5vZGUpIHtcbiAgICB2YXIgb2xkID0gb2xkVm5vZGUuZGF0YSwgY3VyID0gdGh1bmtWTm9kZS5kYXRhO1xuICAgIHZhciBpO1xuICAgIHZhciBvbGRBcmdzID0gb2xkLmFyZ3MsIGFyZ3MgPSBjdXIuYXJncztcbiAgICBpZiAob2xkLmZuICE9PSBjdXIuZm4gfHwgb2xkQXJncy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVua1ZOb2RlKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG9sZEFyZ3NbaV0gIT09IGFyZ3NbaV0pIHtcbiAgICAgICAgICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVua1ZOb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3B5VG9UaHVuayhvbGRWbm9kZSwgdGh1bmtWTm9kZSk7XG59XG5mdW5jdGlvbiB0aHVuayhzZWwsIGtleSwgZm4sIGFyZ3MpIHtcbiAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZ3MgPSBmbjtcbiAgICAgICAgZm4gPSBrZXk7XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGhfMS5oKHNlbCwge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgaG9vazogeyBpbml0OiBpbml0LCBwcmVwYXRjaDogcHJlcGF0Y2ggfSxcbiAgICAgICAgZm46IGZuLFxuICAgICAgICBhcmdzOiBhcmdzLFxuICAgIH0pO1xufVxuZXhwb3J0cy50aHVuayA9IHRodW5rO1xuZXhwb3J0cy5kZWZhdWx0ID0gdGh1bms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHVuay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzVmFsaWROb2RlKG9iaikge1xuICAgIHZhciBFTEVNX1RZUEUgPSAxO1xuICAgIHZhciBGUkFHX1RZUEUgPSAxMTtcbiAgICByZXR1cm4gdHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0J1xuICAgICAgICA/IG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IG9iaiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnRcbiAgICAgICAgOiBvYmogJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgICAgIChvYmoubm9kZVR5cGUgPT09IEVMRU1fVFlQRSB8fCBvYmoubm9kZVR5cGUgPT09IEZSQUdfVFlQRSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNDbGFzc09ySWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPiAxICYmIChzdHJbMF0gPT09ICcuJyB8fCBzdHJbMF0gPT09ICcjJyk7XG59XG5leHBvcnRzLmlzQ2xhc3NPcklkID0gaXNDbGFzc09ySWQ7XG5mdW5jdGlvbiBpc0RvY0ZyYWcoZWwpIHtcbiAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IDExO1xufVxuZXhwb3J0cy5pc0RvY0ZyYWcgPSBpc0RvY0ZyYWc7XG5mdW5jdGlvbiBjaGVja1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgIGlmICh0eXBlb2YgY29udGFpbmVyICE9PSAnc3RyaW5nJyAmJiAhaXNWYWxpZE5vZGUoY29udGFpbmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudCBuZWl0aGVyIGEgc2VsZWN0b3Igc3RyaW5nLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tWYWxpZENvbnRhaW5lciA9IGNoZWNrVmFsaWRDb250YWluZXI7XG5mdW5jdGlvbiBnZXRWYWxpZE5vZGUoc2VsZWN0b3JzKSB7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSB0eXBlb2Ygc2VsZWN0b3JzID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKVxuICAgICAgICA6IHNlbGVjdG9ycztcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9ycyA9PT0gJ3N0cmluZycgJiYgZG9tRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVuZGVyIGludG8gdW5rbm93biBlbGVtZW50IGBcIiArIHNlbGVjdG9ycyArIFwiYFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5leHBvcnRzLmdldFZhbGlkTm9kZSA9IGdldFZhbGlkTm9kZTtcbmZ1bmN0aW9uIGdldFNlbGVjdG9ycyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IG5hbWVzcGFjZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAobmFtZXNwYWNlW2ldLnR5cGUgIT09ICdzZWxlY3RvcicpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG5hbWVzcGFjZVtpXS5zY29wZSArICcgJyArIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5leHBvcnRzLmdldFNlbGVjdG9ycyA9IGdldFNlbGVjdG9ycztcbmZ1bmN0aW9uIGlzRXF1YWxOYW1lc3BhY2UoYSwgYikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSB8fCAhQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0udHlwZSAhPT0gYltpXS50eXBlIHx8IGFbaV0uc2NvcGUgIT09IGJbaV0uc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNFcXVhbE5hbWVzcGFjZSA9IGlzRXF1YWxOYW1lc3BhY2U7XG5mdW5jdGlvbiBtYWtlSW5zZXJ0KG1hcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodHlwZSwgZWxtLCB2YWx1ZSkge1xuICAgICAgICBpZiAobWFwLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgdmFyIGlubmVyTWFwID0gbWFwLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGlubmVyTWFwLnNldChlbG0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbm5lck1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGlubmVyTWFwLnNldChlbG0sIHZhbHVlKTtcbiAgICAgICAgICAgIG1hcC5zZXQodHlwZSwgaW5uZXJNYXApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMubWFrZUluc2VydCA9IG1ha2VJbnNlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICB2YXIgZ2xvYmFsT2JqO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBnbG9iYWxPYmogPSB3aW5kb3c7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsb2JhbE9iaiA9IGdsb2JhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbE9iaiA9IHRoaXM7XG4gICAgfVxuICAgIGdsb2JhbE9iai5DeWNsZWpzID0gZ2xvYmFsT2JqLkN5Y2xlanMgfHwge307XG4gICAgZ2xvYmFsT2JqID0gZ2xvYmFsT2JqLkN5Y2xlanM7XG4gICAgZ2xvYmFsT2JqLmFkYXB0U3RyZWFtID0gZ2xvYmFsT2JqLmFkYXB0U3RyZWFtIHx8IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAgcmV0dXJuIGdsb2JhbE9iajtcbn1cbmZ1bmN0aW9uIHNldEFkYXB0KGYpIHtcbiAgICBnZXRHbG9iYWwoKS5hZGFwdFN0cmVhbSA9IGY7XG59XG5leHBvcnRzLnNldEFkYXB0ID0gc2V0QWRhcHQ7XG5mdW5jdGlvbiBhZGFwdChzdHJlYW0pIHtcbiAgICByZXR1cm4gZ2V0R2xvYmFsKCkuYWRhcHRTdHJlYW0oc3RyZWFtKTtcbn1cbmV4cG9ydHMuYWRhcHQgPSBhZGFwdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICAgIHZhciBnbG9iYWxPYmo7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsb2JhbE9iaiA9IHdpbmRvdztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZ2xvYmFsT2JqID0gZ2xvYmFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsT2JqID0gdGhpcztcbiAgICB9XG4gICAgZ2xvYmFsT2JqLkN5Y2xlanMgPSBnbG9iYWxPYmouQ3ljbGVqcyB8fCB7fTtcbiAgICBnbG9iYWxPYmogPSBnbG9iYWxPYmouQ3ljbGVqcztcbiAgICBnbG9iYWxPYmouYWRhcHRTdHJlYW0gPSBnbG9iYWxPYmouYWRhcHRTdHJlYW0gfHwgKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbiAgICByZXR1cm4gZ2xvYmFsT2JqO1xufVxuZnVuY3Rpb24gc2V0QWRhcHQoZikge1xuICAgIGdldEdsb2JhbCgpLmFkYXB0U3RyZWFtID0gZjtcbn1cbmV4cG9ydHMuc2V0QWRhcHQgPSBzZXRBZGFwdDtcbmZ1bmN0aW9uIGFkYXB0KHN0cmVhbSkge1xuICAgIHJldHVybiBnZXRHbG9iYWwoKS5hZGFwdFN0cmVhbShzdHJlYW0pO1xufVxuZXhwb3J0cy5hZGFwdCA9IGFkYXB0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW50ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbHNcIik7XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBwcmVwYXJlcyB0aGUgQ3ljbGUgYXBwbGljYXRpb24gdG8gYmUgZXhlY3V0ZWQuIFRha2VzIGEgYG1haW5gXG4gKiBmdW5jdGlvbiBhbmQgcHJlcGFyZXMgdG8gY2lyY3VsYXJseSBjb25uZWN0cyBpdCB0byB0aGUgZ2l2ZW4gY29sbGVjdGlvbiBvZlxuICogZHJpdmVyIGZ1bmN0aW9ucy4gQXMgYW4gb3V0cHV0LCBgc2V0dXAoKWAgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aHJlZVxuICogcHJvcGVydGllczogYHNvdXJjZXNgLCBgc2lua3NgIGFuZCBgcnVuYC4gT25seSB3aGVuIGBydW4oKWAgaXMgY2FsbGVkIHdpbGxcbiAqIHRoZSBhcHBsaWNhdGlvbiBhY3R1YWxseSBleGVjdXRlLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbiBvZiBgcnVuKClgIGZvclxuICogbW9yZSBkZXRhaWxzLlxuICpcbiAqICoqRXhhbXBsZToqKlxuICogYGBganNcbiAqIGltcG9ydCB7c2V0dXB9IGZyb20gJ0BjeWNsZS9ydW4nO1xuICogY29uc3Qge3NvdXJjZXMsIHNpbmtzLCBydW59ID0gc2V0dXAobWFpbiwgZHJpdmVycyk7XG4gKiAvLyAuLi5cbiAqIGNvbnN0IGRpc3Bvc2UgPSBydW4oKTsgLy8gRXhlY3V0ZXMgdGhlIGFwcGxpY2F0aW9uXG4gKiAvLyAuLi5cbiAqIGRpc3Bvc2UoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1haW4gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGBzb3VyY2VzYCBhcyBpbnB1dCBhbmQgb3V0cHV0c1xuICogYHNpbmtzYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkcml2ZXJzIGFuIG9iamVjdCB3aGVyZSBrZXlzIGFyZSBkcml2ZXIgbmFtZXMgYW5kIHZhbHVlc1xuICogYXJlIGRyaXZlciBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIHRocmVlIHByb3BlcnRpZXM6IGBzb3VyY2VzYCwgYHNpbmtzYCBhbmRcbiAqIGBydW5gLiBgc291cmNlc2AgaXMgdGhlIGNvbGxlY3Rpb24gb2YgZHJpdmVyIHNvdXJjZXMsIGBzaW5rc2AgaXMgdGhlXG4gKiBjb2xsZWN0aW9uIG9mIGRyaXZlciBzaW5rcywgdGhlc2UgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZyBvciB0ZXN0aW5nLiBgcnVuYFxuICogaXMgdGhlIGZ1bmN0aW9uIHRoYXQgb25jZSBjYWxsZWQgd2lsbCBleGVjdXRlIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEBmdW5jdGlvbiBzZXR1cFxuICovXG5mdW5jdGlvbiBzZXR1cChtYWluLCBkcml2ZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBtYWluICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gQ3ljbGUgbXVzdCBiZSB0aGUgJ21haW4nIFwiICsgXCJmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHJpdmVycyAhPT0gXCJvYmplY3RcIiB8fCBkcml2ZXJzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBnaXZlbiB0byBDeWNsZSBtdXN0IGJlIGFuIG9iamVjdCBcIiArXG4gICAgICAgICAgICBcIndpdGggZHJpdmVyIGZ1bmN0aW9ucyBhcyBwcm9wZXJ0aWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGludGVybmFsc18xLmlzT2JqZWN0RW1wdHkoZHJpdmVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IGdpdmVuIHRvIEN5Y2xlIG11c3QgYmUgYW4gb2JqZWN0IFwiICtcbiAgICAgICAgICAgIFwid2l0aCBhdCBsZWFzdCBvbmUgZHJpdmVyIGZ1bmN0aW9uIGRlY2xhcmVkIGFzIGEgcHJvcGVydHkuXCIpO1xuICAgIH1cbiAgICB2YXIgZW5naW5lID0gc2V0dXBSZXVzYWJsZShkcml2ZXJzKTtcbiAgICB2YXIgc2lua3MgPSBtYWluKGVuZ2luZS5zb3VyY2VzKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LkN5Y2xlanMgPSB3aW5kb3cuQ3ljbGVqcyB8fCB7fTtcbiAgICAgICAgd2luZG93LkN5Y2xlanMuc2lua3MgPSBzaW5rcztcbiAgICB9XG4gICAgZnVuY3Rpb24gX3J1bigpIHtcbiAgICAgICAgdmFyIGRpc3Bvc2VSdW4gPSBlbmdpbmUucnVuKHNpbmtzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBkaXNwb3NlUnVuKCk7XG4gICAgICAgICAgICBlbmdpbmUuZGlzcG9zZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5rczogc2lua3MsIHNvdXJjZXM6IGVuZ2luZS5zb3VyY2VzLCBydW46IF9ydW4gfTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8qKlxuICogQSBwYXJ0aWFsbHktYXBwbGllZCB2YXJpYW50IG9mIHNldHVwKCkgd2hpY2ggYWNjZXB0cyBvbmx5IHRoZSBkcml2ZXJzLCBhbmRcbiAqIGFsbG93cyBtYW55IGBtYWluYCBmdW5jdGlvbnMgdG8gZXhlY3V0ZSBhbmQgcmV1c2UgdGhpcyBzYW1lIHNldCBvZiBkcml2ZXJzLlxuICpcbiAqIFRha2VzIGFuIG9iamVjdCB3aXRoIGRyaXZlciBmdW5jdGlvbnMgYXMgaW5wdXQsIGFuZCBvdXRwdXRzIGFuIG9iamVjdCB3aGljaFxuICogY29udGFpbnMgdGhlIGdlbmVyYXRlZCBzb3VyY2VzIChmcm9tIHRob3NlIGRyaXZlcnMpIGFuZCBhIGBydW5gIGZ1bmN0aW9uXG4gKiAod2hpY2ggaW4gdHVybiBleHBlY3RzIHNpbmtzIGFzIGFyZ3VtZW50KS4gVGhpcyBgcnVuYCBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkXG4gKiBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBhcmd1bWVudHMsIGFuZCBpdCB3aWxsIHJldXNlIHRoZSBkcml2ZXJzIHRoYXRcbiAqIHdlcmUgcGFzc2VkIHRvIGBzZXR1cFJldXNhYmxlYC5cbiAqXG4gKiAqKkV4YW1wbGU6KipcbiAqIGBgYGpzXG4gKiBpbXBvcnQge3NldHVwUmV1c2FibGV9IGZyb20gJ0BjeWNsZS9ydW4nO1xuICogY29uc3Qge3NvdXJjZXMsIHJ1biwgZGlzcG9zZX0gPSBzZXR1cFJldXNhYmxlKGRyaXZlcnMpO1xuICogLy8gLi4uXG4gKiBjb25zdCBzaW5rcyA9IG1haW4oc291cmNlcyk7XG4gKiBjb25zdCBkaXNwb3NlUnVuID0gcnVuKHNpbmtzKTtcbiAqIC8vIC4uLlxuICogZGlzcG9zZVJ1bigpO1xuICogLy8gLi4uXG4gKiBkaXNwb3NlKCk7IC8vIGVuZHMgdGhlIHJldXNhYmlsaXR5IG9mIGRyaXZlcnNcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkcml2ZXJzIGFuIG9iamVjdCB3aGVyZSBrZXlzIGFyZSBkcml2ZXIgbmFtZXMgYW5kIHZhbHVlc1xuICogYXJlIGRyaXZlciBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIHRocmVlIHByb3BlcnRpZXM6IGBzb3VyY2VzYCwgYHJ1bmAgYW5kXG4gKiBgZGlzcG9zZWAuIGBzb3VyY2VzYCBpcyB0aGUgY29sbGVjdGlvbiBvZiBkcml2ZXIgc291cmNlcywgYHJ1bmAgaXMgdGhlXG4gKiBmdW5jdGlvbiB0aGF0IG9uY2UgY2FsbGVkIHdpdGggJ3NpbmtzJyBhcyBhcmd1bWVudCwgd2lsbCBleGVjdXRlIHRoZVxuICogYXBwbGljYXRpb24sIHR5aW5nIHRvZ2V0aGVyIHNvdXJjZXMgd2l0aCBzaW5rcy4gYGRpc3Bvc2VgIHRlcm1pbmF0ZXMgdGhlXG4gKiByZXVzYWJsZSByZXNvdXJjZXMgdXNlZCBieSB0aGUgZHJpdmVycy4gTm90ZSBhbHNvIHRoYXQgYHJ1bmAgcmV0dXJucyBhXG4gKiBkaXNwb3NlIGZ1bmN0aW9uIHdoaWNoIHRlcm1pbmF0ZXMgcmVzb3VyY2VzIHRoYXQgYXJlIHNwZWNpZmljIChub3QgcmV1c2FibGUpXG4gKiB0byB0aGF0IHJ1bi5cbiAqIEBmdW5jdGlvbiBzZXR1cFJldXNhYmxlXG4gKi9cbmZ1bmN0aW9uIHNldHVwUmV1c2FibGUoZHJpdmVycykge1xuICAgIGlmICh0eXBlb2YgZHJpdmVycyAhPT0gXCJvYmplY3RcIiB8fCBkcml2ZXJzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGdpdmVuIHRvIHNldHVwUmV1c2FibGUgbXVzdCBiZSBhbiBvYmplY3QgXCIgK1xuICAgICAgICAgICAgXCJ3aXRoIGRyaXZlciBmdW5jdGlvbnMgYXMgcHJvcGVydGllcy5cIik7XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbHNfMS5pc09iamVjdEVtcHR5KGRyaXZlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGdpdmVuIHRvIHNldHVwUmV1c2FibGUgbXVzdCBiZSBhbiBvYmplY3QgXCIgK1xuICAgICAgICAgICAgXCJ3aXRoIGF0IGxlYXN0IG9uZSBkcml2ZXIgZnVuY3Rpb24gZGVjbGFyZWQgYXMgYSBwcm9wZXJ0eS5cIik7XG4gICAgfVxuICAgIHZhciBzaW5rUHJveGllcyA9IGludGVybmFsc18xLm1ha2VTaW5rUHJveGllcyhkcml2ZXJzKTtcbiAgICB2YXIgcmF3U291cmNlcyA9IGludGVybmFsc18xLmNhbGxEcml2ZXJzKGRyaXZlcnMsIHNpbmtQcm94aWVzKTtcbiAgICB2YXIgc291cmNlcyA9IGludGVybmFsc18xLmFkYXB0U291cmNlcyhyYXdTb3VyY2VzKTtcbiAgICBmdW5jdGlvbiBfcnVuKHNpbmtzKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHNfMS5yZXBsaWNhdGVNYW55KHNpbmtzLCBzaW5rUHJveGllcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3Bvc2VFbmdpbmUoKSB7XG4gICAgICAgIGludGVybmFsc18xLmRpc3Bvc2VTb3VyY2VzKHNvdXJjZXMpO1xuICAgICAgICBpbnRlcm5hbHNfMS5kaXNwb3NlU2lua1Byb3hpZXMoc2lua1Byb3hpZXMpO1xuICAgIH1cbiAgICByZXR1cm4geyBzb3VyY2VzOiBzb3VyY2VzLCBydW46IF9ydW4sIGRpc3Bvc2U6IGRpc3Bvc2VFbmdpbmUgfTtcbn1cbmV4cG9ydHMuc2V0dXBSZXVzYWJsZSA9IHNldHVwUmV1c2FibGU7XG4vKipcbiAqIFRha2VzIGEgYG1haW5gIGZ1bmN0aW9uIGFuZCBjaXJjdWxhcmx5IGNvbm5lY3RzIGl0IHRvIHRoZSBnaXZlbiBjb2xsZWN0aW9uXG4gKiBvZiBkcml2ZXIgZnVuY3Rpb25zLlxuICpcbiAqICoqRXhhbXBsZToqKlxuICogYGBganNcbiAqIGltcG9ydCBydW4gZnJvbSAnQGN5Y2xlL3J1bic7XG4gKiBjb25zdCBkaXNwb3NlID0gcnVuKG1haW4sIGRyaXZlcnMpO1xuICogLy8gLi4uXG4gKiBkaXNwb3NlKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgYG1haW5gIGZ1bmN0aW9uIGV4cGVjdHMgYSBjb2xsZWN0aW9uIG9mIFwic291cmNlXCIgc3RyZWFtcyAocmV0dXJuZWQgZnJvbVxuICogZHJpdmVycykgYXMgaW5wdXQsIGFuZCBzaG91bGQgcmV0dXJuIGEgY29sbGVjdGlvbiBvZiBcInNpbmtcIiBzdHJlYW1zICh0byBiZVxuICogZ2l2ZW4gdG8gZHJpdmVycykuIEEgXCJjb2xsZWN0aW9uIG9mIHN0cmVhbXNcIiBpcyBhIEphdmFTY3JpcHQgb2JqZWN0IHdoZXJlXG4gKiBrZXlzIG1hdGNoIHRoZSBkcml2ZXIgbmFtZXMgcmVnaXN0ZXJlZCBieSB0aGUgYGRyaXZlcnNgIG9iamVjdCwgYW5kIHZhbHVlc1xuICogYXJlIHRoZSBzdHJlYW1zLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbiBvZiBlYWNoIGRyaXZlciB0byBzZWUgbW9yZVxuICogZGV0YWlscyBvbiB3aGF0IHR5cGVzIG9mIHNvdXJjZXMgaXQgb3V0cHV0cyBhbmQgc2lua3MgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWFpbiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYHNvdXJjZXNgIGFzIGlucHV0IGFuZCBvdXRwdXRzXG4gKiBgc2lua3NgLlxuICogQHBhcmFtIHtPYmplY3R9IGRyaXZlcnMgYW4gb2JqZWN0IHdoZXJlIGtleXMgYXJlIGRyaXZlciBuYW1lcyBhbmQgdmFsdWVzXG4gKiBhcmUgZHJpdmVyIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGRpc3Bvc2UgZnVuY3Rpb24sIHVzZWQgdG8gdGVybWluYXRlIHRoZSBleGVjdXRpb24gb2YgdGhlXG4gKiBDeWNsZS5qcyBwcm9ncmFtLCBjbGVhbmluZyB1cCByZXNvdXJjZXMgdXNlZC5cbiAqIEBmdW5jdGlvbiBydW5cbiAqL1xuZnVuY3Rpb24gcnVuKG1haW4sIGRyaXZlcnMpIHtcbiAgICB2YXIgcHJvZ3JhbSA9IHNldHVwKG1haW4sIGRyaXZlcnMpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuQ3ljbGVqc0RldlRvb2xfc3RhcnRHcmFwaFNlcmlhbGl6ZXIpIHtcbiAgICAgICAgd2luZG93LkN5Y2xlanNEZXZUb29sX3N0YXJ0R3JhcGhTZXJpYWxpemVyKHByb2dyYW0uc2lua3MpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZ3JhbS5ydW4oKTtcbn1cbmV4cG9ydHMucnVuID0gcnVuO1xuZXhwb3J0cy5kZWZhdWx0ID0gcnVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgeHN0cmVhbV8xID0gcmVxdWlyZShcInhzdHJlYW1cIik7XG52YXIgcXVpY2t0YXNrXzEgPSByZXF1aXJlKFwicXVpY2t0YXNrXCIpO1xudmFyIGFkYXB0XzEgPSByZXF1aXJlKFwiLi9hZGFwdFwiKTtcbnZhciBzY2hlZHVsZU1pY3JvdGFzayA9IHF1aWNrdGFza18xLmRlZmF1bHQoKTtcbmZ1bmN0aW9uIG1ha2VTaW5rUHJveGllcyhkcml2ZXJzKSB7XG4gICAgdmFyIHNpbmtQcm94aWVzID0ge307XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIGRyaXZlcnMpIHtcbiAgICAgICAgaWYgKGRyaXZlcnMuaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xuICAgICAgICAgICAgc2lua1Byb3hpZXNbbmFtZV8xXSA9IHhzdHJlYW1fMS5kZWZhdWx0LmNyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW5rUHJveGllcztcbn1cbmV4cG9ydHMubWFrZVNpbmtQcm94aWVzID0gbWFrZVNpbmtQcm94aWVzO1xuZnVuY3Rpb24gY2FsbERyaXZlcnMoZHJpdmVycywgc2lua1Byb3hpZXMpIHtcbiAgICB2YXIgc291cmNlcyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWVfMiBpbiBkcml2ZXJzKSB7XG4gICAgICAgIGlmIChkcml2ZXJzLmhhc093blByb3BlcnR5KG5hbWVfMikpIHtcbiAgICAgICAgICAgIHNvdXJjZXNbbmFtZV8yXSA9IGRyaXZlcnNbbmFtZV8yXShzaW5rUHJveGllc1tuYW1lXzJdLCBuYW1lXzIpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZXNbbmFtZV8yXSAmJiB0eXBlb2Ygc291cmNlc1tuYW1lXzJdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHNvdXJjZXNbbmFtZV8yXS5faXNDeWNsZVNvdXJjZSA9IG5hbWVfMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbn1cbmV4cG9ydHMuY2FsbERyaXZlcnMgPSBjYWxsRHJpdmVycztcbi8vIE5PVEU6IHRoaXMgd2lsbCBtdXRhdGUgYHNvdXJjZXNgLlxuZnVuY3Rpb24gYWRhcHRTb3VyY2VzKHNvdXJjZXMpIHtcbiAgICBmb3IgKHZhciBuYW1lXzMgaW4gc291cmNlcykge1xuICAgICAgICBpZiAoc291cmNlcy5oYXNPd25Qcm9wZXJ0eShuYW1lXzMpICYmXG4gICAgICAgICAgICBzb3VyY2VzW25hbWVfM10gJiZcbiAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VzW25hbWVfM10uc2hhbWVmdWxseVNlbmROZXh0ID09PVxuICAgICAgICAgICAgICAgICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNvdXJjZXNbbmFtZV8zXSA9IGFkYXB0XzEuYWRhcHQoc291cmNlc1tuYW1lXzNdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbn1cbmV4cG9ydHMuYWRhcHRTb3VyY2VzID0gYWRhcHRTb3VyY2VzO1xuZnVuY3Rpb24gcmVwbGljYXRlTWFueShzaW5rcywgc2lua1Byb3hpZXMpIHtcbiAgICB2YXIgc2lua05hbWVzID0gT2JqZWN0LmtleXMoc2lua3MpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gISFzaW5rUHJveGllc1tuYW1lXTsgfSk7XG4gICAgdmFyIGJ1ZmZlcnMgPSB7fTtcbiAgICB2YXIgcmVwbGljYXRvcnMgPSB7fTtcbiAgICBzaW5rTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBidWZmZXJzW25hbWVdID0geyBfbjogW10sIF9lOiBbXSB9O1xuICAgICAgICByZXBsaWNhdG9yc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBidWZmZXJzW25hbWVdLl9uLnB1c2goeCk7IH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyByZXR1cm4gYnVmZmVyc1tuYW1lXS5fZS5wdXNoKGVycik7IH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBzdWJzY3JpcHRpb25zID0gc2lua05hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4geHN0cmVhbV8xLmRlZmF1bHQuZnJvbU9ic2VydmFibGUoc2lua3NbbmFtZV0pLnN1YnNjcmliZShyZXBsaWNhdG9yc1tuYW1lXSk7XG4gICAgfSk7XG4gICAgc2lua05hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gc2lua1Byb3hpZXNbbmFtZV07XG4gICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpc3RlbmVyLl9uKHgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShlcnIpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLl9lKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgYnVmZmVyc1tuYW1lXS5fbi5mb3JFYWNoKG5leHQpO1xuICAgICAgICBidWZmZXJzW25hbWVdLl9lLmZvckVhY2goZXJyb3IpO1xuICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5uZXh0ID0gbmV4dDtcbiAgICAgICAgcmVwbGljYXRvcnNbbmFtZV0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgLy8gYmVjYXVzZSBzaW5rLnN1YnNjcmliZShyZXBsaWNhdG9yKSBoYWQgbXV0YXRlZCByZXBsaWNhdG9yIHRvIGFkZFxuICAgICAgICAvLyBfbiwgX2UsIF9jLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZXNlOlxuICAgICAgICByZXBsaWNhdG9yc1tuYW1lXS5fbiA9IG5leHQ7XG4gICAgICAgIHJlcGxpY2F0b3JzW25hbWVdLl9lID0gZXJyb3I7XG4gICAgfSk7XG4gICAgYnVmZmVycyA9IG51bGw7IC8vIGZyZWUgdXAgZm9yIEdDXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRpc3Bvc2VSZXBsaWNhdGlvbigpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG59XG5leHBvcnRzLnJlcGxpY2F0ZU1hbnkgPSByZXBsaWNhdGVNYW55O1xuZnVuY3Rpb24gZGlzcG9zZVNpbmtQcm94aWVzKHNpbmtQcm94aWVzKSB7XG4gICAgT2JqZWN0LmtleXMoc2lua1Byb3hpZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHNpbmtQcm94aWVzW25hbWVdLl9jKCk7IH0pO1xufVxuZXhwb3J0cy5kaXNwb3NlU2lua1Byb3hpZXMgPSBkaXNwb3NlU2lua1Byb3hpZXM7XG5mdW5jdGlvbiBkaXNwb3NlU291cmNlcyhzb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgayBpbiBzb3VyY2VzKSB7XG4gICAgICAgIGlmIChzb3VyY2VzLmhhc093blByb3BlcnR5KGspICYmXG4gICAgICAgICAgICBzb3VyY2VzW2tdICYmXG4gICAgICAgICAgICBzb3VyY2VzW2tdLmRpc3Bvc2UpIHtcbiAgICAgICAgICAgIHNvdXJjZXNba10uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kaXNwb3NlU291cmNlcyA9IGRpc3Bvc2VTb3VyY2VzO1xuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzT2JqZWN0RW1wdHkgPSBpc09iamVjdEVtcHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWxzLmpzLm1hcCIsInZhciBhc24xID0gZXhwb3J0cztcblxuYXNuMS5iaWdudW0gPSByZXF1aXJlKCdibi5qcycpO1xuXG5hc24xLmRlZmluZSA9IHJlcXVpcmUoJy4vYXNuMS9hcGknKS5kZWZpbmU7XG5hc24xLmJhc2UgPSByZXF1aXJlKCcuL2FzbjEvYmFzZScpO1xuYXNuMS5jb25zdGFudHMgPSByZXF1aXJlKCcuL2FzbjEvY29uc3RhbnRzJyk7XG5hc24xLmRlY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2RlY29kZXJzJyk7XG5hc24xLmVuY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2VuY29kZXJzJyk7XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4uL2FzbjEnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhcGkgPSBleHBvcnRzO1xuXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcbiAgcmV0dXJuIG5ldyBFbnRpdHkobmFtZSwgYm9keSk7XG59O1xuXG5mdW5jdGlvbiBFbnRpdHkobmFtZSwgYm9keSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVjb2RlcnMgPSB7fTtcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fY3JlYXRlTmFtZWQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZChiYXNlKSB7XG4gIHZhciBuYW1lZDtcbiAgdHJ5IHtcbiAgICBuYW1lZCA9IHJlcXVpcmUoJ3ZtJykucnVuSW5UaGlzQ29udGV4dChcbiAgICAgICcoZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcoZW50aXR5KSB7XFxuJyArXG4gICAgICAnICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcXG4nICtcbiAgICAgICd9KSdcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmFtZWQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcbiAgICB9O1xuICB9XG4gIGluaGVyaXRzKG5hbWVkLCBiYXNlKTtcbiAgbmFtZWQucHJvdG90eXBlLl9pbml0TmFtZWQgPSBmdW5jdGlvbiBpbml0bmFtZWQoZW50aXR5KSB7XG4gICAgYmFzZS5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBuYW1lZCh0aGlzKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcbiAgaWYgKCF0aGlzLmRlY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5kZWNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5kZWNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZGVjb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5fZ2V0RGVjb2RlcihlbmMpLmRlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldEVuY29kZXIgPSBmdW5jdGlvbiBfZ2V0RW5jb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGVuY29kZXJcbiAgaWYgKCF0aGlzLmVuY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5lbmNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5lbmNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIGVuYywgLyogaW50ZXJuYWwgKi8gcmVwb3J0ZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2dldEVuY29kZXIoZW5jKS5lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBEZWNvZGVyQnVmZmVyKGJhc2UsIG9wdGlvbnMpIHtcbiAgUmVwb3J0ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYmFzZSkpIHtcbiAgICB0aGlzLmVycm9yKCdJbnB1dCBub3QgQnVmZmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLmxlbmd0aCA9IGJhc2UubGVuZ3RoO1xufVxuaW5oZXJpdHMoRGVjb2RlckJ1ZmZlciwgUmVwb3J0ZXIpO1xuZXhwb3J0cy5EZWNvZGVyQnVmZmVyID0gRGVjb2RlckJ1ZmZlcjtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHJldHVybiB7IG9mZnNldDogdGhpcy5vZmZzZXQsIHJlcG9ydGVyOiBSZXBvcnRlci5wcm90b3R5cGUuc2F2ZS5jYWxsKHRoaXMpIH07XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShzYXZlKSB7XG4gIC8vIFJldHVybiBza2lwcGVkIGRhdGFcbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0O1xuXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIFJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlLmNhbGwodGhpcywgc2F2ZS5yZXBvcnRlcik7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IHRoaXMubGVuZ3RoO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KGZhaWwpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICsgMSA8PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChieXRlcywgZmFpbCkge1xuICBpZiAoISh0aGlzLm9mZnNldCArIGJ5dGVzIDw9IHRoaXMubGVuZ3RoKSlcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcblxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcblxuICAvLyBTaGFyZSByZXBvcnRlciBzdGF0ZVxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJlcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XG4gIHRoaXMub2Zmc2V0ICs9IGJ5dGVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiByYXcoc2F2ZSkge1xuICByZXR1cm4gdGhpcy5iYXNlLnNsaWNlKHNhdmUgPyBzYXZlLm9mZnNldCA6IHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIEVuY29kZXJCdWZmZXIodmFsdWUsIHJlcG9ydGVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBFbmNvZGVyQnVmZmVyKSlcbiAgICAgICAgaXRlbSA9IG5ldyBFbmNvZGVyQnVmZmVyKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMHhmZikpXG4gICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ25vbi1ieXRlIEVuY29kZXJCdWZmZXIgdmFsdWUnKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xuXG5FbmNvZGVyQnVmZmVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihvdXQsIG9mZnNldCkge1xuICBpZiAoIW91dClcbiAgICBvdXQgPSBuZXcgQnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgaWYgKCFvZmZzZXQpXG4gICAgb2Zmc2V0ID0gMDtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG91dDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpdGVtLmpvaW4ob3V0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGl0ZW0ubGVuZ3RoO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICBvdXRbb2Zmc2V0XSA9IHRoaXMudmFsdWU7XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgb3V0LndyaXRlKHRoaXMudmFsdWUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMudmFsdWUpKVxuICAgICAgdGhpcy52YWx1ZS5jb3B5KG91dCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbiIsInZhciBiYXNlID0gZXhwb3J0cztcblxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmJhc2UuRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmJhc2UuRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRW5jb2RlckJ1ZmZlcjtcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuIiwidmFyIFJlcG9ydGVyID0gcmVxdWlyZSgnLi4vYmFzZScpLlJlcG9ydGVyO1xudmFyIEVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuRW5jb2RlckJ1ZmZlcjtcbnZhciBEZWNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZScpLkRlY29kZXJCdWZmZXI7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG4vLyBTdXBwb3J0ZWQgdGFnc1xudmFyIHRhZ3MgPSBbXG4gICdzZXEnLCAnc2Vxb2YnLCAnc2V0JywgJ3NldG9mJywgJ29iamlkJywgJ2Jvb2wnLFxuICAnZ2VudGltZScsICd1dGN0aW1lJywgJ251bGxfJywgJ2VudW0nLCAnaW50JywgJ29iakRlc2MnLFxuICAnYml0c3RyJywgJ2JtcHN0cicsICdjaGFyc3RyJywgJ2dlbnN0cicsICdncmFwaHN0cicsICdpYTVzdHInLCAnaXNvNjQ2c3RyJyxcbiAgJ251bXN0cicsICdvY3RzdHInLCAncHJpbnRzdHInLCAndDYxc3RyJywgJ3VuaXN0cicsICd1dGY4c3RyJywgJ3ZpZGVvc3RyJ1xuXTtcblxuLy8gUHVibGljIG1ldGhvZHMgbGlzdFxudmFyIG1ldGhvZHMgPSBbXG4gICdrZXknLCAnb2JqJywgJ3VzZScsICdvcHRpb25hbCcsICdleHBsaWNpdCcsICdpbXBsaWNpdCcsICdkZWYnLCAnY2hvaWNlJyxcbiAgJ2FueScsICdjb250YWlucydcbl0uY29uY2F0KHRhZ3MpO1xuXG4vLyBPdmVycmlkZWQgbWV0aG9kcyBsaXN0XG52YXIgb3ZlcnJpZGVkID0gW1xuICAnX3BlZWtUYWcnLCAnX2RlY29kZVRhZycsICdfdXNlJyxcbiAgJ19kZWNvZGVTdHInLCAnX2RlY29kZU9iamlkJywgJ19kZWNvZGVUaW1lJyxcbiAgJ19kZWNvZGVOdWxsJywgJ19kZWNvZGVJbnQnLCAnX2RlY29kZUJvb2wnLCAnX2RlY29kZUxpc3QnLFxuXG4gICdfZW5jb2RlQ29tcG9zaXRlJywgJ19lbmNvZGVTdHInLCAnX2VuY29kZU9iamlkJywgJ19lbmNvZGVUaW1lJyxcbiAgJ19lbmNvZGVOdWxsJywgJ19lbmNvZGVJbnQnLCAnX2VuY29kZUJvb2wnXG5dO1xuXG5mdW5jdGlvbiBOb2RlKGVuYywgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHt9O1xuICB0aGlzLl9iYXNlU3RhdGUgPSBzdGF0ZTtcblxuICBzdGF0ZS5lbmMgPSBlbmM7XG5cbiAgc3RhdGUucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHN0YXRlLmNoaWxkcmVuID0gbnVsbDtcblxuICAvLyBTdGF0ZVxuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5hcmdzID0gbnVsbDtcbiAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBudWxsO1xuICBzdGF0ZS5jaG9pY2UgPSBudWxsO1xuICBzdGF0ZS5vcHRpb25hbCA9IGZhbHNlO1xuICBzdGF0ZS5hbnkgPSBmYWxzZTtcbiAgc3RhdGUub2JqID0gZmFsc2U7XG4gIHN0YXRlLnVzZSA9IG51bGw7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBudWxsO1xuICBzdGF0ZS5rZXkgPSBudWxsO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gbnVsbDtcbiAgc3RhdGUuZXhwbGljaXQgPSBudWxsO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gIHN0YXRlLmNvbnRhaW5zID0gbnVsbDtcblxuICAvLyBTaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZSBvbiBlYWNoIG1ldGhvZFxuICBpZiAoIXN0YXRlLnBhcmVudCkge1xuICAgIHN0YXRlLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5fd3JhcCgpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG5cbnZhciBzdGF0ZVByb3BzID0gW1xuICAnZW5jJywgJ3BhcmVudCcsICdjaGlsZHJlbicsICd0YWcnLCAnYXJncycsICdyZXZlcnNlQXJncycsICdjaG9pY2UnLFxuICAnb3B0aW9uYWwnLCAnYW55JywgJ29iaicsICd1c2UnLCAnYWx0ZXJlZFVzZScsICdrZXknLCAnZGVmYXVsdCcsICdleHBsaWNpdCcsXG4gICdpbXBsaWNpdCcsICdjb250YWlucydcbl07XG5cbk5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGNzdGF0ZSA9IHt9O1xuICBzdGF0ZVByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGNzdGF0ZVtwcm9wXSA9IHN0YXRlW3Byb3BdO1xuICB9KTtcbiAgdmFyIHJlcyA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGNzdGF0ZS5wYXJlbnQpO1xuICByZXMuX2Jhc2VTdGF0ZSA9IGNzdGF0ZTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbk5vZGUucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24gd3JhcCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgdGhpc1ttZXRob2RdID0gZnVuY3Rpb24gX3dyYXBwZWRNZXRob2QoKSB7XG4gICAgICB2YXIgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLnB1c2goY2xvbmUpO1xuICAgICAgcmV0dXJuIGNsb25lW21ldGhvZF0uYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoYm9keSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIGJvZHkuY2FsbCh0aGlzKTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW5cbiAgc3RhdGUuY2hpbGRyZW4gPSBzdGF0ZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IHRoaXM7XG4gIH0sIHRoaXMpO1xuICBhc3NlcnQuZXF1YWwoc3RhdGUuY2hpbGRyZW4ubGVuZ3RoLCAxLCAnUm9vdCBub2RlIGNhbiBoYXZlIG9ubHkgb25lIGNoaWxkJyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fdXNlQXJncyA9IGZ1bmN0aW9uIHVzZUFyZ3MoYXJncykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRmlsdGVyIGNoaWxkcmVuIGFuZCBhcmdzXG4gIHZhciBjaGlsZHJlbiA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yO1xuICB9LCB0aGlzKTtcbiAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiAhKGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpO1xuICB9LCB0aGlzKTtcblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmNoaWxkcmVuID09PSBudWxsKTtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgLy8gUmVwbGFjZSBwYXJlbnQgdG8gbWFpbnRhaW4gYmFja3dhcmQgbGlua1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID0gdGhpcztcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuYXJncyA9PT0gbnVsbCk7XG4gICAgc3RhdGUuYXJncyA9IGFyZ3M7XG4gICAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuY29uc3RydWN0b3IgIT09IE9iamVjdClcbiAgICAgICAgcmV0dXJuIGFyZztcblxuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IChrZXkgfCAwKSlcbiAgICAgICAgICBrZXkgfD0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnW2tleV07XG4gICAgICAgIHJlc1t2YWx1ZV0gPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vXG4vLyBPdmVycmlkZWQgbWV0aG9kc1xuLy9cblxub3ZlcnJpZGVkLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE5vZGUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiBfb3ZlcnJpZGVkKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQgZm9yIGVuY29kaW5nOiAnICsgc3RhdGUuZW5jKTtcbiAgfTtcbn0pO1xuXG4vL1xuLy8gUHVibGljIG1ldGhvZHNcbi8vXG5cbnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgTm9kZS5wcm90b3R5cGVbdGFnXSA9IGZ1bmN0aW9uIF90YWdNZXRob2QoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFzc2VydChzdGF0ZS50YWcgPT09IG51bGwpO1xuICAgIHN0YXRlLnRhZyA9IHRhZztcblxuICAgIHRoaXMuX3VzZUFyZ3MoYXJncyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG5Ob2RlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoaXRlbSkge1xuICBhc3NlcnQoaXRlbSk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUudXNlID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24gb3B0aW9uYWwoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5kZWYgPSBmdW5jdGlvbiBkZWYodmFsKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbCk7XG4gIHN0YXRlWydkZWZhdWx0J10gPSB2YWw7XG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmV4cGxpY2l0ID0gZnVuY3Rpb24gZXhwbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmltcGxpY2l0ID0gZnVuY3Rpb24gaW1wbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9iaiA9IGZ1bmN0aW9uIG9iaigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgc3RhdGUub2JqID0gdHJ1ZTtcblxuICBpZiAoYXJncy5sZW5ndGggIT09IDApXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIGtleShuZXdLZXkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5rZXkgPT09IG51bGwpO1xuICBzdGF0ZS5rZXkgPSBuZXdLZXk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiBhbnkoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5hbnkgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuY2hvaWNlID0gZnVuY3Rpb24gY2hvaWNlKG9iaikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmNob2ljZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNob2ljZSA9IG9iajtcbiAgdGhpcy5fdXNlQXJncyhPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMoaXRlbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnVzZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNvbnRhaW5zID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBEZWNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxuICBpZiAoc3RhdGUucGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBpbnB1dC53cmFwUmVzdWx0KHN0YXRlLmNoaWxkcmVuWzBdLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpKTtcblxuICB2YXIgcmVzdWx0ID0gc3RhdGVbJ2RlZmF1bHQnXTtcbiAgdmFyIHByZXNlbnQgPSB0cnVlO1xuXG4gIHZhciBwcmV2S2V5ID0gbnVsbDtcbiAgaWYgKHN0YXRlLmtleSAhPT0gbnVsbClcbiAgICBwcmV2S2V5ID0gaW5wdXQuZW50ZXJLZXkoc3RhdGUua2V5KTtcblxuICAvLyBDaGVjayBpZiB0YWcgaXMgdGhlcmVcbiAgaWYgKHN0YXRlLm9wdGlvbmFsKSB7XG4gICAgdmFyIHRhZyA9IG51bGw7XG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuZXhwbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUuaW1wbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS50YWc7XG5cbiAgICBpZiAodGFnID09PSBudWxsICYmICFzdGF0ZS5hbnkpIHtcbiAgICAgIC8vIFRyaWFsIGFuZCBFcnJvclxuICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgICAgIHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBwcmVzZW50ID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJlc2VudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaW5wdXQucmVzdG9yZShzYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlc2VudCA9IHRoaXMuX3BlZWtUYWcoaW5wdXQsIHRhZywgc3RhdGUuYW55KTtcblxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IocHJlc2VudCkpXG4gICAgICAgIHJldHVybiBwcmVzZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggb2JqZWN0IG9uIHN0YWNrXG4gIHZhciBwcmV2T2JqO1xuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcHJldk9iaiA9IGlucHV0LmVudGVyT2JqZWN0KCk7XG5cbiAgaWYgKHByZXNlbnQpIHtcbiAgICAvLyBVbndyYXAgZXhwbGljaXQgdmFsdWVzXG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXhwbGljaXQgPSB0aGlzLl9kZWNvZGVUYWcoaW5wdXQsIHN0YXRlLmV4cGxpY2l0KTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGV4cGxpY2l0KSlcbiAgICAgICAgcmV0dXJuIGV4cGxpY2l0O1xuICAgICAgaW5wdXQgPSBleHBsaWNpdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBpbnB1dC5vZmZzZXQ7XG5cbiAgICAvLyBVbndyYXAgaW1wbGljaXQgYW5kIG5vcm1hbCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUudXNlID09PSBudWxsICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuX2RlY29kZVRhZyhcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWcsXG4gICAgICAgIHN0YXRlLmFueVxuICAgICAgKTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGJvZHkpKVxuICAgICAgICByZXR1cm4gYm9keTtcblxuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgcmVzdWx0ID0gaW5wdXQucmF3KHNhdmUpO1xuICAgICAgZWxzZVxuICAgICAgICBpbnB1dCA9IGJvZHk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFjayAmJiBzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICBvcHRpb25zLnRyYWNrKGlucHV0LnBhdGgoKSwgc3RhcnQsIGlucHV0Lmxlbmd0aCwgJ3RhZ2dlZCcpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFjayAmJiBzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICBvcHRpb25zLnRyYWNrKGlucHV0LnBhdGgoKSwgaW5wdXQub2Zmc2V0LCBpbnB1dC5sZW5ndGgsICdjb250ZW50Jyk7XG5cbiAgICAvLyBTZWxlY3QgcHJvcGVyIG1ldGhvZCBmb3IgdGFnXG4gICAgaWYgKHN0YXRlLmFueSlcbiAgICAgIHJlc3VsdCA9IHJlc3VsdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQsIG9wdGlvbnMpO1xuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoaW5wdXQuaXNFcnJvcihyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIC8vIERlY29kZSBjaGlsZHJlblxuICAgIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgc3RhdGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiBkZWNvZGVDaGlsZHJlbihjaGlsZCkge1xuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgaWdub3JpbmcgZXJyb3JzIGhlcmUsIHRvIGxldCBwYXJzZXIgY29udGludWUgd2l0aCBvdGhlclxuICAgICAgICAvLyBwYXJ0cyBvZiBlbmNvZGVkIGRhdGFcbiAgICAgICAgY2hpbGQuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgY29udGFpbmVkL2VuY29kZWQgYnkgc2NoZW1hLCBvbmx5IGluIGJpdCBvciBvY3RldCBzdHJpbmdzXG4gICAgaWYgKHN0YXRlLmNvbnRhaW5zICYmIChzdGF0ZS50YWcgPT09ICdvY3RzdHInIHx8IHN0YXRlLnRhZyA9PT0gJ2JpdHN0cicpKSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBEZWNvZGVyQnVmZmVyKHJlc3VsdCk7XG4gICAgICByZXN1bHQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIGlucHV0Ll9yZXBvcnRlclN0YXRlLm9iailcbiAgICAgICAgICAuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBQb3Agb2JqZWN0XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICByZXN1bHQgPSBpbnB1dC5sZWF2ZU9iamVjdChwcmV2T2JqKTtcblxuICAvLyBTZXQga2V5XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwgJiYgKHJlc3VsdCAhPT0gbnVsbCB8fCBwcmVzZW50ID09PSB0cnVlKSlcbiAgICBpbnB1dC5sZWF2ZUtleShwcmV2S2V5LCBzdGF0ZS5rZXksIHJlc3VsdCk7XG4gIGVsc2UgaWYgKHByZXZLZXkgIT09IG51bGwpXG4gICAgaW5wdXQuZXhpdEtleShwcmV2S2V5KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZUdlbmVyaWMgPSBmdW5jdGlvbiBkZWNvZGVHZW5lcmljKHRhZywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdzZXEnIHx8IHRhZyA9PT0gJ3NldCcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0YWcgPT09ICdzZXFvZicgfHwgdGFnID09PSAnc2V0b2YnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVMaXN0KGlucHV0LCB0YWcsIHN0YXRlLmFyZ3NbMF0sIG9wdGlvbnMpO1xuICBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgc3RhdGUuYXJnc1swXSwgc3RhdGUuYXJnc1sxXSwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIG51bGwsIG51bGwsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlVGltZShpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVOdWxsKGlucHV0LCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJvb2woaW5wdXQsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVJbnQoaW5wdXQsIHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJnc1swXSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopXG4gICAgICAgIC5fZGVjb2RlKGlucHV0LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5wdXQuZXJyb3IoJ3Vua25vd24gdGFnOiAnICsgdGFnKTtcbiAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX2dldFVzZSA9IGZ1bmN0aW9uIF9nZXRVc2UoZW50aXR5LCBvYmopIHtcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIC8vIENyZWF0ZSBhbHRlcmVkIHVzZSBkZWNvZGVyIGlmIGltcGxpY2l0IGlzIHNldFxuICBzdGF0ZS51c2VEZWNvZGVyID0gdGhpcy5fdXNlKGVudGl0eSwgb2JqKTtcbiAgYXNzZXJ0KHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmNoaWxkcmVuWzBdO1xuICBpZiAoc3RhdGUuaW1wbGljaXQgIT09IHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5pbXBsaWNpdCkge1xuICAgIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLmNsb25lKCk7XG4gICAgc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0ID0gc3RhdGUuaW1wbGljaXQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnVzZURlY29kZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlQ2hvaWNlID0gZnVuY3Rpb24gZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gIE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkuc29tZShmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtrZXldO1xuICAgIHRyeSB7XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IodmFsdWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJlc3VsdCA9IHsgdHlwZToga2V5LCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gaW5wdXQuZXJyb3IoJ0Nob2ljZSBub3QgbWF0Y2hlZCcpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vL1xuLy8gRW5jb2Rpbmdcbi8vXG5cbk5vZGUucHJvdG90eXBlLl9jcmVhdGVFbmNvZGVyQnVmZmVyID0gZnVuY3Rpb24gY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBuZXcgRW5jb2RlckJ1ZmZlcihkYXRhLCB0aGlzLnJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsICYmIHN0YXRlWydkZWZhdWx0J10gPT09IGRhdGEpXG4gICAgcmV0dXJuO1xuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9lbmNvZGVWYWx1ZShkYXRhLCByZXBvcnRlciwgcGFyZW50KTtcbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybjtcblxuICBpZiAodGhpcy5fc2tpcERlZmF1bHQocmVzdWx0LCByZXBvcnRlciwgcGFyZW50KSlcbiAgICByZXR1cm47XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVWYWx1ZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBEZWNvZGUgcm9vdCBub2RlXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIHN0YXRlLmNoaWxkcmVuWzBdLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIgfHwgbmV3IFJlcG9ydGVyKCkpO1xuXG4gIHZhciByZXN1bHQgPSBudWxsO1xuXG4gIC8vIFNldCByZXBvcnRlciB0byBzaGFyZSBpdCB3aXRoIGEgY2hpbGQgY2xhc3NcbiAgdGhpcy5yZXBvcnRlciA9IHJlcG9ydGVyO1xuXG4gIC8vIENoZWNrIGlmIGRhdGEgaXMgdGhlcmVcbiAgaWYgKHN0YXRlLm9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsKVxuICAgICAgZGF0YSA9IHN0YXRlWydkZWZhdWx0J11cbiAgICBlbHNlXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbmNvZGUgY2hpbGRyZW4gZmlyc3RcbiAgdmFyIGNvbnRlbnQgPSBudWxsO1xuICB2YXIgcHJpbWl0aXZlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAvLyBBbnl0aGluZyB0aGF0IHdhcyBnaXZlbiBpcyB0cmFuc2xhdGVkIHRvIGJ1ZmZlclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hvaWNlKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jb250YWlucykge1xuICAgIGNvbnRlbnQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLnRhZyA9PT0gJ251bGxfJylcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xuXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gcmVwb3J0ZXIuZW50ZXJLZXkoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkpO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIGV4cGVjdGVkLCBidXQgaW5wdXQgaXMgbm90IG9iamVjdCcpO1xuXG4gICAgICB2YXIgcmVzID0gY2hpbGQuX2VuY29kZShkYXRhW2NoaWxkLl9iYXNlU3RhdGUua2V5XSwgcmVwb3J0ZXIsIGRhdGEpO1xuICAgICAgcmVwb3J0ZXIubGVhdmVLZXkocHJldktleSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlLnRhZyA9PT0gJ3NlcW9mJyB8fCBzdGF0ZS50YWcgPT09ICdzZXRvZicpIHtcbiAgICAgIC8vIFRPRE8oaW5kdXRueSk6IHRoaXMgc2hvdWxkIGJlIHRocm93biBvbiBEU0wgbGV2ZWxcbiAgICAgIGlmICghKHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJncy5sZW5ndGggPT09IDEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1RvbyBtYW55IGFyZ3MgZm9yIDogJyArIHN0YXRlLnRhZyk7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdzZXFvZi9zZXRvZiwgYnV0IGRhdGEgaXMgbm90IEFycmF5Jyk7XG5cbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBudWxsO1xuICAgICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZShzdGF0ZS5hcmdzWzBdLCBkYXRhKS5fZW5jb2RlKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIH0sIGNoaWxkKSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS51c2UgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFVzZShzdGF0ZS51c2UsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9lbmNvZGVQcmltaXRpdmUoc3RhdGUudGFnLCBkYXRhKTtcbiAgICAgIHByaW1pdGl2ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5jb2RlIGRhdGEgaXRzZWxmXG4gIHZhciByZXN1bHQ7XG4gIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgIHZhciB0YWcgPSBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnO1xuICAgIHZhciBjbHMgPSBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCA/ICd1bml2ZXJzYWwnIDogJ2NvbnRleHQnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcbiAgICAgICAgcmVwb3J0ZXIuZXJyb3IoJ1RhZyBjb3VsZCBiZSBvbWl0dGVkIG9ubHkgZm9yIC51c2UoKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUodGFnLCBwcmltaXRpdmUsIGNscywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcCBpbiBleHBsaWNpdFxuICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHN0YXRlLmV4cGxpY2l0LCBmYWxzZSwgJ2NvbnRleHQnLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlQ2hvaWNlID0gZnVuY3Rpb24gZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtkYXRhLnR5cGVdO1xuICBpZiAoIW5vZGUpIHtcbiAgICBhc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBkYXRhLnR5cGUgKyAnIG5vdCBmb3VuZCBpbiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkpKTtcbiAgfVxuICByZXR1cm4gbm9kZS5fZW5jb2RlKGRhdGEudmFsdWUsIHJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVQcmltaXRpdmUgPSBmdW5jdGlvbiBlbmNvZGVQcmltaXRpdmUodGFnLCBkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBpZiAoL3N0ciQvLnRlc3QodGFnKSlcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBzdGF0ZS5yZXZlcnNlQXJnc1swXSwgc3RhdGUuYXJnc1sxXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgbnVsbCwgbnVsbCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVUaW1lKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ251bGxfJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlTnVsbCgpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVJbnQoZGF0YSwgc3RhdGUuYXJncyAmJiBzdGF0ZS5yZXZlcnNlQXJnc1swXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2Jvb2wnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVCb29sKGRhdGEpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRhZzogJyArIHRhZyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faXNOdW1zdHIgPSBmdW5jdGlvbiBpc051bXN0cihzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOSBdKiQvLnRlc3Qoc3RyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pc1ByaW50c3RyID0gZnVuY3Rpb24gaXNQcmludHN0cihzdHIpIHtcbiAgcmV0dXJuIC9eW0EtWmEtejAtOSAnXFwoXFwpXFwrLFxcLVxcLlxcLzo9XFw/XSokLy50ZXN0KHN0cik7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gUmVwb3J0ZXIob3B0aW9ucykge1xuICB0aGlzLl9yZXBvcnRlclN0YXRlID0ge1xuICAgIG9iajogbnVsbCxcbiAgICBwYXRoOiBbXSxcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9LFxuICAgIGVycm9yczogW11cbiAgfTtcbn1cbmV4cG9ydHMuUmVwb3J0ZXIgPSBSZXBvcnRlcjtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiBpc0Vycm9yKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICByZXR1cm4geyBvYmo6IHN0YXRlLm9iaiwgcGF0aExlbjogc3RhdGUucGF0aC5sZW5ndGggfTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUub2JqID0gZGF0YS5vYmo7XG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGRhdGEucGF0aExlbik7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJLZXkgPSBmdW5jdGlvbiBlbnRlcktleShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3JlcG9ydGVyU3RhdGUucGF0aC5wdXNoKGtleSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZXhpdEtleSA9IGZ1bmN0aW9uIGV4aXRLZXkoaW5kZXgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5wYXRoID0gc3RhdGUucGF0aC5zbGljZSgwLCBpbmRleCAtIDEpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlS2V5ID0gZnVuY3Rpb24gbGVhdmVLZXkoaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB0aGlzLmV4aXRLZXkoaW5kZXgpO1xuICBpZiAoc3RhdGUub2JqICE9PSBudWxsKVxuICAgIHN0YXRlLm9ialtrZXldID0gdmFsdWU7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gIHJldHVybiB0aGlzLl9yZXBvcnRlclN0YXRlLnBhdGguam9pbignLycpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyT2JqZWN0ID0gZnVuY3Rpb24gZW50ZXJPYmplY3QoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIHByZXYgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHt9O1xuICByZXR1cm4gcHJldjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZU9iamVjdCA9IGZ1bmN0aW9uIGxlYXZlT2JqZWN0KHByZXYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgbm93ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSBwcmV2O1xuICByZXR1cm4gbm93O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHZhciBlcnI7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIGluaGVyaXRlZCA9IG1zZyBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG4gIGlmIChpbmhlcml0ZWQpIHtcbiAgICBlcnIgPSBtc2c7XG4gIH0gZWxzZSB7XG4gICAgZXJyID0gbmV3IFJlcG9ydGVyRXJyb3Ioc3RhdGUucGF0aC5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgJ10nO1xuICAgIH0pLmpvaW4oJycpLCBtc2cubWVzc2FnZSB8fCBtc2csIG1zZy5zdGFjayk7XG4gIH1cblxuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICB0aHJvdyBlcnI7XG5cbiAgaWYgKCFpbmhlcml0ZWQpXG4gICAgc3RhdGUuZXJyb3JzLnB1c2goZXJyKTtcblxuICByZXR1cm4gZXJyO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLndyYXBSZXN1bHQgPSBmdW5jdGlvbiB3cmFwUmVzdWx0KHJlc3VsdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB0aGlzLmlzRXJyb3IocmVzdWx0KSA/IG51bGwgOiByZXN1bHQsXG4gICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlcG9ydGVyRXJyb3IocGF0aCwgbXNnKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMucmV0aHJvdyhtc2cpO1xufTtcbmluaGVyaXRzKFJlcG9ydGVyRXJyb3IsIEVycm9yKTtcblxuUmVwb3J0ZXJFcnJvci5wcm90b3R5cGUucmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3cobXNnKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1zZyArICcgYXQ6ICcgKyAodGhpcy5wYXRoIHx8ICcoc2hhbGxvdyknKTtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcG9ydGVyRXJyb3IpO1xuXG4gIGlmICghdGhpcy5zdGFjaykge1xuICAgIHRyeSB7XG4gICAgICAvLyBJRSBvbmx5IGFkZHMgc3RhY2sgd2hlbiB0aHJvd25cbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbmV4cG9ydHMudGFnQ2xhc3MgPSB7XG4gIDA6ICd1bml2ZXJzYWwnLFxuICAxOiAnYXBwbGljYXRpb24nLFxuICAyOiAnY29udGV4dCcsXG4gIDM6ICdwcml2YXRlJ1xufTtcbmV4cG9ydHMudGFnQ2xhc3NCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWdDbGFzcyk7XG5cbmV4cG9ydHMudGFnID0ge1xuICAweDAwOiAnZW5kJyxcbiAgMHgwMTogJ2Jvb2wnLFxuICAweDAyOiAnaW50JyxcbiAgMHgwMzogJ2JpdHN0cicsXG4gIDB4MDQ6ICdvY3RzdHInLFxuICAweDA1OiAnbnVsbF8nLFxuICAweDA2OiAnb2JqaWQnLFxuICAweDA3OiAnb2JqRGVzYycsXG4gIDB4MDg6ICdleHRlcm5hbCcsXG4gIDB4MDk6ICdyZWFsJyxcbiAgMHgwYTogJ2VudW0nLFxuICAweDBiOiAnZW1iZWQnLFxuICAweDBjOiAndXRmOHN0cicsXG4gIDB4MGQ6ICdyZWxhdGl2ZU9pZCcsXG4gIDB4MTA6ICdzZXEnLFxuICAweDExOiAnc2V0JyxcbiAgMHgxMjogJ251bXN0cicsXG4gIDB4MTM6ICdwcmludHN0cicsXG4gIDB4MTQ6ICd0NjFzdHInLFxuICAweDE1OiAndmlkZW9zdHInLFxuICAweDE2OiAnaWE1c3RyJyxcbiAgMHgxNzogJ3V0Y3RpbWUnLFxuICAweDE4OiAnZ2VudGltZScsXG4gIDB4MTk6ICdncmFwaHN0cicsXG4gIDB4MWE6ICdpc282NDZzdHInLFxuICAweDFiOiAnZ2Vuc3RyJyxcbiAgMHgxYzogJ3VuaXN0cicsXG4gIDB4MWQ6ICdjaGFyc3RyJyxcbiAgMHgxZTogJ2JtcHN0cidcbn07XG5leHBvcnRzLnRhZ0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZyk7XG4iLCJ2YXIgY29uc3RhbnRzID0gZXhwb3J0cztcblxuLy8gSGVscGVyXG5jb25zdGFudHMuX3JldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKG1hcCkge1xuICB2YXIgcmVzID0ge307XG5cbiAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIENvbnZlcnQga2V5IHRvIGludGVnZXIgaWYgaXQgaXMgc3RyaW5naWZpZWRcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcbiAgICAgIGtleSA9IGtleSB8IDA7XG5cbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICByZXNbdmFsdWVdID0ga2V5O1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3RhbnRzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xudmFyIGJpZ251bSA9IGFzbjEuYmlnbnVtO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRGVjb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkRlY29kZXI7XG5cbkRFUkRlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIGlmICghKGRhdGEgaW5zdGFuY2VvZiBiYXNlLkRlY29kZXJCdWZmZXIpKVxuICAgIGRhdGEgPSBuZXcgYmFzZS5EZWNvZGVyQnVmZmVyKGRhdGEsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLnRyZWUuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9wZWVrVGFnID0gZnVuY3Rpb24gcGVla1RhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIGlmIChidWZmZXIuaXNFbXB0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgc3RhdGUgPSBidWZmZXIuc2F2ZSgpO1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsICdGYWlsZWQgdG8gcGVlayB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuXG4gIHJldHVybiBkZWNvZGVkVGFnLnRhZyA9PT0gdGFnIHx8IGRlY29kZWRUYWcudGFnU3RyID09PSB0YWcgfHxcbiAgICAoZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnKSA9PT0gdGFnIHx8IGFueTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUYWcgPSBmdW5jdGlvbiBkZWNvZGVUYWcoYnVmZmVyLCB0YWcsIGFueSkge1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZGVjb2RlIHRhZyBvZiBcIicgKyB0YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGRlY29kZWRUYWcpKVxuICAgIHJldHVybiBkZWNvZGVkVGFnO1xuXG4gIHZhciBsZW4gPSBkZXJEZWNvZGVMZW4oYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRUYWcucHJpbWl0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGxlbmd0aCBvZiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBGYWlsdXJlXG4gIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgaWYgKCFhbnkgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICsgJ29mJyAhPT0gdGFnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRmFpbGVkIHRvIG1hdGNoIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIH1cblxuICBpZiAoZGVjb2RlZFRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gSW5kZWZpbml0ZSBsZW5ndGguLi4gZmluZCBFTkQgdGFnXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciByZXMgPSB0aGlzLl9za2lwVW50aWxFbmQoXG4gICAgICBidWZmZXIsXG4gICAgICAnRmFpbGVkIHRvIHNraXAgaW5kZWZpbml0ZSBsZW5ndGggYm9keTogXCInICsgdGhpcy50YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcblxuICBsZW4gPSBidWZmZXIub2Zmc2V0IC0gc3RhdGUub2Zmc2V0O1xuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG4gIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fc2tpcFVudGlsRW5kID0gZnVuY3Rpb24gc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciB0YWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLCBmYWlsKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IodGFnKSlcbiAgICAgIHJldHVybiB0YWc7XG4gICAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsIHRhZy5wcmltaXRpdmUsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgICAgcmV0dXJuIGxlbjtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgICAgcmVzID0gYnVmZmVyLnNraXAobGVuKVxuICAgIGVsc2VcbiAgICAgIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpO1xuXG4gICAgLy8gRmFpbHVyZVxuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIGlmICh0YWcudGFnU3RyID09PSAnZW5kJylcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlTGlzdCA9IGZ1bmN0aW9uIGRlY29kZUxpc3QoYnVmZmVyLCB0YWcsIGRlY29kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBwb3NzaWJsZUVuZCA9IHRoaXMuX3BlZWtUYWcoYnVmZmVyLCAnZW5kJyk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHBvc3NpYmxlRW5kKSlcbiAgICAgIHJldHVybiBwb3NzaWJsZUVuZDtcblxuICAgIHZhciByZXMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIsICdkZXInLCBvcHRpb25zKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSAmJiBwb3NzaWJsZUVuZClcbiAgICAgIGJyZWFrO1xuICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVTdHIgPSBmdW5jdGlvbiBkZWNvZGVTdHIoYnVmZmVyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICB2YXIgdW51c2VkID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih1bnVzZWQpKVxuICAgICAgcmV0dXJuIHVudXNlZDtcbiAgICByZXR1cm4geyB1bnVzZWQ6IHVudXNlZCwgZGF0YTogYnVmZmVyLnJhdygpIH07XG4gIH0gZWxzZSBpZiAodGFnID09PSAnYm1wc3RyJykge1xuICAgIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gICAgaWYgKHJhdy5sZW5ndGggJSAyID09PSAxKVxuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IGJtcHN0ciBsZW5ndGggbWlzbWF0Y2gnKTtcblxuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJhdy5yZWFkVUludDE2QkUoaSAqIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdudW1zdHInKSB7XG4gICAgdmFyIG51bXN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKG51bXN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ251bXN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBudW1zdHI7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2N0c3RyJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIHZhciBwcmludHN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzUHJpbnRzdHIocHJpbnRzdHIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdwcmludHN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBwcmludHN0cjtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICsgJyB1bnN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlT2JqaWQgPSBmdW5jdGlvbiBkZWNvZGVPYmppZChidWZmZXIsIHZhbHVlcywgcmVsYXRpdmUpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIHZhciBpZGVudCA9IDA7XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBzdWJpZGVudCA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgICBpZGVudCA8PD0gNztcbiAgICBpZGVudCB8PSBzdWJpZGVudCAmIDB4N2Y7XG4gICAgaWYgKChzdWJpZGVudCAmIDB4ODApID09PSAwKSB7XG4gICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcbiAgICAgIGlkZW50ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKHN1YmlkZW50ICYgMHg4MClcbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcblxuICB2YXIgZmlyc3QgPSAoaWRlbnRpZmllcnNbMF0gLyA0MCkgfCAwO1xuICB2YXIgc2Vjb25kID0gaWRlbnRpZmllcnNbMF0gJSA0MDtcblxuICBpZiAocmVsYXRpdmUpXG4gICAgcmVzdWx0ID0gaWRlbnRpZmllcnM7XG4gIGVsc2VcbiAgICByZXN1bHQgPSBbZmlyc3QsIHNlY29uZF0uY29uY2F0KGlkZW50aWZpZXJzLnNsaWNlKDEpKTtcblxuICBpZiAodmFsdWVzKSB7XG4gICAgdmFyIHRtcCA9IHZhbHVlc1tyZXN1bHQuam9pbignICcpXTtcbiAgICBpZiAodG1wID09PSB1bmRlZmluZWQpXG4gICAgICB0bXAgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJy4nKV07XG4gICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVzdWx0ID0gdG1wO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUaW1lID0gZnVuY3Rpb24gZGVjb2RlVGltZShidWZmZXIsIHRhZykge1xuICB2YXIgc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDQpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMiwgMTQpIHwgMDtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDIpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDIsIDQpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgaWYgKHllYXIgPCA3MClcbiAgICAgIHllYXIgPSAyMDAwICsgeWVhcjtcbiAgICBlbHNlXG4gICAgICB5ZWFyID0gMTkwMCArIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2RpbmcgJyArIHRhZyArICcgdGltZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgcmV0dXJuIERhdGUuVVRDKHllYXIsIG1vbiAtIDEsIGRheSwgaG91ciwgbWluLCBzZWMsIDApO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU51bGwgPSBmdW5jdGlvbiBkZWNvZGVOdWxsKGJ1ZmZlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVCb29sID0gZnVuY3Rpb24gZGVjb2RlQm9vbChidWZmZXIpIHtcbiAgdmFyIHJlcyA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcbiAgZWxzZVxuICAgIHJldHVybiByZXMgIT09IDA7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ1ZmZlciwgdmFsdWVzKSB7XG4gIC8vIEJpZ2ludCwgcmV0dXJuIGFzIGl0IGlzIChhc3N1bWUgYmlnIGVuZGlhbilcbiAgdmFyIHJhdyA9IGJ1ZmZlci5yYXcoKTtcbiAgdmFyIHJlcyA9IG5ldyBiaWdudW0ocmF3KTtcblxuICBpZiAodmFsdWVzKVxuICAgIHJlcyA9IHZhbHVlc1tyZXMudG9TdHJpbmcoMTApXSB8fCByZXM7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl91c2UgPSBmdW5jdGlvbiB1c2UoZW50aXR5LCBvYmopIHtcbiAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdmdW5jdGlvbicpXG4gICAgZW50aXR5ID0gZW50aXR5KG9iaik7XG4gIHJldHVybiBlbnRpdHkuX2dldERlY29kZXIoJ2RlcicpLnRyZWU7XG59O1xuXG4vLyBVdGlsaXR5IG1ldGhvZHNcblxuZnVuY3Rpb24gZGVyRGVjb2RlVGFnKGJ1ZiwgZmFpbCkge1xuICB2YXIgdGFnID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKHRhZykpXG4gICAgcmV0dXJuIHRhZztcblxuICB2YXIgY2xzID0gZGVyLnRhZ0NsYXNzW3RhZyA+PiA2XTtcbiAgdmFyIHByaW1pdGl2ZSA9ICh0YWcgJiAweDIwKSA9PT0gMDtcblxuICAvLyBNdWx0aS1vY3RldCB0YWcgLSBsb2FkXG4gIGlmICgodGFnICYgMHgxZikgPT09IDB4MWYpIHtcbiAgICB2YXIgb2N0ID0gdGFnO1xuICAgIHRhZyA9IDA7XG4gICAgd2hpbGUgKChvY3QgJiAweDgwKSA9PT0gMHg4MCkge1xuICAgICAgb2N0ID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICAgIGlmIChidWYuaXNFcnJvcihvY3QpKVxuICAgICAgICByZXR1cm4gb2N0O1xuXG4gICAgICB0YWcgPDw9IDc7XG4gICAgICB0YWcgfD0gb2N0ICYgMHg3ZjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFnICY9IDB4MWY7XG4gIH1cbiAgdmFyIHRhZ1N0ciA9IGRlci50YWdbdGFnXTtcblxuICByZXR1cm4ge1xuICAgIGNsczogY2xzLFxuICAgIHByaW1pdGl2ZTogcHJpbWl0aXZlLFxuICAgIHRhZzogdGFnLFxuICAgIHRhZ1N0cjogdGFnU3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlckRlY29kZUxlbihidWYsIHByaW1pdGl2ZSwgZmFpbCkge1xuICB2YXIgbGVuID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICAvLyBJbmRlZmluaXRlIGZvcm1cbiAgaWYgKCFwcmltaXRpdmUgJiYgbGVuID09PSAweDgwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIC8vIERlZmluaXRlIGZvcm1cbiAgaWYgKChsZW4gJiAweDgwKSA9PT0gMCkge1xuICAgIC8vIFNob3J0IGZvcm1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIHZhciBudW0gPSBsZW4gJiAweDdmO1xuICBpZiAobnVtID4gNClcbiAgICByZXR1cm4gYnVmLmVycm9yKCdsZW5ndGggb2N0ZWN0IGlzIHRvbyBsb25nJyk7XG5cbiAgbGVuID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGxlbiA8PD0gODtcbiAgICB2YXIgaiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgaWYgKGJ1Zi5pc0Vycm9yKGopKVxuICAgICAgcmV0dXJuIGo7XG4gICAgbGVuIHw9IGo7XG4gIH1cblxuICByZXR1cm4gbGVuO1xufVxuIiwidmFyIGRlY29kZXJzID0gZXhwb3J0cztcblxuZGVjb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbmRlY29kZXJzLnBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIERFUkRlY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1EZWNvZGVyKGVudGl0eSkge1xuICBERVJEZWNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1EZWNvZGVyLCBERVJEZWNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRGVjb2RlcjtcblxuUEVNRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cbiAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciByZSA9IC9eLS0tLS0oQkVHSU58RU5EKSAoW14tXSspLS0tLS0kLztcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKHJlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0JFR0lOJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0VORCcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xuXG4gIHZhciBiYXNlNjQgPSBsaW5lcy5zbGljZShzdGFydCArIDEsIGVuZCkuam9pbignJyk7XG4gIC8vIFJlbW92ZSBleGNlc3NpdmUgc3ltYm9sc1xuICBiYXNlNjQucmVwbGFjZSgvW15hLXowLTlcXCtcXC89XSsvZ2ksICcnKTtcblxuICB2YXIgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgaW5wdXQsIG9wdGlvbnMpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRW5jb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkVuY29kZXI7XG5cbkRFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy50cmVlLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpLmpvaW4oKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVDb21wb3NpdGUgPSBmdW5jdGlvbiBlbmNvZGVDb21wb3NpdGUodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xuICB2YXIgZW5jb2RlZFRhZyA9IGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCB0aGlzLnJlcG9ydGVyKTtcblxuICAvLyBTaG9ydCBmb3JtXG4gIGlmIChjb250ZW50Lmxlbmd0aCA8IDB4ODApIHtcbiAgICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigyKTtcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICAgIGhlYWRlclsxXSA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcbiAgdmFyIGxlbk9jdGV0cyA9IDE7XG4gIGZvciAodmFyIGkgPSBjb250ZW50Lmxlbmd0aDsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBsZW5PY3RldHMrKztcblxuICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigxICsgMSArIGxlbk9jdGV0cyk7XG4gIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gIGhlYWRlclsxXSA9IDB4ODAgfCBsZW5PY3RldHM7XG5cbiAgZm9yICh2YXIgaSA9IDEgKyBsZW5PY3RldHMsIGogPSBjb250ZW50Lmxlbmd0aDsgaiA+IDA7IGktLSwgaiA+Pj0gOClcbiAgICBoZWFkZXJbaV0gPSBqICYgMHhmZjtcblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVTdHIgPSBmdW5jdGlvbiBlbmNvZGVTdHIoc3RyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIHN0ci51bnVzZWQgfCAwLCBzdHIuZGF0YSBdKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShzdHIuY2hhckNvZGVBdChpKSwgaSAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogbnVtc3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgZGlnaXRzIGFuZCBzcGFjZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IHByaW50c3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgbGF0aW4gdXBwZXIgYW5kIGxvd2VyIGNhc2UgbGV0dGVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlnaXRzLCBzcGFjZSwgYXBvc3Ryb3BoZSwgbGVmdCBhbmQgcmlndGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50aGVzaXMsIHBsdXMgc2lnbiwgY29tbWEsIGh5cGhlbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZG90LCBzbGFzaCwgY29sb24sIGVxdWFsIHNpZ24sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3F1ZXN0aW9uIG1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKCFudW0uc2lnbiAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiIsInZhciBlbmNvZGVycyA9IGV4cG9ydHM7XG5cbmVuY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5lbmNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIERFUkVuY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1FbmNvZGVyKGVudGl0eSkge1xuICBERVJFbmNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1FbmNvZGVyLCBERVJFbmNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRW5jb2RlcjtcblxuUEVNRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJ1ZiA9IERFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gIHZhciBwID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIG91dCA9IFsgJy0tLS0tQkVHSU4gJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gNjQpXG4gICAgb3V0LnB1c2gocC5zbGljZShpLCBpICsgNjQpKTtcbiAgb3V0LnB1c2goJy0tLS0tRU5EICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyk7XG4gIHJldHVybiBvdXQuam9pbignXFxuJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleCAoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgPDw9IDQ7XG5cbiAgICAgIC8vICdhJyAtICdmJ1xuICAgICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NCkge1xuICAgICAgICByIHw9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnIC0gJ0YnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcgJiYgYyA8PSAyMikge1xuICAgICAgICByIHw9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByIHw9IGMgJiAweGY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCkge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuICAgIHZhciBvZmYgPSAwO1xuICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAvLyBOT1RFOiBgMHgzZmZmZmZgIGlzIGludGVudGlvbmFsIGhlcmUsIDI2Yml0cyBtYXggc2hpZnQgKyAyNGJpdCBoZXggbGltYlxuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgICAgb2ZmICs9IDI0O1xuICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgKyA2ICE9PSBzdGFydCkge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgciArPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgKz0gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfTtcblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2RuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuICAgIHZhciBsaXR0bGVFbmRpYW4gPSBlbmRpYW4gPT09ICdsZSc7XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuICAgIHZhciBiLCBpO1xuICAgIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJlcUxlbmd0aCAtIGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbcmVxTGVuZ3RoIC0gaSAtIDFdID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW2ldID0gYjtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdICYgKDEgPDwgd2JpdCkpID4+PiB3Yml0O1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDwgbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5zdHJpcCgpO1xuICAgIH1cbiAgICBhLnN0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5zdHJpcCgpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCJ2YXIgcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByYW5kKGxlbikge1xuICBpZiAoIXIpXG4gICAgciA9IG5ldyBSYW5kKG51bGwpO1xuXG4gIHJldHVybiByLmdlbmVyYXRlKGxlbik7XG59O1xuXG5mdW5jdGlvbiBSYW5kKHJhbmQpIHtcbiAgdGhpcy5yYW5kID0gcmFuZDtcbn1cbm1vZHVsZS5leHBvcnRzLlJhbmQgPSBSYW5kO1xuXG5SYW5kLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbikge1xuICByZXR1cm4gdGhpcy5fcmFuZChsZW4pO1xufTtcblxuLy8gRW11bGF0ZSBjcnlwdG8gQVBJIHVzaW5nIHJhbmR5XG5SYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgaWYgKHRoaXMucmFuZC5nZXRCeXRlcylcbiAgICByZXR1cm4gdGhpcy5yYW5kLmdldEJ5dGVzKG4pO1xuXG4gIHZhciByZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspXG4gICAgcmVzW2ldID0gdGhpcy5yYW5kLmdldEJ5dGUoKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcpIHtcbiAgaWYgKHNlbGYuY3J5cHRvICYmIHNlbGYuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIE1vZGVybiBicm93c2Vyc1xuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc2VsZi5tc0NyeXB0byAmJiBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIElFXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gIC8vIFNhZmFyaSdzIFdlYldvcmtlcnMgZG8gbm90IGhhdmUgYGNyeXB0b2BcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE9sZCBqdW5rXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH07XG4gIH1cbn0gZWxzZSB7XG4gIC8vIE5vZGUuanMgb3IgV2ViIHdvcmtlciB3aXRoIG5vIGNyeXB0byBzdXBwb3J0XG4gIHRyeSB7XG4gICAgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMobik7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG4iLCIiLCIvLyBiYXNlZCBvbiB0aGUgYWVzIGltcGxpbWVudGF0aW9uIGluIHRyaXBsZSBzZWNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXliYXNlL3RyaXBsZXNlY1xuLy8gd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiB0aGUgb25lIGZyb20gY3J5cHRvLWpzXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIGFzVUludDMyQXJyYXkgKGJ1Zikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG5cbiAgdmFyIGxlbiA9IChidWYubGVuZ3RoIC8gNCkgfCAwXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBzY3J1YlZlYyAodikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyB2KyspIHtcbiAgICB2W2ldID0gMFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyeXB0QmxvY2sgKE0sIGtleVNjaGVkdWxlLCBTVUJfTUlYLCBTQk9YLCBuUm91bmRzKSB7XG4gIHZhciBTVUJfTUlYMCA9IFNVQl9NSVhbMF1cbiAgdmFyIFNVQl9NSVgxID0gU1VCX01JWFsxXVxuICB2YXIgU1VCX01JWDIgPSBTVUJfTUlYWzJdXG4gIHZhciBTVUJfTUlYMyA9IFNVQl9NSVhbM11cblxuICB2YXIgczAgPSBNWzBdIF4ga2V5U2NoZWR1bGVbMF1cbiAgdmFyIHMxID0gTVsxXSBeIGtleVNjaGVkdWxlWzFdXG4gIHZhciBzMiA9IE1bMl0gXiBrZXlTY2hlZHVsZVsyXVxuICB2YXIgczMgPSBNWzNdIF4ga2V5U2NoZWR1bGVbM11cbiAgdmFyIHQwLCB0MSwgdDIsIHQzXG4gIHZhciBrc1JvdyA9IDRcblxuICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuICAgIHQwID0gU1VCX01JWDBbczAgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MSA9IFNVQl9NSVgwW3MxID4+PiAyNF0gXiBTVUJfTUlYMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDIgPSBTVUJfTUlYMFtzMiA+Pj4gMjRdIF4gU1VCX01JWDFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQzID0gU1VCX01JWDBbczMgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICBzMCA9IHQwXG4gICAgczEgPSB0MVxuICAgIHMyID0gdDJcbiAgICBzMyA9IHQzXG4gIH1cblxuICB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQwID0gdDAgPj4+IDBcbiAgdDEgPSB0MSA+Pj4gMFxuICB0MiA9IHQyID4+PiAwXG4gIHQzID0gdDMgPj4+IDBcblxuICByZXR1cm4gW3QwLCB0MSwgdDIsIHQzXVxufVxuXG4vLyBBRVMgY29uc3RhbnRzXG52YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XVxudmFyIEcgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuICB2YXIgZCA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMjU2OyBqKyspIHtcbiAgICBpZiAoaiA8IDEyOCkge1xuICAgICAgZFtqXSA9IGogPDwgMVxuICAgIH0gZWxzZSB7XG4gICAgICBkW2pdID0gKGogPDwgMSkgXiAweDExYlxuICAgIH1cbiAgfVxuXG4gIHZhciBTQk9YID0gW11cbiAgdmFyIElOVl9TQk9YID0gW11cbiAgdmFyIFNVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHZhciBJTlZfU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cblxuICAvLyBXYWxrIEdGKDJeOClcbiAgdmFyIHggPSAwXG4gIHZhciB4aSA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIC8vIENvbXB1dGUgc2JveFxuICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpXG4gICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzXG4gICAgU0JPWFt4XSA9IHN4XG4gICAgSU5WX1NCT1hbc3hdID0geFxuXG4gICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgIHZhciB4MiA9IGRbeF1cbiAgICB2YXIgeDQgPSBkW3gyXVxuICAgIHZhciB4OCA9IGRbeDRdXG5cbiAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApXG4gICAgU1VCX01JWFswXVt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIFNVQl9NSVhbMV1beF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgU1VCX01JWFsyXVt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIFNVQl9NSVhbM11beF0gPSB0XG5cbiAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApXG4gICAgSU5WX1NVQl9NSVhbMF1bc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgSU5WX1NVQl9NSVhbMV1bc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIElOVl9TVUJfTUlYWzJdW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIElOVl9TVUJfTUlYWzNdW3N4XSA9IHRcblxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICB4ID0geGkgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV1cbiAgICAgIHhpIF49IGRbZFt4aV1dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBTQk9YOiBTQk9YLFxuICAgIElOVl9TQk9YOiBJTlZfU0JPWCxcbiAgICBTVUJfTUlYOiBTVUJfTUlYLFxuICAgIElOVl9TVUJfTUlYOiBJTlZfU1VCX01JWFxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIEFFUyAoa2V5KSB7XG4gIHRoaXMuX2tleSA9IGFzVUludDMyQXJyYXkoa2V5KVxuICB0aGlzLl9yZXNldCgpXG59XG5cbkFFUy5ibG9ja1NpemUgPSA0ICogNFxuQUVTLmtleVNpemUgPSAyNTYgLyA4XG5BRVMucHJvdG90eXBlLmJsb2NrU2l6ZSA9IEFFUy5ibG9ja1NpemVcbkFFUy5wcm90b3R5cGUua2V5U2l6ZSA9IEFFUy5rZXlTaXplXG5BRVMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGtleVdvcmRzID0gdGhpcy5fa2V5XG4gIHZhciBrZXlTaXplID0ga2V5V29yZHMubGVuZ3RoXG4gIHZhciBuUm91bmRzID0ga2V5U2l6ZSArIDZcbiAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0XG5cbiAgdmFyIGtleVNjaGVkdWxlID0gW11cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlTaXplOyBrKyspIHtcbiAgICBrZXlTY2hlZHVsZVtrXSA9IGtleVdvcmRzW2tdXG4gIH1cblxuICBmb3IgKGsgPSBrZXlTaXplOyBrIDwga3NSb3dzOyBrKyspIHtcbiAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2sgLSAxXVxuXG4gICAgaWYgKGsgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgICB0ID1cbiAgICAgICAgKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgIChHLlNCT1hbdCAmIDB4ZmZdKVxuXG4gICAgICB0IF49IFJDT05bKGsgLyBrZXlTaXplKSB8IDBdIDw8IDI0XG4gICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgdCA9XG4gICAgICAgIChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAoRy5TQk9YW3QgJiAweGZmXSlcbiAgICB9XG5cbiAgICBrZXlTY2hlZHVsZVtrXSA9IGtleVNjaGVkdWxlW2sgLSBrZXlTaXplXSBeIHRcbiAgfVxuXG4gIHZhciBpbnZLZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAodmFyIGlrID0gMDsgaWsgPCBrc1Jvd3M7IGlrKyspIHtcbiAgICB2YXIga3NSID0ga3NSb3dzIC0gaWtcbiAgICB2YXIgdHQgPSBrZXlTY2hlZHVsZVtrc1IgLSAoaWsgJSA0ID8gMCA6IDQpXVxuXG4gICAgaWYgKGlrIDwgNCB8fCBrc1IgPD0gNCkge1xuICAgICAgaW52S2V5U2NoZWR1bGVbaWtdID0gdHRcbiAgICB9IGVsc2Uge1xuICAgICAgaW52S2V5U2NoZWR1bGVbaWtdID1cbiAgICAgICAgRy5JTlZfU1VCX01JWFswXVtHLlNCT1hbdHQgPj4+IDI0XV0gXlxuICAgICAgICBHLklOVl9TVUJfTUlYWzFdW0cuU0JPWFsodHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG4gICAgICAgIEcuSU5WX1NVQl9NSVhbMl1bRy5TQk9YWyh0dCA+Pj4gOCkgJiAweGZmXV0gXlxuICAgICAgICBHLklOVl9TVUJfTUlYWzNdW0cuU0JPWFt0dCAmIDB4ZmZdXVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX25Sb3VuZHMgPSBuUm91bmRzXG4gIHRoaXMuX2tleVNjaGVkdWxlID0ga2V5U2NoZWR1bGVcbiAgdGhpcy5faW52S2V5U2NoZWR1bGUgPSBpbnZLZXlTY2hlZHVsZVxufVxuXG5BRVMucHJvdG90eXBlLmVuY3J5cHRCbG9ja1JhdyA9IGZ1bmN0aW9uIChNKSB7XG4gIE0gPSBhc1VJbnQzMkFycmF5KE0pXG4gIHJldHVybiBjcnlwdEJsb2NrKE0sIHRoaXMuX2tleVNjaGVkdWxlLCBHLlNVQl9NSVgsIEcuU0JPWCwgdGhpcy5fblJvdW5kcylcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgb3V0ID0gdGhpcy5lbmNyeXB0QmxvY2tSYXcoTSlcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLmRlY3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNKSB7XG4gIE0gPSBhc1VJbnQzMkFycmF5KE0pXG5cbiAgLy8gc3dhcFxuICB2YXIgbTEgPSBNWzFdXG4gIE1bMV0gPSBNWzNdXG4gIE1bM10gPSBtMVxuXG4gIHZhciBvdXQgPSBjcnlwdEJsb2NrKE0sIHRoaXMuX2ludktleVNjaGVkdWxlLCBHLklOVl9TVUJfTUlYLCBHLklOVl9TQk9YLCB0aGlzLl9uUm91bmRzKVxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuc2NydWIgPSBmdW5jdGlvbiAoKSB7XG4gIHNjcnViVmVjKHRoaXMuX2tleVNjaGVkdWxlKVxuICBzY3J1YlZlYyh0aGlzLl9pbnZLZXlTY2hlZHVsZSlcbiAgc2NydWJWZWModGhpcy5fa2V5KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5BRVMgPSBBRVNcbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgR0hBU0ggPSByZXF1aXJlKCcuL2doYXNoJylcbnZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcbnZhciBpbmNyMzIgPSByZXF1aXJlKCcuL2luY3IzMicpXG5cbmZ1bmN0aW9uIHhvclRlc3QgKGEsIGIpIHtcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgb3V0KytcblxuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgb3V0ICs9IChhW2ldIF4gYltpXSlcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gY2FsY0l2IChzZWxmLCBpdiwgY2spIHtcbiAgaWYgKGl2Lmxlbmd0aCA9PT0gMTIpIHtcbiAgICBzZWxmLl9maW5JRCA9IEJ1ZmZlci5jb25jYXQoW2l2LCBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMV0pXSlcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbaXYsIEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAyXSldKVxuICB9XG4gIHZhciBnaGFzaCA9IG5ldyBHSEFTSChjaylcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgdG9QYWQgPSBsZW4gJSAxNlxuICBnaGFzaC51cGRhdGUoaXYpXG4gIGlmICh0b1BhZCkge1xuICAgIHRvUGFkID0gMTYgLSB0b1BhZFxuICAgIGdoYXNoLnVwZGF0ZShCdWZmZXIuYWxsb2ModG9QYWQsIDApKVxuICB9XG4gIGdoYXNoLnVwZGF0ZShCdWZmZXIuYWxsb2MoOCwgMCkpXG4gIHZhciBpdkJpdHMgPSBsZW4gKiA4XG4gIHZhciB0YWlsID0gQnVmZmVyLmFsbG9jKDgpXG4gIHRhaWwud3JpdGVVSW50QkUoaXZCaXRzLCAwLCA4KVxuICBnaGFzaC51cGRhdGUodGFpbClcbiAgc2VsZi5fZmluSUQgPSBnaGFzaC5zdGF0ZVxuICB2YXIgb3V0ID0gQnVmZmVyLmZyb20oc2VsZi5fZmluSUQpXG4gIGluY3IzMihvdXQpXG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHZhciBoID0gQnVmZmVyLmFsbG9jKDQsIDApXG5cbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB2YXIgY2sgPSB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGgpXG4gIHRoaXMuX2doYXNoID0gbmV3IEdIQVNIKGNrKVxuICBpdiA9IGNhbGNJdih0aGlzLCBpdiwgY2spXG5cbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9zZWNDYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9hbGVuID0gMFxuICB0aGlzLl9sZW4gPSAwXG4gIHRoaXMuX21vZGUgPSBtb2RlXG5cbiAgdGhpcy5fYXV0aFRhZyA9IG51bGxcbiAgdGhpcy5fY2FsbGVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBpZiAoIXRoaXMuX2NhbGxlZCAmJiB0aGlzLl9hbGVuKSB7XG4gICAgdmFyIHJ1bXAgPSAxNiAtICh0aGlzLl9hbGVuICUgMTYpXG4gICAgaWYgKHJ1bXAgPCAxNikge1xuICAgICAgcnVtcCA9IEJ1ZmZlci5hbGxvYyhydW1wLCAwKVxuICAgICAgdGhpcy5fZ2hhc2gudXBkYXRlKHJ1bXApXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2FsbGVkID0gdHJ1ZVxuICB2YXIgb3V0ID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShjaHVuaylcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUob3V0KVxuICB9XG4gIHRoaXMuX2xlbiArPSBjaHVuay5sZW5ndGhcbiAgcmV0dXJuIG91dFxufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQgJiYgIXRoaXMuX2F1dGhUYWcpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcblxuICB2YXIgdGFnID0geG9yKHRoaXMuX2doYXNoLmZpbmFsKHRoaXMuX2FsZW4gKiA4LCB0aGlzLl9sZW4gKiA4KSwgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl9maW5JRCkpXG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmIHhvclRlc3QodGFnLCB0aGlzLl9hdXRoVGFnKSkgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuXG4gIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gZ2V0QXV0aFRhZyAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0IHx8ICFCdWZmZXIuaXNCdWZmZXIodGhpcy5fYXV0aFRhZykpIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuXG4gIHJldHVybiB0aGlzLl9hdXRoVGFnXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uIHNldEF1dGhUYWcgKHRhZykge1xuICBpZiAoIXRoaXMuX2RlY3J5cHQpIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuXG4gIHRoaXMuX2F1dGhUYWcgPSB0YWdcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiBzZXRBQUQgKGJ1Zikge1xuICBpZiAodGhpcy5fY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IEFBRCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG5cbiAgdGhpcy5fZ2hhc2gudXBkYXRlKGJ1ZilcbiAgdGhpcy5fYWxlbiArPSBidWYubGVuZ3RoXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG4iLCJ2YXIgY2lwaGVycyA9IHJlcXVpcmUoJy4vZW5jcnlwdGVyJylcbnZhciBkZWNpcGhlcnMgPSByZXF1aXJlKCcuL2RlY3J5cHRlcicpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzL2xpc3QuanNvbicpXG5cbmZ1bmN0aW9uIGdldENpcGhlcnMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobW9kZXMpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gZXhwb3J0cy5DaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZUNpcGhlclxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGV4cG9ydHMuQ2lwaGVyaXYgPSBjaXBoZXJzLmNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGRlY2lwaGVycy5jcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gZXhwb3J0cy5EZWNpcGhlcml2ID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXZcbmV4cG9ydHMubGlzdENpcGhlcnMgPSBleHBvcnRzLmdldENpcGhlcnMgPSBnZXRDaXBoZXJzXG4iLCJ2YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBNT0RFUyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIERlY2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9sYXN0ID0gdm9pZCAwXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cblxuaW5oZXJpdHMoRGVjaXBoZXIsIFRyYW5zZm9ybSlcblxuRGVjaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCh0aGlzLl9hdXRvcGFkZGluZykpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuXG5EZWNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIHJldHVybiB1bnBhZCh0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspKVxuICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5cbkRlY2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXV0b1BhZGRpbmcpIHtcbiAgdmFyIG91dFxuICBpZiAoYXV0b1BhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2FjaGVcbn1cblxuZnVuY3Rpb24gdW5wYWQgKGxhc3QpIHtcbiAgdmFyIHBhZGRlZCA9IGxhc3RbMTVdXG4gIGlmIChwYWRkZWQgPCAxIHx8IHBhZGRlZCA+IDE2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgfVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBwYWRkZWQpIHtcbiAgICBpZiAobGFzdFsoaSArICgxNiAtIHBhZGRlZCkpXSAhPT0gcGFkZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZWNyeXB0IGRhdGEnKVxuICAgIH1cbiAgfVxuICBpZiAocGFkZGVkID09PSAxNikgcmV0dXJuXG5cbiAgcmV0dXJuIGxhc3Quc2xpY2UoMCwgMTYgLSBwYWRkZWQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSBpdiA9IEJ1ZmZlci5mcm9tKGl2KVxuICBpZiAoY29uZmlnLm1vZGUgIT09ICdHQ00nICYmIGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuXG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkKVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG5cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfVxuXG4gIHJldHVybiBuZXcgRGVjaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG4iLCJ2YXIgTU9ERVMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIENpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuXG5pbmhlcml0cyhDaXBoZXIsIFRyYW5zZm9ybSlcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG5cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCgpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuXG52YXIgUEFERElORyA9IEJ1ZmZlci5hbGxvYygxNiwgMHgxMClcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgY2h1bmsgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICByZXR1cm4gY2h1bmtcbiAgfVxuXG4gIGlmICghY2h1bmsuZXF1YWxzKFBBRERJTkcpKSB7XG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cblxuQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE1KSB7XG4gICAgdmFyIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIHJldHVybiBudWxsXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IDE2IC0gdGhpcy5jYWNoZS5sZW5ndGhcbiAgdmFyIHBhZEJ1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZEJ1ZmYud3JpdGVVSW50OChsZW4sIGkpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgcGFkQnVmZl0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZClcbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuXG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSBpdiA9IEJ1ZmZlci5mcm9tKGl2KVxuICBpZiAoY29uZmlnLm1vZGUgIT09ICdHQ00nICYmIGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuXG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG4gIH1cblxuICByZXR1cm4gbmV3IENpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBjcmVhdGVDaXBoZXJcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFpFUk9FUyA9IEJ1ZmZlci5hbGxvYygxNiwgMClcblxuZnVuY3Rpb24gdG9BcnJheSAoYnVmKSB7XG4gIHJldHVybiBbXG4gICAgYnVmLnJlYWRVSW50MzJCRSgwKSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoOCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSgxMilcbiAgXVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKG91dCkge1xuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0gPj4+IDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSA+Pj4gMCwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdID4+PiAwLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10gPj4+IDAsIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIEdIQVNIIChrZXkpIHtcbiAgdGhpcy5oID0ga2V5XG4gIHRoaXMuc3RhdGUgPSBCdWZmZXIuYWxsb2MoMTYsIDApXG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbn1cblxuLy8gZnJvbSBodHRwOi8vYml0d2lzZXNoaWZ0bGVmdC5naXRodWIuaW8vc2pjbC9kb2Mvc3ltYm9scy9zcmMvY29yZV9nY20uanMuaHRtbFxuLy8gYnkgSnVobyBWw6Row6QtSGVydHR1YVxuR0hBU0gucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGJsb2NrLmxlbmd0aCkge1xuICAgIHRoaXMuc3RhdGVbaV0gXj0gYmxvY2tbaV1cbiAgfVxuICB0aGlzLl9tdWx0aXBseSgpXG59XG5cbkdIQVNILnByb3RvdHlwZS5fbXVsdGlwbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBWaSA9IHRvQXJyYXkodGhpcy5oKVxuICB2YXIgWmkgPSBbMCwgMCwgMCwgMF1cbiAgdmFyIGosIHhpLCBsc2JWaVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCAxMjgpIHtcbiAgICB4aSA9ICh0aGlzLnN0YXRlW35+KGkgLyA4KV0gJiAoMSA8PCAoNyAtIChpICUgOCkpKSkgIT09IDBcbiAgICBpZiAoeGkpIHtcbiAgICAgIC8vIFpfaSsxID0gWl9pIF4gVl9pXG4gICAgICBaaVswXSBePSBWaVswXVxuICAgICAgWmlbMV0gXj0gVmlbMV1cbiAgICAgIFppWzJdIF49IFZpWzJdXG4gICAgICBaaVszXSBePSBWaVszXVxuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSB2YWx1ZSBvZiBMU0IoVl9pKVxuICAgIGxzYlZpID0gKFZpWzNdICYgMSkgIT09IDBcblxuICAgIC8vIFZfaSsxID0gVl9pID4+IDFcbiAgICBmb3IgKGogPSAzOyBqID4gMDsgai0tKSB7XG4gICAgICBWaVtqXSA9IChWaVtqXSA+Pj4gMSkgfCAoKFZpW2ogLSAxXSAmIDEpIDw8IDMxKVxuICAgIH1cbiAgICBWaVswXSA9IFZpWzBdID4+PiAxXG5cbiAgICAvLyBJZiBMU0IoVl9pKSBpcyAxLCBWX2krMSA9IChWX2kgPj4gMSkgXiBSXG4gICAgaWYgKGxzYlZpKSB7XG4gICAgICBWaVswXSA9IFZpWzBdIF4gKDB4ZTEgPDwgMjQpXG4gICAgfVxuICB9XG4gIHRoaXMuc3RhdGUgPSBmcm9tQXJyYXkoWmkpXG59XG5cbkdIQVNILnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBidWZdKVxuICB2YXIgY2h1bmtcbiAgd2hpbGUgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgY2h1bmsgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHRoaXMuZ2hhc2goY2h1bmspXG4gIH1cbn1cblxuR0hBU0gucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gKGFibCwgYmwpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5naGFzaChCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBaRVJPRVNdLCAxNikpXG4gIH1cblxuICB0aGlzLmdoYXNoKGZyb21BcnJheShbMCwgYWJsLCAwLCBibF0pKVxuICByZXR1cm4gdGhpcy5zdGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdIQVNIXG4iLCJmdW5jdGlvbiBpbmNyMzIgKGl2KSB7XG4gIHZhciBsZW4gPSBpdi5sZW5ndGhcbiAgdmFyIGl0ZW1cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaXRlbSA9IGl2LnJlYWRVSW50OChsZW4pXG4gICAgaWYgKGl0ZW0gPT09IDI1NSkge1xuICAgICAgaXYud3JpdGVVSW50OCgwLCBsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0rK1xuICAgICAgaXYud3JpdGVVSW50OChpdGVtLCBsZW4pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNyMzJcbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBkYXRhID0geG9yKGJsb2NrLCBzZWxmLl9wcmV2KVxuXG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGRhdGEpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZGVjcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICB2YXIgcGFkID0gc2VsZi5fcHJldlxuXG4gIHNlbGYuX3ByZXYgPSBibG9ja1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmRlY3J5cHRCbG9jayhibG9jaylcblxuICByZXR1cm4geG9yKG91dCwgcGFkKVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGVuY3J5cHRTdGFydCAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIG91dCA9IHhvcihkYXRhLCBzZWxmLl9jYWNoZSlcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShsZW4pXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LCBkZWNyeXB0ID8gZGF0YSA6IG91dF0pXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB2YXIgbGVuXG5cbiAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgICBzZWxmLl9wcmV2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgbGVuID0gc2VsZi5fY2FjaGUubGVuZ3RoXG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLnNsaWNlKDAsIGxlbiksIGRlY3J5cHQpXSlcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YSwgZGVjcnlwdCldKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkXG4gIHZhciBpID0gLTFcbiAgdmFyIGxlbiA9IDhcbiAgdmFyIG91dCA9IDBcbiAgdmFyIGJpdCwgdmFsdWVcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICBiaXQgPSAoYnl0ZVBhcmFtICYgKDEgPDwgKDcgLSBpKSkpID8gMHg4MCA6IDBcbiAgICB2YWx1ZSA9IHBhZFswXSBeIGJpdFxuICAgIG91dCArPSAoKHZhbHVlICYgMHg4MCkgPj4gKGkgJSA4KSlcbiAgICBzZWxmLl9wcmV2ID0gc2hpZnRJbihzZWxmLl9wcmV2LCBkZWNyeXB0ID8gYml0IDogdmFsdWUpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBzaGlmdEluIChidWZmZXIsIHZhbHVlKSB7XG4gIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoXG4gIHZhciBpID0gLTFcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZmZXIubGVuZ3RoKVxuICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIEJ1ZmZlci5mcm9tKFt2YWx1ZV0pXSlcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmZmVyW2ldIDw8IDEgfCBidWZmZXJbaSArIDFdID4+ICg3KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcbiAgdmFyIGkgPSAtMVxuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHZhciBvdXQgPSBwYWRbMF0gXiBieXRlUGFyYW1cblxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgc2VsZi5fcHJldi5zbGljZSgxKSxcbiAgICBCdWZmZXIuZnJvbShbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXG4gIF0pXG5cbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcbiAgdmFyIGkgPSAtMVxuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGluY3IzMiA9IHJlcXVpcmUoJy4uL2luY3IzMicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrUmF3KHNlbGYuX3ByZXYpXG4gIGluY3IzMihzZWxmLl9wcmV2KVxuICByZXR1cm4gb3V0XG59XG5cbnZhciBibG9ja1NpemUgPSAxNlxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHZhciBjaHVua051bSA9IE1hdGguY2VpbChjaHVuay5sZW5ndGggLyBibG9ja1NpemUpXG4gIHZhciBzdGFydCA9IHNlbGYuX2NhY2hlLmxlbmd0aFxuICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIHNlbGYuX2NhY2hlLFxuICAgIEJ1ZmZlci5hbGxvY1Vuc2FmZShjaHVua051bSAqIGJsb2NrU2l6ZSlcbiAgXSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua051bTsgaSsrKSB7XG4gICAgdmFyIG91dCA9IGdldEJsb2NrKHNlbGYpXG4gICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgaSAqIGJsb2NrU2l6ZVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzBdLCBvZmZzZXQgKyAwKVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzFdLCBvZmZzZXQgKyA0KVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzJdLCBvZmZzZXQgKyA4KVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzNdLCBvZmZzZXQgKyAxMilcbiAgfVxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuIiwiZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGJsb2NrKVxufVxuXG5leHBvcnRzLmRlY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgcmV0dXJuIHNlbGYuX2NpcGhlci5kZWNyeXB0QmxvY2soYmxvY2spXG59XG4iLCJ2YXIgbW9kZU1vZHVsZXMgPSB7XG4gIEVDQjogcmVxdWlyZSgnLi9lY2InKSxcbiAgQ0JDOiByZXF1aXJlKCcuL2NiYycpLFxuICBDRkI6IHJlcXVpcmUoJy4vY2ZiJyksXG4gIENGQjg6IHJlcXVpcmUoJy4vY2ZiOCcpLFxuICBDRkIxOiByZXF1aXJlKCcuL2NmYjEnKSxcbiAgT0ZCOiByZXF1aXJlKCcuL29mYicpLFxuICBDVFI6IHJlcXVpcmUoJy4vY3RyJyksXG4gIEdDTTogcmVxdWlyZSgnLi9jdHInKVxufVxuXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL2xpc3QuanNvbicpXG5cbmZvciAodmFyIGtleSBpbiBtb2Rlcykge1xuICBtb2Rlc1trZXldLm1vZHVsZSA9IG1vZGVNb2R1bGVzW21vZGVzW2tleV0ubW9kZV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb2Rlc1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImFlcy0xMjgtZWNiXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDEyOCxcbiAgICBcIml2XCI6IDAsXG4gICAgXCJtb2RlXCI6IFwiRUNCXCIsXG4gICAgXCJ0eXBlXCI6IFwiYmxvY2tcIlxuICB9LFxuICBcImFlcy0xOTItZWNiXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDE5MixcbiAgICBcIml2XCI6IDAsXG4gICAgXCJtb2RlXCI6IFwiRUNCXCIsXG4gICAgXCJ0eXBlXCI6IFwiYmxvY2tcIlxuICB9LFxuICBcImFlcy0yNTYtZWNiXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDI1NixcbiAgICBcIml2XCI6IDAsXG4gICAgXCJtb2RlXCI6IFwiRUNCXCIsXG4gICAgXCJ0eXBlXCI6IFwiYmxvY2tcIlxuICB9LFxuICBcImFlcy0xMjgtY2JjXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDEyOCxcbiAgICBcIml2XCI6IDE2LFxuICAgIFwibW9kZVwiOiBcIkNCQ1wiLFxuICAgIFwidHlwZVwiOiBcImJsb2NrXCJcbiAgfSxcbiAgXCJhZXMtMTkyLWNiY1wiOiB7XG4gICAgXCJjaXBoZXJcIjogXCJBRVNcIixcbiAgICBcImtleVwiOiAxOTIsXG4gICAgXCJpdlwiOiAxNixcbiAgICBcIm1vZGVcIjogXCJDQkNcIixcbiAgICBcInR5cGVcIjogXCJibG9ja1wiXG4gIH0sXG4gIFwiYWVzLTI1Ni1jYmNcIjoge1xuICAgIFwiY2lwaGVyXCI6IFwiQUVTXCIsXG4gICAgXCJrZXlcIjogMjU2LFxuICAgIFwiaXZcIjogMTYsXG4gICAgXCJtb2RlXCI6IFwiQ0JDXCIsXG4gICAgXCJ0eXBlXCI6IFwiYmxvY2tcIlxuICB9LFxuICBcImFlczEyOFwiOiB7XG4gICAgXCJjaXBoZXJcIjogXCJBRVNcIixcbiAgICBcImtleVwiOiAxMjgsXG4gICAgXCJpdlwiOiAxNixcbiAgICBcIm1vZGVcIjogXCJDQkNcIixcbiAgICBcInR5cGVcIjogXCJibG9ja1wiXG4gIH0sXG4gIFwiYWVzMTkyXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDE5MixcbiAgICBcIml2XCI6IDE2LFxuICAgIFwibW9kZVwiOiBcIkNCQ1wiLFxuICAgIFwidHlwZVwiOiBcImJsb2NrXCJcbiAgfSxcbiAgXCJhZXMyNTZcIjoge1xuICAgIFwiY2lwaGVyXCI6IFwiQUVTXCIsXG4gICAgXCJrZXlcIjogMjU2LFxuICAgIFwiaXZcIjogMTYsXG4gICAgXCJtb2RlXCI6IFwiQ0JDXCIsXG4gICAgXCJ0eXBlXCI6IFwiYmxvY2tcIlxuICB9LFxuICBcImFlcy0xMjgtY2ZiXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDEyOCxcbiAgICBcIml2XCI6IDE2LFxuICAgIFwibW9kZVwiOiBcIkNGQlwiLFxuICAgIFwidHlwZVwiOiBcInN0cmVhbVwiXG4gIH0sXG4gIFwiYWVzLTE5Mi1jZmJcIjoge1xuICAgIFwiY2lwaGVyXCI6IFwiQUVTXCIsXG4gICAgXCJrZXlcIjogMTkyLFxuICAgIFwiaXZcIjogMTYsXG4gICAgXCJtb2RlXCI6IFwiQ0ZCXCIsXG4gICAgXCJ0eXBlXCI6IFwic3RyZWFtXCJcbiAgfSxcbiAgXCJhZXMtMjU2LWNmYlwiOiB7XG4gICAgXCJjaXBoZXJcIjogXCJBRVNcIixcbiAgICBcImtleVwiOiAyNTYsXG4gICAgXCJpdlwiOiAxNixcbiAgICBcIm1vZGVcIjogXCJDRkJcIixcbiAgICBcInR5cGVcIjogXCJzdHJlYW1cIlxuICB9LFxuICBcImFlcy0xMjgtY2ZiOFwiOiB7XG4gICAgXCJjaXBoZXJcIjogXCJBRVNcIixcbiAgICBcImtleVwiOiAxMjgsXG4gICAgXCJpdlwiOiAxNixcbiAgICBcIm1vZGVcIjogXCJDRkI4XCIsXG4gICAgXCJ0eXBlXCI6IFwic3RyZWFtXCJcbiAgfSxcbiAgXCJhZXMtMTkyLWNmYjhcIjoge1xuICAgIFwiY2lwaGVyXCI6IFwiQUVTXCIsXG4gICAgXCJrZXlcIjogMTkyLFxuICAgIFwiaXZcIjogMTYsXG4gICAgXCJtb2RlXCI6IFwiQ0ZCOFwiLFxuICAgIFwidHlwZVwiOiBcInN0cmVhbVwiXG4gIH0sXG4gIFwiYWVzLTI1Ni1jZmI4XCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDI1NixcbiAgICBcIml2XCI6IDE2LFxuICAgIFwibW9kZVwiOiBcIkNGQjhcIixcbiAgICBcInR5cGVcIjogXCJzdHJlYW1cIlxuICB9LFxuICBcImFlcy0xMjgtY2ZiMVwiOiB7XG4gICAgXCJjaXBoZXJcIjogXCJBRVNcIixcbiAgICBcImtleVwiOiAxMjgsXG4gICAgXCJpdlwiOiAxNixcbiAgICBcIm1vZGVcIjogXCJDRkIxXCIsXG4gICAgXCJ0eXBlXCI6IFwic3RyZWFtXCJcbiAgfSxcbiAgXCJhZXMtMTkyLWNmYjFcIjoge1xuICAgIFwiY2lwaGVyXCI6IFwiQUVTXCIsXG4gICAgXCJrZXlcIjogMTkyLFxuICAgIFwiaXZcIjogMTYsXG4gICAgXCJtb2RlXCI6IFwiQ0ZCMVwiLFxuICAgIFwidHlwZVwiOiBcInN0cmVhbVwiXG4gIH0sXG4gIFwiYWVzLTI1Ni1jZmIxXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDI1NixcbiAgICBcIml2XCI6IDE2LFxuICAgIFwibW9kZVwiOiBcIkNGQjFcIixcbiAgICBcInR5cGVcIjogXCJzdHJlYW1cIlxuICB9LFxuICBcImFlcy0xMjgtb2ZiXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDEyOCxcbiAgICBcIml2XCI6IDE2LFxuICAgIFwibW9kZVwiOiBcIk9GQlwiLFxuICAgIFwidHlwZVwiOiBcInN0cmVhbVwiXG4gIH0sXG4gIFwiYWVzLTE5Mi1vZmJcIjoge1xuICAgIFwiY2lwaGVyXCI6IFwiQUVTXCIsXG4gICAgXCJrZXlcIjogMTkyLFxuICAgIFwiaXZcIjogMTYsXG4gICAgXCJtb2RlXCI6IFwiT0ZCXCIsXG4gICAgXCJ0eXBlXCI6IFwic3RyZWFtXCJcbiAgfSxcbiAgXCJhZXMtMjU2LW9mYlwiOiB7XG4gICAgXCJjaXBoZXJcIjogXCJBRVNcIixcbiAgICBcImtleVwiOiAyNTYsXG4gICAgXCJpdlwiOiAxNixcbiAgICBcIm1vZGVcIjogXCJPRkJcIixcbiAgICBcInR5cGVcIjogXCJzdHJlYW1cIlxuICB9LFxuICBcImFlcy0xMjgtY3RyXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDEyOCxcbiAgICBcIml2XCI6IDE2LFxuICAgIFwibW9kZVwiOiBcIkNUUlwiLFxuICAgIFwidHlwZVwiOiBcInN0cmVhbVwiXG4gIH0sXG4gIFwiYWVzLTE5Mi1jdHJcIjoge1xuICAgIFwiY2lwaGVyXCI6IFwiQUVTXCIsXG4gICAgXCJrZXlcIjogMTkyLFxuICAgIFwiaXZcIjogMTYsXG4gICAgXCJtb2RlXCI6IFwiQ1RSXCIsXG4gICAgXCJ0eXBlXCI6IFwic3RyZWFtXCJcbiAgfSxcbiAgXCJhZXMtMjU2LWN0clwiOiB7XG4gICAgXCJjaXBoZXJcIjogXCJBRVNcIixcbiAgICBcImtleVwiOiAyNTYsXG4gICAgXCJpdlwiOiAxNixcbiAgICBcIm1vZGVcIjogXCJDVFJcIixcbiAgICBcInR5cGVcIjogXCJzdHJlYW1cIlxuICB9LFxuICBcImFlcy0xMjgtZ2NtXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDEyOCxcbiAgICBcIml2XCI6IDEyLFxuICAgIFwibW9kZVwiOiBcIkdDTVwiLFxuICAgIFwidHlwZVwiOiBcImF1dGhcIlxuICB9LFxuICBcImFlcy0xOTItZ2NtXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDE5MixcbiAgICBcIml2XCI6IDEyLFxuICAgIFwibW9kZVwiOiBcIkdDTVwiLFxuICAgIFwidHlwZVwiOiBcImF1dGhcIlxuICB9LFxuICBcImFlcy0yNTYtZ2NtXCI6IHtcbiAgICBcImNpcGhlclwiOiBcIkFFU1wiLFxuICAgIFwia2V5XCI6IDI1NixcbiAgICBcIml2XCI6IDEyLFxuICAgIFwibW9kZVwiOiBcIkdDTVwiLFxuICAgIFwidHlwZVwiOiBcImF1dGhcIlxuICB9XG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9zZWNDYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9tb2RlID0gbW9kZVxufVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmssIHRoaXMuX2RlY3J5cHQpXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuIiwidmFyIERFUyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzJylcbnZhciBhZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcy9icm93c2VyJylcbnZhciBhZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzL21vZGVzJylcbnZhciBkZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcblxuICB2YXIga2V5TGVuLCBpdkxlblxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gYWVzTW9kZXNbc3VpdGVdLmtleVxuICAgIGl2TGVuID0gYWVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gZGVzTW9kZXNbc3VpdGVdLmtleSAqIDhcbiAgICBpdkxlbiA9IGRlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBrZXlMZW4sIGl2TGVuKVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuXG4gIHZhciBrZXlMZW4sIGl2TGVuXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0ua2V5XG4gICAgaXZMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0ua2V5ICogOFxuICAgIGl2TGVuID0gZGVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGtleUxlbiwgaXZMZW4pXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBrZXksIGl2KSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSByZXR1cm4gYWVzLmNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXksIGl2KVxuICBpZiAoZGVzTW9kZXNbc3VpdGVdKSByZXR1cm4gbmV3IERFUyh7IGtleToga2V5LCBpdjogaXYsIG1vZGU6IHN1aXRlIH0pXG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIGtleSwgaXYpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHJldHVybiBhZXMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgaWYgKGRlc01vZGVzW3N1aXRlXSkgcmV0dXJuIG5ldyBERVMoeyBrZXk6IGtleSwgaXY6IGl2LCBtb2RlOiBzdWl0ZSwgZGVjcnlwdDogdHJ1ZSB9KVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG59XG5cbmZ1bmN0aW9uIGdldENpcGhlcnMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGVzTW9kZXMpLmNvbmNhdChhZXMuZ2V0Q2lwaGVycygpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuIiwidmFyIENpcGhlckJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgZGVzID0gcmVxdWlyZSgnZGVzLmpzJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgbW9kZXMgPSB7XG4gICdkZXMtZWRlMy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZTMnOiBkZXMuRURFLFxuICAnZGVzLWVkZS1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZSc6IGRlcy5FREUsXG4gICdkZXMtY2JjJzogZGVzLkNCQy5pbnN0YW50aWF0ZShkZXMuREVTKSxcbiAgJ2Rlcy1lY2InOiBkZXMuREVTXG59XG5tb2Rlcy5kZXMgPSBtb2Rlc1snZGVzLWNiYyddXG5tb2Rlcy5kZXMzID0gbW9kZXNbJ2Rlcy1lZGUzLWNiYyddXG5tb2R1bGUuZXhwb3J0cyA9IERFU1xuaW5oZXJpdHMoREVTLCBDaXBoZXJCYXNlKVxuZnVuY3Rpb24gREVTIChvcHRzKSB7XG4gIENpcGhlckJhc2UuY2FsbCh0aGlzKVxuICB2YXIgbW9kZU5hbWUgPSBvcHRzLm1vZGUudG9Mb3dlckNhc2UoKVxuICB2YXIgbW9kZSA9IG1vZGVzW21vZGVOYW1lXVxuICB2YXIgdHlwZVxuICBpZiAob3B0cy5kZWNyeXB0KSB7XG4gICAgdHlwZSA9ICdkZWNyeXB0J1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSAnZW5jcnlwdCdcbiAgfVxuICB2YXIga2V5ID0gb3B0cy5rZXlcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuICBpZiAobW9kZU5hbWUgPT09ICdkZXMtZWRlJyB8fCBtb2RlTmFtZSA9PT0gJ2Rlcy1lZGUtY2JjJykge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwga2V5LnNsaWNlKDAsIDgpXSlcbiAgfVxuICB2YXIgaXYgPSBvcHRzLml2XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGl2KSkge1xuICAgIGl2ID0gQnVmZmVyLmZyb20oaXYpXG4gIH1cbiAgdGhpcy5fZGVzID0gbW9kZS5jcmVhdGUoe1xuICAgIGtleToga2V5LFxuICAgIGl2OiBpdixcbiAgICB0eXBlOiB0eXBlXG4gIH0pXG59XG5ERVMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fZGVzLnVwZGF0ZShkYXRhKSlcbn1cbkRFUy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fZGVzLmZpbmFsKCkpXG59XG4iLCJleHBvcnRzWydkZXMtZWNiJ10gPSB7XG4gIGtleTogOCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1jYmMnXSA9IGV4cG9ydHMuZGVzID0ge1xuICBrZXk6IDgsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlMy1jYmMnXSA9IGV4cG9ydHMuZGVzMyA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzJ10gPSB7XG4gIGtleTogMjQsXG4gIGl2OiAwXG59XG5leHBvcnRzWydkZXMtZWRlLWNiYyddID0ge1xuICBrZXk6IDE2LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZSddID0ge1xuICBrZXk6IDE2LFxuICBpdjogMFxufVxuIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNydDtcbmZ1bmN0aW9uIGJsaW5kKHByaXYpIHtcbiAgdmFyIHIgPSBnZXRyKHByaXYpO1xuICB2YXIgYmxpbmRlciA9IHIudG9SZWQoYm4ubW9udChwcml2Lm1vZHVsdXMpKVxuICAucmVkUG93KG5ldyBibihwcml2LnB1YmxpY0V4cG9uZW50KSkuZnJvbVJlZCgpO1xuICByZXR1cm4ge1xuICAgIGJsaW5kZXI6IGJsaW5kZXIsXG4gICAgdW5ibGluZGVyOnIuaW52bShwcml2Lm1vZHVsdXMpXG4gIH07XG59XG5mdW5jdGlvbiBjcnQobXNnLCBwcml2KSB7XG4gIHZhciBibGluZHMgPSBibGluZChwcml2KTtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtb2QgPSBibi5tb250KHByaXYubW9kdWx1cyk7XG4gIHZhciBibGluZGVkID0gbmV3IGJuKG1zZykubXVsKGJsaW5kcy5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cyk7XG4gIHZhciBjMSA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMSkpO1xuICB2YXIgYzIgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTIpKTtcbiAgdmFyIHFpbnYgPSBwcml2LmNvZWZmaWNpZW50O1xuICB2YXIgcCA9IHByaXYucHJpbWUxO1xuICB2YXIgcSA9IHByaXYucHJpbWUyO1xuICB2YXIgbTEgPSBjMS5yZWRQb3cocHJpdi5leHBvbmVudDEpO1xuICB2YXIgbTIgPSBjMi5yZWRQb3cocHJpdi5leHBvbmVudDIpO1xuICBtMSA9IG0xLmZyb21SZWQoKTtcbiAgbTIgPSBtMi5mcm9tUmVkKCk7XG4gIHZhciBoID0gbTEuaXN1YihtMikuaW11bChxaW52KS51bW9kKHApO1xuICBoLmltdWwocSk7XG4gIG0yLmlhZGQoaCk7XG4gIHJldHVybiBuZXcgQnVmZmVyKG0yLmltdWwoYmxpbmRzLnVuYmxpbmRlcikudW1vZChwcml2Lm1vZHVsdXMpLnRvQXJyYXkoZmFsc2UsIGxlbikpO1xufVxuY3J0LmdldHIgPSBnZXRyO1xuZnVuY3Rpb24gZ2V0cihwcml2KSB7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgd2hpbGUgKHIuY21wKHByaXYubW9kdWx1cykgPj0gIDAgfHwgIXIudW1vZChwcml2LnByaW1lMSkgfHwgIXIudW1vZChwcml2LnByaW1lMikpIHtcbiAgICByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB9XG4gIHJldHVybiByO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIvYWxnb3JpdGhtcy5qc29uJylcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJzaGEyMjRXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG4gICAgXCJzaWduXCI6IFwicnNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhMjI0XCIsXG4gICAgXCJpZFwiOiBcIjMwMmQzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwNDA1MDAwNDFjXCJcbiAgfSxcbiAgXCJSU0EtU0hBMjI0XCI6IHtcbiAgICBcInNpZ25cIjogXCJlY2RzYS9yc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGEyMjRcIixcbiAgICBcImlkXCI6IFwiMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWNcIlxuICB9LFxuICBcInNoYTI1NldpdGhSU0FFbmNyeXB0aW9uXCI6IHtcbiAgICBcInNpZ25cIjogXCJyc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGEyNTZcIixcbiAgICBcImlkXCI6IFwiMzAzMTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAxMDUwMDA0MjBcIlxuICB9LFxuICBcIlJTQS1TSEEyNTZcIjoge1xuICAgIFwic2lnblwiOiBcImVjZHNhL3JzYVwiLFxuICAgIFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuICAgIFwiaWRcIjogXCIzMDMxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDEwNTAwMDQyMFwiXG4gIH0sXG4gIFwic2hhMzg0V2l0aFJTQUVuY3J5cHRpb25cIjoge1xuICAgIFwic2lnblwiOiBcInJzYVwiLFxuICAgIFwiaGFzaFwiOiBcInNoYTM4NFwiLFxuICAgIFwiaWRcIjogXCIzMDQxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDIwNTAwMDQzMFwiXG4gIH0sXG4gIFwiUlNBLVNIQTM4NFwiOiB7XG4gICAgXCJzaWduXCI6IFwiZWNkc2EvcnNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhMzg0XCIsXG4gICAgXCJpZFwiOiBcIjMwNDEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMjA1MDAwNDMwXCJcbiAgfSxcbiAgXCJzaGE1MTJXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG4gICAgXCJzaWduXCI6IFwicnNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhNTEyXCIsXG4gICAgXCJpZFwiOiBcIjMwNTEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMzA1MDAwNDQwXCJcbiAgfSxcbiAgXCJSU0EtU0hBNTEyXCI6IHtcbiAgICBcInNpZ25cIjogXCJlY2RzYS9yc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGE1MTJcIixcbiAgICBcImlkXCI6IFwiMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDBcIlxuICB9LFxuICBcIlJTQS1TSEExXCI6IHtcbiAgICBcInNpZ25cIjogXCJyc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGExXCIsXG4gICAgXCJpZFwiOiBcIjMwMjEzMDA5MDYwNTJiMGUwMzAyMWEwNTAwMDQxNFwiXG4gIH0sXG4gIFwiZWNkc2Etd2l0aC1TSEExXCI6IHtcbiAgICBcInNpZ25cIjogXCJlY2RzYVwiLFxuICAgIFwiaGFzaFwiOiBcInNoYTFcIixcbiAgICBcImlkXCI6IFwiXCJcbiAgfSxcbiAgXCJzaGEyNTZcIjoge1xuICAgIFwic2lnblwiOiBcImVjZHNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhMjU2XCIsXG4gICAgXCJpZFwiOiBcIlwiXG4gIH0sXG4gIFwic2hhMjI0XCI6IHtcbiAgICBcInNpZ25cIjogXCJlY2RzYVwiLFxuICAgIFwiaGFzaFwiOiBcInNoYTIyNFwiLFxuICAgIFwiaWRcIjogXCJcIlxuICB9LFxuICBcInNoYTM4NFwiOiB7XG4gICAgXCJzaWduXCI6IFwiZWNkc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGEzODRcIixcbiAgICBcImlkXCI6IFwiXCJcbiAgfSxcbiAgXCJzaGE1MTJcIjoge1xuICAgIFwic2lnblwiOiBcImVjZHNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhNTEyXCIsXG4gICAgXCJpZFwiOiBcIlwiXG4gIH0sXG4gIFwiRFNBLVNIQVwiOiB7XG4gICAgXCJzaWduXCI6IFwiZHNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhMVwiLFxuICAgIFwiaWRcIjogXCJcIlxuICB9LFxuICBcIkRTQS1TSEExXCI6IHtcbiAgICBcInNpZ25cIjogXCJkc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGExXCIsXG4gICAgXCJpZFwiOiBcIlwiXG4gIH0sXG4gIFwiRFNBXCI6IHtcbiAgICBcInNpZ25cIjogXCJkc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGExXCIsXG4gICAgXCJpZFwiOiBcIlwiXG4gIH0sXG4gIFwiRFNBLVdJVEgtU0hBMjI0XCI6IHtcbiAgICBcInNpZ25cIjogXCJkc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGEyMjRcIixcbiAgICBcImlkXCI6IFwiXCJcbiAgfSxcbiAgXCJEU0EtU0hBMjI0XCI6IHtcbiAgICBcInNpZ25cIjogXCJkc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGEyMjRcIixcbiAgICBcImlkXCI6IFwiXCJcbiAgfSxcbiAgXCJEU0EtV0lUSC1TSEEyNTZcIjoge1xuICAgIFwic2lnblwiOiBcImRzYVwiLFxuICAgIFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuICAgIFwiaWRcIjogXCJcIlxuICB9LFxuICBcIkRTQS1TSEEyNTZcIjoge1xuICAgIFwic2lnblwiOiBcImRzYVwiLFxuICAgIFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuICAgIFwiaWRcIjogXCJcIlxuICB9LFxuICBcIkRTQS1XSVRILVNIQTM4NFwiOiB7XG4gICAgXCJzaWduXCI6IFwiZHNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhMzg0XCIsXG4gICAgXCJpZFwiOiBcIlwiXG4gIH0sXG4gIFwiRFNBLVNIQTM4NFwiOiB7XG4gICAgXCJzaWduXCI6IFwiZHNhXCIsXG4gICAgXCJoYXNoXCI6IFwic2hhMzg0XCIsXG4gICAgXCJpZFwiOiBcIlwiXG4gIH0sXG4gIFwiRFNBLVdJVEgtU0hBNTEyXCI6IHtcbiAgICBcInNpZ25cIjogXCJkc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGE1MTJcIixcbiAgICBcImlkXCI6IFwiXCJcbiAgfSxcbiAgXCJEU0EtU0hBNTEyXCI6IHtcbiAgICBcInNpZ25cIjogXCJkc2FcIixcbiAgICBcImhhc2hcIjogXCJzaGE1MTJcIixcbiAgICBcImlkXCI6IFwiXCJcbiAgfSxcbiAgXCJEU0EtUklQRU1EMTYwXCI6IHtcbiAgICBcInNpZ25cIjogXCJkc2FcIixcbiAgICBcImhhc2hcIjogXCJybWQxNjBcIixcbiAgICBcImlkXCI6IFwiXCJcbiAgfSxcbiAgXCJyaXBlbWQxNjBXaXRoUlNBXCI6IHtcbiAgICBcInNpZ25cIjogXCJyc2FcIixcbiAgICBcImhhc2hcIjogXCJybWQxNjBcIixcbiAgICBcImlkXCI6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCJcbiAgfSxcbiAgXCJSU0EtUklQRU1EMTYwXCI6IHtcbiAgICBcInNpZ25cIjogXCJyc2FcIixcbiAgICBcImhhc2hcIjogXCJybWQxNjBcIixcbiAgICBcImlkXCI6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCJcbiAgfSxcbiAgXCJtZDVXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG4gICAgXCJzaWduXCI6IFwicnNhXCIsXG4gICAgXCJoYXNoXCI6IFwibWQ1XCIsXG4gICAgXCJpZFwiOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMFwiXG4gIH0sXG4gIFwiUlNBLU1ENVwiOiB7XG4gICAgXCJzaWduXCI6IFwicnNhXCIsXG4gICAgXCJoYXNoXCI6IFwibWQ1XCIsXG4gICAgXCJpZFwiOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMFwiXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIxLjMuMTMyLjAuMTBcIjogXCJzZWNwMjU2azFcIixcbiAgXCIxLjMuMTMyLjAuMzNcIjogXCJwMjI0XCIsXG4gIFwiMS4yLjg0MC4xMDA0NS4zLjEuMVwiOiBcInAxOTJcIixcbiAgXCIxLjIuODQwLjEwMDQ1LjMuMS43XCI6IFwicDI1NlwiLFxuICBcIjEuMy4xMzIuMC4zNFwiOiBcInAzODRcIixcbiAgXCIxLjMuMTMyLjAuMzVcIjogXCJwNTIxXCJcbn1cbiIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpXG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKVxuXG52YXIgYWxnb3JpdGhtcyA9IHJlcXVpcmUoJy4vYWxnb3JpdGhtcy5qc29uJylcbk9iamVjdC5rZXlzKGFsZ29yaXRobXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBhbGdvcml0aG1zW2tleV0uaWQgPSBuZXcgQnVmZmVyKGFsZ29yaXRobXNba2V5XS5pZCwgJ2hleCcpXG4gIGFsZ29yaXRobXNba2V5LnRvTG93ZXJDYXNlKCldID0gYWxnb3JpdGhtc1trZXldXG59KVxuXG5mdW5jdGlvbiBTaWduIChhbGdvcml0aG0pIHtcbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcylcblxuICB2YXIgZGF0YSA9IGFsZ29yaXRobXNbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaFR5cGUgPSBkYXRhLmhhc2hcbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhTaWduLCBzdHJlYW0uV3JpdGFibGUpXG5cblNpZ24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuU2lnbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblNpZ24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduTWV0aG9kIChrZXksIGVuYykge1xuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICB2YXIgc2lnID0gc2lnbihoYXNoLCBrZXksIHRoaXMuX2hhc2hUeXBlLCB0aGlzLl9zaWduVHlwZSwgdGhpcy5fdGFnKVxuXG4gIHJldHVybiBlbmMgPyBzaWcudG9TdHJpbmcoZW5jKSA6IHNpZ1xufVxuXG5mdW5jdGlvbiBWZXJpZnkgKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHZhciBkYXRhID0gYWxnb3JpdGhtc1thbGdvcml0aG1dXG4gIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cbmluaGVyaXRzKFZlcmlmeSwgc3RyZWFtLldyaXRhYmxlKVxuXG5WZXJpZnkucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlNZXRob2QgKGtleSwgc2lnLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBzaWcgPT09ICdzdHJpbmcnKSBzaWcgPSBuZXcgQnVmZmVyKHNpZywgZW5jKVxuXG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHJldHVybiB2ZXJpZnkoc2lnLCBoYXNoLCBrZXksIHRoaXMuX3NpZ25UeXBlLCB0aGlzLl90YWcpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24gKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFNpZ24oYWxnb3JpdGhtKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJpZnkgKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFZlcmlmeShhbGdvcml0aG0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTaWduOiBjcmVhdGVTaWduLFxuICBWZXJpZnk6IGNyZWF0ZVZlcmlmeSxcbiAgY3JlYXRlU2lnbjogY3JlYXRlU2lnbixcbiAgY3JlYXRlVmVyaWZ5OiBjcmVhdGVWZXJpZnlcbn1cbiIsIi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJylcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcy5qc29uJylcblxuZnVuY3Rpb24gc2lnbiAoaGFzaCwga2V5LCBoYXNoVHlwZSwgc2lnblR5cGUsIHRhZykge1xuICB2YXIgcHJpdiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwcml2LmN1cnZlKSB7XG4gICAgLy8gcnNhIGtleXMgY2FuIGJlIGludGVycHJldGVkIGFzIGVjZHNhIG9uZXMgaW4gb3BlbnNzbFxuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjU2lnbihoYXNoLCBwcml2KVxuICB9IGVsc2UgaWYgKHByaXYudHlwZSA9PT0gJ2RzYScpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdkc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICAgIHJldHVybiBkc2FTaWduKGhhc2gsIHByaXYsIGhhc2hUeXBlKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICB9XG4gIGhhc2ggPSBCdWZmZXIuY29uY2F0KFt0YWcsIGhhc2hdKVxuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAwLCAxIF1cbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDEgPCBsZW4pIHBhZC5wdXNoKDB4ZmYpXG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSBwYWQucHVzaChoYXNoW2ldKVxuXG4gIHZhciBvdXQgPSBjcnQocGFkLCBwcml2KVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGVjU2lnbiAoaGFzaCwgcHJpdikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twcml2LmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHByaXYuY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBFQyhjdXJ2ZUlkKVxuICB2YXIga2V5ID0gY3VydmUua2V5RnJvbVByaXZhdGUocHJpdi5wcml2YXRlS2V5KVxuICB2YXIgb3V0ID0ga2V5LnNpZ24oaGFzaClcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXQudG9ERVIoKSlcbn1cblxuZnVuY3Rpb24gZHNhU2lnbiAoaGFzaCwgcHJpdiwgYWxnbykge1xuICB2YXIgeCA9IHByaXYucGFyYW1zLnByaXZfa2V5XG4gIHZhciBwID0gcHJpdi5wYXJhbXMucFxuICB2YXIgcSA9IHByaXYucGFyYW1zLnFcbiAgdmFyIGcgPSBwcml2LnBhcmFtcy5nXG4gIHZhciByID0gbmV3IEJOKDApXG4gIHZhciBrXG4gIHZhciBIID0gYml0czJpbnQoaGFzaCwgcSkubW9kKHEpXG4gIHZhciBzID0gZmFsc2VcbiAgdmFyIGt2ID0gZ2V0S2V5KHgsIHEsIGhhc2gsIGFsZ28pXG4gIHdoaWxlIChzID09PSBmYWxzZSkge1xuICAgIGsgPSBtYWtlS2V5KHEsIGt2LCBhbGdvKVxuICAgIHIgPSBtYWtlUihnLCBrLCBwLCBxKVxuICAgIHMgPSBrLmludm0ocSkuaW11bChILmFkZCh4Lm11bChyKSkpLm1vZChxKVxuICAgIGlmIChzLmNtcG4oMCkgPT09IDApIHtcbiAgICAgIHMgPSBmYWxzZVxuICAgICAgciA9IG5ldyBCTigwKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9ERVIociwgcylcbn1cblxuZnVuY3Rpb24gdG9ERVIgKHIsIHMpIHtcbiAgciA9IHIudG9BcnJheSgpXG4gIHMgPSBzLnRvQXJyYXkoKVxuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKSByID0gWyAwIF0uY29uY2F0KHIpXG4gIGlmIChzWzBdICYgMHg4MCkgcyA9IFsgMCBdLmNvbmNhdChzKVxuXG4gIHZhciB0b3RhbCA9IHIubGVuZ3RoICsgcy5sZW5ndGggKyA0XG4gIHZhciByZXMgPSBbIDB4MzAsIHRvdGFsLCAweDAyLCByLmxlbmd0aCBdXG4gIHJlcyA9IHJlcy5jb25jYXQociwgWyAweDAyLCBzLmxlbmd0aCBdLCBzKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihyZXMpXG59XG5cbmZ1bmN0aW9uIGdldEtleSAoeCwgcSwgaGFzaCwgYWxnbykge1xuICB4ID0gbmV3IEJ1ZmZlcih4LnRvQXJyYXkoKSlcbiAgaWYgKHgubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0geC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIHggPSBCdWZmZXIuY29uY2F0KFsgemVyb3MsIHggXSlcbiAgfVxuICB2YXIgaGxlbiA9IGhhc2gubGVuZ3RoXG4gIHZhciBoYml0cyA9IGJpdHMyb2N0ZXRzKGhhc2gsIHEpXG4gIHZhciB2ID0gbmV3IEJ1ZmZlcihobGVuKVxuICB2LmZpbGwoMSlcbiAgdmFyIGsgPSBuZXcgQnVmZmVyKGhsZW4pXG4gIGsuZmlsbCgwKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS51cGRhdGUoeCkudXBkYXRlKGhiaXRzKS5kaWdlc3QoKVxuICB2ID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikuZGlnZXN0KClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMSBdKSkudXBkYXRlKHgpLnVwZGF0ZShoYml0cykuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG4gIHJldHVybiB7IGs6IGssIHY6IHYgfVxufVxuXG5mdW5jdGlvbiBiaXRzMmludCAob2JpdHMsIHEpIHtcbiAgdmFyIGJpdHMgPSBuZXcgQk4ob2JpdHMpXG4gIHZhciBzaGlmdCA9IChvYml0cy5sZW5ndGggPDwgMykgLSBxLmJpdExlbmd0aCgpXG4gIGlmIChzaGlmdCA+IDApIGJpdHMuaXNocm4oc2hpZnQpXG4gIHJldHVybiBiaXRzXG59XG5cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzIChiaXRzLCBxKSB7XG4gIGJpdHMgPSBiaXRzMmludChiaXRzLCBxKVxuICBiaXRzID0gYml0cy5tb2QocSlcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYml0cy50b0FycmF5KCkpXG4gIGlmIChvdXQubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0gb3V0Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbIHplcm9zLCBvdXQgXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIG1ha2VLZXkgKHEsIGt2LCBhbGdvKSB7XG4gIHZhciB0XG4gIHZhciBrXG5cbiAgZG8ge1xuICAgIHQgPSBuZXcgQnVmZmVyKDApXG5cbiAgICB3aGlsZSAodC5sZW5ndGggKiA4IDwgcS5iaXRMZW5ndGgoKSkge1xuICAgICAga3YudiA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaykudXBkYXRlKGt2LnYpLmRpZ2VzdCgpXG4gICAgICB0ID0gQnVmZmVyLmNvbmNhdChbIHQsIGt2LnYgXSlcbiAgICB9XG5cbiAgICBrID0gYml0czJpbnQodCwgcSlcbiAgICBrdi5rID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKS51cGRhdGUoa3YudikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS5kaWdlc3QoKVxuICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspLnVwZGF0ZShrdi52KS5kaWdlc3QoKVxuICB9IHdoaWxlIChrLmNtcChxKSAhPT0gLTEpXG5cbiAgcmV0dXJuIGtcbn1cblxuZnVuY3Rpb24gbWFrZVIgKGcsIGssIHAsIHEpIHtcbiAgcmV0dXJuIGcudG9SZWQoQk4ubW9udChwKSkucmVkUG93KGspLmZyb21SZWQoKS5tb2QocSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5tb2R1bGUuZXhwb3J0cy5nZXRLZXkgPSBnZXRLZXlcbm1vZHVsZS5leHBvcnRzLm1ha2VLZXkgPSBtYWtlS2V5XG4iLCIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG5cbmZ1bmN0aW9uIHZlcmlmeSAoc2lnLCBoYXNoLCBrZXksIHNpZ25UeXBlLCB0YWcpIHtcbiAgdmFyIHB1YiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwdWIudHlwZSA9PT0gJ2VjJykge1xuICAgIC8vIHJzYSBrZXlzIGNhbiBiZSBpbnRlcnByZXRlZCBhcyBlY2RzYSBvbmVzIGluIG9wZW5zc2xcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2UgaWYgKHB1Yi50eXBlID09PSAnZHNhJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2RzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICByZXR1cm4gZHNhVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gIH1cbiAgaGFzaCA9IEJ1ZmZlci5jb25jYXQoW3RhZywgaGFzaF0pXG4gIHZhciBsZW4gPSBwdWIubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMSBdXG4gIHZhciBwYWROdW0gPSAwXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAyIDwgbGVuKSB7XG4gICAgcGFkLnB1c2goMHhmZilcbiAgICBwYWROdW0rK1xuICB9XG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSB7XG4gICAgcGFkLnB1c2goaGFzaFtpXSlcbiAgfVxuICBwYWQgPSBuZXcgQnVmZmVyKHBhZClcbiAgdmFyIHJlZCA9IEJOLm1vbnQocHViLm1vZHVsdXMpXG4gIHNpZyA9IG5ldyBCTihzaWcpLnRvUmVkKHJlZClcblxuICBzaWcgPSBzaWcucmVkUG93KG5ldyBCTihwdWIucHVibGljRXhwb25lbnQpKVxuICBzaWcgPSBuZXcgQnVmZmVyKHNpZy5mcm9tUmVkKCkudG9BcnJheSgpKVxuICB2YXIgb3V0ID0gcGFkTnVtIDwgOCA/IDEgOiAwXG4gIGxlbiA9IE1hdGgubWluKHNpZy5sZW5ndGgsIHBhZC5sZW5ndGgpXG4gIGlmIChzaWcubGVuZ3RoICE9PSBwYWQubGVuZ3RoKSBvdXQgPSAxXG5cbiAgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIG91dCB8PSBzaWdbaV0gXiBwYWRbaV1cbiAgcmV0dXJuIG91dCA9PT0gMFxufVxuXG5mdW5jdGlvbiBlY1ZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIGN1cnZlSWQgPSBjdXJ2ZXNbcHViLmRhdGEuYWxnb3JpdGhtLmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHB1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IEVDKGN1cnZlSWQpXG4gIHZhciBwdWJrZXkgPSBwdWIuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleS5kYXRhXG5cbiAgcmV0dXJuIGN1cnZlLnZlcmlmeShoYXNoLCBzaWcsIHB1YmtleSlcbn1cblxuZnVuY3Rpb24gZHNhVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgcCA9IHB1Yi5kYXRhLnBcbiAgdmFyIHEgPSBwdWIuZGF0YS5xXG4gIHZhciBnID0gcHViLmRhdGEuZ1xuICB2YXIgeSA9IHB1Yi5kYXRhLnB1Yl9rZXlcbiAgdmFyIHVucGFja2VkID0gcGFyc2VLZXlzLnNpZ25hdHVyZS5kZWNvZGUoc2lnLCAnZGVyJylcbiAgdmFyIHMgPSB1bnBhY2tlZC5zXG4gIHZhciByID0gdW5wYWNrZWQuclxuICBjaGVja1ZhbHVlKHMsIHEpXG4gIGNoZWNrVmFsdWUociwgcSlcbiAgdmFyIG1vbnRwID0gQk4ubW9udChwKVxuICB2YXIgdyA9IHMuaW52bShxKVxuICB2YXIgdiA9IGcudG9SZWQobW9udHApXG4gICAgLnJlZFBvdyhuZXcgQk4oaGFzaCkubXVsKHcpLm1vZChxKSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLm11bCh5LnRvUmVkKG1vbnRwKS5yZWRQb3coci5tdWwodykubW9kKHEpKS5mcm9tUmVkKCkpXG4gICAgLm1vZChwKVxuICAgIC5tb2QocSlcbiAgcmV0dXJuIHYuY21wKHIpID09PSAwXG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWUgKGIsIHEpIHtcbiAgaWYgKGIuY21wbigwKSA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnJylcbiAgaWYgKGIuY21wKHEpID49IHEpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcmlmeVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBhW2ldIF4gYltpXVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIGlmICh0aGlzLl9maW5hbCkge1xuICAgIHRoaXMuX19maW5hbCA9IHRoaXMuX2ZpbmFsXG4gICAgdGhpcy5fZmluYWwgPSBudWxsXG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgaW5wdXRFbmMpXG4gIH1cblxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkgcmV0dXJuIHRoaXNcblxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuXG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfVxuXG4gIGRvbmUoZXJyKVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fX2ZpbmFsKCkgfHwgQnVmZmVyLmFsbG9jKDApXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW4pIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG5cbiAgaWYgKHRoaXMuX2VuY29kaW5nICE9PSBlbmMpIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcblxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbikge1xuICAgIG91dCArPSB0aGlzLl9kZWNvZGVyLmVuZCgpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwidmFyIGVsbGlwdGljID0gcmVxdWlyZSgnZWxsaXB0aWMnKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVDREggKGN1cnZlKSB7XG4gIHJldHVybiBuZXcgRUNESChjdXJ2ZSlcbn1cblxudmFyIGFsaWFzZXMgPSB7XG4gIHNlY3AyNTZrMToge1xuICAgIG5hbWU6ICdzZWNwMjU2azEnLFxuICAgIGJ5dGVMZW5ndGg6IDMyXG4gIH0sXG4gIHNlY3AyMjRyMToge1xuICAgIG5hbWU6ICdwMjI0JyxcbiAgICBieXRlTGVuZ3RoOiAyOFxuICB9LFxuICBwcmltZTI1NnYxOiB7XG4gICAgbmFtZTogJ3AyNTYnLFxuICAgIGJ5dGVMZW5ndGg6IDMyXG4gIH0sXG4gIHByaW1lMTkydjE6IHtcbiAgICBuYW1lOiAncDE5MicsXG4gICAgYnl0ZUxlbmd0aDogMjRcbiAgfSxcbiAgZWQyNTUxOToge1xuICAgIG5hbWU6ICdlZDI1NTE5JyxcbiAgICBieXRlTGVuZ3RoOiAzMlxuICB9LFxuICBzZWNwMzg0cjE6IHtcbiAgICBuYW1lOiAncDM4NCcsXG4gICAgYnl0ZUxlbmd0aDogNDhcbiAgfSxcbiAgc2VjcDUyMXIxOiB7XG4gICAgbmFtZTogJ3A1MjEnLFxuICAgIGJ5dGVMZW5ndGg6IDY2XG4gIH1cbn1cblxuYWxpYXNlcy5wMjI0ID0gYWxpYXNlcy5zZWNwMjI0cjFcbmFsaWFzZXMucDI1NiA9IGFsaWFzZXMuc2VjcDI1NnIxID0gYWxpYXNlcy5wcmltZTI1NnYxXG5hbGlhc2VzLnAxOTIgPSBhbGlhc2VzLnNlY3AxOTJyMSA9IGFsaWFzZXMucHJpbWUxOTJ2MVxuYWxpYXNlcy5wMzg0ID0gYWxpYXNlcy5zZWNwMzg0cjFcbmFsaWFzZXMucDUyMSA9IGFsaWFzZXMuc2VjcDUyMXIxXG5cbmZ1bmN0aW9uIEVDREggKGN1cnZlKSB7XG4gIHRoaXMuY3VydmVUeXBlID0gYWxpYXNlc1tjdXJ2ZV1cbiAgaWYgKCF0aGlzLmN1cnZlVHlwZSkge1xuICAgIHRoaXMuY3VydmVUeXBlID0ge1xuICAgICAgbmFtZTogY3VydmVcbiAgICB9XG4gIH1cbiAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5lYyh0aGlzLmN1cnZlVHlwZS5uYW1lKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgdGhpcy5rZXlzID0gdm9pZCAwXG59XG5cbkVDREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuICB0aGlzLmtleXMgPSB0aGlzLmN1cnZlLmdlbktleVBhaXIoKVxuICByZXR1cm4gdGhpcy5nZXRQdWJsaWNLZXkoZW5jLCBmb3JtYXQpXG59XG5cbkVDREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIsIGluZW5jLCBlbmMpIHtcbiAgaW5lbmMgPSBpbmVuYyB8fCAndXRmOCdcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgb3RoZXIgPSBuZXcgQnVmZmVyKG90aGVyLCBpbmVuYylcbiAgfVxuICB2YXIgb3RoZXJQdWIgPSB0aGlzLmN1cnZlLmtleUZyb21QdWJsaWMob3RoZXIpLmdldFB1YmxpYygpXG4gIHZhciBvdXQgPSBvdGhlclB1Yi5tdWwodGhpcy5rZXlzLmdldFByaXZhdGUoKSkuZ2V0WCgpXG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZShvdXQsIGVuYywgdGhpcy5jdXJ2ZVR5cGUuYnl0ZUxlbmd0aClcbn1cblxuRUNESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG4gIHZhciBrZXkgPSB0aGlzLmtleXMuZ2V0UHVibGljKGZvcm1hdCA9PT0gJ2NvbXByZXNzZWQnLCB0cnVlKVxuICBpZiAoZm9ybWF0ID09PSAnaHlicmlkJykge1xuICAgIGlmIChrZXlba2V5Lmxlbmd0aCAtIDFdICUgMikge1xuICAgICAga2V5WzBdID0gN1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlbMF0gPSA2XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZShrZXksIGVuYylcbn1cblxuRUNESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMua2V5cy5nZXRQcml2YXRlKCksIGVuYylcbn1cblxuRUNESC5wcm90b3R5cGUuc2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHViKSkge1xuICAgIHB1YiA9IG5ldyBCdWZmZXIocHViLCBlbmMpXG4gIH1cbiAgdGhpcy5rZXlzLl9pbXBvcnRQdWJsaWMocHViKVxuICByZXR1cm4gdGhpc1xufVxuXG5FQ0RILnByb3RvdHlwZS5zZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXYsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKVxuICB9XG5cbiAgdmFyIF9wcml2ID0gbmV3IEJOKHByaXYpXG4gIF9wcml2ID0gX3ByaXYudG9TdHJpbmcoMTYpXG4gIHRoaXMua2V5cyA9IHRoaXMuY3VydmUuZ2VuS2V5UGFpcigpXG4gIHRoaXMua2V5cy5faW1wb3J0UHJpdmF0ZShfcHJpdilcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUgKGJuLCBlbmMsIGxlbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYm4pKSB7XG4gICAgYm4gPSBibi50b0FycmF5KClcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihibilcbiAgaWYgKGxlbiAmJiBidWYubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEJ1ZmZlcihsZW4gLSBidWYubGVuZ3RoKVxuICAgIHplcm9zLmZpbGwoMClcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgYnVmXSlcbiAgfVxuICBpZiAoIWVuYykge1xuICAgIHJldHVybiBidWZcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuYylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxuZnVuY3Rpb24gSGFzaCAoaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgQmFzZSlcblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhhc2gucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFsZyA9PT0gJ21kNScpIHJldHVybiBuZXcgTUQ1KClcbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKVxuXG4gIHJldHVybiBuZXcgSGFzaChzaGEoYWxnKSlcbn1cbiIsInZhciBNRDUgPSByZXF1aXJlKCdtZDUuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIG5ldyBNRDUoKS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3knKVxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG5cbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIHZhciBoYXNoID0gYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYShhbGcpXG4gICAga2V5ID0gaGFzaC51cGRhdGUoa2V5KS5kaWdlc3QoKVxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG4gIHRoaXMuX2hhc2ggPSBhbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKGFsZylcbiAgdGhpcy5faGFzaC51cGRhdGUoaXBhZClcbn1cblxuaW5oZXJpdHMoSG1hYywgQmFzZSlcblxuSG1hYy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhtYWMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHZhciBoYXNoID0gdGhpcy5fYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYSh0aGlzLl9hbGcpXG4gIHJldHVybiBoYXNoLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIbWFjIChhbGcsIGtleSkge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSB7XG4gICAgcmV0dXJuIG5ldyBIbWFjKCdybWQxNjAnLCBrZXkpXG4gIH1cbiAgaWYgKGFsZyA9PT0gJ21kNScpIHtcbiAgICByZXR1cm4gbmV3IExlZ2FjeShtZDUsIGtleSlcbiAgfVxuICByZXR1cm4gbmV3IEhtYWMoYWxnLCBrZXkpXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcbnZhciBibG9ja3NpemUgPSA2NFxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGFsZyhrZXkpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gW2lwYWRdXG59XG5cbmluaGVyaXRzKEhtYWMsIEJhc2UpXG5cbkhtYWMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnB1c2goZGF0YSlcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaCA9IHRoaXMuX2FsZyhCdWZmZXIuY29uY2F0KHRoaXMuX2hhc2gpKVxuICByZXR1cm4gdGhpcy5fYWxnKEJ1ZmZlci5jb25jYXQoW3RoaXMuX29wYWQsIGhdKSlcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnJuZyA9IGV4cG9ydHMucHNldWRvUmFuZG9tQnl0ZXMgPSBleHBvcnRzLnBybmcgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBleHBvcnRzLkhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBleHBvcnRzLkhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG5cbnZhciBhbGdvcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbi9hbGdvcycpXG52YXIgYWxnb0tleXMgPSBPYmplY3Qua2V5cyhhbGdvcylcbnZhciBoYXNoZXMgPSBbJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXS5jb25jYXQoYWxnb0tleXMpXG5leHBvcnRzLmdldEhhc2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGhhc2hlc1xufVxuXG52YXIgcCA9IHJlcXVpcmUoJ3Bia2RmMicpXG5leHBvcnRzLnBia2RmMiA9IHAucGJrZGYyXG5leHBvcnRzLnBia2RmMlN5bmMgPSBwLnBia2RmMlN5bmNcblxudmFyIGFlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktY2lwaGVyJylcblxuZXhwb3J0cy5DaXBoZXIgPSBhZXMuQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGFlcy5jcmVhdGVDaXBoZXJcbmV4cG9ydHMuQ2lwaGVyaXYgPSBhZXMuQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBhZXMuY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuRGVjaXBoZXIgPSBhZXMuRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBhZXMuY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuRGVjaXBoZXJpdiA9IGFlcy5EZWNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBhZXMuY3JlYXRlRGVjaXBoZXJpdlxuZXhwb3J0cy5nZXRDaXBoZXJzID0gYWVzLmdldENpcGhlcnNcbmV4cG9ydHMubGlzdENpcGhlcnMgPSBhZXMubGlzdENpcGhlcnNcblxudmFyIGRoID0gcmVxdWlyZSgnZGlmZmllLWhlbGxtYW4nKVxuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW5Hcm91cCA9IGRoLkRpZmZpZUhlbGxtYW5Hcm91cFxuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAgPSBkaC5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXBcbmV4cG9ydHMuZ2V0RGlmZmllSGVsbG1hbiA9IGRoLmdldERpZmZpZUhlbGxtYW5cbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGRoLmNyZWF0ZURpZmZpZUhlbGxtYW5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGRoLkRpZmZpZUhlbGxtYW5cblxudmFyIHNpZ24gPSByZXF1aXJlKCdicm93c2VyaWZ5LXNpZ24nKVxuXG5leHBvcnRzLmNyZWF0ZVNpZ24gPSBzaWduLmNyZWF0ZVNpZ25cbmV4cG9ydHMuU2lnbiA9IHNpZ24uU2lnblxuZXhwb3J0cy5jcmVhdGVWZXJpZnkgPSBzaWduLmNyZWF0ZVZlcmlmeVxuZXhwb3J0cy5WZXJpZnkgPSBzaWduLlZlcmlmeVxuXG5leHBvcnRzLmNyZWF0ZUVDREggPSByZXF1aXJlKCdjcmVhdGUtZWNkaCcpXG5cbnZhciBwdWJsaWNFbmNyeXB0ID0gcmVxdWlyZSgncHVibGljLWVuY3J5cHQnKVxuXG5leHBvcnRzLnB1YmxpY0VuY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnB1YmxpY0VuY3J5cHRcbmV4cG9ydHMucHJpdmF0ZUVuY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnByaXZhdGVFbmNyeXB0XG5leHBvcnRzLnB1YmxpY0RlY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnB1YmxpY0RlY3J5cHRcbmV4cG9ydHMucHJpdmF0ZURlY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnByaXZhdGVEZWNyeXB0XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuLy8gO1tcbi8vICAgJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLy8gXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4vLyAgIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKFtcbi8vICAgICAgICdzb3JyeSwgJyArIG5hbWUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnLFxuLy8gICAgICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbi8vICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvLWJyb3dzZXJpZnkvY3J5cHRvLWJyb3dzZXJpZnknXG4vLyAgICAgXS5qb2luKCdcXG4nKSlcbi8vICAgfVxuLy8gfSlcblxudmFyIHJmID0gcmVxdWlyZSgncmFuZG9tZmlsbCcpXG5cbmV4cG9ydHMucmFuZG9tRmlsbCA9IHJmLnJhbmRvbUZpbGxcbmV4cG9ydHMucmFuZG9tRmlsbFN5bmMgPSByZi5yYW5kb21GaWxsU3luY1xuXG5leHBvcnRzLmNyZWF0ZUNyZWRlbnRpYWxzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICdzb3JyeSwgY3JlYXRlQ3JlZGVudGlhbHMgaXMgbm90IGltcGxlbWVudGVkIHlldCcsXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0by1icm93c2VyaWZ5L2NyeXB0by1icm93c2VyaWZ5J1xuICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNvbnN0YW50cyA9IHtcbiAgJ0RIX0NIRUNLX1BfTk9UX1NBRkVfUFJJTUUnOiAyLFxuICAnREhfQ0hFQ0tfUF9OT1RfUFJJTUUnOiAxLFxuICAnREhfVU5BQkxFX1RPX0NIRUNLX0dFTkVSQVRPUic6IDQsXG4gICdESF9OT1RfU1VJVEFCTEVfR0VORVJBVE9SJzogOCxcbiAgJ05QTl9FTkFCTEVEJzogMSxcbiAgJ0FMUE5fRU5BQkxFRCc6IDEsXG4gICdSU0FfUEtDUzFfUEFERElORyc6IDEsXG4gICdSU0FfU1NMVjIzX1BBRERJTkcnOiAyLFxuICAnUlNBX05PX1BBRERJTkcnOiAzLFxuICAnUlNBX1BLQ1MxX09BRVBfUEFERElORyc6IDQsXG4gICdSU0FfWDkzMV9QQURESU5HJzogNSxcbiAgJ1JTQV9QS0NTMV9QU1NfUEFERElORyc6IDYsXG4gICdQT0lOVF9DT05WRVJTSU9OX0NPTVBSRVNTRUQnOiAyLFxuICAnUE9JTlRfQ09OVkVSU0lPTl9VTkNPTVBSRVNTRUQnOiA0LFxuICAnUE9JTlRfQ09OVkVSU0lPTl9IWUJSSUQnOiA2XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudXRpbHMgPSByZXF1aXJlKCcuL2Rlcy91dGlscycpO1xuZXhwb3J0cy5DaXBoZXIgPSByZXF1aXJlKCcuL2Rlcy9jaXBoZXInKTtcbmV4cG9ydHMuREVTID0gcmVxdWlyZSgnLi9kZXMvZGVzJyk7XG5leHBvcnRzLkNCQyA9IHJlcXVpcmUoJy4vZGVzL2NiYycpO1xuZXhwb3J0cy5FREUgPSByZXF1aXJlKCcuL2Rlcy9lZGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBwcm90byA9IHt9O1xuXG5mdW5jdGlvbiBDQkNTdGF0ZShpdikge1xuICBhc3NlcnQuZXF1YWwoaXYubGVuZ3RoLCA4LCAnSW52YWxpZCBJViBsZW5ndGgnKTtcblxuICB0aGlzLml2ID0gbmV3IEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXYubGVuZ3RoOyBpKyspXG4gICAgdGhpcy5pdltpXSA9IGl2W2ldO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZShCYXNlKSB7XG4gIGZ1bmN0aW9uIENCQyhvcHRpb25zKSB7XG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2NiY0luaXQoKTtcbiAgfVxuICBpbmhlcml0cyhDQkMsIEJhc2UpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBDQkMucHJvdG90eXBlW2tleV0gPSBwcm90b1trZXldO1xuICB9XG5cbiAgQ0JDLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDQkMob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIENCQztcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZSA9IGluc3RhbnRpYXRlO1xuXG5wcm90by5fY2JjSW5pdCA9IGZ1bmN0aW9uIF9jYmNJbml0KCkge1xuICB2YXIgc3RhdGUgPSBuZXcgQ0JDU3RhdGUodGhpcy5vcHRpb25zLml2KTtcbiAgdGhpcy5fY2JjU3RhdGUgPSBzdGF0ZTtcbn07XG5cbnByb3RvLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2NiY1N0YXRlO1xuICB2YXIgc3VwZXJQcm90byA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZTtcblxuICB2YXIgaXYgPSBzdGF0ZS5pdjtcbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gXj0gaW5wW2luT2ZmICsgaV07XG5cbiAgICBzdXBlclByb3RvLl91cGRhdGUuY2FsbCh0aGlzLCBpdiwgMCwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBvdXRbb3V0T2ZmICsgaV07XG4gIH0gZWxzZSB7XG4gICAgc3VwZXJQcm90by5fdXBkYXRlLmNhbGwodGhpcywgaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgb3V0W291dE9mZiArIGldIF49IGl2W2ldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBpbnBbaW5PZmYgKyBpXTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQ2lwaGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICB0aGlzLnR5cGUgPSB0aGlzLm9wdGlvbnMudHlwZTtcbiAgdGhpcy5ibG9ja1NpemUgPSA4O1xuICB0aGlzLl9pbml0KCk7XG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLmJ1ZmZlck9mZiA9IDA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlcjtcblxuQ2lwaGVyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBNaWdodCBiZSBvdmVycmlkZWRcbn07XG5cbkNpcGhlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodGhpcy50eXBlID09PSAnZGVjcnlwdCcpXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZURlY3J5cHQoZGF0YSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRW5jcnlwdChkYXRhKTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2J1ZmZlciA9IGZ1bmN0aW9uIF9idWZmZXIoZGF0YSwgb2ZmKSB7XG4gIC8vIEFwcGVuZCBkYXRhIHRvIGJ1ZmZlclxuICB2YXIgbWluID0gTWF0aC5taW4odGhpcy5idWZmZXIubGVuZ3RoIC0gdGhpcy5idWZmZXJPZmYsIGRhdGEubGVuZ3RoIC0gb2ZmKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKylcbiAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlck9mZiArIGldID0gZGF0YVtvZmYgKyBpXTtcbiAgdGhpcy5idWZmZXJPZmYgKz0gbWluO1xuXG4gIC8vIFNoaWZ0IG5leHRcbiAgcmV0dXJuIG1pbjtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZsdXNoQnVmZmVyID0gZnVuY3Rpb24gX2ZsdXNoQnVmZmVyKG91dCwgb2ZmKSB7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLmJ1ZmZlciwgMCwgb3V0LCBvZmYpO1xuICB0aGlzLmJ1ZmZlck9mZiA9IDA7XG4gIHJldHVybiB0aGlzLmJsb2NrU2l6ZTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZUVuY3J5cHQgPSBmdW5jdGlvbiBfdXBkYXRlRW5jcnlwdChkYXRhKSB7XG4gIHZhciBpbnB1dE9mZiA9IDA7XG4gIHZhciBvdXRwdXRPZmYgPSAwO1xuXG4gIHZhciBjb3VudCA9ICgodGhpcy5idWZmZXJPZmYgKyBkYXRhLmxlbmd0aCkgLyB0aGlzLmJsb2NrU2l6ZSkgfCAwO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGNvdW50ICogdGhpcy5ibG9ja1NpemUpO1xuXG4gIGlmICh0aGlzLmJ1ZmZlck9mZiAhPT0gMCkge1xuICAgIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG5cbiAgICBpZiAodGhpcy5idWZmZXJPZmYgPT09IHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgIG91dHB1dE9mZiArPSB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIG91dHB1dE9mZik7XG4gIH1cblxuICAvLyBXcml0ZSBibG9ja3NcbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoIC0gKChkYXRhLmxlbmd0aCAtIGlucHV0T2ZmKSAlIHRoaXMuYmxvY2tTaXplKTtcbiAgZm9yICg7IGlucHV0T2ZmIDwgbWF4OyBpbnB1dE9mZiArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZShkYXRhLCBpbnB1dE9mZiwgb3V0LCBvdXRwdXRPZmYpO1xuICAgIG91dHB1dE9mZiArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfVxuXG4gIC8vIFF1ZXVlIHJlc3RcbiAgZm9yICg7IGlucHV0T2ZmIDwgZGF0YS5sZW5ndGg7IGlucHV0T2ZmKyssIHRoaXMuYnVmZmVyT2ZmKyspXG4gICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJPZmZdID0gZGF0YVtpbnB1dE9mZl07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZURlY3J5cHQgPSBmdW5jdGlvbiBfdXBkYXRlRGVjcnlwdChkYXRhKSB7XG4gIHZhciBpbnB1dE9mZiA9IDA7XG4gIHZhciBvdXRwdXRPZmYgPSAwO1xuXG4gIHZhciBjb3VudCA9IE1hdGguY2VpbCgodGhpcy5idWZmZXJPZmYgKyBkYXRhLmxlbmd0aCkgLyB0aGlzLmJsb2NrU2l6ZSkgLSAxO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGNvdW50ICogdGhpcy5ibG9ja1NpemUpO1xuXG4gIC8vIFRPRE8oaW5kdXRueSk6IG9wdGltaXplIGl0LCB0aGlzIGlzIGZhciBmcm9tIG9wdGltYWxcbiAgZm9yICg7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG4gICAgb3V0cHV0T2ZmICs9IHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgb3V0cHV0T2ZmKTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciByZXN0IG9mIHRoZSBpbnB1dFxuICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gZmluYWwoYnVmZmVyKSB7XG4gIHZhciBmaXJzdDtcbiAgaWYgKGJ1ZmZlcilcbiAgICBmaXJzdCA9IHRoaXMudXBkYXRlKGJ1ZmZlcik7XG5cbiAgdmFyIGxhc3Q7XG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0JylcbiAgICBsYXN0ID0gdGhpcy5fZmluYWxFbmNyeXB0KCk7XG4gIGVsc2VcbiAgICBsYXN0ID0gdGhpcy5fZmluYWxEZWNyeXB0KCk7XG5cbiAgaWYgKGZpcnN0KVxuICAgIHJldHVybiBmaXJzdC5jb25jYXQobGFzdCk7XG4gIGVsc2VcbiAgICByZXR1cm4gbGFzdDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIF9wYWQoYnVmZmVyLCBvZmYpIHtcbiAgaWYgKG9mZiA9PT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgd2hpbGUgKG9mZiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgYnVmZmVyW29mZisrXSA9IDA7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbEVuY3J5cHQgPSBmdW5jdGlvbiBfZmluYWxFbmNyeXB0KCkge1xuICBpZiAoIXRoaXMuX3BhZCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJPZmYpKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgb3V0ID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuYnVmZmVyLCAwLCBvdXQsIDApO1xuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdW5wYWQgPSBmdW5jdGlvbiBfdW5wYWQoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbERlY3J5cHQgPSBmdW5jdGlvbiBfZmluYWxEZWNyeXB0KCkge1xuICBhc3NlcnQuZXF1YWwodGhpcy5idWZmZXJPZmYsIHRoaXMuYmxvY2tTaXplLCAnTm90IGVub3VnaCBkYXRhIHRvIGRlY3J5cHQnKTtcbiAgdmFyIG91dCA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgMCk7XG5cbiAgcmV0dXJuIHRoaXMuX3VucGFkKG91dCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGRlcyA9IHJlcXVpcmUoJy4uL2RlcycpO1xudmFyIHV0aWxzID0gZGVzLnV0aWxzO1xudmFyIENpcGhlciA9IGRlcy5DaXBoZXI7XG5cbmZ1bmN0aW9uIERFU1N0YXRlKCkge1xuICB0aGlzLnRtcCA9IG5ldyBBcnJheSgyKTtcbiAgdGhpcy5rZXlzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gREVTKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IERFU1N0YXRlKCk7XG4gIHRoaXMuX2Rlc1N0YXRlID0gc3RhdGU7XG5cbiAgdGhpcy5kZXJpdmVLZXlzKHN0YXRlLCBvcHRpb25zLmtleSk7XG59XG5pbmhlcml0cyhERVMsIENpcGhlcik7XG5tb2R1bGUuZXhwb3J0cyA9IERFUztcblxuREVTLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgREVTKG9wdGlvbnMpO1xufTtcblxudmFyIHNoaWZ0VGFibGUgPSBbXG4gIDEsIDEsIDIsIDIsIDIsIDIsIDIsIDIsXG4gIDEsIDIsIDIsIDIsIDIsIDIsIDIsIDFcbl07XG5cbkRFUy5wcm90b3R5cGUuZGVyaXZlS2V5cyA9IGZ1bmN0aW9uIGRlcml2ZUtleXMoc3RhdGUsIGtleSkge1xuICBzdGF0ZS5rZXlzID0gbmV3IEFycmF5KDE2ICogMik7XG5cbiAgYXNzZXJ0LmVxdWFsKGtleS5sZW5ndGgsIHRoaXMuYmxvY2tTaXplLCAnSW52YWxpZCBrZXkgbGVuZ3RoJyk7XG5cbiAgdmFyIGtMID0gdXRpbHMucmVhZFVJbnQzMkJFKGtleSwgMCk7XG4gIHZhciBrUiA9IHV0aWxzLnJlYWRVSW50MzJCRShrZXksIDQpO1xuXG4gIHV0aWxzLnBjMShrTCwga1IsIHN0YXRlLnRtcCwgMCk7XG4gIGtMID0gc3RhdGUudG1wWzBdO1xuICBrUiA9IHN0YXRlLnRtcFsxXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHNoaWZ0ID0gc2hpZnRUYWJsZVtpID4+PiAxXTtcbiAgICBrTCA9IHV0aWxzLnIyOHNobChrTCwgc2hpZnQpO1xuICAgIGtSID0gdXRpbHMucjI4c2hsKGtSLCBzaGlmdCk7XG4gICAgdXRpbHMucGMyKGtMLCBrUiwgc3RhdGUua2V5cywgaSk7XG4gIH1cbn07XG5cbkRFUy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fZGVzU3RhdGU7XG5cbiAgdmFyIGwgPSB1dGlscy5yZWFkVUludDMyQkUoaW5wLCBpbk9mZik7XG4gIHZhciByID0gdXRpbHMucmVhZFVJbnQzMkJFKGlucCwgaW5PZmYgKyA0KTtcblxuICAvLyBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLmlwKGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKVxuICAgIHRoaXMuX2VuY3J5cHQoc3RhdGUsIGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGVsc2VcbiAgICB0aGlzLl9kZWNyeXB0KHN0YXRlLCBsLCByLCBzdGF0ZS50bXAsIDApO1xuXG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgdXRpbHMud3JpdGVVSW50MzJCRShvdXQsIGwsIG91dE9mZik7XG4gIHV0aWxzLndyaXRlVUludDMyQkUob3V0LCByLCBvdXRPZmYgKyA0KTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIF9wYWQoYnVmZmVyLCBvZmYpIHtcbiAgdmFyIHZhbHVlID0gYnVmZmVyLmxlbmd0aCAtIG9mZjtcbiAgZm9yICh2YXIgaSA9IG9mZjsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKylcbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3VucGFkID0gZnVuY3Rpb24gX3VucGFkKGJ1ZmZlcikge1xuICB2YXIgcGFkID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXTtcbiAgZm9yICh2YXIgaSA9IGJ1ZmZlci5sZW5ndGggLSBwYWQ7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgYXNzZXJ0LmVxdWFsKGJ1ZmZlcltpXSwgcGFkKTtcblxuICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ1ZmZlci5sZW5ndGggLSBwYWQpO1xufTtcblxuREVTLnByb3RvdHlwZS5fZW5jcnlwdCA9IGZ1bmN0aW9uIF9lbmNyeXB0KHN0YXRlLCBsU3RhcnQsIHJTdGFydCwgb3V0LCBvZmYpIHtcbiAgdmFyIGwgPSBsU3RhcnQ7XG4gIHZhciByID0gclN0YXJ0O1xuXG4gIC8vIEFwcGx5IGYoKSB4MTYgdGltZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGtleUwgPSBzdGF0ZS5rZXlzW2ldO1xuICAgIHZhciBrZXlSID0gc3RhdGUua2V5c1tpICsgMV07XG5cbiAgICAvLyBmKHIsIGspXG4gICAgdXRpbHMuZXhwYW5kKHIsIHN0YXRlLnRtcCwgMCk7XG5cbiAgICBrZXlMIF49IHN0YXRlLnRtcFswXTtcbiAgICBrZXlSIF49IHN0YXRlLnRtcFsxXTtcbiAgICB2YXIgcyA9IHV0aWxzLnN1YnN0aXR1dGUoa2V5TCwga2V5Uik7XG4gICAgdmFyIGYgPSB1dGlscy5wZXJtdXRlKHMpO1xuXG4gICAgdmFyIHQgPSByO1xuICAgIHIgPSAobCBeIGYpID4+PiAwO1xuICAgIGwgPSB0O1xuICB9XG5cbiAgLy8gUmV2ZXJzZSBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLnJpcChyLCBsLCBvdXQsIG9mZik7XG59O1xuXG5ERVMucHJvdG90eXBlLl9kZWNyeXB0ID0gZnVuY3Rpb24gX2RlY3J5cHQoc3RhdGUsIGxTdGFydCwgclN0YXJ0LCBvdXQsIG9mZikge1xuICB2YXIgbCA9IHJTdGFydDtcbiAgdmFyIHIgPSBsU3RhcnQ7XG5cbiAgLy8gQXBwbHkgZigpIHgxNiB0aW1lc1xuICBmb3IgKHZhciBpID0gc3RhdGUua2V5cy5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgIHZhciBrZXlMID0gc3RhdGUua2V5c1tpXTtcbiAgICB2YXIga2V5UiA9IHN0YXRlLmtleXNbaSArIDFdO1xuXG4gICAgLy8gZihyLCBrKVxuICAgIHV0aWxzLmV4cGFuZChsLCBzdGF0ZS50bXAsIDApO1xuXG4gICAga2V5TCBePSBzdGF0ZS50bXBbMF07XG4gICAga2V5UiBePSBzdGF0ZS50bXBbMV07XG4gICAgdmFyIHMgPSB1dGlscy5zdWJzdGl0dXRlKGtleUwsIGtleVIpO1xuICAgIHZhciBmID0gdXRpbHMucGVybXV0ZShzKTtcblxuICAgIHZhciB0ID0gbDtcbiAgICBsID0gKHIgXiBmKSA+Pj4gMDtcbiAgICByID0gdDtcbiAgfVxuXG4gIC8vIFJldmVyc2UgSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5yaXAobCwgciwgb3V0LCBvZmYpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBkZXMgPSByZXF1aXJlKCcuLi9kZXMnKTtcbnZhciBDaXBoZXIgPSBkZXMuQ2lwaGVyO1xudmFyIERFUyA9IGRlcy5ERVM7XG5cbmZ1bmN0aW9uIEVERVN0YXRlKHR5cGUsIGtleSkge1xuICBhc3NlcnQuZXF1YWwoa2V5Lmxlbmd0aCwgMjQsICdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICB2YXIgazEgPSBrZXkuc2xpY2UoMCwgOCk7XG4gIHZhciBrMiA9IGtleS5zbGljZSg4LCAxNik7XG4gIHZhciBrMyA9IGtleS5zbGljZSgxNiwgMjQpO1xuXG4gIGlmICh0eXBlID09PSAnZW5jcnlwdCcpIHtcbiAgICB0aGlzLmNpcGhlcnMgPSBbXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsxIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMiB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazMgfSlcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2lwaGVycyA9IFtcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazMgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsyIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMSB9KVxuICAgIF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRURFKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IEVERVN0YXRlKHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLmtleSk7XG4gIHRoaXMuX2VkZVN0YXRlID0gc3RhdGU7XG59XG5pbmhlcml0cyhFREUsIENpcGhlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gRURFO1xuXG5FREUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBFREUob3B0aW9ucyk7XG59O1xuXG5FREUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2VkZVN0YXRlO1xuXG4gIHN0YXRlLmNpcGhlcnNbMF0uX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZik7XG4gIHN0YXRlLmNpcGhlcnNbMV0uX3VwZGF0ZShvdXQsIG91dE9mZiwgb3V0LCBvdXRPZmYpO1xuICBzdGF0ZS5jaXBoZXJzWzJdLl91cGRhdGUob3V0LCBvdXRPZmYsIG91dCwgb3V0T2ZmKTtcbn07XG5cbkVERS5wcm90b3R5cGUuX3BhZCA9IERFUy5wcm90b3R5cGUuX3BhZDtcbkVERS5wcm90b3R5cGUuX3VucGFkID0gREVTLnByb3RvdHlwZS5fdW5wYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGJ5dGVzLCBvZmYpIHtcbiAgdmFyIHJlcyA9ICAoYnl0ZXNbMCArIG9mZl0gPDwgMjQpIHxcbiAgICAgICAgICAgICAoYnl0ZXNbMSArIG9mZl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAoYnl0ZXNbMiArIG9mZl0gPDwgOCkgfFxuICAgICAgICAgICAgIGJ5dGVzWzMgKyBvZmZdO1xuICByZXR1cm4gcmVzID4+PiAwO1xufTtcblxuZXhwb3J0cy53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRShieXRlcywgdmFsdWUsIG9mZikge1xuICBieXRlc1swICsgb2ZmXSA9IHZhbHVlID4+PiAyNDtcbiAgYnl0ZXNbMSArIG9mZl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gIGJ5dGVzWzIgKyBvZmZdID0gKHZhbHVlID4+PiA4KSAmIDB4ZmY7XG4gIGJ5dGVzWzMgKyBvZmZdID0gdmFsdWUgJiAweGZmO1xufTtcblxuZXhwb3J0cy5pcCA9IGZ1bmN0aW9uIGlwKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBmb3IgKHZhciBpID0gNjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gNjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSAyNTsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDI1OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5yaXAgPSBmdW5jdGlvbiByaXAoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gNDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5wYzEgPSBmdW5jdGlvbiBwYzEoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIC8vIDcsIDE1LCAyMywgMzEsIDM5LCA0NywgNTUsIDYzXG4gIC8vIDYsIDE0LCAyMiwgMzAsIDM5LCA0NywgNTUsIDYzXG4gIC8vIDUsIDEzLCAyMSwgMjksIDM5LCA0NywgNTUsIDYzXG4gIC8vIDQsIDEyLCAyMCwgMjhcbiAgZm9yICh2YXIgaSA9IDc7IGkgPj0gNTsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgb3V0TCA8PD0gMTtcbiAgICBvdXRMIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICB9XG5cbiAgLy8gMSwgOSwgMTcsIDI1LCAzMywgNDEsIDQ5LCA1N1xuICAvLyAyLCAxMCwgMTgsIDI2LCAzNCwgNDIsIDUwLCA1OFxuICAvLyAzLCAxMSwgMTksIDI3LCAzNSwgNDMsIDUxLCA1OVxuICAvLyAzNiwgNDQsIDUyLCA2MFxuICBmb3IgKHZhciBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICBvdXRSIDw8PSAxO1xuICAgIG91dFIgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5yMjhzaGwgPSBmdW5jdGlvbiByMjhzaGwobnVtLCBzaGlmdCkge1xuICByZXR1cm4gKChudW0gPDwgc2hpZnQpICYgMHhmZmZmZmZmKSB8IChudW0gPj4+ICgyOCAtIHNoaWZ0KSk7XG59O1xuXG52YXIgcGMydGFibGUgPSBbXG4gIC8vIGluTCA9PiBvdXRMXG4gIDE0LCAxMSwgMTcsIDQsIDI3LCAyMywgMjUsIDAsXG4gIDEzLCAyMiwgNywgMTgsIDUsIDksIDE2LCAyNCxcbiAgMiwgMjAsIDEyLCAyMSwgMSwgOCwgMTUsIDI2LFxuXG4gIC8vIGluUiA9PiBvdXRSXG4gIDE1LCA0LCAyNSwgMTksIDksIDEsIDI2LCAxNixcbiAgNSwgMTEsIDIzLCA4LCAxMiwgNywgMTcsIDAsXG4gIDIyLCAzLCAxMCwgMTQsIDYsIDIwLCAyNywgMjRcbl07XG5cbmV4cG9ydHMucGMyID0gZnVuY3Rpb24gcGMyKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICB2YXIgbGVuID0gcGMydGFibGUubGVuZ3RoID4+PiAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0TCA8PD0gMTtcbiAgICBvdXRMIHw9IChpbkwgPj4+IHBjMnRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuICBmb3IgKHZhciBpID0gbGVuOyBpIDwgcGMydGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRSIDw8PSAxO1xuICAgIG91dFIgfD0gKGluUiA+Pj4gcGMydGFibGVbaV0pICYgMHgxO1xuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMuZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKHIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIG91dEwgPSAoKHIgJiAxKSA8PCA1KSB8IChyID4+PiAyNyk7XG4gIGZvciAodmFyIGkgPSAyMzsgaSA+PSAxNTsgaSAtPSA0KSB7XG4gICAgb3V0TCA8PD0gNjtcbiAgICBvdXRMIHw9IChyID4+PiBpKSAmIDB4M2Y7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDExOyBpID49IDM7IGkgLT0gNCkge1xuICAgIG91dFIgfD0gKHIgPj4+IGkpICYgMHgzZjtcbiAgICBvdXRSIDw8PSA2O1xuICB9XG4gIG91dFIgfD0gKChyICYgMHgxZikgPDwgMSkgfCAociA+Pj4gMzEpO1xuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG52YXIgc1RhYmxlID0gW1xuICAxNCwgMCwgNCwgMTUsIDEzLCA3LCAxLCA0LCAyLCAxNCwgMTUsIDIsIDExLCAxMywgOCwgMSxcbiAgMywgMTAsIDEwLCA2LCA2LCAxMiwgMTIsIDExLCA1LCA5LCA5LCA1LCAwLCAzLCA3LCA4LFxuICA0LCAxNSwgMSwgMTIsIDE0LCA4LCA4LCAyLCAxMywgNCwgNiwgOSwgMiwgMSwgMTEsIDcsXG4gIDE1LCA1LCAxMiwgMTEsIDksIDMsIDcsIDE0LCAzLCAxMCwgMTAsIDAsIDUsIDYsIDAsIDEzLFxuXG4gIDE1LCAzLCAxLCAxMywgOCwgNCwgMTQsIDcsIDYsIDE1LCAxMSwgMiwgMywgOCwgNCwgMTQsXG4gIDksIDEyLCA3LCAwLCAyLCAxLCAxMywgMTAsIDEyLCA2LCAwLCA5LCA1LCAxMSwgMTAsIDUsXG4gIDAsIDEzLCAxNCwgOCwgNywgMTAsIDExLCAxLCAxMCwgMywgNCwgMTUsIDEzLCA0LCAxLCAyLFxuICA1LCAxMSwgOCwgNiwgMTIsIDcsIDYsIDEyLCA5LCAwLCAzLCA1LCAyLCAxNCwgMTUsIDksXG5cbiAgMTAsIDEzLCAwLCA3LCA5LCAwLCAxNCwgOSwgNiwgMywgMywgNCwgMTUsIDYsIDUsIDEwLFxuICAxLCAyLCAxMywgOCwgMTIsIDUsIDcsIDE0LCAxMSwgMTIsIDQsIDExLCAyLCAxNSwgOCwgMSxcbiAgMTMsIDEsIDYsIDEwLCA0LCAxMywgOSwgMCwgOCwgNiwgMTUsIDksIDMsIDgsIDAsIDcsXG4gIDExLCA0LCAxLCAxNSwgMiwgMTQsIDEyLCAzLCA1LCAxMSwgMTAsIDUsIDE0LCAyLCA3LCAxMixcblxuICA3LCAxMywgMTMsIDgsIDE0LCAxMSwgMywgNSwgMCwgNiwgNiwgMTUsIDksIDAsIDEwLCAzLFxuICAxLCA0LCAyLCA3LCA4LCAyLCA1LCAxMiwgMTEsIDEsIDEyLCAxMCwgNCwgMTQsIDE1LCA5LFxuICAxMCwgMywgNiwgMTUsIDksIDAsIDAsIDYsIDEyLCAxMCwgMTEsIDEsIDcsIDEzLCAxMywgOCxcbiAgMTUsIDksIDEsIDQsIDMsIDUsIDE0LCAxMSwgNSwgMTIsIDIsIDcsIDgsIDIsIDQsIDE0LFxuXG4gIDIsIDE0LCAxMiwgMTEsIDQsIDIsIDEsIDEyLCA3LCA0LCAxMCwgNywgMTEsIDEzLCA2LCAxLFxuICA4LCA1LCA1LCAwLCAzLCAxNSwgMTUsIDEwLCAxMywgMywgMCwgOSwgMTQsIDgsIDksIDYsXG4gIDQsIDExLCAyLCA4LCAxLCAxMiwgMTEsIDcsIDEwLCAxLCAxMywgMTQsIDcsIDIsIDgsIDEzLFxuICAxNSwgNiwgOSwgMTUsIDEyLCAwLCA1LCA5LCA2LCAxMCwgMywgNCwgMCwgNSwgMTQsIDMsXG5cbiAgMTIsIDEwLCAxLCAxNSwgMTAsIDQsIDE1LCAyLCA5LCA3LCAyLCAxMiwgNiwgOSwgOCwgNSxcbiAgMCwgNiwgMTMsIDEsIDMsIDEzLCA0LCAxNCwgMTQsIDAsIDcsIDExLCA1LCAzLCAxMSwgOCxcbiAgOSwgNCwgMTQsIDMsIDE1LCAyLCA1LCAxMiwgMiwgOSwgOCwgNSwgMTIsIDE1LCAzLCAxMCxcbiAgNywgMTEsIDAsIDE0LCA0LCAxLCAxMCwgNywgMSwgNiwgMTMsIDAsIDExLCA4LCA2LCAxMyxcblxuICA0LCAxMywgMTEsIDAsIDIsIDExLCAxNCwgNywgMTUsIDQsIDAsIDksIDgsIDEsIDEzLCAxMCxcbiAgMywgMTQsIDEyLCAzLCA5LCA1LCA3LCAxMiwgNSwgMiwgMTAsIDE1LCA2LCA4LCAxLCA2LFxuICAxLCA2LCA0LCAxMSwgMTEsIDEzLCAxMywgOCwgMTIsIDEsIDMsIDQsIDcsIDEwLCAxNCwgNyxcbiAgMTAsIDksIDE1LCA1LCA2LCAwLCA4LCAxNSwgMCwgMTQsIDUsIDIsIDksIDMsIDIsIDEyLFxuXG4gIDEzLCAxLCAyLCAxNSwgOCwgMTMsIDQsIDgsIDYsIDEwLCAxNSwgMywgMTEsIDcsIDEsIDQsXG4gIDEwLCAxMiwgOSwgNSwgMywgNiwgMTQsIDExLCA1LCAwLCAwLCAxNCwgMTIsIDksIDcsIDIsXG4gIDcsIDIsIDExLCAxLCA0LCAxNCwgMSwgNywgOSwgNCwgMTIsIDEwLCAxNCwgOCwgMiwgMTMsXG4gIDAsIDE1LCA2LCAxMiwgMTAsIDksIDEzLCAwLCAxNSwgMywgMywgNSwgNSwgNiwgOCwgMTFcbl07XG5cbmV4cG9ydHMuc3Vic3RpdHV0ZSA9IGZ1bmN0aW9uIHN1YnN0aXR1dGUoaW5MLCBpblIpIHtcbiAgdmFyIG91dCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIGIgPSAoaW5MID4+PiAoMTggLSBpICogNikpICYgMHgzZjtcbiAgICB2YXIgc2IgPSBzVGFibGVbaSAqIDB4NDAgKyBiXTtcblxuICAgIG91dCA8PD0gNDtcbiAgICBvdXQgfD0gc2I7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgYiA9IChpblIgPj4+ICgxOCAtIGkgKiA2KSkgJiAweDNmO1xuICAgIHZhciBzYiA9IHNUYWJsZVs0ICogMHg0MCArIGkgKiAweDQwICsgYl07XG5cbiAgICBvdXQgPDw9IDQ7XG4gICAgb3V0IHw9IHNiO1xuICB9XG4gIHJldHVybiBvdXQgPj4+IDA7XG59O1xuXG52YXIgcGVybXV0ZVRhYmxlID0gW1xuICAxNiwgMjUsIDEyLCAxMSwgMywgMjAsIDQsIDE1LCAzMSwgMTcsIDksIDYsIDI3LCAxNCwgMSwgMjIsXG4gIDMwLCAyNCwgOCwgMTgsIDAsIDUsIDI5LCAyMywgMTMsIDE5LCAyLCAyNiwgMTAsIDIxLCAyOCwgN1xuXTtcblxuZXhwb3J0cy5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZShudW0pIHtcbiAgdmFyIG91dCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGVybXV0ZVRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0IDw8PSAxO1xuICAgIG91dCB8PSAobnVtID4+PiBwZXJtdXRlVGFibGVbaV0pICYgMHgxO1xuICB9XG4gIHJldHVybiBvdXQgPj4+IDA7XG59O1xuXG5leHBvcnRzLnBhZFNwbGl0ID0gZnVuY3Rpb24gcGFkU3BsaXQobnVtLCBzaXplLCBncm91cCkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDIpO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgc3RyID0gJzAnICsgc3RyO1xuXG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IGdyb3VwKVxuICAgIG91dC5wdXNoKHN0ci5zbGljZShpLCBpICsgZ3JvdXApKTtcbiAgcmV0dXJuIG91dC5qb2luKCcgJyk7XG59O1xuIiwidmFyIGdlbmVyYXRlUHJpbWUgPSByZXF1aXJlKCcuL2xpYi9nZW5lcmF0ZVByaW1lJylcbnZhciBwcmltZXMgPSByZXF1aXJlKCcuL2xpYi9wcmltZXMuanNvbicpXG5cbnZhciBESCA9IHJlcXVpcmUoJy4vbGliL2RoJylcblxuZnVuY3Rpb24gZ2V0RGlmZmllSGVsbG1hbiAobW9kKSB7XG4gIHZhciBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWVzW21vZF0ucHJpbWUsICdoZXgnKVxuICB2YXIgZ2VuID0gbmV3IEJ1ZmZlcihwcmltZXNbbW9kXS5nZW4sICdoZXgnKVxuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbilcbn1cblxudmFyIEVOQ09ESU5HUyA9IHtcbiAgJ2JpbmFyeSc6IHRydWUsICdoZXgnOiB0cnVlLCAnYmFzZTY0JzogdHJ1ZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEaWZmaWVIZWxsbWFuIChwcmltZSwgZW5jLCBnZW5lcmF0b3IsIGdlbmMpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlbmMpIHx8IEVOQ09ESU5HU1tlbmNdID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlRGlmZmllSGVsbG1hbihwcmltZSwgJ2JpbmFyeScsIGVuYywgZ2VuZXJhdG9yKVxuICB9XG5cbiAgZW5jID0gZW5jIHx8ICdiaW5hcnknXG4gIGdlbmMgPSBnZW5jIHx8ICdiaW5hcnknXG4gIGdlbmVyYXRvciA9IGdlbmVyYXRvciB8fCBuZXcgQnVmZmVyKFsyXSlcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihnZW5lcmF0b3IpKSB7XG4gICAgZ2VuZXJhdG9yID0gbmV3IEJ1ZmZlcihnZW5lcmF0b3IsIGdlbmMpXG4gIH1cblxuICBpZiAodHlwZW9mIHByaW1lID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXcgREgoZ2VuZXJhdGVQcmltZShwcmltZSwgZ2VuZXJhdG9yKSwgZ2VuZXJhdG9yLCB0cnVlKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpbWUpKSB7XG4gICAgcHJpbWUgPSBuZXcgQnVmZmVyKHByaW1lLCBlbmMpXG4gIH1cblxuICByZXR1cm4gbmV3IERIKHByaW1lLCBnZW5lcmF0b3IsIHRydWUpXG59XG5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbkdyb3VwID0gZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAgPSBleHBvcnRzLmdldERpZmZpZUhlbGxtYW4gPSBnZXREaWZmaWVIZWxsbWFuXG5leHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW4gPSBleHBvcnRzLkRpZmZpZUhlbGxtYW4gPSBjcmVhdGVEaWZmaWVIZWxsbWFuXG4iLCJ2YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVByaW1lJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBESDtcblxuZnVuY3Rpb24gc2V0UHVibGljS2V5KHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcbiAgICBwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wdWIgPSBuZXcgQk4ocHViKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldFByaXZhdGVLZXkocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wcml2ID0gbmV3IEJOKHByaXYpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByaW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGNoZWNrUHJpbWUocHJpbWUsIGdlbmVyYXRvcikge1xuICB2YXIgZ2VuID0gZ2VuZXJhdG9yLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIGhleCA9IFtnZW4sIHByaW1lLnRvU3RyaW5nKDE2KV0uam9pbignXycpO1xuICBpZiAoaGV4IGluIHByaW1lQ2FjaGUpIHtcbiAgICByZXR1cm4gcHJpbWVDYWNoZVtoZXhdO1xuICB9XG4gIHZhciBlcnJvciA9IDA7XG5cbiAgaWYgKHByaW1lLmlzRXZlbigpIHx8XG4gICAgIXByaW1lcy5zaW1wbGVTaWV2ZSB8fFxuICAgICFwcmltZXMuZmVybWF0VGVzdChwcmltZSkgfHxcbiAgICAhbWlsbGVyUmFiaW4udGVzdChwcmltZSkpIHtcbiAgICAvL25vdCBhIHByaW1lIHNvICsxXG4gICAgZXJyb3IgKz0gMTtcblxuICAgIGlmIChnZW4gPT09ICcwMicgfHwgZ2VuID09PSAnMDUnKSB7XG4gICAgICAvLyB3ZSdkIGJlIGFibGUgdG8gY2hlY2sgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gaXQgd291bGQgZmFpbCBzbyArOFxuICAgICAgZXJyb3IgKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgLy93ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHRlc3QgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gc28gKzRcbiAgICAgIGVycm9yICs9IDQ7XG4gICAgfVxuICAgIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoIW1pbGxlclJhYmluLnRlc3QocHJpbWUuc2hybigxKSkpIHtcbiAgICAvL25vdCBhIHNhZmUgcHJpbWVcbiAgICBlcnJvciArPSAyO1xuICB9XG4gIHZhciByZW07XG4gIHN3aXRjaCAoZ2VuKSB7XG4gICAgY2FzZSAnMDInOlxuICAgICAgaWYgKHByaW1lLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICAvLyB1bnN1aWRhYmxlIGdlbmVyYXRvclxuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMDUnOlxuICAgICAgcmVtID0gcHJpbWUubW9kKFRFTik7XG4gICAgICBpZiAocmVtLmNtcChUSFJFRSkgJiYgcmVtLmNtcChTRVZFTikpIHtcbiAgICAgICAgLy8gcHJpbWUgbW9kIDEwIG5lZWRzIHRvIGVxdWFsIDMgb3IgN1xuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9yICs9IDQ7XG4gIH1cbiAgcHJpbWVDYWNoZVtoZXhdID0gZXJyb3I7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gREgocHJpbWUsIGdlbmVyYXRvciwgbWFsbGVhYmxlKSB7XG4gIHRoaXMuc2V0R2VuZXJhdG9yKGdlbmVyYXRvcik7XG4gIHRoaXMuX19wcmltZSA9IG5ldyBCTihwcmltZSk7XG4gIHRoaXMuX3ByaW1lID0gQk4ubW9udCh0aGlzLl9fcHJpbWUpO1xuICB0aGlzLl9wcmltZUxlbiA9IHByaW1lLmxlbmd0aDtcbiAgdGhpcy5fcHViID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcml2ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcmltZUNvZGUgPSB1bmRlZmluZWQ7XG4gIGlmIChtYWxsZWFibGUpIHtcbiAgICB0aGlzLnNldFB1YmxpY0tleSA9IHNldFB1YmxpY0tleTtcbiAgICB0aGlzLnNldFByaXZhdGVLZXkgPSBzZXRQcml2YXRlS2V5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ByaW1lQ29kZSA9IDg7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShESC5wcm90b3R5cGUsICd2ZXJpZnlFcnJvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wcmltZUNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9wcmltZUNvZGUgPSBjaGVja1ByaW1lKHRoaXMuX19wcmltZSwgdGhpcy5fX2dlbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmltZUNvZGU7XG4gIH1cbn0pO1xuREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9wcml2KSB7XG4gICAgdGhpcy5fcHJpdiA9IG5ldyBCTihyYW5kb21CeXRlcyh0aGlzLl9wcmltZUxlbikpO1xuICB9XG4gIHRoaXMuX3B1YiA9IHRoaXMuX2dlbi50b1JlZCh0aGlzLl9wcmltZSkucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KCk7XG59O1xuXG5ESC5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBvdGhlciA9IG5ldyBCTihvdGhlcik7XG4gIG90aGVyID0gb3RoZXIudG9SZWQodGhpcy5fcHJpbWUpO1xuICB2YXIgc2VjcmV0ID0gb3RoZXIucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2VjcmV0LnRvQXJyYXkoKSk7XG4gIHZhciBwcmltZSA9IHRoaXMuZ2V0UHJpbWUoKTtcbiAgaWYgKG91dC5sZW5ndGggPCBwcmltZS5sZW5ndGgpIHtcbiAgICB2YXIgZnJvbnQgPSBuZXcgQnVmZmVyKHByaW1lLmxlbmd0aCAtIG91dC5sZW5ndGgpO1xuICAgIGZyb250LmZpbGwoMCk7XG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbZnJvbnQsIG91dF0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gZ2V0UHVibGljS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHViLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiBnZXRQcml2YXRlS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHJpdiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQcmltZSA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX19wcmltZSwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9nZW4sIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuc2V0R2VuZXJhdG9yID0gZnVuY3Rpb24gKGdlbiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbikpIHtcbiAgICBnZW4gPSBuZXcgQnVmZmVyKGdlbiwgZW5jKTtcbiAgfVxuICB0aGlzLl9fZ2VuID0gZ2VuO1xuICB0aGlzLl9nZW4gPSBuZXcgQk4oZ2VuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRSZXR1cm5WYWx1ZShibiwgZW5jKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGJuLnRvQXJyYXkoKSk7XG4gIGlmICghZW5jKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuYyk7XG4gIH1cbn1cbiIsInZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRQcmltZTtcbmZpbmRQcmltZS5zaW1wbGVTaWV2ZSA9IHNpbXBsZVNpZXZlO1xuZmluZFByaW1lLmZlcm1hdFRlc3QgPSBmZXJtYXRUZXN0O1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBNaWxsZXJSYWJpbiA9IHJlcXVpcmUoJ21pbGxlci1yYWJpbicpO1xudmFyIG1pbGxlclJhYmluID0gbmV3IE1pbGxlclJhYmluKCk7XG52YXIgT05FID0gbmV3IEJOKDEpO1xudmFyIFRXTyA9IG5ldyBCTigyKTtcbnZhciBGSVZFID0gbmV3IEJOKDUpO1xudmFyIFNJWFRFRU4gPSBuZXcgQk4oMTYpO1xudmFyIEVJR0hUID0gbmV3IEJOKDgpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgRUxFVkVOID0gbmV3IEJOKDExKTtcbnZhciBGT1VSID0gbmV3IEJOKDQpO1xudmFyIFRXRUxWRSA9IG5ldyBCTigxMik7XG52YXIgcHJpbWVzID0gbnVsbDtcblxuZnVuY3Rpb24gX2dldFByaW1lcygpIHtcbiAgaWYgKHByaW1lcyAhPT0gbnVsbClcbiAgICByZXR1cm4gcHJpbWVzO1xuXG4gIHZhciBsaW1pdCA9IDB4MTAwMDAwO1xuICB2YXIgcmVzID0gW107XG4gIHJlc1swXSA9IDI7XG4gIGZvciAodmFyIGkgPSAxLCBrID0gMzsgayA8IGxpbWl0OyBrICs9IDIpIHtcbiAgICB2YXIgc3FydCA9IE1hdGguY2VpbChNYXRoLnNxcnQoaykpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSAmJiByZXNbal0gPD0gc3FydDsgaisrKVxuICAgICAgaWYgKGsgJSByZXNbal0gPT09IDApXG4gICAgICAgIGJyZWFrO1xuXG4gICAgaWYgKGkgIT09IGogJiYgcmVzW2pdIDw9IHNxcnQpXG4gICAgICBjb250aW51ZTtcblxuICAgIHJlc1tpKytdID0gaztcbiAgfVxuICBwcmltZXMgPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVNpZXZlKHApIHtcbiAgdmFyIHByaW1lcyA9IF9nZXRQcmltZXMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1lcy5sZW5ndGg7IGkrKylcbiAgICBpZiAocC5tb2RuKHByaW1lc1tpXSkgPT09IDApIHtcbiAgICAgIGlmIChwLmNtcG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZlcm1hdFRlc3QocCkge1xuICB2YXIgcmVkID0gQk4ubW9udChwKTtcbiAgcmV0dXJuIFRXTy50b1JlZChyZWQpLnJlZFBvdyhwLnN1Ym4oMSkpLmZyb21SZWQoKS5jbXBuKDEpID09PSAwO1xufVxuXG5mdW5jdGlvbiBmaW5kUHJpbWUoYml0cywgZ2VuKSB7XG4gIGlmIChiaXRzIDwgMTYpIHtcbiAgICAvLyB0aGlzIGlzIHdoYXQgb3BlbnNzbCBkb2VzXG4gICAgaWYgKGdlbiA9PT0gMiB8fCBnZW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBuZXcgQk4oWzB4OGMsIDB4N2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHgyN10pO1xuICAgIH1cbiAgfVxuICBnZW4gPSBuZXcgQk4oZ2VuKTtcblxuICB2YXIgbnVtLCBuMjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIG51bSA9IG5ldyBCTihyYW5kb21CeXRlcyhNYXRoLmNlaWwoYml0cyAvIDgpKSk7XG4gICAgd2hpbGUgKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bS5pc2hybigxKTtcbiAgICB9XG4gICAgaWYgKG51bS5pc0V2ZW4oKSkge1xuICAgICAgbnVtLmlhZGQoT05FKTtcbiAgICB9XG4gICAgaWYgKCFudW0udGVzdG4oMSkpIHtcbiAgICAgIG51bS5pYWRkKFRXTyk7XG4gICAgfVxuICAgIGlmICghZ2VuLmNtcChUV08pKSB7XG4gICAgICB3aGlsZSAobnVtLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICBudW0uaWFkZChGT1VSKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFnZW4uY21wKEZJVkUpKSB7XG4gICAgICB3aGlsZSAobnVtLm1vZChURU4pLmNtcChUSFJFRSkpIHtcbiAgICAgICAgbnVtLmlhZGQoRk9VUik7XG4gICAgICB9XG4gICAgfVxuICAgIG4yID0gbnVtLnNocm4oMSk7XG4gICAgaWYgKHNpbXBsZVNpZXZlKG4yKSAmJiBzaW1wbGVTaWV2ZShudW0pICYmXG4gICAgICBmZXJtYXRUZXN0KG4yKSAmJiBmZXJtYXRUZXN0KG51bSkgJiZcbiAgICAgIG1pbGxlclJhYmluLnRlc3QobjIpICYmIG1pbGxlclJhYmluLnRlc3QobnVtKSkge1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gIH1cblxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwibW9kcDFcIjoge1xuICAgICAgICBcImdlblwiOiBcIjAyXCIsXG4gICAgICAgIFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjNhMzYyMGZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwMlwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U2NTM4MWZmZmZmZmZmZmZmZmZmZmZcIlxuICAgIH0sXG4gICAgXCJtb2RwNVwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMjM3MzI3ZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxNFwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhY2FhNjhmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDE1XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkzYWQyY2FmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9LFxuICAgIFwibW9kcDE2XCI6IHtcbiAgICAgICAgXCJnZW5cIjogXCIwMlwiLFxuICAgICAgICBcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkyMTA4MDExYTcyM2MxMmE3ODdlNmQ3ODg3MTlhMTBiZGJhNWIyNjk5YzMyNzE4NmFmNGUyM2MxYTk0NjgzNGI2MTUwYmRhMjU4M2U5Y2EyYWQ0NGNlOGRiYmJjMmRiMDRkZThlZjkyZThlZmMxNDFmYmVjYWE2Mjg3YzU5NDc0ZTZiYzA1ZDk5YjI5NjRmYTA5MGMzYTIyMzNiYTE4NjUxNWJlN2VkMWY2MTI5NzBjZWUyZDdhZmI4MWJkZDc2MjE3MDQ4MWNkMDA2OTEyN2Q1YjA1YWE5OTNiNGVhOTg4ZDhmZGRjMTg2ZmZiN2RjOTBhNmMwOGY0ZGY0MzVjOTM0MDYzMTk5ZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxN1wiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDAyODQ5MjM2YzNmYWI0ZDI3YzcwMjZjMWQ0ZGNiMjYwMjY0NmRlYzk3NTFlNzYzZGJhMzdiZGY4ZmY5NDA2YWQ5ZTUzMGVlNWRiMzgyZjQxMzAwMWFlYjA2YTUzZWQ5MDI3ZDgzMTE3OTcyN2IwODY1YTg5MThkYTNlZGJlYmNmOWIxNGVkNDRjZTZjYmFjZWQ0YmIxYmRiN2YxNDQ3ZTZjYzI1NGIzMzIwNTE1MTJiZDdhZjQyNmZiOGY0MDEzNzhjZDJiZjU5ODNjYTAxYzY0YjkyZWNmMDMyZWExNWQxNzIxZDAzZjQ4MmQ3Y2U2ZTc0ZmVmNmQ1NWU3MDJmNDY5ODBjODJiNWE4NDAzMTkwMGIxYzllNTllN2M5N2ZiZWM3ZThmMzIzYTk3YTdlMzZjYzg4YmUwZjFkNDViN2ZmNTg1YWM1NGJkNDA3YjIyYjQxNTRhYWNjOGY2ZDdlYmY0OGUxZDgxNGNjNWVkMjBmODAzN2UwYTc5NzE1ZWVmMjliZTMyODA2YTFkNThiYjdjNWRhNzZmNTUwYWEzZDhhMWZiZmYwZWIxOWNjYjFhMzEzZDU1Y2RhNTZjOWVjMmVmMjk2MzIzODdmZThkNzZlM2MwNDY4MDQzZThmNjYzZjQ4NjBlZTEyYmYyZDViMGI3NDc0ZDZlNjk0ZjkxZTZkY2M0MDI0ZmZmZmZmZmZmZmZmZmZmZlwiXG4gICAgfSxcbiAgICBcIm1vZHAxOFwiOiB7XG4gICAgICAgIFwiZ2VuXCI6IFwiMDJcIixcbiAgICAgICAgXCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDAyODQ5MjM2YzNmYWI0ZDI3YzcwMjZjMWQ0ZGNiMjYwMjY0NmRlYzk3NTFlNzYzZGJhMzdiZGY4ZmY5NDA2YWQ5ZTUzMGVlNWRiMzgyZjQxMzAwMWFlYjA2YTUzZWQ5MDI3ZDgzMTE3OTcyN2IwODY1YTg5MThkYTNlZGJlYmNmOWIxNGVkNDRjZTZjYmFjZWQ0YmIxYmRiN2YxNDQ3ZTZjYzI1NGIzMzIwNTE1MTJiZDdhZjQyNmZiOGY0MDEzNzhjZDJiZjU5ODNjYTAxYzY0YjkyZWNmMDMyZWExNWQxNzIxZDAzZjQ4MmQ3Y2U2ZTc0ZmVmNmQ1NWU3MDJmNDY5ODBjODJiNWE4NDAzMTkwMGIxYzllNTllN2M5N2ZiZWM3ZThmMzIzYTk3YTdlMzZjYzg4YmUwZjFkNDViN2ZmNTg1YWM1NGJkNDA3YjIyYjQxNTRhYWNjOGY2ZDdlYmY0OGUxZDgxNGNjNWVkMjBmODAzN2UwYTc5NzE1ZWVmMjliZTMyODA2YTFkNThiYjdjNWRhNzZmNTUwYWEzZDhhMWZiZmYwZWIxOWNjYjFhMzEzZDU1Y2RhNTZjOWVjMmVmMjk2MzIzODdmZThkNzZlM2MwNDY4MDQzZThmNjYzZjQ4NjBlZTEyYmYyZDViMGI3NDc0ZDZlNjk0ZjkxZTZkYmUxMTU5NzRhMzkyNmYxMmZlZTVlNDM4Nzc3Y2I2YTkzMmRmOGNkOGJlYzRkMDczYjkzMWJhM2JjODMyYjY4ZDlkZDMwMDc0MWZhN2JmOGFmYzQ3ZWQyNTc2ZjY5MzZiYTQyNDY2M2FhYjYzOWM1YWU0ZjU2ODM0MjNiNDc0MmJmMWM5NzgyMzhmMTZjYmUzOWQ2NTJkZTNmZGI4YmVmYzg0OGFkOTIyMjIyZTA0YTQwMzdjMDcxM2ViNTdhODFhMjNmMGM3MzQ3M2ZjNjQ2Y2VhMzA2YjRiY2JjODg2MmY4Mzg1ZGRmYTlkNGI3ZmEyYzA4N2U4Nzk2ODMzMDNlZDViZGQzYTA2MmIzY2Y1YjNhMjc4YTY2ZDJhMTNmODNmNDRmODJkZGYzMTBlZTA3NGFiNmEzNjQ1OTdlODk5YTAyNTVkYzE2NGYzMWNjNTA4NDY4NTFkZjlhYjQ4MTk1ZGVkN2VhMWIxZDUxMGJkN2VlNzRkNzNmYWYzNmJjMzFlY2ZhMjY4MzU5MDQ2ZjRlYjg3OWY5MjQwMDk0MzhiNDgxYzZjZDc4ODlhMDAyZWQ1ZWUzODJiYzkxOTBkYTZmYzAyNmU0Nzk1NThlNDQ3NTY3N2U5YWE5ZTMwNTBlMjc2NTY5NGRmYzgxZjU2ZTg4MGI5NmU3MTYwYzk4MGRkOThlZGQzZGZmZmZmZmZmZmZmZmZmZmZmXCJcbiAgICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy91dGlscycpO1xuZWxsaXB0aWMucmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbmVsbGlwdGljLmN1cnZlID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZScpO1xuZWxsaXB0aWMuY3VydmVzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZXMnKTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWMnKTtcbmVsbGlwdGljLmVkZHNhID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lZGRzYScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBnZXROQUYgPSB1dGlscy5nZXROQUY7XG52YXIgZ2V0SlNGID0gdXRpbHMuZ2V0SlNGO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgLy8gR2VuZXJhbGl6ZWQgR3JlZyBNYXh3ZWxsJ3MgdHJpY2tcbiAgdmFyIGFkanVzdENvdW50ID0gdGhpcy5uICYmIHRoaXMucC5kaXYodGhpcy5uKTtcbiAgaWYgKCFhZGp1c3RDb3VudCB8fCBhZGp1c3RDb3VudC5jbXBuKDEwMCkgPiAwKSB7XG4gICAgdGhpcy5yZWROID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9tYXh3ZWxsVHJpY2sgPSB0cnVlO1xuICAgIHRoaXMucmVkTiA9IHRoaXMubi50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQmFzZUN1cnZlO1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG4gIGFzc2VydChwLnByZWNvbXB1dGVkKTtcbiAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cbiAgdmFyIG5hZiA9IGdldE5BRihrLCAxKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgIHZhciBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBrID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGsgPj0gajsgay0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2tdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXByLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFmVyA9IHJlcHJbal07XG4gICAgICBpZiAobmFmVyA9PT0gaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcbiAgICB9XG4gICAgYSA9IGEuYWRkKGIpO1xuICB9XG4gIHJldHVybiBhLnRvUCgpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgdmFyIHcgPSA0O1xuXG4gIC8vIFByZWNvbXB1dGUgd2luZG93XG4gIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG4gIHcgPSBuYWZQb2ludHMud25kO1xuICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuICAvLyBHZXQgTkFGIGZvcm1cbiAgdmFyIG5hZiA9IGdldE5BRihrLCB3KTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBrID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgaysrO1xuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0pO1xuICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0pO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYiA9IFtcbiAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuICAgICAgbnVsbCwgLyogMyAqL1xuICAgICAgbnVsbCwgLyogNSAqL1xuICAgICAgcG9pbnRzW2JdIC8qIDcgKi9cbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IFtcbiAgICAgIC0zLCAvKiAtMSAtMSAqL1xuICAgICAgLTEsIC8qIC0xIDAgKi9cbiAgICAgIC01LCAvKiAtMSAxICovXG4gICAgICAtNywgLyogMCAtMSAqL1xuICAgICAgMCwgLyogMCAwICovXG4gICAgICA3LCAvKiAwIDEgKi9cbiAgICAgIDUsIC8qIDEgLTEgKi9cbiAgICAgIDEsIC8qIDEgMCAqL1xuICAgICAgMyAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXg7IGorKykge1xuICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcbiAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cbiAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICB3bmRbYV0gPSBjb21iO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcbiAgZm9yICh2YXIgaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciB6ID0gdG1wW2pdO1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuICAgICAgZWxzZSBpZiAoeiA8IDApXG4gICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cbiAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICB9XG4gIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG5cbiAgaWYgKGphY29iaWFuUmVzdWx0KVxuICAgIHJldHVybiBhY2M7XG4gIGVsc2VcbiAgICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG4gIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuXG4gIC8vIHVuY29tcHJlc3NlZCwgaHlicmlkLW9kZCwgaHlicmlkLWV2ZW5cbiAgaWYgKChieXRlc1swXSA9PT0gMHgwNCB8fCBieXRlc1swXSA9PT0gMHgwNiB8fCBieXRlc1swXSA9PT0gMHgwNykgJiZcbiAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IDIgKiBsZW4pIHtcbiAgICBpZiAoYnl0ZXNbMF0gPT09IDB4MDYpXG4gICAgICBhc3NlcnQoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcbiAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcbiAgICAgIGFzc2VydChieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDEpO1xuXG4gICAgdmFyIHJlcyA9ICB0aGlzLnBvaW50KGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSkgO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZW5jLCBjb21wYWN0KSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbFxuICB9O1xuICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG4gIHByZWNvbXB1dGVkLmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIHBvd2VyKTtcbiAgcHJlY29tcHV0ZWQuYmV0YSA9IHRoaXMuX2dldEJldGEoKTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgaWYgKCFkb3VibGVzKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXMgPSBmdW5jdGlvbiBfZ2V0RG91YmxlcyhzdGVwLCBwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcblxuICB2YXIgZG91YmxlcyA9IFsgdGhpcyBdO1xuICB2YXIgYWNjID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3dlcjsgaSArPSBzdGVwKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwOyBqKyspXG4gICAgICBhY2MgPSBhY2MuZGJsKCk7XG4gICAgZG91Ymxlcy5wdXNoKGFjYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIHBvaW50czogZG91Ymxlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gX2dldE5BRlBvaW50cyh3bmQpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG4gIHZhciByZXMgPSBbIHRoaXMgXTtcbiAgdmFyIG1heCA9ICgxIDw8IHduZCkgLSAxO1xuICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbWF4OyBpKyspXG4gICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcbiAgcmV0dXJuIHtcbiAgICB3bmQ6IHduZCxcbiAgICBwb2ludHM6IHJlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEVkd2FyZHNDdXJ2ZShjb25mKSB7XG4gIC8vIE5PVEU6IEltcG9ydGFudCBhcyB3ZSBhcmUgY3JlYXRpbmcgcG9pbnQgaW4gQmFzZS5jYWxsKClcbiAgdGhpcy50d2lzdGVkID0gKGNvbmYuYSB8IDApICE9PSAxO1xuICB0aGlzLm1PbmVBID0gdGhpcy50d2lzdGVkICYmIChjb25mLmEgfCAwKSA9PT0gLTE7XG4gIHRoaXMuZXh0ZW5kZWQgPSB0aGlzLm1PbmVBO1xuXG4gIEJhc2UuY2FsbCh0aGlzLCAnZWR3YXJkcycsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS51bW9kKHRoaXMucmVkLm0pO1xuICB0aGlzLmEgPSB0aGlzLmEudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMgPSBuZXcgQk4oY29uZi5jLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMyID0gdGhpcy5jLnJlZFNxcigpO1xuICB0aGlzLmQgPSBuZXcgQk4oY29uZi5kLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmRkID0gdGhpcy5kLnJlZEFkZCh0aGlzLmQpO1xuXG4gIGFzc2VydCghdGhpcy50d2lzdGVkIHx8IHRoaXMuYy5mcm9tUmVkKCkuY21wbigxKSA9PT0gMCk7XG4gIHRoaXMub25lQyA9IChjb25mLmMgfCAwKSA9PT0gMTtcbn1cbmluaGVyaXRzKEVkd2FyZHNDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IEVkd2FyZHNDdXJ2ZTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQSA9IGZ1bmN0aW9uIF9tdWxBKG51bSkge1xuICBpZiAodGhpcy5tT25lQSlcbiAgICByZXR1cm4gbnVtLnJlZE5lZygpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYS5yZWRNdWwobnVtKTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEMgPSBmdW5jdGlvbiBfbXVsQyhudW0pIHtcbiAgaWYgKHRoaXMub25lQylcbiAgICByZXR1cm4gbnVtO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYy5yZWRNdWwobnVtKTtcbn07XG5cbi8vIEp1c3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTaG9ydCBjdXJ2ZVxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5LCB6LCB0KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeDIgPSB4LnJlZFNxcigpO1xuICB2YXIgcmhzID0gdGhpcy5jMi5yZWRTdWIodGhpcy5hLnJlZE11bCh4MikpO1xuICB2YXIgbGhzID0gdGhpcy5vbmUucmVkU3ViKHRoaXMuYzIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHgyKSk7XG5cbiAgdmFyIHkyID0gcmhzLnJlZE11bChsaHMucmVkSW52bSgpKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWSA9IGZ1bmN0aW9uIHBvaW50RnJvbVkoeSwgb2RkKSB7XG4gIHkgPSBuZXcgQk4oeSwgMTYpO1xuICBpZiAoIXkucmVkKVxuICAgIHkgPSB5LnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyB4XjIgPSAoeV4yIC0gY14yKSAvIChjXjIgZCB5XjIgLSBhKVxuICB2YXIgeTIgPSB5LnJlZFNxcigpO1xuICB2YXIgbGhzID0geTIucmVkU3ViKHRoaXMuYzIpO1xuICB2YXIgcmhzID0geTIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHRoaXMuYzIpLnJlZFN1Yih0aGlzLmEpO1xuICB2YXIgeDIgPSBsaHMucmVkTXVsKHJocy5yZWRJbnZtKCkpO1xuXG4gIGlmICh4Mi5jbXAodGhpcy56ZXJvKSA9PT0gMCkge1xuICAgIGlmIChvZGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5wb2ludCh0aGlzLnplcm8sIHkpO1xuICB9XG5cbiAgdmFyIHggPSB4Mi5yZWRTcXJ0KCk7XG4gIGlmICh4LnJlZFNxcigpLnJlZFN1Yih4MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgaWYgKHguZnJvbVJlZCgpLmlzT2RkKCkgIT09IG9kZClcbiAgICB4ID0geC5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIEN1cnZlOiBBICogWF4yICsgWV4yID0gQ14yICogKDEgKyBEICogWF4yICogWV4yKVxuICBwb2ludC5ub3JtYWxpemUoKTtcblxuICB2YXIgeDIgPSBwb2ludC54LnJlZFNxcigpO1xuICB2YXIgeTIgPSBwb2ludC55LnJlZFNxcigpO1xuICB2YXIgbGhzID0geDIucmVkTXVsKHRoaXMuYSkucmVkQWRkKHkyKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkTXVsKHRoaXMub25lLnJlZEFkZCh0aGlzLmQucmVkTXVsKHgyKS5yZWRNdWwoeTIpKSk7XG5cbiAgcmV0dXJuIGxocy5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCB6LCB0KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUuemVybztcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy56T25lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0geiA/IG5ldyBCTih6LCAxNikgOiB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0ICYmIG5ldyBCTih0LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKHRoaXMudCAmJiAhdGhpcy50LnJlZClcbiAgICAgIHRoaXMudCA9IHRoaXMudC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcblxuICAgIC8vIFVzZSBleHRlbmRlZCBjb29yZGluYXRlc1xuICAgIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkICYmICF0aGlzLnQpIHtcbiAgICAgIHRoaXMudCA9IHRoaXMueC5yZWRNdWwodGhpcy55KTtcbiAgICAgIGlmICghdGhpcy56T25lKVxuICAgICAgICB0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICAgIH1cbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIHosIHQpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdLCBvYmpbMl0pO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy54LmNtcG4oMCkgPT09IDAgJiZcbiAgICAodGhpcy55LmNtcCh0aGlzLnopID09PSAwIHx8XG4gICAgKHRoaXMuek9uZSAmJiB0aGlzLnkuY21wKHRoaXMuY3VydmUuYykgPT09IDApKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0RGJsID0gZnVuY3Rpb24gX2V4dERibCgpIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAvLyA0TSArIDRTXG5cbiAgLy8gQSA9IFgxXjJcbiAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEIgPSBZMV4yXG4gIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBDID0gMiAqIFoxXjJcbiAgdmFyIGMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIGMgPSBjLnJlZElBZGQoYyk7XG4gIC8vIEQgPSBhICogQVxuICB2YXIgZCA9IHRoaXMuY3VydmUuX211bEEoYSk7XG4gIC8vIEUgPSAoWDEgKyBZMSleMiAtIEEgLSBCXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihiKTtcbiAgLy8gRyA9IEQgKyBCXG4gIHZhciBnID0gZC5yZWRBZGQoYik7XG4gIC8vIEYgPSBHIC0gQ1xuICB2YXIgZiA9IGcucmVkU3ViKGMpO1xuICAvLyBIID0gRCAtIEJcbiAgdmFyIGggPSBkLnJlZFN1YihiKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qRGJsID0gZnVuY3Rpb24gX3Byb2pEYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLXByb2plY3RpdmUuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWJiamxwXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDctYmxcbiAgLy8gYW5kIG90aGVyc1xuICAvLyBHZW5lcmFsbHkgM00gKyA0UyBvciAyTSArIDRTXG5cbiAgLy8gQiA9IChYMSArIFkxKV4yXG4gIHZhciBiID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpO1xuICAvLyBDID0gWDFeMlxuICB2YXIgYyA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gRCA9IFkxXjJcbiAgdmFyIGQgPSB0aGlzLnkucmVkU3FyKCk7XG5cbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIEUgPSBhICogQ1xuICAgIHZhciBlID0gdGhpcy5jdXJ2ZS5fbXVsQShjKTtcbiAgICAvLyBGID0gRSArIERcbiAgICB2YXIgZiA9IGUucmVkQWRkKGQpO1xuICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgIC8vIFgzID0gKEIgLSBDIC0gRCkgKiAoRiAtIDIpXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZFN1YihkKS5yZWRNdWwoZi5yZWRTdWIodGhpcy5jdXJ2ZS50d28pKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGXjIgLSAyICogRlxuICAgICAgbnogPSBmLnJlZFNxcigpLnJlZFN1YihmKS5yZWRTdWIoZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEggPSBaMV4yXG4gICAgICB2YXIgaCA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAgIC8vIEogPSBGIC0gMiAqIEhcbiAgICAgIHZhciBqID0gZi5yZWRTdWIoaCkucmVkSVN1YihoKTtcbiAgICAgIC8vIFgzID0gKEItQy1EKSpKXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZElTdWIoZCkucmVkTXVsKGopO1xuICAgICAgLy8gWTMgPSBGICogKEUgLSBEKVxuICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAvLyBaMyA9IEYgKiBKXG4gICAgICBueiA9IGYucmVkTXVsKGopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBFID0gQyArIERcbiAgICB2YXIgZSA9IGMucmVkQWRkKGQpO1xuICAgIC8vIEggPSAoYyAqIFoxKV4yXG4gICAgdmFyIGggPSB0aGlzLmN1cnZlLl9tdWxDKHRoaXMueikucmVkU3FyKCk7XG4gICAgLy8gSiA9IEUgLSAyICogSFxuICAgIHZhciBqID0gZS5yZWRTdWIoaCkucmVkU3ViKGgpO1xuICAgIC8vIFgzID0gYyAqIChCIC0gRSkgKiBKXG4gICAgbnggPSB0aGlzLmN1cnZlLl9tdWxDKGIucmVkSVN1YihlKSkucmVkTXVsKGopO1xuICAgIC8vIFkzID0gYyAqIEUgKiAoQyAtIEQpXG4gICAgbnkgPSB0aGlzLmN1cnZlLl9tdWxDKGUpLnJlZE11bChjLnJlZElTdWIoZCkpO1xuICAgIC8vIFozID0gRSAqIEpcbiAgICBueiA9IGUucmVkTXVsKGopO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIERvdWJsZSBpbiBleHRlbmRlZCBjb29yZGluYXRlc1xuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0RGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcHJvakRibCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9leHRBZGQgPSBmdW5jdGlvbiBfZXh0QWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtaHdjZC0zXG4gIC8vIDhNXG5cbiAgLy8gQSA9IChZMSAtIFgxKSAqIChZMiAtIFgyKVxuICB2YXIgYSA9IHRoaXMueS5yZWRTdWIodGhpcy54KS5yZWRNdWwocC55LnJlZFN1YihwLngpKTtcbiAgLy8gQiA9IChZMSArIFgxKSAqIChZMiArIFgyKVxuICB2YXIgYiA9IHRoaXMueS5yZWRBZGQodGhpcy54KS5yZWRNdWwocC55LnJlZEFkZChwLngpKTtcbiAgLy8gQyA9IFQxICogayAqIFQyXG4gIHZhciBjID0gdGhpcy50LnJlZE11bCh0aGlzLmN1cnZlLmRkKS5yZWRNdWwocC50KTtcbiAgLy8gRCA9IFoxICogMiAqIFoyXG4gIHZhciBkID0gdGhpcy56LnJlZE11bChwLnoucmVkQWRkKHAueikpO1xuICAvLyBFID0gQiAtIEFcbiAgdmFyIGUgPSBiLnJlZFN1YihhKTtcbiAgLy8gRiA9IEQgLSBDXG4gIHZhciBmID0gZC5yZWRTdWIoYyk7XG4gIC8vIEcgPSBEICsgQ1xuICB2YXIgZyA9IGQucmVkQWRkKGMpO1xuICAvLyBIID0gQiArIEFcbiAgdmFyIGggPSBiLnJlZEFkZChhKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qQWRkID0gZnVuY3Rpb24gX3Byb2pBZGQocCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwOC1iYmpscFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA3LWJsXG4gIC8vIDEwTSArIDFTXG5cbiAgLy8gQSA9IFoxICogWjJcbiAgdmFyIGEgPSB0aGlzLnoucmVkTXVsKHAueik7XG4gIC8vIEIgPSBBXjJcbiAgdmFyIGIgPSBhLnJlZFNxcigpO1xuICAvLyBDID0gWDEgKiBYMlxuICB2YXIgYyA9IHRoaXMueC5yZWRNdWwocC54KTtcbiAgLy8gRCA9IFkxICogWTJcbiAgdmFyIGQgPSB0aGlzLnkucmVkTXVsKHAueSk7XG4gIC8vIEUgPSBkICogQyAqIERcbiAgdmFyIGUgPSB0aGlzLmN1cnZlLmQucmVkTXVsKGMpLnJlZE11bChkKTtcbiAgLy8gRiA9IEIgLSBFXG4gIHZhciBmID0gYi5yZWRTdWIoZSk7XG4gIC8vIEcgPSBCICsgRVxuICB2YXIgZyA9IGIucmVkQWRkKGUpO1xuICAvLyBYMyA9IEEgKiBGICogKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEMgLSBEKVxuICB2YXIgdG1wID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZE11bChwLngucmVkQWRkKHAueSkpLnJlZElTdWIoYykucmVkSVN1YihkKTtcbiAgdmFyIG54ID0gYS5yZWRNdWwoZikucmVkTXVsKHRtcCk7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICBpZiAodGhpcy5jdXJ2ZS50d2lzdGVkKSB7XG4gICAgLy8gWTMgPSBBICogRyAqIChEIC0gYSAqIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIodGhpcy5jdXJ2ZS5fbXVsQShjKSkpO1xuICAgIC8vIFozID0gRiAqIEdcbiAgICBueiA9IGYucmVkTXVsKGcpO1xuICB9IGVsc2Uge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIoYykpO1xuICAgIC8vIFozID0gYyAqIEYgKiBHXG4gICAgbnogPSB0aGlzLmN1cnZlLl9tdWxDKGYpLnJlZE11bChnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0QWRkKHApO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pBZGQocCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgZmFsc2UpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICBpZiAodGhpcy56T25lKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB2YXIgemkgPSB0aGlzLnoucmVkSW52bSgpO1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHppKTtcbiAgdGhpcy55ID0gdGhpcy55LnJlZE11bCh6aSk7XG4gIGlmICh0aGlzLnQpXG4gICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh6aSk7XG4gIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICB0aGlzLnpPbmUgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWROZWcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnosXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCAmJiB0aGlzLnQucmVkTmVnKCkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAgICAgIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwICYmXG4gICAgICAgICB0aGlzLmdldFkoKS5jbXAob3RoZXIuZ2V0WSgpKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwodGhpcy56KTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHRoaXMueik7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBDb21wYXRpYmlsaXR5IHdpdGggQmFzZUN1cnZlXG5Qb2ludC5wcm90b3R5cGUudG9QID0gUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZTtcblBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IFBvaW50LnByb3RvdHlwZS5hZGQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cbmN1cnZlLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmN1cnZlLnNob3J0ID0gcmVxdWlyZSgnLi9zaG9ydCcpO1xuY3VydmUubW9udCA9IHJlcXVpcmUoJy4vbW9udCcpO1xuY3VydmUuZWR3YXJkcyA9IHJlcXVpcmUoJy4vZWR3YXJkcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIE1vbnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnbW9udCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuaTQgPSBuZXcgQk4oNCkudG9SZWQodGhpcy5yZWQpLnJlZEludm0oKTtcbiAgdGhpcy50d28gPSBuZXcgQk4oMikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmEyNCA9IHRoaXMuaTQucmVkTXVsKHRoaXMuYS5yZWRBZGQodGhpcy50d28pKTtcbn1cbmluaGVyaXRzKE1vbnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1vbnRDdXJ2ZTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIHZhciB4ID0gcG9pbnQubm9ybWFsaXplKCkueDtcbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHgyLnJlZE11bCh4KS5yZWRBZGQoeDIucmVkTXVsKHRoaXMuYSkpLnJlZEFkZCh4KTtcbiAgdmFyIHkgPSByaHMucmVkU3FydCgpO1xuXG4gIHJldHVybiB5LnJlZFNxcigpLmNtcChyaHMpID09PSAwO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHopIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ3Byb2plY3RpdmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUuemVybztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5Nb250Q3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICByZXR1cm4gdGhpcy5wb2ludCh1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpLCAxKTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB6KSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeik7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgLy8gTm8tb3Bcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZSgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKSk7XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgb2JqWzBdLCBvYmpbMV0gfHwgY3VydmUub25lKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1tb250Z29tLXh6Lmh0bWwjZG91YmxpbmctZGJsLTE5ODctbS0zXG4gIC8vIDJNICsgMlMgKyA0QVxuXG4gIC8vIEEgPSBYMSArIFoxXG4gIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAvLyBBQSA9IEFeMlxuICB2YXIgYWEgPSBhLnJlZFNxcigpO1xuICAvLyBCID0gWDEgLSBaMVxuICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgLy8gQkIgPSBCXjJcbiAgdmFyIGJiID0gYi5yZWRTcXIoKTtcbiAgLy8gQyA9IEFBIC0gQkJcbiAgdmFyIGMgPSBhYS5yZWRTdWIoYmIpO1xuICAvLyBYMyA9IEFBICogQkJcbiAgdmFyIG54ID0gYWEucmVkTXVsKGJiKTtcbiAgLy8gWjMgPSBDICogKEJCICsgQTI0ICogQylcbiAgdmFyIG56ID0gYy5yZWRNdWwoYmIucmVkQWRkKHRoaXMuY3VydmUuYTI0LnJlZE11bChjKSkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kaWZmQWRkID0gZnVuY3Rpb24gZGlmZkFkZChwLCBkaWZmKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RpZmZhZGQtZGFkZC0xOTg3LW0tM1xuICAvLyA0TSArIDJTICsgNkFcblxuICAvLyBBID0gWDIgKyBaMlxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQiA9IFgyIC0gWjJcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEMgPSBYMyArIFozXG4gIHZhciBjID0gcC54LnJlZEFkZChwLnopO1xuICAvLyBEID0gWDMgLSBaM1xuICB2YXIgZCA9IHAueC5yZWRTdWIocC56KTtcbiAgLy8gREEgPSBEICogQVxuICB2YXIgZGEgPSBkLnJlZE11bChhKTtcbiAgLy8gQ0IgPSBDICogQlxuICB2YXIgY2IgPSBjLnJlZE11bChiKTtcbiAgLy8gWDUgPSBaMSAqIChEQSArIENCKV4yXG4gIHZhciBueCA9IGRpZmYuei5yZWRNdWwoZGEucmVkQWRkKGNiKS5yZWRTcXIoKSk7XG4gIC8vIFo1ID0gWDEgKiAoREEgLSBDQileMlxuICB2YXIgbnogPSBkaWZmLngucmVkTXVsKGRhLnJlZElTdWIoY2IpLnJlZFNxcigpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICB2YXIgdCA9IGsuY2xvbmUoKTtcbiAgdmFyIGEgPSB0aGlzOyAvLyAoTiAvIDIpICogUSArIFFcbiAgdmFyIGIgPSB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpOyAvLyAoTiAvIDIpICogUVxuICB2YXIgYyA9IHRoaXM7IC8vIFFcblxuICBmb3IgKHZhciBiaXRzID0gW107IHQuY21wbigwKSAhPT0gMDsgdC5pdXNocm4oMSkpXG4gICAgYml0cy5wdXNoKHQuYW5kbG4oMSkpO1xuXG4gIGZvciAodmFyIGkgPSBiaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGJpdHNbaV0gPT09IDApIHtcbiAgICAgIC8vIE4gKiBRICsgUSA9ICgoTiAvIDIpICogUSArIFEpKSArIChOIC8gMikgKiBRXG4gICAgICBhID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgPSAyICogKChOIC8gMikgKiBRICsgUSkpXG4gICAgICBiID0gYi5kYmwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTiAqIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSArICgoTiAvIDIpICogUSlcbiAgICAgIGIgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSArIFEgPSAyICogKChOIC8gMikgKiBRICsgUSlcbiAgICAgIGEgPSBhLmRibCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuanVtbEFkZCA9IGZ1bmN0aW9uIGp1bWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcy5nZXRYKCkuY21wKG90aGVyLmdldFgoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0cyhTaG9ydEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gU2hvcnRDdXJ2ZTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9tb3JwaGlzbSA9IGZ1bmN0aW9uIF9nZXRFbmRvbW9ycGhpc20oY29uZikge1xuICAvLyBObyBlZmZpY2llbnQgZW5kb21vcnBoaXNtXG4gIGlmICghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpXG4gICAgcmV0dXJuO1xuXG4gIC8vIENvbXB1dGUgYmV0YSBhbmQgbGFtYmRhLCB0aGF0IGxhbWJkYSAqIFAgPSAoYmV0YSAqIFB4OyBQeSlcbiAgdmFyIGJldGE7XG4gIHZhciBsYW1iZGE7XG4gIGlmIChjb25mLmJldGEpIHtcbiAgICBiZXRhID0gbmV3IEJOKGNvbmYuYmV0YSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmV0YXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcbiAgICAvLyBDaG9vc2UgdGhlIHNtYWxsZXN0IGJldGFcbiAgICBiZXRhID0gYmV0YXNbMF0uY21wKGJldGFzWzFdKSA8IDAgPyBiZXRhc1swXSA6IGJldGFzWzFdO1xuICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxuICBpZiAoY29uZi5sYW1iZGEpIHtcbiAgICBsYW1iZGEgPSBuZXcgQk4oY29uZi5sYW1iZGEsIDE2KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaG9vc2UgdGhlIGxhbWJkYSB0aGF0IGlzIG1hdGNoaW5nIHNlbGVjdGVkIGJldGFcbiAgICB2YXIgbGFtYmRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO1xuICAgIGlmICh0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG4gICAgICBhc3NlcnQodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBiYXNpcyB2ZWN0b3JzLCB1c2VkIGZvciBiYWxhbmNlZCBsZW5ndGgtdHdvIHJlcHJlc2VudGF0aW9uXG4gIHZhciBiYXNpcztcbiAgaWYgKGNvbmYuYmFzaXMpIHtcbiAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogbmV3IEJOKHZlYy5hLCAxNiksXG4gICAgICAgIGI6IG5ldyBCTih2ZWMuYiwgMTYpXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJldGE6IGJldGEsXG4gICAgbGFtYmRhOiBsYW1iZGEsXG4gICAgYmFzaXM6IGJhc2lzXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9XG4gIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG4gIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcbiAgdmFyIHYxID0gYmFzaXNbMF07XG4gIHZhciB2MiA9IGJhc2lzWzFdO1xuXG4gIHZhciBjMSA9IHYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG4gIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cbiAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuICB2YXIgcDIgPSBjMi5tdWwodjIuYSk7XG4gIHZhciBxMSA9IGMxLm11bCh2MS5iKTtcbiAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG4gIC8vIENhbGN1bGF0ZSBhbnN3ZXJcbiAgdmFyIGsxID0gay5zdWIocDEpLnN1YihwMik7XG4gIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG4gIHJldHVybiB7IGsxOiBrMSwgazI6IGsyIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB5MiA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoeC5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuICAvLyB0byBub24tcmVkIGZvcm0/XG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pbmYpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHggPSBwb2ludC54O1xuICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcbiAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcbiAgcmV0dXJuIHkucmVkU3FyKCkucmVkSVN1YihyaHMpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuICAgIGZ1bmN0aW9uIF9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIG5wb2ludHMgPSB0aGlzLl9lbmRvV25hZlQxO1xuICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNwbGl0ID0gdGhpcy5fZW5kb1NwbGl0KGNvZWZmc1tpXSk7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIGJldGEgPSBwLl9nZXRCZXRhKCk7XG5cbiAgICBpZiAoc3BsaXQuazEubmVnYXRpdmUpIHtcbiAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgIHAgPSBwLm5lZyh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMi5pbmVnKCk7XG4gICAgICBiZXRhID0gYmV0YS5uZWcodHJ1ZSk7XG4gICAgfVxuXG4gICAgbnBvaW50c1tpICogMl0gPSBwO1xuICAgIG5wb2ludHNbaSAqIDIgKyAxXSA9IGJldGE7XG4gICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICBuY29lZmZzW2kgKiAyICsgMV0gPSBzcGxpdC5rMjtcbiAgfVxuICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gIC8vIENsZWFuLXVwIHJlZmVyZW5jZXMgdG8gcG9pbnRzIGFuZCBjb2VmZmljaWVudHNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBpICogMjsgaisrKSB7XG4gICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgbmNvZWZmc1tqXSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSBudWxsO1xuICAgIHRoaXMueSA9IG51bGw7XG4gICAgdGhpcy5pbmYgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICAvLyBGb3JjZSByZWRnb21lcnkgcmVwcmVzZW50YXRpb24gd2hlbiBsb2FkaW5nIGZyb20gSlNPTlxuICAgIGlmIChpc1JlZCkge1xuICAgICAgdGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLmluZiA9IGZhbHNlO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpXG4gICAgfSxcbiAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSlcbiAgICB9XG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH0sXG4gICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgQk4oaywgMTYpO1xuXG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgQk4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmVzID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3Nob3J0JylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlLnNob3J0KG9wdGlvbnMpO1xuICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlLmVkd2FyZHMob3B0aW9ucyk7XG4gIGVsc2VcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlLm1vbnQob3B0aW9ucyk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cbiAgYXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLCAnSW52YWxpZCBjdXJ2ZScpO1xuICBhc3NlcnQodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSwgJ0ludmFsaWQgY3VydmUsIEcqTiAhPSBPJyk7XG59XG5jdXJ2ZXMuUHJlc2V0Q3VydmUgPSBQcmVzZXRDdXJ2ZTtcblxuZnVuY3Rpb24gZGVmaW5lQ3VydmUobmFtZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IG5ldyBQcmVzZXRDdXJ2ZShvcHRpb25zKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogY3VydmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGN1cnZlO1xuICAgIH1cbiAgfSk7XG59XG5cbmRlZmluZUN1cnZlKCdwMTkyJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AxOTInLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICcwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjI0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AyMjQnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnLFxuICBiOiAnYjQwNTBhODUgMGMwNGIzYWIgZjU0MTMyNTYgNTA0NGIwYjcgZDdiZmQ4YmEgMjcwYjM5NDMgMjM1NWZmYjQnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2QnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjEnLFxuICAgICdiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNCdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjU2Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJyxcbiAgbjogJ2ZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyIDc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2JyxcbiAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjUnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDM4NCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmMnLFxuICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSAnICtcbiAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcbiAgaGFzaDogaGFzaC5zaGEzODQsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG4gICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZidcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwNTIxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnMDAwMDAwNTEgOTUzZWI5NjEgOGUxYzlhMWYgOTI5YTIxYTAgYjY4NTQwZWUgYTJkYTcyNWIgJyArXG4gICAgICc5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAnICtcbiAgICAgJzNiYjFiZjA3IDM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJyxcbiAgbjogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggJyArXG4gICAgICdmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOScsXG4gIGhhc2g6IGhhc2guc2hhNTEyLFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAnICtcbiAgICAnMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgJyArXG4gICAgJ2EyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2JyxcbiAgICAnMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgJyArXG4gICAgJzU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjIDk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxICcgK1xuICAgICczZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdjdXJ2ZTI1NTE5Jywge1xuICB0eXBlOiAnbW9udCcsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnNzZkMDYnLFxuICBiOiAnMScsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzknXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCdcbiAgXVxufSk7XG5cbnZhciBwcmU7XG50cnkge1xuICBwcmUgPSByZXF1aXJlKCcuL3ByZWNvbXB1dGVkL3NlY3AyNTZrMScpO1xufSBjYXRjaCAoZSkge1xuICBwcmUgPSB1bmRlZmluZWQ7XG59XG5cbmRlZmluZUN1cnZlKCdzZWNwMjU2azEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAnazI1NicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicsXG4gIGE6ICcwJyxcbiAgYjogJzcnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDEnLFxuICBoOiAnMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuXG4gIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG4gIGxhbWJkYTogJzUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzInLFxuICBiYXNpczogW1xuICAgIHtcbiAgICAgIGE6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJ1xuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnXG4gICAgfVxuICBdLFxuXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuICAgICc0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4JyxcbiAgICBwcmVcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgSG1hY0RSQkcgPSByZXF1aXJlKCdobWFjLWRyYmcnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi4vY3VydmVzJyk7XG52YXIgcmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQoY3VydmVzLmhhc093blByb3BlcnR5KG9wdGlvbnMpLCAnVW5rbm93biBjdXJ2ZSAnICsgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gY3VydmVzW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXMuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFQztcblxuRUMucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbiBrZXlQYWlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21Qcml2YXRlKHRoaXMsIHByaXYsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCByYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIGVudHJvcHlFbmM6IG9wdGlvbnMuZW50cm9weSAmJiBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ3V0ZjgnLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBCTigyKSk7XG4gIGRvIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBCTihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiB0cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4J1xuICB9KTtcblxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcbiAgdmFyIG5zMSA9IHRoaXMubi5zdWIobmV3IEJOKDEpKTtcblxuICBmb3IgKHZhciBpdGVyID0gMDsgdHJ1ZTsgaXRlcisrKSB7XG4gICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgICBvcHRpb25zLmsoaXRlcikgOlxuICAgICAgICBuZXcgQk4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG4gICAgaWYgKHIuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcbiAgICBzID0gcy51bW9kKHRoaXMubik7XG4gICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuICAgIGlmIChvcHRpb25zLmNhbm9uaWNhbCAmJiBzLmNtcCh0aGlzLm5oKSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSwga2V5LCBlbmMpIHtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcbiAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuXG4gIGlmICghdGhpcy5jdXJ2ZS5fbWF4d2VsbFRyaWNrKSB7XG4gICAgdmFyIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcbiAgfVxuXG4gIC8vIE5PVEU6IEdyZWcgTWF4d2VsbCdzIHRyaWNrLCBpbnNwaXJlZCBieTpcbiAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuICB2YXIgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgYXNzZXJ0KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBCTihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgdmFyIHMxID0gbi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7XG4gIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUsIFEsIGVuYykge1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWMsIHB1YiwgZW5jKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHViOiBwdWIsXG4gICAgcHViRW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuICBpZiAocHViLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdJbnZhbGlkIHB1YmxpYyBrZXknIH07XG4gIGlmICghcHViLnZhbGlkYXRlKCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcbiAgaWYgKCFwdWIubXVsKHRoaXMuZWMuY3VydmUubikuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cbiAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcbiAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuICBpZiAodHlwZW9mIGNvbXBhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gY29tcGFjdDtcbiAgICBjb21wYWN0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5wdWIpXG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cbiAgaWYgKCFlbmMpXG4gICAgcmV0dXJuIHRoaXMucHViO1xuXG4gIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLnByaXY7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG4gIHRoaXMucHJpdiA9IG5ldyBCTihrZXksIGVuYyB8fCAxNik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHByaXYgd29uJ3QgYmUgYmlnZ2VyIHRoYW4gbiwgb3RoZXJ3aXNlIHdlIG1heSBmYWlsXG4gIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuICB0aGlzLnByaXYgPSB0aGlzLnByaXYudW1vZCh0aGlzLmVjLmN1cnZlLm4pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgaWYgKGtleS54IHx8IGtleS55KSB7XG4gICAgLy8gTW9udGdvbWVyeSBwb2ludHMgb25seSBoYXZlIGFuIGB4YCBjb29yZGluYXRlLlxuICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG4gICAgLy8gYHlgIGNvb3JkaW5hdGVzLlxuICAgIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdtb250Jykge1xuICAgICAgYXNzZXJ0KGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydChrZXkueCAmJiBrZXkueSwgJ05lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGUnKTtcbiAgICB9XG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LCBrZXkueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChrZXksIGVuYyk7XG59O1xuXG4vLyBFQ0RIXG5LZXlQYWlyLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiBkZXJpdmUocHViKSB7XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBCTihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcblxuZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gIHRoaXMucGxhY2UgPSAwO1xufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGgoYnVmLCBwKSB7XG4gIHZhciBpbml0aWFsID0gYnVmW3AucGxhY2UrK107XG4gIGlmICghKGluaXRpYWwgJiAweDgwKSkge1xuICAgIHJldHVybiBpbml0aWFsO1xuICB9XG4gIHZhciBvY3RldExlbiA9IGluaXRpYWwgJiAweGY7XG4gIHZhciB2YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gcC5wbGFjZTsgaSA8IG9jdGV0TGVuOyBpKyssIG9mZisrKSB7XG4gICAgdmFsIDw8PSA4O1xuICAgIHZhbCB8PSBidWZbb2ZmXTtcbiAgfVxuICBwLnBsYWNlID0gb2ZmO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHMudG9BcnJheShkYXRhLCBlbmMpO1xuICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG4gIHAucGxhY2UgKz0gcmxlbjtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCAmJiAoclsxXSAmIDB4ODApKSB7XG4gICAgciA9IHIuc2xpY2UoMSk7XG4gIH1cbiAgaWYgKHNbMF0gPT09IDAgJiYgKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG5cbiAgdGhpcy5yID0gbmV3IEJOKHIpO1xuICB0aGlzLnMgPSBuZXcgQk4ocyk7XG4gIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA8IDB4ODApIHtcbiAgICBhcnIucHVzaChsZW4pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuICBhcnIucHVzaChvY3RldHMgfCAweDgwKTtcbiAgd2hpbGUgKC0tb2N0ZXRzKSB7XG4gICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcbiAgfVxuICBhcnIucHVzaChsZW4pO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gdG9ERVIoZW5jKSB7XG4gIHZhciByID0gdGhpcy5yLnRvQXJyYXkoKTtcbiAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKVxuICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHNbMF0gJiAweDgwKVxuICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cbiAgciA9IHJtUGFkZGluZyhyKTtcbiAgcyA9IHJtUGFkZGluZyhzKTtcblxuICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuICB2YXIgYXJyID0gWyAweDAyIF07XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHIubGVuZ3RoKTtcbiAgYXJyID0gYXJyLmNvbmNhdChyKTtcbiAgYXJyLnB1c2goMHgwMik7XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHMubGVuZ3RoKTtcbiAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcbiAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuICBjb25zdHJ1Y3RMZW5ndGgocmVzLCBiYWNrSGFsZi5sZW5ndGgpO1xuICByZXMgPSByZXMuY29uY2F0KGJhY2tIYWxmKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuLi9jdXJ2ZXMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVERFNBKGN1cnZlKSB7XG4gIGFzc2VydChjdXJ2ZSA9PT0gJ2VkMjU1MTknLCAnb25seSB0ZXN0ZWQgd2l0aCBlZDI1NTE5IHNvIGZhcicpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFRERTQSkpXG4gICAgcmV0dXJuIG5ldyBFRERTQShjdXJ2ZSk7XG5cbiAgdmFyIGN1cnZlID0gY3VydmVzW2N1cnZlXS5jdXJ2ZTtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLmcgPSBjdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShjdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgdGhpcy5wb2ludENsYXNzID0gY3VydmUucG9pbnQoKS5jb25zdHJ1Y3RvcjtcbiAgdGhpcy5lbmNvZGluZ0xlbmd0aCA9IE1hdGguY2VpbChjdXJ2ZS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gIHRoaXMuaGFzaCA9IGhhc2guc2hhNTEyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVERFNBO1xuXG4vKipcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfEtleVBhaXJ9IHNlY3JldCAtIHNlY3JldCBieXRlcyBvciBhIGtleXBhaXJcbiogQHJldHVybnMge1NpZ25hdHVyZX0gLSBzaWduYXR1cmVcbiovXG5FRERTQS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgc2VjcmV0KSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tU2VjcmV0KHNlY3JldCk7XG4gIHZhciByID0gdGhpcy5oYXNoSW50KGtleS5tZXNzYWdlUHJlZml4KCksIG1lc3NhZ2UpO1xuICB2YXIgUiA9IHRoaXMuZy5tdWwocik7XG4gIHZhciBSZW5jb2RlZCA9IHRoaXMuZW5jb2RlUG9pbnQoUik7XG4gIHZhciBzXyA9IHRoaXMuaGFzaEludChSZW5jb2RlZCwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAubXVsKGtleS5wcml2KCkpO1xuICB2YXIgUyA9IHIuYWRkKHNfKS51bW9kKHRoaXMuY3VydmUubik7XG4gIHJldHVybiB0aGlzLm1ha2VTaWduYXR1cmUoeyBSOiBSLCBTOiBTLCBSZW5jb2RlZDogUmVuY29kZWQgfSk7XG59O1xuXG4vKipcbiogQHBhcmFtIHtBcnJheX0gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8U2lnbmF0dXJlfSBzaWcgLSBzaWcgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8UG9pbnR8S2V5UGFpcn0gcHViIC0gcHVibGljIGtleVxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHB1YmxpYyBrZXkgbWF0Y2hlcyBzaWcgb2YgbWVzc2FnZVxuKi9cbkVERFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnLCBwdWIpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHNpZyA9IHRoaXMubWFrZVNpZ25hdHVyZShzaWcpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKHB1Yik7XG4gIHZhciBoID0gdGhpcy5oYXNoSW50KHNpZy5SZW5jb2RlZCgpLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSk7XG4gIHZhciBTRyA9IHRoaXMuZy5tdWwoc2lnLlMoKSk7XG4gIHZhciBScGx1c0FoID0gc2lnLlIoKS5hZGQoa2V5LnB1YigpLm11bChoKSk7XG4gIHJldHVybiBScGx1c0FoLmVxKFNHKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5oYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludCgpIHtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgaGFzaC51cGRhdGUoYXJndW1lbnRzW2ldKTtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShoYXNoLmRpZ2VzdCgpKS51bW9kKHRoaXMuY3VydmUubik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24ga2V5RnJvbVNlY3JldChzZWNyZXQpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVNlY3JldCh0aGlzLCBzZWNyZXQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLm1ha2VTaWduYXR1cmUgPSBmdW5jdGlvbiBtYWtlU2lnbmF0dXJlKHNpZykge1xuICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBzaWc7XG4gIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMsIHNpZyk7XG59O1xuXG4vKipcbiogKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtam9zZWZzc29uLWVkZHNhLWVkMjU1MTktMDMjc2VjdGlvbi01LjJcbipcbiogRUREU0EgZGVmaW5lcyBtZXRob2RzIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcG9pbnRzIGFuZCBpbnRlZ2Vycy4gVGhlc2UgYXJlXG4qIGhlbHBlciBjb252ZW5pZW5jZSBtZXRob2RzLCB0aGF0IHBhc3MgYWxvbmcgdG8gdXRpbGl0eSBmdW5jdGlvbnMgaW1wbGllZFxuKiBwYXJhbWV0ZXJzLlxuKlxuKi9cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVQb2ludCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50KHBvaW50KSB7XG4gIHZhciBlbmMgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgZW5jW3RoaXMuZW5jb2RpbmdMZW5ndGggLSAxXSB8PSBwb2ludC5nZXRYKCkuaXNPZGQoKSA/IDB4ODAgOiAwO1xuICByZXR1cm4gZW5jO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzKGJ5dGVzKTtcblxuICB2YXIgbGFzdEl4ID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgdmFyIG5vcm1lZCA9IGJ5dGVzLnNsaWNlKDAsIGxhc3RJeCkuY29uY2F0KGJ5dGVzW2xhc3RJeF0gJiB+MHg4MCk7XG4gIHZhciB4SXNPZGQgPSAoYnl0ZXNbbGFzdEl4XSAmIDB4ODApICE9PSAwO1xuXG4gIHZhciB5ID0gdXRpbHMuaW50RnJvbUxFKG5vcm1lZCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50RnJvbVkoeSwgeElzT2RkKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtKSB7XG4gIHJldHVybiBudW0udG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShieXRlcyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaXNQb2ludCA9IGZ1bmN0aW9uIGlzUG9pbnQodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiB0aGlzLnBvaW50Q2xhc3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBpbnN0YW5jZVxuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcHVibGljL3ByaXZhdGUga2V5IHBhcmFtZXRlcnNcbipcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5zZWNyZXRdIC0gc2VjcmV0IHNlZWQgYnl0ZXNcbiogQHBhcmFtIHtQb2ludH0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCAoYWthIGBBYCBpbiBlZGRzYSB0ZXJtcylcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCBlbmNvZGVkIGFzIGJ5dGVzXG4qXG4qL1xuZnVuY3Rpb24gS2V5UGFpcihlZGRzYSwgcGFyYW1zKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcbiAgdGhpcy5fc2VjcmV0ID0gcGFyc2VCeXRlcyhwYXJhbXMuc2VjcmV0KTtcbiAgaWYgKGVkZHNhLmlzUG9pbnQocGFyYW1zLnB1YikpXG4gICAgdGhpcy5fcHViID0gcGFyYW1zLnB1YjtcbiAgZWxzZVxuICAgIHRoaXMuX3B1YkJ5dGVzID0gcGFyc2VCeXRlcyhwYXJhbXMucHViKTtcbn1cblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlZGRzYSwgcHViKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBwdWI6IHB1YiB9KTtcbn07XG5cbktleVBhaXIuZnJvbVNlY3JldCA9IGZ1bmN0aW9uIGZyb21TZWNyZXQoZWRkc2EsIHNlY3JldCkge1xuICBpZiAoc2VjcmV0IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gc2VjcmV0O1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgc2VjcmV0OiBzZWNyZXQgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbiBzZWNyZXQoKSB7XG4gIHJldHVybiB0aGlzLl9zZWNyZXQ7XG59O1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViQnl0ZXMnLCBmdW5jdGlvbiBwdWJCeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5wdWIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YicsIGZ1bmN0aW9uIHB1YigpIHtcbiAgaWYgKHRoaXMuX3B1YkJ5dGVzKVxuICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuX3B1YkJ5dGVzKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZy5tdWwodGhpcy5wcml2KCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2Qnl0ZXMnLCBmdW5jdGlvbiBwcml2Qnl0ZXMoKSB7XG4gIHZhciBlZGRzYSA9IHRoaXMuZWRkc2E7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIHZhciBsYXN0SXggPSBlZGRzYS5lbmNvZGluZ0xlbmd0aCAtIDE7XG5cbiAgdmFyIGEgPSBoYXNoLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbiAgYVswXSAmPSAyNDg7XG4gIGFbbGFzdEl4XSAmPSAxMjc7XG4gIGFbbGFzdEl4XSB8PSA2NDtcblxuICByZXR1cm4gYTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdicsIGZ1bmN0aW9uIHByaXYoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLnByaXZCeXRlcygpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAnaGFzaCcsIGZ1bmN0aW9uIGhhc2goKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmhhc2goKS51cGRhdGUodGhpcy5zZWNyZXQoKSkuZGlnZXN0KCk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ21lc3NhZ2VQcmVmaXgnLCBmdW5jdGlvbiBtZXNzYWdlUHJlZml4KCkge1xuICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSkge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBjYW4gb25seSB2ZXJpZnknKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2Euc2lnbihtZXNzYWdlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EudmVyaWZ5KG1lc3NhZ2UsIHNpZywgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiBnZXRTZWNyZXQoZW5jKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGlzIHB1YmxpYyBvbmx5Jyk7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5zZWNyZXQoKSwgZW5jKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhlbmMpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnB1YkJ5dGVzKCksIGVuYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBlZGRzYSBpbnN0YW5jZVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxPYmplY3R9IHNpZyAtXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fFBvaW50fSBbc2lnLlJdIC0gUiBwb2ludCBhcyBQb2ludCBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxibn0gW3NpZy5TXSAtIFMgc2NhbGFyIGFzIGJuIG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlJlbmNvZGVkXSAtIFIgcG9pbnQgZW5jb2RlZFxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5TZW5jb2RlZF0gLSBTIHNjYWxhciBlbmNvZGVkXG4qL1xuZnVuY3Rpb24gU2lnbmF0dXJlKGVkZHNhLCBzaWcpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuXG4gIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICBzaWcgPSBwYXJzZUJ5dGVzKHNpZyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHNpZyA9IHtcbiAgICAgIFI6IHNpZy5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICBTOiBzaWcuc2xpY2UoZWRkc2EuZW5jb2RpbmdMZW5ndGgpXG4gICAgfTtcbiAgfVxuXG4gIGFzc2VydChzaWcuUiAmJiBzaWcuUywgJ1NpZ25hdHVyZSB3aXRob3V0IFIgb3IgUycpO1xuXG4gIGlmIChlZGRzYS5pc1BvaW50KHNpZy5SKSlcbiAgICB0aGlzLl9SID0gc2lnLlI7XG4gIGlmIChzaWcuUyBpbnN0YW5jZW9mIEJOKVxuICAgIHRoaXMuX1MgPSBzaWcuUztcblxuICB0aGlzLl9SZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlIpID8gc2lnLlIgOiBzaWcuUmVuY29kZWQ7XG4gIHRoaXMuX1NlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUykgPyBzaWcuUyA6IHNpZy5TZW5jb2RlZDtcbn1cblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnUycsIGZ1bmN0aW9uIFMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLlNlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1InLCBmdW5jdGlvbiBSKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLlJlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1JlbmNvZGVkJywgZnVuY3Rpb24gUmVuY29kZWQoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMuUigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdTZW5jb2RlZCcsIGZ1bmN0aW9uIFNlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVJbnQodGhpcy5TKCkpO1xufSk7XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLlJlbmNvZGVkKCkuY29uY2F0KHRoaXMuU2VuY29kZWQoKSk7XG59O1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gdG9IZXgoKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy50b0J5dGVzKCksICdoZXgnKS50b1VwcGVyQ2FzZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZG91Ymxlczoge1xuICAgIHN0ZXA6IDQsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdlNjBmY2U5M2I1OWU5ZWM1MzAxMWFhYmMyMWMyM2U5N2IyYTMxMzY5Yjg3YTVhZTljNDRlZTg5ZTJhNmRlYzBhJyxcbiAgICAgICAgJ2Y3ZTM1MDczOTllNTk1OTI5ZGI5OWYzNGY1NzkzNzEwMTI5Njg5MWU0NGQyM2YwYmUxZjMyY2NlNjk2MTY4MjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI4MjI2MzIxMmM2MDlkOWVhMmE2ZTNlMTcyZGUyMzhkOGMzOWNhYmQ1YWMxY2ExMDY0NmUyM2ZkNWY1MTUwOCcsXG4gICAgICAgICcxMWY4YTgwOTg1NTdkZmU0NWU4MjU2ZTgzMGI2MGFjZTYyZDYxM2FjMmY3YjE3YmVkMzFiNmVhZmY2ZTI2Y2FmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NWUxNTlmNzI4Yjg2NWE3MmY5OWNjNmM2ZmM4NDZkZTBiOTM4MzNmZDIyMjJlZDczZmNlNWI1NTFlNWI3MzknLFxuICAgICAgICAnZDM1MDZlMGQ5ZTNjNzllYmE0ZWY5N2E1MWZmNzFmNWVhY2I1OTU1YWRkMjQzNDVjNmVmYTZmZmVlOWZlZDY5NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNjNkOTBkNDQ3YjAwYzljOTljZWFjMDViNjI2MmVlMDUzNDQxYzdlNTU1NTJmZmU1MjZiYWQ4ZjgzZmY0NjQwJyxcbiAgICAgICAgJzRlMjczYWRmYzczMjIyMTk1M2I0NDUzOTdmMzM2MzE0NWI5YTg5MDA4MTk5ZWNiNjIwMDNjN2YzYmVlOWRlOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YjRiNWYxNjVkZjNjMmJlOGM2MjQ0YjViNzQ1NjM4ODQzZTRhNzgxYTE1YmNkMWI2OWY3OWE1NWRmZmRmODBjJyxcbiAgICAgICAgJzRhYWQwYTZmNjhkMzA4YjRiM2ZiZDc4MTNhYjBkYTA0ZjllMzM2NTQ2MTYyZWU1NmIzZWZmMGM2NWZkNGZkMzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzIzY2JhYTZlNWRiOTk2ZDZiZjc3MWMwMGJkNTQ4YzdiNzAwZGJmZmE2YzBlNzdiY2I2MTE1OTI1MjMyZmNkYScsXG4gICAgICAgICc5NmU4NjdiNTU5NWNjNDk4YTkyMTEzNzQ4ODgyNGQ2ZTI2NjBhMDY1Mzc3OTQ5NDgwMWRjMDY5ZDllYjM5ZjVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlYmZhNGQ0OTNiZWJmOThiYTVmZWVjODEyYzJkM2I1MDk0Nzk2MTIzN2E5MTk4MzlhNTMzZWNhMGU3ZGQ3ZmEnLFxuICAgICAgICAnNWQ5YThjYTM5NzBlZjBmMjY5ZWU3ZWRhZjE3ODA4OWQ5YWU0Y2RjM2E3MTFmNzEyZGRmZDRmZGFlMWRlODk5OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMDBmNDRkYTY5NmU3MTY3Mjc5MWQwYTA5YjdiZGU0NTlmMTIxNWEyOWIzYzAzYmZlZmQ3ODM1YjM5YTQ4ZGIwJyxcbiAgICAgICAgJ2NkZDllMTMxOTJhMDBiNzcyZWM4ZjMzMDBjMDkwNjY2YjdmZjRhMThmZjUxOTVhYzBmYmQ1Y2Q2MmJjNjVhMDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTEwMzFiZTI2MmM3ZWQxYjFkYzkyMjdhNGEwNGMwMTdhNzdmOGQ0NDY0ZjNiMzg1MmM4YWNkZTZlNTM0ZmQyZCcsXG4gICAgICAgICc5ZDcwNjE5Mjg5NDA0MDVlNmJiNmE0MTc2NTk3NTM1YWYyOTJkZDQxOWUxY2VkNzlhNDRmMThmMjk0NTZhMDBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlZWE2Y2FlNDZkNTViNTMwYWMyODM5ZjE0M2JkN2VjNWNmOGIyNjZhNDFkNmFmNTJkNWU2ODhkOTA5NDY5NmQnLFxuICAgICAgICAnZTU3YzZiNmM5N2RjZTFiYWIwNmU0ZTEyYmYzZWNkNWM5ODFjODk1N2NjNDE0NDJkMzE1NWRlYmYxODA5MDA4OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY3YTkxZDkxMDQ5Y2RjYjM2N2JlNGJlNmZmY2EzY2ZlZWQ2NTdkODA4NTgzZGUzM2ZhOTc4YmMxZWM2Y2IxJyxcbiAgICAgICAgJzliYWNhYTM1NDgxNjQyYmM0MWY0NjNmN2VjOTc4MGU1ZGVjN2FkYzUwOGY3NDBhMTdlOWVhOGUyN2E2OGJlMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTM5MDRmYWEwYjMzNGNkZGE2ZTAwMDkzNWVmMjIxNTFlYzA4ZDBmN2JiMTEwNjlmNTc1NDVjY2MxYTM3YjdjMCcsXG4gICAgICAgICc1YmMwODdkMGJjODAxMDZkODhjOWVjY2FjMjBkM2MxYzEzOTk5OTgxZTE0NDM0Njk5ZGNiMDk2YjAyMjc3MWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlN2JjZDBiZDM1OTgzYTc3MTljY2E3NzY0Y2E5MDY3NzliNTNhMDQzYTliOGJjYWVmZjk1OWY0M2FkODYwNDcnLFxuICAgICAgICAnMTBiNzc3MGIyYTNkYTRiMzk0MDMxMDQyMGNhOTUxNDU3OWU4OGUyZTQ3ZmQ2OGIzZWExMDA0N2U4NDYwMzcyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczODVlZWQzNGMxY2RmZjIxZTZkMDgxODY4OWI4MWJkZTcxYTdmNGYxODM5N2U2NjkwYTg0MWUxNTk5YzQzODYyJyxcbiAgICAgICAgJzI4M2JlYmMzZThlYTIzZjU2NzAxZGUxOWU5ZWJmNDU3NmIzMDRlZWMyMDg2ZGM4Y2MwNDU4ZmU1NTQyZTU0NTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmY5ZDliODAzZWNmMTkxNjM3YzczYTQ0MTNkZmExODBmZGRmODRhNTk0N2ZiYzljNjA2ZWQ4NmMzZmFjM2E3JyxcbiAgICAgICAgJzdjODBjNjhlNjAzMDU5YmE2OWI4ZTJhMzBlNDVjNGQ0N2VhNGRkMmY1YzI4MTAwMmQ4Njg5MDYwM2E4NDIxNjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzMyMmQ0MDEyNDNjNGUyNTgyYTIxNDdjMTA0ZDZlY2JmNzc0ZDE2M2RiMGY1ZTUzMTNiN2UwZTc0MmQwZTZiZCcsXG4gICAgICAgICc1NmU3MDc5N2U5NjY0ZWY1YmZiMDE5YmM0ZGRhZjliNzI4MDVmNjNlYTI4NzNhZjYyNGYzYTJlOTZjMjhiMmEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1NjcyYzdkMmRlMGI3ZGEyYmQxNzcwZDg5NjY1ODY4NzQxYjNmOWFmNzY0MzM5NzcyMWQ3NGQyODEzNGFiODMnLFxuICAgICAgICAnN2M0ODFiOWI1YjQzYjJlYjYzNzQwNDliZmE2MmMyZTVlNzdmMTdmY2M1Mjk4ZjQ0YzhlMzA5NGY3OTAzMTNhNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhiZjgwOWIxOTg4YTQ2YjA2YzlmMTkxOTQxM2IxMGY5MjI2YzYwZjY2ODgzMmZmZDk1OWFmNjBjODJhMGEnLFxuICAgICAgICAnNTNhNTYyODU2ZGNiNjY0NmRjNmI3NGM1ZDFjMzQxOGM2ZDRkZmYwOGM5N2NkMmJlZDRjYjdmODhkOGM4ZTU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MjYwY2U3ZjQ2MTgwMWMzNGYwNjdjZTBmMDI4NzNhOGYxYjBlNDRkZmM2OTc1MmFjY2VjZDgxOWYzOGZkOGU4JyxcbiAgICAgICAgJ2JjMmRhODJiNmZhNWI1NzFhN2YwOTA0OTc3NmExZWY3ZWNkMjkyMjM4MDUxYzE5OGMxYTg0ZTk1YjJiNGFlMTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTUwMzdkZTBhZmMxZDhkNDNkODM0ODQxNGJiZjQxMDMwNDNlYzhmNTc1YmZkYzQzMjk1M2NjOGQyMDM3ZmEyZCcsXG4gICAgICAgICc0NTcxNTM0YmFhOTRkM2I1ZjlmOThkMDlmYjk5MGJkZGJkNWY1YjAzZWM0ODFmMTBlMGU1ZGM4NDFkNzU1YmRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UwNjM3MmIwZjRhMjA3YWRmNWVhOTA1ZThmMTc3MWI0ZTdlOGRiZDFjNmE2YzViNzI1ODY2YTBhZTRmY2U3MjUnLFxuICAgICAgICAnN2E5MDg5NzRiY2UxOGNmZTEyYTI3YmIyYWQ1YTQ4OGNkNzQ4NGE3Nzg3MTA0ODcwYjI3MDM0Zjk0ZWVlMzFkZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyMTNjN2E3MTVjZDVkNDUzNThkMGJiZjlkYzBjZTAyMjA0YjEwYmRkZTJhM2Y1ODU0MGFkNjkwOGQwNTU5NzU0JyxcbiAgICAgICAgJzRiNmRhZDBiNWFlNDYyNTA3MDEzYWQwNjI0NWJhMTkwYmI0ODUwZjVmMzZhN2VlZGRmZjJjMjc1MzRiNDU4ZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU3YzI3MmE3YWY0YjM0ZThkYmI5MzUyYTU0MTlhODdlMjgzOGM3MGFkYzYyY2RkZjBjYzNhM2IwOGZiZDUzYycsXG4gICAgICAgICcxNzc0OWM3NjZjOWQwYjE4ZTE2ZmQwOWY2ZGVmNjgxYjUzMGI5NjE0YmZmN2RkMzNlMGIzOTQxODE3ZGNhYWU2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlYTc0ZTNkYmU3NzhiMWIxMGYyMzhhZDYxNjg2YWE1Yzc2ZTNkYjJiZTQzMDU3NjMyNDI3ZTI4NDBmYjI3YjYnLFxuICAgICAgICAnNmUwNTY4ZGI5YjBiMTMyOTdjZjY3NGRlY2NiNmFmOTMxMjZiNTk2Yjk3M2Y3Yjc3NzAxZDNkYjdmMjNjYjk2ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NmU2NDExM2Y2NzdjZjBlMTBhMjU3MGQ1OTk5NjhkMzE1NDRlMTc5Yjc2MDQzMjk1MmMwMmE0NDE3YmRkZTM5JyxcbiAgICAgICAgJ2M5MGRkZjhkZWU0ZTk1Y2Y1NzcwNjZkNzA2ODFmMGQzNWUyYTMzZDJiNTZkMjAzMmI0YjE3NTJkMTkwMWFjMDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzczOGM1NmIwM2IyYWJlMWU4MjgxYmFhNzQzZjhmOWE4ZjdjYzY0M2RmMjZjYmVlM2FiMTUwMjQyYmNiYjg5MScsXG4gICAgICAgICc4OTNmYjU3ODk1MWFkMjUzN2Y3MThmMmVhY2JmYmJiYjgyMzE0ZWVmNzg4MGNmZTkxN2U3MzVkOTY5OWE4NGMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q4OTU2MjY1NDhiNjViODFlMjY0Yzc2MzdjOTcyODc3ZDFkNzJlNWYzYTkyNTAxNDM3MmU5ZjY1ODhmNmMxNGInLFxuICAgICAgICAnZmViZmFhMzhmMmJjN2VhZTcyOGVjNjA4MThjMzQwZWIwMzQyOGQ2MzJiYjA2N2UxNzkzNjNlZDc1ZDdkOTkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiOGRhOTQwMzJhOTU3NTE4ZWIwZjY0MzM1NzFlODc2MWNlZmZjNzM2OTNlODRlZGQ0OTE1MGE1NjRmNjc2ZTAzJyxcbiAgICAgICAgJzI4MDRkZmE0NDgwNWExZTRkN2M5OWNjOTc2MjgwOGIwOTJjYzU4NGQ5NWZmM2I1MTE0ODhlNGU3NGVmZGY2ZTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTgwZmVhMTQ0NDFmYjMzYTdkOGFkYWI5NDc1ZDdmYWIyMDE5ZWZmYjUxNTZhNzkyZjFhMTE3NzhlM2MwZGY1ZCcsXG4gICAgICAgICdlZWQxZGU3ZjYzOGUwMDc3MWU4OTc2OGNhM2NhOTQ0NzJkMTU1ZTgwYWYzMjJlYTlmY2I0MjkxYjZhYzllYzc4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EzMDE2OTdiZGZjZDcwNDMxM2JhNDhlNTFkNTY3NTQzZjJhMTgyMDMxZWZkNjkxNWRkYzA3YmJjYzRlMTYwNzAnLFxuICAgICAgICAnNzM3MGY5MWNmYjY3ZTRmNTA4MTgwOWZhMjVkNDBmOWIxNzM1ZGJmN2MwYTExYTEzMGMwZDFhMDQxZTE3N2VhMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MGFkODViMzg5ZDZiOTM2NDYzZjlkMDUxMjY3OGRlMjA4Y2MzMzBiMTEzMDdmZmZhYjdhYzYzZTNmYjA0ZWQ0JyxcbiAgICAgICAgJ2U1MDdhMzYyMGEzODI2MWFmZmRjYmQ5NDI3MjIyYjgzOWFlZmFiZTE1ODI4OTRkOTkxZDRkNDhjYjZlZjE1MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZjY4YjlkMmY2M2I1ZjMzOTIzOWMxYWQ5ODFmMTYyZWU4OGM1Njc4NzIzZWEzMzUxYjdiNDQ0YzllYzRjMGRhJyxcbiAgICAgICAgJzY2MmE5ZjJkYmEwNjM5ODZkZTFkOTBjMmI2YmUyMTVkYmJlYTJjZmU5NTUxMGJmZGYyM2NiZjc5NTAxZmZmODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRmM2ZiMDE3NmFmODVkNjVmZjk5ZmY5MTk4YzM2MDkxZjQ4ZTg2NTAzNjgxZTNlNjY4NmZkNTA1MzIzMWUxMScsXG4gICAgICAgICcxZTYzNjMzYWQwZWY0ZjFjMTY2MWE2ZDBlYTAyYjcyODZjYzdlNzRlYzk1MWQxYzk4MjJjMzg1NzZmZWI3M2JjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMDBmYTliMThlYmYzMzFlYjk2MTUzN2E0NWE0MjY2YzcwMzRmMmYwZDRlMWQwNzE2ZmI2ZWFlMjBlYWUyOWUnLFxuICAgICAgICAnZWZhNDcyNjdmZWE1MjFhMWE5ZGMzNDNhMzczNmM5NzRjMmZhZGFmYTgxZTM2YzU0ZTdkMmE0YzY2NzAyNDE0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlN2EyNmNlNjlkZDQ4MjlmM2UxMGNlYzBhOWU5OGVkMzE0M2QwODRmMzA4YjkyYzA5OTdmZGRmYzYwY2IzZTQxJyxcbiAgICAgICAgJzJhNzU4ZTMwMGZhNzk4NGI0NzFiMDA2YTFhYWZiYjE4ZDBhNmIyYzA0MjBlODNlMjBlOGE5NDIxY2YyY2ZkNTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjY0NTllMGVlMzY2MmVjOGQyMzU0MGMyMjNiY2JkYzU3MWNiY2I5NjdkNzk0MjRmM2NmMjllYjNkZTZiODBlZicsXG4gICAgICAgICc2N2M4NzZkMDZmM2UwNmRlMWRhZGYxNmU1NjYxZGIzYzRiM2FlNmQ0OGUzNWIyZmYzMGJmMGI2MWE3MWJhNDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDY4YTgwYzgyODBiYjg0MDc5MzIzNGFhMTE4ZjA2MjMxZDZmMWZjNjdlNzNjNWE1ZGVkYTBmNWI0OTY5NDNlOCcsXG4gICAgICAgICdkYjhiYTlmZmY0YjU4NmQwMGM0YjFmOTE3N2IwZTI4YjViMGU3YjhmNzg0NTI5NWEyOTRjODQyNjZiMTMzMTIwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyNGFlZDdkZjY1YzgwNDI1MmRjMDI3MDkwN2EzMGIwOTYxMmFlYjk3MzQ0OWNlYTQwOTU5ODBmYzI4ZDNkNWQnLFxuICAgICAgICAnNjQ4YTM2NTc3NGI2MWYyZmYxMzBjMGMzNWFlYzFmNGYxOTIxM2IwYzdlMzMyODQzOTY3MjI0YWY5NmFiN2M4NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZGY5YzE0OTE5Y2RlNjFmNmQ1MWRmZGJlNWZlZTVkY2VlYzQxNDNiYThkMWNhODg4ZThiZDM3M2ZkMDU0Yzk2JyxcbiAgICAgICAgJzM1ZWM1MTA5MmQ4NzI4MDUwOTc0YzIzYTFkODVkNGI1ZDUwNmNkYzI4ODQ5MDE5MmViYWMwNmNhZDEwZDVkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzljMzkxOWE4NGE0NzQ4NzBmYWVkOGE5YzFjYzY2MDIxNTIzNDg5MDU0ZDdmMDMwOGNiZmM5OWM4YWMxZjk4Y2QnLFxuICAgICAgICAnZGRiODRmMGY0YTRkZGQ1NzU4NGYwNDRiZjI2MGU2NDE5MDUzMjZmNzZjNjRjOGU2YmU3ZTVlMDNkNGZjNTk5ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDU3MTcwYjFkZDEyZmRmOGRlMDVmMjgxZDhlMDZiYjkxZTE0OTNhOGI5MWQ0Y2M1YTIxMzgyMTIwYTk1OWU1JyxcbiAgICAgICAgJzlhMWFmMGIyNmE2YTQ4MDdhZGQ5YTJkYWY3MWRmMjYyNDY1MTUyYmMzZWUyNGM2NWU4OTliZTkzMjM4NWEyYTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU3NmRmOGUyM2EwODQxMTQyMTQzOWE0NTE4ZGEzMTg4MGNlZjBmYmE3ZDRkZjEyYjFhNjk3M2VlY2I5NDI2NicsXG4gICAgICAgICc0MGE2YmYyMGU3NjY0MGIyYzkyYjk3YWZlNThjZDgyYzQzMmUxMGE3ZjUxNGQ5ZjNlZThiZTExYWUxYjI4ZWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NzhhNzhjMjhkZWMzZTMwYTA1ZmU5NjI5ZGU4YzM4YmIzMGQxZjVjZjlhM2EyMDhmNzYzODg5YmU1OGFkNzEnLFxuICAgICAgICAnMzQ2MjZkOWFiNWE1YjIyZmY3MDk4ZTEyZjJmZjU4MDA4N2IzODQxMWZmMjRhYzU2M2I1MTNmYzFmZDlmNDNhYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5Mjg5NTVlZTYzN2E4NDQ2MzcyOWZkMzBlN2FmZDJlZDVmOTYyNzRlNWFkN2U1Y2IwOWVkYTljMDZkOTAzYWMnLFxuICAgICAgICAnYzI1NjIxMDAzZDNmNDJhODI3Yjc4YTEzMDkzYTk1ZWVhYzNkMjZlZmE4YThkODNmYzUxODBlOTM1YmNkMDkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWQwZmVmM2VjNmRiMTA5Mzk5MDY0ZjNhMGUzYjI4NTU2NDViNGE5MDdhZDM1NDUyN2FhZTc1MTYzZDgyNzUxJyxcbiAgICAgICAgJzFmMDM2NDg0MTNhMzhjMGJlMjlkNDk2ZTU4MmNmNTY2M2U4NzUxZTk2ODc3MzMxNTgyYzIzN2EyNGViMWY5NjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYyYjBkY2U5N2VlY2U5N2MxYzliNjA0MTc5OGI4NWRmZGZiNmQ4ODgyZGEyMDMwOGY1NDA0ODI0NTI2MDg3ZScsXG4gICAgICAgICc0OTNkMTNmZWY1MjRiYTE4OGFmNGM0ZGM1NGQwNzkzNmM3YjdlZDZmYjkwZTJjZWIyYzk1MWUwMWYwYzI5OTA3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyN2ZiYmU0YjFlODgwZWE5ZWQyYjJlNjMwMWIyMTJiNTdmMWVlMTQ4Y2Q2ZGQyODc4MGU1ZTJjZjg1NmUyNDEnLFxuICAgICAgICAnYzYwZjljOTIzYzcyN2IwYjcxYmVmMmM2N2QxZDEyNjg3ZmY3YTYzMTg2OTAzMTY2ZDYwNWI2OGJhZWMyOTNlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE2NDlmMjFmNTFiZGJhZTdiZTRhZTM0Y2U2ZTUyMTdhNThmZGNlN2Y0N2Y5YWE3ZjNiNThmYTIxMjBlMmIzJyxcbiAgICAgICAgJ2JlMzI3OWVkNWJiYmIwM2FjNjlhODBmODk4NzlhYTVhMDFhNmI5NjVmMTNmN2U1OWQ0N2E1MzA1YmE1YWQ5M2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRhNDJkNDNjNWNmMTY5ZDkzOTFkZjZkZWNmNDJlZTU0MWI2ZDhmMGM5YTEzNzQwMWUyMzYzMmRkYTM0ZDI0ZicsXG4gICAgICAgICc0ZDlmOTJlNzE2ZDFjNzM1MjZmYzk5Y2NmYjhhZDM0Y2U4ODZlZWRmYThkOGU0ZjEzYTdmNzEzMWRlYmE5NDE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlYzgwZmVmMzYwY2JkZDk1NDE2MGZhZGFiMzUyYjZiOTJiNTM1NzZhODhmZWE0OTQ3MTczYjlkNDMwMGJmMTknLFxuICAgICAgICAnYWVlZmU5Mzc1NmI1MzQwZDJmM2E0OTU4YTdhYmJmNWUwMTQ2ZTc3ZjYyOTVhMDdiNjcxY2RjMWNjMTA3Y2VmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNDZhNzc4YzA0NjcwYzJmOTFiMDBhZjQ2ODBkZmE4YmNlMzQ5MDcxN2Q1OGJhODg5ZGRiNTkyODM2NjY0MmJlJyxcbiAgICAgICAgJ2IzMThlMGVjMzM1NDAyOGFkZDY2OTgyN2Y5ZDRiMjg3MGFhYTk3MWQyZjdlNWVkMWQwYjI5NzQ4M2Q4M2VmZDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmE1MGMwZjYxZDIyZTVmMDdlM2FjZWJiMWFhMDdiMTI4ZDAwMTIyMDlhMjhiOTc3NmQ3NmE4NzkzMTgwZWVmOScsXG4gICAgICAgICc2Yjg0YzY5MjIzOTdlYmE5YjcyY2QyODcyMjgxYTY4YTVlNjgzMjkzYTU3YTIxM2IzOGNkOGQ3ZDNmNGYyODExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhMWQ2MWQwY2E3MjFhMTFiMWE1YmY2YjdkODhlODQyMWEyODhhYjVkNWJiYTUyMjBlNTNkMzJiNWYwNjdlYzInLFxuICAgICAgICAnODE1N2Y1NWE3Yzk5MzA2Yzc5YzA3NjYxNjFjOTFlMjk2NmE3Mzg5OWQyNzliNDhhNjU1ZmJhMGYxYWQ4MzZmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhOGUyODJmZjBjOTcwNjkwNzIxNWZmOThlOGZkNDE2NjE1MzExZGUwNDQ2ZjFlMDYyYTczYjA2MTBkMDY0ZTEzJyxcbiAgICAgICAgJzdmOTczNTViOGRiODFjMDlhYmZiN2YzYzViMjUxNTg4OGI2NzlhM2U1MGRkNmJkNmNlZjdjNzMxMTFmNGNjMGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc0YTUzYjljOWEyODU4NzJkMzllNTZlNjkxM2NhYjE1ZDU5YjFmYTUxMjUwOGMwMjJmMzgyZGU4MzE5NDk3YycsXG4gICAgICAgICdjY2M5ZGMzN2FiZmM5YzE2NTdiNDE1NWYyYzQ3ZjllNjY0NmIzYTFkOGNiOTg1NDM4M2RhMTNhYzA3OWFmYTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk1OTM5Njk4MTk0Mzc4NWMzZDNlNTdlZGY1MDE4Y2RiZTAzOWU3MzBlNDkxOGIzZDg4NGZkZmYwOTQ3NWI3YmEnLFxuICAgICAgICAnMmU3ZTU1Mjg4OGMzMzFkZDhiYTAzODZhNGI5Y2Q2ODQ5YzY1M2Y2NGM4NzA5Mzg1ZTliOGFiZjg3NTI0ZjJmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMmE2M2E1MGFlNDAxZTU2ZDY0NWExMTUzYjEwOWE4ZmNjYTBhNDNkNTYxZmJhMmRiYjUxMzQwYzlkODJiMTUxJyxcbiAgICAgICAgJ2U4MmQ4NmZiNjQ0M2ZjYjc1NjVhZWU1OGIyOTQ4MjIwYTcwZjc1MGFmNDg0Y2E1MmQ0MTQyMTc0ZGNmODk0MDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjQ1ODdlMjMzNTQ3MWViODkwZWU3ODk2ZDdjZmRjODY2YmFjYmRiZDM4MzkzMTdiMzQzNmY5YjQ1NjE3ZTA3MycsXG4gICAgICAgICdkOTlmY2RkNWJmNjkwMmUyYWU5NmRkNjQ0N2MyOTlhMTg1YjkwYTM5MTMzYWVhYjM1ODI5OWU1ZTlmYWY2NTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0ODFiZGUwZTRlNGQ4ODViM2E1NDZkM2U1NDlkZTA0MmYwYWE2Y2VhMjUwZTdmZDM1OGQ2Yzg2ZGQ0NWU0NTgnLFxuICAgICAgICAnMzhlZTdiOGNiYTU0MDRkZDg0YTI1YmYzOWNlY2IyY2E5MDBhNzljNDJiMjYyZTU1NmQ2NGIxYjU5Nzc5MDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMzQ2NGE1N2E3ODEwMmFhNjJiNjk3OWFlODE3ZjQ2MzdmZmNmZWQzYzRiMWNlMzBiY2Q2MzAzZjZjYWY2NjZiJyxcbiAgICAgICAgJzY5YmUxNTkwMDQ2MTQ1ODBlZjdlNDMzNDUzY2NiMGNhNDhmMzAwYTgxZDA5NDJlMTNmNDk1YTkwN2Y2ZWNjMjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmM0YTlkZjViNzEzZmUyZTlhZWY0MzBiY2MxZGM5N2EwY2Q5Y2NlZGUyZjI4NTg4Y2FkYTNhMGQyZDgzZjM2NicsXG4gICAgICAgICdkM2E4MWNhNmU3ODVjMDYzODM5MzdhZGY0Yjc5OGNhYTZlOGE5ZmJmYTU0N2IxNmQ3NThkNjY2NTgxZjMzYzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMyOGE5N2JmODI5OGJjMGQyM2Q4Yzc0OTQ1MmEzMmU2OTRiNjVlMzBhOTQ3MmEzOTU0YWIzMGZlNTMyNGNhYScsXG4gICAgICAgICc0MGEzMDQ2M2EzMzA1MTkzMzc4ZmVkZjMxZjdjYzBlYjdhZTc4NGYwNDUxY2I5NDU5ZTcxZGM3M2NiZWY5NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlYTk2NjYxMzk1MjdhOGMxZGQ5NGNlNGYwNzFmZDIzYzhiMzUwYzVhNGJiMzM3NDhjNGJhMTExZmFjY2FlMCcsXG4gICAgICAgICc2MjBlZmFiYmM4ZWUyNzgyZTI0ZTdjMGNmYjk1YzVkNzM1Yjc4M2JlOWNmMGY4ZTk1NWFmMzRhMzBlNjJiOTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RkMzYyNWZhZWY1YmEwNjA3NDY2OTcxNmJiZDM3ODhkODliZGRlODE1OTU5OTY4MDkyZjc2Y2M0ZWI5YTk3ODcnLFxuICAgICAgICAnN2ExODhmYTM1MjBlMzBkNDYxZGEyNTAxMDQ1NzMxY2E5NDE0NjE5ODI4ODMzOTU5MzdmNjhkMDBjNjQ0YTU3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmNzEwZDc5ZDllYjk2MjI5N2U0ZjYyMzJiNDBlOGY3ZmViMmJjNjM4MTQ2MTRkNjkyYzEyZGU3NTI0MDgyMjFlJyxcbiAgICAgICAgJ2VhOThlNjcyMzJkM2IzMjk1ZDNiNTM1NTMyMTE1Y2NhYzg2MTJjNzIxODUxNjE3NTI2YWU0N2E5Yzc3YmZjODInXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBuYWY6IHtcbiAgICB3bmQ6IDcsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5JyxcbiAgICAgICAgJzM4OGY3YjBmNjMyZGU4MTQwZmUzMzdlNjJhMzdmMzU2NjUwMGE5OTkzNGMyMjMxYjZjYjlmZDc1ODRiOGU2NzInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmY4YmRlNGQxYTA3MjA5MzU1YjRhNzI1MGE1YzUxMjhlODhiODRiZGRjNjE5YWI3Y2JhOGQ1NjliMjQwZWZlNCcsXG4gICAgICAgICdkOGFjMjIyNjM2ZTVlM2Q2ZDRkYmE5ZGRhNmM5YzQyNmY3ODgyNzFiYWIwZDY4NDBkY2E4N2QzYWE2YWM2MmQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVjYmRmMDY0NmU1ZGI0ZWFhMzk4ZjM2NWYyZWE3YTBlM2Q0MTliN2UwMzMwZTM5Y2U5MmJkZGVkY2FjNGY5YmMnLFxuICAgICAgICAnNmFlYmNhNDBiYTI1NTk2MGEzMTc4ZDZkODYxYTU0ZGJhODEzZDBiODEzZmRlN2I1YTUwODI2MjgwODcyNjRkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhY2Q0ODRlMmYwYzdmNjUzMDlhZDE3OGE5ZjU1OWFiZGUwOTc5Njk3NGM1N2U3MTRjMzVmMTEwZGZjMjdjY2JlJyxcbiAgICAgICAgJ2NjMzM4OTIxYjBhN2Q5ZmQ2NDM4MDk3MTc2M2I2MWU5YWRkODg4YTQzNzVmOGUwZjA1Y2MyNjJhYzY0ZjljMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc0YWU3Zjg1OGE5NDExZTVlZjQyNDZiNzBjNjVhYWM1NjQ5OTgwYmU1YzE3ODkxYmJlYzE3ODk1ZGEwMDhjYicsXG4gICAgICAgICdkOTg0YTAzMmViNmI1ZTE5MDI0M2RkNTZkN2I3YjM2NTM3MmRiMWUyZGZmOWQ2YTgzMDFkNzRjOWM5NTNjNjFiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyODc3M2MyZDk3NTI4OGJjN2QxZDIwNWMzNzQ4NjUxYjA3NWZiYzY2MTBlNThjZGRlZWRkZjhmMTk0MDVhYTgnLFxuICAgICAgICAnYWIwOTAyZThkODgwYTg5NzU4MjEyZWI2NWNkYWY0NzNhMWEwNmRhNTIxZmE5MWYyOWI1Y2I1MmRiMDNlZDgxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3OTI0ZDRmN2Q0M2VhOTY1YTQ2NWFlMzA5NWZmNDExMzFlNTk0NmYzYzg1Zjc5ZTQ0YWRiY2Y4ZTI3ZTA4MGUnLFxuICAgICAgICAnNTgxZTI4NzJhODZjNzJhNjgzODQyZWMyMjhjYzZkZWZlYTQwYWYyYmQ4OTZkM2E1YzUwNGRjOWZmNmEyNmI1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZWZkZWE0Y2RiNjc3NzUwYTQyMGZlZTgwN2VhY2YyMWViOTg5OGFlNzliOTc2ODc2NmU0ZmFhMDRhMmQ0YTM0JyxcbiAgICAgICAgJzQyMTFhYjA2OTQ2MzUxNjhlOTk3YjBlYWQyYTkzZGFlY2VkMWY0YTA0YTk1YzBmNmNmYjE5OWY2OWU1NmViNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmI0ZWEwYTc5N2E0NDNkMjkzZWY1Y2ZmNDQ0ZjQ5NzlmMDZhY2ZlYmQ3ZTg2ZDI3NzQ3NTY1NjEzODM4NWI2YycsXG4gICAgICAgICc4NWU4OWJjMDM3OTQ1ZDkzYjM0MzA4M2I1YTFjODYxMzFhMDFmNjBjNTAyNjk3NjNiNTcwYzg1NGU1YzA5YjdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MmJiZjRhNGNkZDEyNTY0ZjkzZmEzMzJjZTMzMzMwMWQ5YWQ0MDI3MWY4MTA3MTgxMzQwYWVmMjViZTU5ZDUnLFxuICAgICAgICAnMzIxZWI0MDc1MzQ4ZjUzNGQ1OWMxODI1OWRkYTNlMWY0YTFiM2IyZTcxYjEwMzljNjdiZDNkOGJjZjgxOTk4YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZmEyMTA0ZDZiMzhkMTFiMDIzMDAxMDU1OTg3OTEyNGU0MmFiOGRmZWZmNWZmMjlkYzljZGFkZDRlY2FjYzNmJyxcbiAgICAgICAgJzJkZTEwNjgyOTVkZDg2NWI2NDU2OTMzNWJkNWRkODAxODFkNzBlY2ZjODgyNjQ4NDIzYmE3NmI1MzJiN2Q2NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MjQ4Mjc5YjA5YjRkNjhkYWIyMWE5YjA2NmVkZGE4MzI2M2MzZDg0ZTA5NTcyZTI2OWNhMGNkN2Y1NDUzNzE0JyxcbiAgICAgICAgJzczMDE2ZjdiZjIzNGFhZGU1ZDFhYTcxYmRlYTJiMWZmM2ZjMGRlMmE4ODc5MTJmZmU1NGEzMmNlOTdjYjM0MDInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGFlZDRmMmJlM2E4YmYyNzhlNzAxMzJmYjBiZWI3NTIyZjU3MGUxNDRiZjYxNWMwN2U5OTZkNDQzZGVlODcyOScsXG4gICAgICAgICdhNjlkY2U0YTdkNmM5OGU4ZDRhMWFjYTg3ZWY4ZDcwMDNmODNjMjMwZjNhZmE3MjZhYjQwZTUyMjkwYmUxYzU1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0NGQxMmM3MDY1ZDgxMmU4YWNmMjhkN2NiYjE5ZjkwMTFlY2Q5ZTlmZGYyODFiMGU2YTNiNWU4N2QyMmU3ZGInLFxuICAgICAgICAnMjExOWE0NjBjZTMyNmNkYzc2YzQ1OTI2Yzk4MmZkYWMwZTEwNmU4NjFlZGY2MWM1YTAzOTA2M2YwZTBlNjQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2YTI0NWJmNmRjNjk4NTA0Yzg5YTIwY2ZkZWQ2MDg1MzE1MmI2OTUzMzZjMjgwNjNiNjFjNjVjYmQyNjllNmI0JyxcbiAgICAgICAgJ2UwMjJjZjQyYzJiZDRhNzA4YjNmNTEyNmYxNmEyNGFkOGIzM2JhNDhkMDQyM2I2ZWZkNWU2MzQ4MTAwZDhhODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTY5N2ZmYTZmZDlkZTYyN2MwNzdlM2QyZmU1NDEwODRjZTEzMzAwYjBiZWMxMTQ2Zjk1YWU1N2YwZDBiZDZhNScsXG4gICAgICAgICdiOWMzOThmMTg2ODA2ZjVkMjc1NjE1MDZlNDU1NzQzM2EyY2YxNTAwOWU0OThhZTdhZGVlOWQ2M2QwMWIyMzk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNWJkYjAxOTk4MTcxOGI5ODZkMGYwN2U4MzRjYjBkOWRlYjgzNjBmZmI3ZjYxZGY5ODIzNDVlZjI3YTc0NzknLFxuICAgICAgICAnMjk3MmQyZGU0ZjhkMjA2ODFhNzhkOTNlYzk2ZmUyM2MyNmJmYWU4NGZiMTRkYjQzYjAxZTFlOTA1NmI4YzQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyZDE0ZGFiNDE1MGJmNDk3NDAyZmRjNDVhMjE1ZTEwZGNiMDFjMzU0OTU5YjEwY2ZlMzFjN2U5ZDg3ZmYzM2QnLFxuICAgICAgICAnODBmYzA2YmQ4Y2M1YjAxMDk4MDg4YTE5NTBlZWQwZGIwMWFhMTMyOTY3YWI0NzIyMzVmNTY0MjQ4M2IyNWVhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MGM2MGFkMDA0MGYyN2RhZGU1YjRiMDZjNDA4ZTU2YjJjNTBlOWY1NmI5YjhiNDI1ZTU1NWMyZjg2MzA4YjZmJyxcbiAgICAgICAgJzFjMzgzMDNmMWNjNWMzMGYyNmU2NmJhZDdmZTcyZjcwYTY1ZWVkNGNiZTcwMjRlYjFhYTAxZjU2NDMwYmQ1N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2E5Mzc1YWQ2MTY3YWQ1NGFhNzRjNjM0OGNjNTRkMzQ0Y2M1ZGM5NDg3ZDg0NzA0OWQ1ZWFiYjBmYTAzYzhmYicsXG4gICAgICAgICdkMGUzZmE5ZWNhODcyNjkwOTU1OWUwZDc5MjY5MDQ2YmRjNTllYTEwYzcwY2UyYjAyZDQ5OWVjMjI0ZGM3ZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDUyOGVjZDliNjk2YjU0YzkwN2E5ZWQwNDU0NDdhNzliYjQwOGVjMzliNjhkZjUwNGJiNTFmNDU5YmMzZmZjOScsXG4gICAgICAgICdlZWNmNDEyNTMxMzZlNWY5OTk2NmYyMTg4MWZkNjU2ZWJjNDM0NTQwNWM1MjBkYmMwNjM0NjViNTIxNDA5OTMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5MzcwYTRiNWY0MzQxMmVhMjVmNTE0ZThlY2RhZDA1MjY2MTE1ZTRhN2VjYjEzODcyMzE4MDhmOGI0NTk2MycsXG4gICAgICAgICc3NThmM2Y0MWFmZDZlZDQyOGIzMDgxYjA1MTJmZDYyYTU0YzNmM2FmYmI1YjY3NjRiNjUzMDUyYTEyOTQ5YzlhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3ZjIzMDkzNmVlODhjYmJkNzNkZjkzMGQ2NDcwMmVmODgxZDgxMWUwZTE0OThlMmYxYzEzZWIxZmMzNDVkNzQnLFxuICAgICAgICAnOTU4ZWY0MmE3ODg2YjY0MDBhMDgyNjZlOWJhMWIzNzg5NmM5NTMzMGQ5NzA3N2NiYmU4ZWIzYzc2NzFjNjBkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMmRhYzk5MWNjNGNlNGI5ZWE0NDg4N2U1YzdjMGJjZTU4YzgwMDc0YWI5ZDRkYmFlYjI4NTMxYjc3MzlmNTMwJyxcbiAgICAgICAgJ2UwZGVkYzliM2IyZjhkYWQ0ZGExZjMyZGVjMjUzMWRmOWViNWZiZWIwNTk4ZTRmZDFhMTE3ZGJhNzAzYTNjMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzYjNkOWY2NjI2MjFmYjFiNGJlOGZiYmUyNTIwMTI1YTIxNmNkZmM5ZGFlM2RlYmNiYTQ4NTBjNjkwZDQ1YicsXG4gICAgICAgICc1ZWQ0MzBkNzhjMjk2YzM1NDMxMTQzMDZkZDg2MjJkN2M2MjJlMjdjOTcwYTFkZTMxY2IzNzdiMDFhZjczMDdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxNmY4MDQyNDRlNDZlMmEwOTIzMmQ0YWZmM2I1OTk3NmI5OGZhYzE0MzI4YTJkMWEzMjQ5NmI0OTk5OGYyNDcnLFxuICAgICAgICAnY2VkYWJkOWI4MjIwM2Y3ZTEzZDIwNmZjZGY0ZTMzZDkyYTZjNTNjMjZlNWNjZTI2ZDY1Nzk5NjJjNGUzMWRmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYWY3NTQyNzJkYzg0NTYzYjAzNTJiN2ExNDMxMWFmNTVkMjQ1MzE1YWNlMjdjNjUzNjllMTVmNzE1MWQ0MWQxJyxcbiAgICAgICAgJ2NiNDc0NjYwZWYzNWY1ZjJhNDFiNjQzZmE1ZTQ2MDU3NWY0ZmE5Yjc5NjIyMzJhNWMzMmY5MDgzMThhMDQ0NzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjYwMGNhNGIyODJjYjk4NmY4NWQwZjE3MDk5NzlkOGI0NGEwOWMwN2NiODZkN2MxMjQ0OTdiYzg2ZjA4MjEyMCcsXG4gICAgICAgICc0MTE5Yjg4NzUzYzE1YmQ2YTY5M2IwM2ZjZGRiYjQ1ZDVhYzZiZTc0YWI1ZjBlZjQ0YjBiZTk0NzVhN2U0YjQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2MzVjYTcyZDdlODQzMmMzMzhlYzUzY2QxMjIyMGJjMDFjNDg2ODVlMjRmN2RjOGM2MDJhNzc0Njk5OGU0MzUnLFxuICAgICAgICAnOTFiNjQ5NjA5NDg5ZDYxM2QxZDVlNTkwZjc4ZTZkNzRlY2ZjMDYxZDU3MDQ4YmFkOWU3NmYzMDJjNWI5YzYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1NGUzMjM5ZjMyNTU3MGNkYmJmNGE4N2RlZWU4YTY2YjdmMmIzMzQ3OWQ0NjhmYmMxYTUwNzQzYmY1NmNjMTgnLFxuICAgICAgICAnNjczZmI4NmU1YmRhMzBmYjNjZDBlZDMwNGVhNDlhMDIzZWUzM2QwMTk3YTY5NWQwYzVkOTgwOTNjNTM2NjgzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzZTZiZDEwNzFhMWU5NmFmZjU3ODU5YzgyZDU3MGYwMzMwODAwNjYxZDFjOTUyZjlmZTI2OTQ2OTFkOWI5ZTgnLFxuICAgICAgICAnNTljOWUwYmJhMzk0ZTc2ZjQwYzBhYTU4Mzc5YTNjYjZhNWEyMjgzOTkzZTkwYzQxNjcwMDJhZjQ5MjBlMzdmNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxODZiNDgzZDA1NmEwMzM4MjZhZTczZDg4ZjczMjk4NWM0Y2NiMWYzMmJhMzVmNGI0Y2M0N2ZkY2YwNGFhNmViJyxcbiAgICAgICAgJzNiOTUyZDMyYzY3Y2Y3N2UyZTE3NDQ2ZTIwNDE4MGFiMjFmYjgwOTA4OTUxMzhiNGE0YTc5N2Y4NmU4MDg4OGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGY5ZDcwYTZiOTg3NmNlNTQ0Yzk4NTYxZjRiZTRmNzI1NDQyZTZkMmI3MzdkOWM5MWE4MzIxNzI0Y2UwOTYzZicsXG4gICAgICAgICc1NWViMmRhZmQ4NGQ2Y2NkNWY4NjJiNzg1ZGMzOWQ0YWIxNTcyMjI3MjBlZjlkYTIxN2I4YzQ1Y2YyYmEyNDE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlZGQ1Y2MyM2M1MWU4N2E0OTdjYTgxNWQ1ZGNlMGY4YWI1MjU1NGY4NDllZDg5OTVkZTY0YzVmMzRjZTcxNDMnLFxuICAgICAgICAnZWZhZTljOGRiYzE0MTMwNjYxZThjZWMwMzBjODlhZDBjMTNjNjZjMGQxN2EyOTA1Y2RjNzA2YWI3Mzk5YTg2OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOTA3OThjMmI2NDc2ODMwZGExMmZlMDIyODdlOWU3NzdhYTNmYmExYzM1NWIxN2E3MjJkMzYyZjg0NjE0ZmJhJyxcbiAgICAgICAgJ2UzOGRhNzZkY2Q0NDA2MjE5ODhkMDBiY2Y3OWFmMjVkNWIyOWMwOTRkYjJhMjMxNDZkMDAzYWZkNDE5NDNlN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWYzYzQyM2E5NWQ5ZjViMzA1NDc1NGVmYTE1MGFjMzljZDI5NTUyZmUzNjAyNTczNjJkZmRlY2VmNDA1M2I0NScsXG4gICAgICAgICdmOThhM2ZkODMxZWIyYjc0OWE5M2IwZTZmMzVjZmI0MGM4Y2Q1YWE2NjdhMTU1ODFiYzJmZWRlZDQ5OGZkOWM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2NmRiYjI0ZDEzNGU3NDVjY2NhYTI4Yzk5YmYyNzQ5MDZiYjY2YjI2ZGNmOThkZjhkMmZlZDUwZDg4NDI0OWEnLFxuICAgICAgICAnNzQ0YjExNTJlYWNiZTVlMzhkY2M4ODc5ODBkYTM4Yjg5NzU4NGE2NWZhMDZjZWRkMmM5MjRmOTdjYmFjNTk5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OWRiZjQ2ZjhjOTQ3NTliYTIxMjc3YzMzNzg0ZjQxNjQ1ZjdiNDRmNmM1OTZhNThjZTkyZTY2NjE5MWFiZTNlJyxcbiAgICAgICAgJ2M1MzRhZDQ0MTc1ZmJjMzAwZjRlYTZjZTY0ODMwOWEwNDJjZTczOWE3OTE5Nzk4Y2Q4NWUyMTZjNGEzMDdmNmUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjEzYWRhOTUxMDNjNDUzNzMwNWU2OTFlNzRlOWE0YThkZDY0N2U3MTFhOTVlNzNjYjYyZGM2MDE4Y2ZkODdiOCcsXG4gICAgICAgICdlMTM4MTdiNDRlZTE0ZGU2NjNiZjRiYzgwODM0MWYzMjY5NDllMjFhNmE3NWMyNTcwNzc4NDE5YmRhZjU3MzNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NTRiNGZhMGU4YWNlZDA2ZDQxNjdhMmM1OWNjYTRjZGExODY5YzA2ZWJhZGZiNjQ4ODU1MDAxNWE4ODUyMmMnLFxuICAgICAgICAnMzBlOTNlODY0ZTY2OWQ4MjIyNGI5NjdjMzAyMGI4ZmE4ZDFlNGUzNTBiNmNiY2M1MzdhNDhiNTc4NDExNjNhMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhkY2FkZjU5OTBlMDQ4YWEzODc0ZDQ2YWJlZjlkNzAxODU4Zjk1ZGU4MDQxZDJhNjgyOGM5OWUyMjYyNTE5JyxcbiAgICAgICAgJ2U0OTFhNDI1MzdmNmU1OTdkNWQyOGEzMjI0YjFiYzI1ZGY5MTU0ZWZiZDJlZjFkMmNiYmEyY2FlNTM0N2Q1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk2MjQxNDQ1MGM3NmMxNjg5YzdiNDhmODIwMmVjMzdmYjIyNGNmNWFjMGJmYTE1NzAzMjhhOGEzZDdjNzdhYicsXG4gICAgICAgICcxMDBiNjEwZWM0ZmZiNDc2MGQ1YzFmYzEzM2VmNmY2YjEyNTA3YTA1MWYwNGFjNTc2MGFmYTViMjlkYjgzNDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MTQwODc4MzQ5NjRiNTRiMTViMTYwNjQ0ZDkxNTQ4NWExNjk3NzIyNWI4ODQ3YmIwZGQwODUxMzdlYzQ3Y2EnLFxuICAgICAgICAnZWYwYWZiYjIwNTYyMDU0NDhlMTY1MmM0OGU4MTI3ZmM2MDM5ZTc3YzE1YzIzNzhiN2U3ZDE1YTBkZTI5MzMxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2NjMzBhZDZiNDgzZTRiYzc5Y2UyYzlkZDhiYzU0OTkzZTk0N2ViOGRmNzg3YjQ0Mjk0M2QzZjdiNTI3ZWFmJyxcbiAgICAgICAgJzhiMzc4YTIyZDgyNzI3OGQ4OWM1ZTliZThmOTUwOGFlM2MyYWQ0NjI5MDM1ODYzMGFmYjM0ZGIwNGVlZGUwYTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTYyNGQ4NDc4MDczMjg2MGNlMWM3OGZjYmZlZmUwOGIyYjI5ODIzZGI5MTNmNjQ5Mzk3NWJhMGZmNDg0NzYxMCcsXG4gICAgICAgICc2ODY1MWNmOWI2ZGE5MDNlMDkxNDQ0OGM2Y2Q5ZDRjYTg5Njg3OGY1MjgyYmU0YzhjYzA2ZTJhNDA0MDc4NTc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzczM2NlODBkYTk1NWE4YTI2OTAyYzk1NjMzZTYyYTk4NTE5MjQ3NGI1YWYyMDdkYTZkZjdiNGZkNWZjNjFjZDQnLFxuICAgICAgICAnZjU0MzVhMmJkMmJhZGY3ZDQ4NWE0ZDhiOGRiOWZjY2UzZTFlZjhlMDIwMWU0NTc4YzU0NjczYmMxZGM1ZWExZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNWQ5NDQxMjU0OTQ1MDY0Y2YxYTFjMzNiYmQzYjQ5Zjg5NjZjNTA5MjE3MWU2OTllZjI1OGRmYWI4MWMwNDVjJyxcbiAgICAgICAgJ2Q1NmViMzBiNjk0NjNlNzIzNGY1MTM3YjczYjg0MTc3NDM0ODAwYmFjZWJmYzY4NWZjMzdiYmU5ZWZlNDA3MGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTFkMGZjZjJlYzlkZTY3NWI2MTIxMzZlNWNlNzBkMjcxYzIxNDE3YzlkMmI4YWFhYWMxMzg1OTlkMDcxNzk0MCcsXG4gICAgICAgICdlZGQ3N2Y1MGJjYjVhM2NhYjJlOTA3MzczMDk2NjdmMjY0MTQ2MmE1NDA3MGYzZDUxOTIxMmQzOWMxOTdhNjI5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyMmZiZTE1YzBhZjhjY2M1NzgwYzA3MzVmODRkYmU5YTc5MGJhZGVlODI0NWMwNmM3Y2EzNzMzMWNiMzY5ODAnLFxuICAgICAgICAnYTg1NWJhYmFkNWNkNjBjODhiNDMwYTY5ZjUzYTFhN2EzODI4OTE1NDk2NDc5OWJlNDNkMDZkNzdkMzFkYTA2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMxMTA5MWRkOTg2MGU4ZTIwZWUxMzQ3M2MxMTU1ZjVmNjk2MzVlMzk0NzA0ZWFhNzQwMDk0NTIyNDZjZmE5YjMnLFxuICAgICAgICAnNjZkYjY1NmY4N2QxZjA0ZmZmZDFmMDQ3ODhjMDY4MzA4NzFlYzVhNjRmZWVlNjg1YmQ4MGYwYjEyODZkODM3NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNGMxZmQwNGQzMDFiZTg5YjMxYzA0NDJkM2U2YWMyNDg4MzkyOGI0NWE5MzQwNzgxODY3ZDQyMzJlYzJkYmRmJyxcbiAgICAgICAgJzk0MTQ2ODVlOTdiMWI1OTU0YmQ0NmY3MzAxNzQxMzZkNTdmMWNlZWI0ODc0NDNkYzUzMjE4NTdiYTczYWJlZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjE5ZWE1ZDZiNTQ3MDFjMWMxNGRlNWI1NTdlYjQyYThkMTNmM2FiYmNkMDhhZmZjYzJhNWU2YjA0OWI4ZDYzJyxcbiAgICAgICAgJzRjYjk1OTU3ZTgzZDQwYjBmNzNhZjQ1NDRjY2NmNmIxZjRiMDhkM2MwN2IyN2ZiOGQ4YzI5NjJhNDAwNzY2ZDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDdiODc0MGY3NGE4ZmJhYWIxZjY4M2RiOGY0NWRlMjY1NDNhNTQ5MGJjYTYyNzA4NzIzNjkxMjQ2OWEwYjQ0OCcsXG4gICAgICAgICdmYTc3OTY4MTI4ZDljOTJlZTEwMTBmMzM3YWQ0NzE3ZWZmMTVkYjVlZDNjMDQ5YjM0MTFlMDMxNWVhYTQ1OTNiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyZDMxYzIyMmY4ZjZmMGVmODZmN2M5OGQzYTMzMzVlYWQ1YmNkMzJhYmRkOTQyODlmZTRkMzA5MWFhODI0YmYnLFxuICAgICAgICAnNWYzMDMyZjU4OTIxNTZlMzljY2QzZDc5MTViOWUxZGEyZTZkYWM5ZTZmMjZlOTYxMTE4ZDE0Yjg0NjJlMTY2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NDYxZjM3MTkxNGFiMzI2NzEwNDVhMTU1ZDk4MzFlYTg3OTNkNzdjZDU5NTkyYzQzNDBmODZjYmMxODM0N2I1JyxcbiAgICAgICAgJzhlYzBiYTIzOGI5NmJlYzBjYmRkZGNhZTBhYTQ0MjU0MmVlZTFmZjUwYzk4NmVhNmIzOTg0N2IzY2MwOTJmZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUwNzlhZGIxZGYxODYwMDc0MzU2YTI1YWEzODIwNmE2ZDcxNmIyYzNlNjc0NTNkMjg3Njk4YmFkN2IyYjJkNicsXG4gICAgICAgICc4ZGMyNDEyYWFmZTNiZTVjNGM1ZjM3ZTBlY2M1ZjlmNmE0NDY5ODlhZjA0YzRlMjVlYmFhYzQ3OWVjMWM4YzFlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2ZWM5M2U0NDdlYzgzZjA0NjdiMTgzMDJlZTYyMGY3ZTY1ZGUzMzE4NzRjOWRjNzJiZmQ4NjE2YmE5ZGE2YjUnLFxuICAgICAgICAnNWU0NjMxMTUwZTYyZmI0MGQwZThjMmE3Y2E1ODA0YTM5ZDU4MTg2YTUwZTQ5NzEzOTYyNjc3OGUyNWIwNjc0ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE1Zjk4MGMyNDVmNmYwMzg5NzgyOTBhZmE3MGI2YmQ4ODU1ODk3Zjk4YjZhYTQ4NWI5NjA2NWQ1MzdiZDk5JyxcbiAgICAgICAgJ2Y2NWY1ZDNlMjkyYzJlMDgxOWE1MjgzOTFjOTk0NjI0ZDc4NDg2OWQ3ZTZlYTY3ZmIxODA0MTAyNGVkYzA3ZGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzhjOTQwNzU0NGFjMTMyNjkyZWUxOTEwYTAyNDM5OTU4YWUwNDg3NzE1MTM0MmVhOTZjNGI2YjM1YTQ5ZjUxJyxcbiAgICAgICAgJ2YzZTAzMTkxNjllYjliODVkNTQwNDc5NTUzOWE1ZTY4ZmExZmJkNTgzYzA2NGQyNDYyYjY3NWYxOTRhM2RkYjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDk0ZjRiZTIxOWExYTc3MDE2ZGNkODM4NDMxYWVhMDAwMWNkYzhhZTdhNmZjNjg4NzI2NTc4ZDk3MDI4NTdhNScsXG4gICAgICAgICc0MjI0MmE5NjkyODNhNWYzMzliYTdmMDc1ZTM2YmEyYWY5MjVjZTMwZDc2N2VkNmU1NWY0YjAzMTg4MGQ1NjJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1OThhODAzMGRhNmQ4NmM2YmM3ZjJmNTE0NGVhNTQ5ZDI4MjExZWE1OGZhYTcwZWJmNGMxZTY2NWMxZmU5YjUnLFxuICAgICAgICAnMjA0YjVkNmY4NDgyMmMzMDdlNGI0YTcxNDA3MzdhZWMyM2ZjNjNiNjViMzVmODZhMTAwMjZkYmQyZDg2NGU2YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDE5MTYzNjVhYmIyYjVkMDkxOTJmNWYyZGJlYWZlYzIwOGYwMjBmMTI1NzBhMTg0ZGJhZGMzZTU4NTk1OTk3JyxcbiAgICAgICAgJzRmMTQzNTFkMDA4N2VmYTQ5ZDI0NWIzMjg5ODQ5ODlkNWNhZjk0NTBmMzRiZmMwZWQxNmU5NmI1OGZhOTkxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDFkNjA2M2E1ODZmYTQ3NWE3MjQ2MDRkYTAzYmM1YjkyYTJlMGQyZTBhMzZhY2ZlNGM3M2E1NTE0NzQyODgxJyxcbiAgICAgICAgJzczODY3ZjU5YzA2NTllODE5MDRmOWExYzc1NDM2OThlNjI1NjJkNjc0NGMxNjljZTdhMzZkZTAxYThkNjE1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZTk1YmIzOTlhNjk3MWQzNzYwMjY5NDdmODliZGUyZjI4MmIzMzgxMDkyOGJlNGRlZDExMmFjNGQ3MGUyMGQ1JyxcbiAgICAgICAgJzM5ZjIzZjM2NjgwOTA4NWJlZWJmYzcxMTgxMzEzNzc1YTk5YzlhZWQ3ZDhiYTM4YjE2MTM4NGM3NDYwMTI4NjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzZlNDY0MWE1Mzk0OGZkNDc2YzM5ZjhhOTlmZDk3NGU1ZWMwNzU2NGI1MzE1ZDhiZjk5NDcxYmNhMGVmMmY2NicsXG4gICAgICAgICdkMjQyNGIxYjFhYmU0ZWI4MTY0MjI3YjA4NWM5YWE5NDU2ZWExMzQ5M2ZkNTYzZTA2ZmQ1MWNmNTY5NGM3OGZjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzNjU4MWVhN2JmYmJiMjkwYzE5MWEyZjUwN2E0MWNmNTY0Mzg0MjE3MGU5MTRmYWVhYjI3YzJjNTc5ZjcyNicsXG4gICAgICAgICdlYWQxMjE2ODU5NWZlMWJlOTkyNTIxMjliNmU1NmIzMzkxZjdhYjE0MTBjZDFlMGVmM2RjZGNhYmQyZmRhMjI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhhYjg5ODE2ZGFkZmQ2YjZhMWYyNjM0ZmNmMDBlYzg0MDM3ODEwMjVlZDY4OTBjNDg0OTc0MjcwNmJkNDNlZGUnLFxuICAgICAgICAnNmZkY2VmMDlmMmY2ZDBhMDQ0ZTY1NGFlZjYyNDEzNmY1MDNkNDU5YzNlODk4NDU4NThhNDdhOTEyOWNkZDI0ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZTMzZjFhNzQ2YzljNTc3ODEzMzM0NGQ5Mjk5ZmNhYTIwYjA5MzhlOGFjZmYyNTQ0YmI0MDI4NGI4YzVmYjk0JyxcbiAgICAgICAgJzYwNjYwMjU3ZGQxMWIzYWE5YzhlZDYxOGQyNGVkZmYyMzA2ZDMyMGYxZDAzMDEwZTMzYTdkMjA1N2YzYjNiNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWI3YzFkY2IzY2VjMWI3ZWU3ZjMwZGVkNzlkZDIwYTBlZDFmNGNjMThjYmNmY2ZhNDEwMzYxZmQ4ZjA4ZjMxJyxcbiAgICAgICAgJzNkOThhOWNkZDAyNmRkNDNmMzkwNDhmMjVhODg0N2Y0ZmNhZmFkMTg5NWQ3YTYzM2M2ZmVkM2MzNWU5OTk1MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjlkZjlmYmQ4ZDllNDY1MDkyNzVmNGIxMjVkNmQ0NWQ3ZmJlOWEzYjg3OGE3YWY4NzJhMjgwMDY2MWFjNWY1MScsXG4gICAgICAgICdiNGM0ZmU5OWM3NzVhNjA2ZTJkODg2MjE3OTEzOWZmZGE2MWRjODYxYzAxOWU1NWNkMjg3NmViMmEyN2Q4NGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTBiMWNhZTA2YjBhODQ3YTNmZWE2ZTY3MWFhZjhhZGZkZmU1OGNhMmY3NjgxMDVjODA4MmIyZTQ0OWZjZTI1MicsXG4gICAgICAgICdhZTQzNDEwMmVkZGUwOTU4ZWM0YjE5ZDkxN2E2YTI4ZTZiNzJkYTE4MzRhZmYwZTY1MGYwNDk1MDNhMjk2Y2YyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlOGNlYWZiOWIzZTlhMTM2ZGM3ZmY2N2U4NDAyOTViNDk5ZGZiM2IyMTMzZTRiYTExM2YyZTRjMGUxMjFlNScsXG4gICAgICAgICdjZjIxNzQxMThjOGI2ZDdhNGI0OGY2ZDUzNGNlNWM3OTQyMmMwODZhNjM0NjA1MDJiODI3Y2U2MmEzMjY2ODNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyNGE0NGUwNDdlMTliNmY1YWZiODFjN2NhMmY2OTA4MGE1MDc2Njg5YTAxMDkxOWY0MjcyNWMyYjc4OWEzM2InLFxuICAgICAgICAnNmZiOGQ1NTkxYjQ2NmY4ZmM2M2RiNTBmMWMwZjFjNjkwMTNmOTk2ODg3YjgyNDRkMmNkZWM0MTdhZmVhOGZhMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYTAxNjA2YTdhNmM5Y2RkMjQ5ZmRmY2ZhY2I5OTU4NDAwMWVkZDI4YWJiYWI3N2I1MTA0ZTk4ZThlM2IzNWQ0JyxcbiAgICAgICAgJzMyMmFmNDkwOGM3MzEyYjBjZmJmZTM2OWY3YTdiM2NkYjdkNDQ5NGJjMjgyMzcwMGNmZDY1MjE4OGEzZWE5OGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWY4YWRkYmYyYjY2MWM4YTZjNjMyODY1NWViOTY2NTEyNTIwMDdkOGM1ZWEzMWJlNGFkMTk2ZGU4Y2UyMTMxZicsXG4gICAgICAgICc2NzQ5ZTY3YzAyOWI4NWY1MmEwMzRlYWZkMDk2ODM2YjI1MjA4MTg2ODBlMjZhYzhmM2RmYmNkYjcxNzQ5NzAwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzYWUxOTc0NTY2Y2EwNmNjNTE2ZDQ3ZTBmYjE2NWE2NzRhM2RhYmNmY2ExNWU3MjJmMGUzNDUwZjQ1ODg5JyxcbiAgICAgICAgJzJhZWFiZTdlNDUzMTUxMDExNjIxN2YwN2JmNGQwNzMwMGRlOTdlNDg3NGY4MWY1MzM0MjBhNzJlZWIwYmQ2YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTkxZWUzNTUzMTNkOTk3MjFjZjY5OTNmZmVkMWUzZTMwMTk5M2ZmM2VkMjU4ODAyMDc1ZWE4Y2VkMzk3ZTI0NicsXG4gICAgICAgICdiMGVhNTU4YTExM2MzMGJlYTYwZmM0Nzc1NDYwYzc5MDFmZjBiMDUzZDI1Y2EyYmRlZWU5OGYxYTRiZTVkMTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzExMzk2ZDU1ZmRhNTRjNDlmMTlhYTk3MzE4ZDhkYTYxZmE4NTg0ZTQ3YjA4NDk0NTA3N2NmMDMyNTViNTI5ODQnLFxuICAgICAgICAnOTk4Yzc0YThjZDQ1YWMwMTI4OWQ1ODMzYTdiZWI0NzQ0ZmY1MzZiMDFiMjU3YmU0YzU3NjdiZWE5M2VhNTdhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczYzVkMmExYmEzOWM1YTE3OTAwMDA3MzhjOWUwYzQwYjhkY2RmZDU0Njg3NTRiNjQwNTU0MDE1N2UwMTdhYTdhJyxcbiAgICAgICAgJ2IyMjg0Mjc5OTk1YTM0ZTJmOWQ0ZGU3Mzk2ZmMxOGI4MGY5YjhiOWZkZDI3MGY2NjYxZjc5Y2E0YzgxYmQyNTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2M4NzA0YjhhNjBhMGRlZmEzYTk5YTcyOTlmMmU5YzNmYmMzOTVhZmIwNGFjMDc4NDI1ZWY4YTE3OTNjYzAzMCcsXG4gICAgICAgICdiZGQ0NjAzOWZlZWQxNzg4MWQxZTA4NjJkYjM0N2Y4Y2YzOTViNzRmYzRiY2RjNGU5NDBiNzRlM2FjMWYxYjEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M1MzNlNGY3ZWE4NTU1YWFjZDk3NzdhYzVjYWQyOWI5N2RkNGRlZmNjYzUzZWU3ZWEyMDQxMTliMjg4OWIxOTcnLFxuICAgICAgICAnNmYwYTI1NmJjNWVmZGY0MjlhMmZiNjI0MmYxYTQzYTJkOWI5MjViYjRhNGIzYTI2YmI4ZTBmNDVlYjU5NjA5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjMTRmOGYyY2NiMjdkNmYxMDlmNmQwOGQwM2NjOTZhNjliYThjMzRlZWMwN2JiY2Y1NjZkNDhlMzNkYTY1OTMnLFxuICAgICAgICAnYzM1OWQ2OTIzYmIzOThmN2ZkNDQ3M2UxNmZlMWMyODQ3NWI3NDBkZDA5ODA3NWU2YzBlODY0OTExM2RjM2EzOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNmNiYzMwNDZiYzZhNDUwYmFjMjQ3ODlmYTE3MTE1YTRjOTczOWVkNzVmOGYyMWNlNDQxZjcyZTBiOTBlNmVmJyxcbiAgICAgICAgJzIxYWU3ZjQ2ODBlODg5YmIxMzA2MTllMmMwZjk1YTM2MGNlYjU3M2M3MDYwMzEzOTg2MmFmZDYxN2ZhOWI5ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNDdkNmQ5YTAyYzQ4OTI3ZWJmYjg2YzEzNTliMWNhZjEzMGEzYzAyNjdkMTFjZTYzNDRiMzlmOTlkNDNjYzM4JyxcbiAgICAgICAgJzYwZWE3ZjYxYTM1MzUyNGQxYzk4N2Y2ZWNlYzkyZjA4NmQ1NjVhYjY4Nzg3MGNiMTI2ODlmZjFlMzFjNzQ0NDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2NTQ1ZDIxODFkYjhkOTgzZjdkY2IzNzVlZjU4NjZkNDdjNjdiMWJmMzFjOGNmODU1ZWY3NDM3YjcyNjU2YScsXG4gICAgICAgICc0OWI5NjcxNWFiNjg3OGE3OWU3OGYwN2NlNTY4MGM1ZDY2NzMwNTFiNDkzNWJkODk3ZmVhODI0Yjc3ZGMyMDhhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MDc0N2NjOWQwMTJjYjFhMTNiODE0ODMwOWM2ZGU3ZWMyNWQ2OTQ1ZDY1NzE0NmI5ZDU5OTRiOGZlYjExMTEnLFxuICAgICAgICAnNWNhNTYwNzUzYmUyYTEyZmM2ZGU2Y2FmMmNiNDg5NTY1ZGI5MzYxNTZiOTUxNGUxYmI1ZTgzMDM3ZTBmYTJkNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTQyYzhlYzgyYzk5Nzk4Y2NmM2E2MTBiZTg3MGU3ODMzOGM3ZjcxMzM0OGJkMzRjODIwM2VmNDAzN2YzNTAyJyxcbiAgICAgICAgJzc1NzFkNzRlZTVlMGZiOTJhN2E4YjMzYTA3NzgzMzQxYTU0OTIxNDRjYzU0YmNjNDBhOTQ0NzM2OTM2MDY0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzc3NWFiNzA4OWJjNmFmODIzYWJhMmUxYWY3MGIyMzZkMjUxY2FkYjBjODY3NDMyODc1MjJhMWIzYjBkZWRlYScsXG4gICAgICAgICdiZTUyZDEwN2JjZmEwOWQ4YmNiOTczNmE4MjhjZmE3ZmFjOGRiMTdiZjdhNzZhMmM0MmFkOTYxNDA5MDE4Y2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NlZTMxY2JmN2UzNGVjMzc5ZDk0ZmI4MTRkM2Q3NzVhZDk1NDU5NWQxMzE0YmE4ODQ2OTU5ZTNlODJmNzRlMjYnLFxuICAgICAgICAnOGZkNjRhMTRjMDZiNTg5YzI2Yjk0N2FlMmJjZjZiZmEwMTQ5ZWYwYmUxNGVkNGQ4MGY0NDhhMDFjNDNiMWM2ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNGY5ZWFlYTA5YjY5MTc2MTlmNmVhNmE0ZWI1NDY0ZWZkZGI1OGZkNDViMWViZWZjZGMxYTAxZDA4YjQ3OTg2JyxcbiAgICAgICAgJzM5ZTVjOTkyNWI1YTU0YjA3NDMzYTRmMThjNjE3MjZmOGJiMTMxYzAxMmNhNTQyZWIyNGE4YWMwNzIwMDY4MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDQyNjNkZmMzZDJkZjkyM2EwMTc5YTQ4OTY2ZDMwY2U4NGUyNTE1YWZjM2RjY2MxYjc3OTA3NzkyZWJjYzYwZScsXG4gICAgICAgICc2MmRmYWYwN2EwZjc4ZmViMzBlMzBkNjI5NTg1M2NlMTg5ZTEyNzc2MGFkNmNmN2ZhZTE2NGUxMjJhMjA4ZDU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ4NDU3NTI0ODIwZmE2NWE0ZjhkMzVlYjY5MzA4NTdjMDAzMmFjYzBhNGEyZGU0MjIyMzNlZWRhODk3NjEyYzQnLFxuICAgICAgICAnMjVhNzQ4YWIzNjc5NzlkOTg3MzNjMzhhMWZhMWMyZTdkYzZjYzA3ZGIyZDYwYTlhZTdhNzZhYWE0OWJkMGY3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZmVlZWYxODgxMTAxZjJjYjExNjQ0ZjNhMmFmZGZjMjA0NWUxOTkxOTE1MjkyM2YzNjdhMTc2N2MxMWNjZWRhJyxcbiAgICAgICAgJ2VjZmI3MDU2Y2YxZGUwNDJmOTQyMGJhYjM5Njc5M2MwYzM5MGJkZTc0YjRiYmRmZjE2YTgzYWUwOWE5YTc1MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmQ3ZWY2YjE3NTQzZjgzNzNjNTczZjQ0ZTFmMzg5ODM1ZDg5YmNiYzYwNjJjZWQzNmM4MmRmODNiOGZhZTg1OScsXG4gICAgICAgICdjZDQ1MGVjMzM1NDM4OTg2ZGZlZmExMGM1N2ZlYTliY2M1MjFhMDk1OWIyZDgwYmJmNzRiMTkwZGNhNzEyZDEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3NTYwNWQ1OTEwMmE1YTI2ODQ1MDBkM2I5OTFmMmUzZjNjODhiOTMyMjU1NDcwMzVhZjI1YWY2NmUwNDU0MWYnLFxuICAgICAgICAnZjVjNTQ3NTRhOGY3MWVlNTQwYjliNDg3Mjg0NzNlMzE0ZjcyOWFjNTMwOGIwNjkzODM2MDk5MGUyYmZhZDEyNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYjk4NjYwZjRjNGRmYWEwNmEyYmU0NTNkNTAyMGJjOTlhMGMyZTYwYWJlMzg4NDU3ZGQ0M2ZlZmIxZWQ2MjBjJyxcbiAgICAgICAgJzZjYjlhODg3NmQ5Y2I4NTIwNjA5YWYzYWRkMjZjZDIwYTBhN2NkOGE5NDExMTMxY2U4NWY0NDEwMDA5OTIyM2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTNlODdiMDI3ZDg1MTRkMzU5MzlmMmU2ODkyYjE5OTIyMTU0NTk2OTQxODg4MzM2ZGMzNTYzZTNiOGRiYTk0MicsXG4gICAgICAgICdmZWY1YTNjNjgwNTlhNmRlYzVkNjI0MTE0YmYxZTkxYWFjMmI5ZGE1NjhkNmFiZWIyNTcwZDU1NjQ2YjhhZGYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMTYzMDI2ZTlmZDZmZTAxN2MzOGYwNmE1YmU2ZmMxMjU0MjRiMzcxY2UyNzA4ZTdiZjQ0OTE2OTFlNTc2NGEnLFxuICAgICAgICAnMWFjYjI1MGYyNTVkZDYxYzQzZDk0Y2NjNjcwZDBmNThmNDlhZTNmYTE1Yjk2NjIzZTU0MzBkYTBhZDZjNjJiMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMjY4ZjVlZjlhZDUxZTRkNzhkZTNhNzUwYzJkYzg5YjFlNjI2ZDQzNTA1ODY3OTk5OTMyZTVkYjMzYWYzZDgwJyxcbiAgICAgICAgJzVmMzEwZDRiM2M5OWI5ZWJiMTlmNzdkNDFjMWRlZTAxOGNmMGQzNGZkNDE5MTYxNDAwM2U5NDVhMTIxNmU0MjMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYwN2YzMTE4YTlkZjAzNWU5ZmFkODVlYjZjN2JmZTQyYjAyZjAxY2E5OWNlZWEzYmY3ZmZkYmE5M2M0NzUwZCcsXG4gICAgICAgICc0MzgxMzZkNjAzZTg1OGEzYTVjNDQwYzM4ZWNjYmFkZGMxZDI5NDIxMTRlMmVkZGQ0NzQwZDA5OGNlZDFmMGQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhkOGI5ODU1YzdjMDUyYTM0MTQ2ZmQyMGZmYjY1OGJlYTRiOWY2OWUwZDgyNWViZWMxNmU4YzNjZTJiNTI2YTEnLFxuICAgICAgICAnY2RiNTU5ZWVkYzJkNzlmOTI2YmFmNDRmYjg0ZWE0ZDQ0YmNmNTBmZWU1MWQ3Y2ViMzBlMmU3ZjQ2MzAzNjc1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MmRiMGI1Mzg0ZGZiZjA1YmZhOWQ0NzJkN2FlMjZkZmU0Yjg1MWNlY2E5MWIxZWJhNTQyNjMxODBkYTMyYjYzJyxcbiAgICAgICAgJ2MzYjk5N2QwNTBlZTVkNDIzZWJhZjY2YTZkYjlmNTdiMzE4MGM5MDI4NzU2NzlkZTkyNGI2OWQ4NGE3YjM3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNjJmOTQ5MGQzZDUxZGE2Mzk1ZWZkMjRlODA5MTljYzdkMGYyOWMzZjNmYTQ4YzZmZmY1NDNiZWNiZDQzMzUyJyxcbiAgICAgICAgJzZkODlhZDdiYTQ4NzZiMGIyMmMyY2EyODBjNjgyODYyZjM0MmM4NTkxZjFkYWY1MTcwZTA3YmZkOWNjYWZhN2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2YzMGVhMjQ3NmIzOTliNDk1NzUwOWM4OGY3N2QwMTkxYWZhMmZmNWNiN2IxNGZkNmQ4ZTdkNjVhYWFiMTE5MycsXG4gICAgICAgICdjYTVlZjdkNGIyMzFjOTRjM2IxNTM4OWE1ZjYzMTFlOWRhZmY3YmI2N2IxMDNlOTg4MGVmNGJmZjYzN2FjYWVjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUwOThmZjFlMWQ5ZjE0ZmI0NmEyMTBmYWRhNmM5MDNmZWYwZmI3YjRhMWRkMWQ5YWM2MGEwMzYxODAwYjdhMDAnLFxuICAgICAgICAnOTczMTE0MWQ4MWZjOGY4MDg0ZDM3YzZlNzU0MjAwNmIzZWUxYjQwZDYwZGZlNTM2MmE1YjEzMmZkMTdkZGMwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyYjc4YzdkZTllZTUxMmE3Mjg5NWJlNmI5Y2JlZmE2ZTJmM2M0Y2NjZTQ0NWM5NmI5ZjJjODFlMjc3OGFkNTgnLFxuICAgICAgICAnZWUxODQ5ZjUxM2RmNzFlMzJlZmMzODk2ZWUyODI2MGM3M2JiODA1NDdhZTIyNzViYTQ5NzIzNzc5NGM4NzUzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMmNiNzRmZGRjOGU5ZmJjZDA3NmVlZjJhN2M3MmIwY2UzN2Q1MGYwODI2OWRmYzA3NGI1ODE1NTA1NDdhNGY3JyxcbiAgICAgICAgJ2QzYWEyZWQ3MWM5ZGQyMjQ3YTYyZGYwNjI3MzZlYjBiYWRkZWE5ZTM2MTIyZDJiZTg2NDFhYmNiMDA1Y2M0YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQzODQ0NzU2NmQ0ZDdiZWRhZGMyOTk0OTZhYjM1NzQyNjAwOWEzNWYyMzVjYjE0MWJlMGQ5OWNkMTBhZTNhOCcsXG4gICAgICAgICdjNGUxMDIwOTE2OTgwYTRkYTVkMDFhYzVlNmFkMzMwNzM0ZWYwZDc5MDY2MzFjNGYyMzkwNDI2YjJlZGQ3OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQxNjJkNDg4Yjg5NDAyMDM5YjU4NGM2ZmM2YzMwODg3MDU4N2Q5YzQ2ZjY2MGI4NzhhYjY1YzgyYzcxMWQ2N2UnLFxuICAgICAgICAnNjcxNjNlOTAzMjM2Mjg5Zjc3NmYyMmMyNWZiOGEzYWZjMTczMmYyYjg0YjRlOTVkYmRhNDdhZTVhMDg1MjY0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczZmFkM2ZhODRjYWYwZjM0ZjBmODliZmQyZGNmNTRmYzE3NWQ3NjdhZWMzZTUwNjg0ZjNiYTRhNGJmNWY2ODNkJyxcbiAgICAgICAgJ2NkMWJjN2NiNmNjNDA3YmIyZjBjYTY0N2M3MThhNzMwY2Y3MTg3MmU3ZDBkMmE1M2ZhMjBlZmNkZmU2MTgyNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NzRmMjYwMGEzMDA3YTAwNTY4YzFhN2NlMDVkMDgxNmMxZmI4NGJmMTM3MDc5OGYxYzY5NTMyZmFlYjFhODZiJyxcbiAgICAgICAgJzI5OWQyMWY5NDEzZjMzYjNlZGY0M2IyNTcwMDQ1ODBiNzBkYjU3ZGEwYjE4MjI1OWUwOWVlY2M2OWUwZDM4YTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDMyZjRkYTU0YWRlNzRhYmI4MWI4MTVhZDFmYjNiMjYzZDgyZDZjNjkyNzE0YmNmZjg3ZDI5YmQ1ZWU5ZjA4ZicsXG4gICAgICAgICdmOTQyOWU3MzhiOGU1M2I5NjhlOTkwMTZjMDU5NzA3NzgyZTE0ZjQ1MzUzNTlkNTgyZmM0MTY5MTBiM2VlYTg3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwZTRlNjcwNDM1Mzg1NTU2ZTU5MzY1NzEzNTg0NWQzNmZiYjY5MzFmNzJiMDhjYjFlZDk1NGYxZTNjZTNmZjYnLFxuICAgICAgICAnNDYyZjliY2U2MTk4OTg2Mzg0OTkzNTAxMTNiYmM5YjEwYTg3OGQzNWRhNzA3NDBkYzY5NWE1NTllYjg4ZGI3YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiZTIwNjIwMDNjNTFjYzMwMDQ2ODI5MDQzMzBlNGRlZTdmM2RjZDEwYjAxZTU4MGJmMTk3MWIwNGQ0Y2FkMjk3JyxcbiAgICAgICAgJzYyMTg4YmM0OWQ2MWU1NDI4NTczZDQ4YTc0ZTFjNjU1YjFjNjEwOTA5MDU2ODJhMGQ1NTU4ZWQ3MmRjY2I5YmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTMxNDQ0MjNhY2UzNDUxZWQyOWUwZmI5YWMyYWYyMTFjYjZlODRhNjAxZGY1OTkzYzQxOTg1OWZmZjVkZjA0YScsXG4gICAgICAgICc3YzEwZGZiMTY0YzM0MjVmNWM3MWEzZjlkNzk5MjAzOGYxMDY1MjI0ZjcyYmI5ZDFkOTAyYTZkMTMwMzdiNDdjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IwMTVmODA0NGY1ZmNiZGNmMjFjYTI2ZDZjMzRmYjgxOTc4MjkyMDVjN2I3ZDJhN2NiNjY0MThjMTU3YjExMmMnLFxuICAgICAgICAnYWI4YzFlMDg2ZDA0ZTgxMzc0NGE2NTViMmRmOGQ1ZjgzYjNjZGM2ZmFhMzA4OGMxZDNhZWExNDU0ZTNhMWQ1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNWU5ZTFkYTY0OWQ5N2Q4OWU0ODY4MTE3YTQ2NWEzYTRmOGExOGRlNTdhMTQwZDM2YjNmMmFmMzQxYTIxYjUyJyxcbiAgICAgICAgJzRjYjA0NDM3ZjM5MWVkNzMxMTFhMTNjYzFkNGRkMGRiMTY5MzQ2NWMyMjQwNDgwZDg5NTVlODU5MmYyNzQ0N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNhZTQxMDQ3ZGQ3Y2EwNjVkYmY4ZWQ3N2I5OTI0Mzk5ODMwMDVjZDcyZTE2ZDZmOTk2YTUzMTZkMzY5NjZiYicsXG4gICAgICAgICdiZDFhZWIyMWFkMjJlYmIyMmExMGYwMzAzNDE3YzZkOTY0ZjhjZGQ3ZGYwYWNhNjE0YjEwZGMxNGQxMjVhYzQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2UyNzYzZDg4NWY5NThmYzY2Y2RkMjI4MDBmMGE0ODcxOTdkMGE4MmUzNzdiNDlmODBhZjg3Yzg5N2IwNjUnLFxuICAgICAgICAnYmZlZmFjZGIwZTVkMGZkN2RmM2EzMTFhOTRkZTA2MmIyNmI4MGM2MWZiYzk3NTA4Yjc5OTkyNjcxZWY3Y2E3ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTg1ZmRmZDEyN2MwNTY3YzZmNTNlYzFiYjYzZWMzMTU4ZTU5N2M0MGJmZTc0N2M4M2NkZGZjOTEwNjQxOTE3JyxcbiAgICAgICAgJzYwM2MxMmRhZjNkOTg2MmVmMmIyNWZlMWRlMjg5YWVkMjRlZDI5MWUwZWM2NzA4NzAzYTViZDU2N2YzMmVkMDMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzRhMWFkNmI1Zjc2ZTM5ZGIyZGQyNDk0MTBlYWM3Zjk5ZTc0YzU5Y2I4M2QyZDBlZDVmZjE1NDNkYTc3MDNlOScsXG4gICAgICAgICdjYzYxNTdlZjE4YzljNjNjZDYxOTNkODM2MzFiYmVhMDA5M2UwOTY4OTQyZThjMzNkNTczN2ZkNzkwZTBkYjA4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwNjgyYTUwNzAzMzc1ZjYwMmQ0MTY2NjRiYTE5YjdmYzliYWI0MmM3Mjc0NzQ2M2E3MWQwODk2YjIyZjZkYTMnLFxuICAgICAgICAnNTUzZTA0ZjZiMDE4YjRmYTZjOGYzOWU3ZjMxMWQzMTc2MjkwZDBlMGYxOWNhNzNmMTc3MTRkOTk3N2EyMmZmOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5ZTIxNThmMGQ3YzBkNWYyNmMzNzkxZWZlZmE3OTU5NzY1NGU3YTJiMjQ2NGY1MmIxZWU2YzEzNDc3NjllZjU3JyxcbiAgICAgICAgJzcxMmZjZGQxYjkwNTNmMDkwMDNhMzQ4MWZhNzc2MmU5ZmZkN2M4ZWYzNWEzODUwOWUyZmJmMjYyOTAwODM3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzZlMjY5ODlhNDNjOWNmZWJhNDAyOWMyMDI1MzhjMjgxNzJlNTY2ZTNjNGZjZTczMjI4NTdmM2JlMzI3ZDY2JyxcbiAgICAgICAgJ2VkOGNjOWQwNGIyOWViODc3ZDI3MGI0ODc4ZGM0M2MxOWFlZmQzMWY0ZWVlMDllZTdiNDc4MzRjMWZhNGIxYzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzVkNDZlZmVhMzc3MWU2ZTY4YWJiODlhMTNhZDc0N2VjZjE4OTIzOTNkZmM0ZjFiNzAwNDc4OGM1MDM3NGRhOCcsXG4gICAgICAgICc5ODUyMzkwYTk5NTA3Njc5ZmQwYjg2ZmQyYjM5YTg2OGQ3ZWZjMjIxNTEzNDZlMWEzY2E0NzI2NTg2YTZiZWQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwOWEyMGM2N2Q2NDkwMGZmYjY5OGM0YzgyNWY2ZDVmMjMxMGZiMDQ1MWM4NjkzNDViNzMxOWY2NDU2MDU3MjEnLFxuICAgICAgICAnOWU5OTQ5ODBkOTkxN2UyMmI3NmIwNjE5MjdmYTA0MTQzZDA5NmNjYzU0OTYzZTZhNWViZmE1ZjNmOGUyODZjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxYjM4OTAzYTQzZjdmMTE0ZWQ0NTAwYjRlYWM3MDgzZmRlZmVjZTFjZjI5YzYzNTI4ZDU2MzQ0NmY5NzJjMTgwJyxcbiAgICAgICAgJzQwMzZlZGM5MzFhNjBhZTg4OTM1M2Y3N2ZkNTNkZTRhMjcwOGIyNmI2ZjVkYTcyYWQzMzk0MTE5ZGFmNDA4ZjknXG4gICAgICBdXG4gICAgXVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBtaW5Bc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgbWluVXRpbHMgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzJyk7XG5cbnV0aWxzLmFzc2VydCA9IG1pbkFzc2VydDtcbnV0aWxzLnRvQXJyYXkgPSBtaW5VdGlscy50b0FycmF5O1xudXRpbHMuemVybzIgPSBtaW5VdGlscy56ZXJvMjtcbnV0aWxzLnRvSGV4ID0gbWluVXRpbHMudG9IZXg7XG51dGlscy5lbmNvZGUgPSBtaW5VdGlscy5lbmNvZGU7XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3KSB7XG4gIHZhciBuYWYgPSBbXTtcbiAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuICB2YXIgayA9IG51bS5jbG9uZSgpO1xuICB3aGlsZSAoay5jbXBuKDEpID49IDApIHtcbiAgICB2YXIgejtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgICAgaWYgKG1vZCA+ICh3cyA+PiAxKSAtIDEpXG4gICAgICAgIHogPSAod3MgPj4gMSkgLSBtb2Q7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBtb2Q7XG4gICAgICBrLmlzdWJuKHopO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gMDtcbiAgICB9XG4gICAgbmFmLnB1c2goeik7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24sIHNoaWZ0IGJ5IHdvcmQgaWYgcG9zc2libGVcbiAgICB2YXIgc2hpZnQgPSAoay5jbXBuKDApICE9PSAwICYmIGsuYW5kbG4od3MgLSAxKSA9PT0gMCkgPyAodyArIDEpIDogMTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoaWZ0OyBpKyspXG4gICAgICBuYWYucHVzaCgwKTtcbiAgICBrLml1c2hybihzaGlmdCk7XG4gIH1cblxuICByZXR1cm4gbmFmO1xufVxudXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG4vLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cbmZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcbiAgdmFyIGpzZiA9IFtcbiAgICBbXSxcbiAgICBbXVxuICBdO1xuXG4gIGsxID0gazEuY2xvbmUoKTtcbiAgazIgPSBrMi5jbG9uZSgpO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgZDIgPSAwO1xuICB3aGlsZSAoazEuY21wbigtZDEpID4gMCB8fCBrMi5jbXBuKC1kMikgPiAwKSB7XG5cbiAgICAvLyBGaXJzdCBwaGFzZVxuICAgIHZhciBtMTQgPSAoazEuYW5kbG4oMykgKyBkMSkgJiAzO1xuICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuICAgIGlmIChtMTQgPT09IDMpXG4gICAgICBtMTQgPSAtMTtcbiAgICBpZiAobTI0ID09PSAzKVxuICAgICAgbTI0ID0gLTE7XG4gICAgdmFyIHUxO1xuICAgIGlmICgobTE0ICYgMSkgPT09IDApIHtcbiAgICAgIHUxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG04ID0gKGsxLmFuZGxuKDcpICsgZDEpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcbiAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgZWxzZVxuICAgICAgICB1MSA9IG0xNDtcbiAgICB9XG4gICAganNmWzBdLnB1c2godTEpO1xuXG4gICAgdmFyIHUyO1xuICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcbiAgICAgIHUyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG04ID0gKGsyLmFuZGxuKDcpICsgZDIpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0xNCA9PT0gMilcbiAgICAgICAgdTIgPSAtbTI0O1xuICAgICAgZWxzZVxuICAgICAgICB1MiA9IG0yNDtcbiAgICB9XG4gICAganNmWzFdLnB1c2godTIpO1xuXG4gICAgLy8gU2Vjb25kIHBoYXNlXG4gICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuICAgICAgZDEgPSAxIC0gZDE7XG4gICAgaWYgKDIgKiBkMiA9PT0gdTIgKyAxKVxuICAgICAgZDIgPSAxIC0gZDI7XG4gICAgazEuaXVzaHJuKDEpO1xuICAgIGsyLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBqc2Y7XG59XG51dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG5cbmZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KG9iaiwgbmFtZSwgY29tcHV0ZXIpIHtcbiAgdmFyIGtleSA9ICdfJyArIG5hbWU7XG4gIG9iai5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpc1trZXldICE9PSB1bmRlZmluZWQgPyB0aGlzW2tleV0gOlxuICAgICAgICAgICB0aGlzW2tleV0gPSBjb21wdXRlci5jYWxsKHRoaXMpO1xuICB9O1xufVxudXRpbHMuY2FjaGVkUHJvcGVydHkgPSBjYWNoZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM7XG59XG51dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuZnVuY3Rpb24gaW50RnJvbUxFKGJ5dGVzKSB7XG4gIHJldHVybiBuZXcgQk4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcbn1cbnV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcblxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcImVsbGlwdGljQDYuNS4wXCIsXG4gICAgICBcIi9Vc2Vycy9tanljL2hjcmxhYi9jeWNsZS1yb2JvdC1kcml2ZXJzL2V4YW1wbGVzL2RlbW9zL2hhbmR0cmFja1wiXG4gICAgXVxuICBdLFxuICBcIl9kZXZlbG9wbWVudFwiOiB0cnVlLFxuICBcIl9mcm9tXCI6IFwiZWxsaXB0aWNANi41LjBcIixcbiAgXCJfaWRcIjogXCJlbGxpcHRpY0A2LjUuMFwiLFxuICBcIl9pbkJ1bmRsZVwiOiBmYWxzZSxcbiAgXCJfaW50ZWdyaXR5XCI6IFwic2hhNTEyLWVGT0pUTXlDWWI3eHRFL2NhSjZKSnUrYmhpNjdXQ1lOYmtHU2tudTIwcG1NOEtlL2JxT2ZkblpXeHlvR04yNkpnZnhUYlhyc0NrRXc0S2hlQ1QvS0dnPT1cIixcbiAgXCJfbG9jYXRpb25cIjogXCIvZWxsaXB0aWNcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwidHlwZVwiOiBcInZlcnNpb25cIixcbiAgICBcInJlZ2lzdHJ5XCI6IHRydWUsXG4gICAgXCJyYXdcIjogXCJlbGxpcHRpY0A2LjUuMFwiLFxuICAgIFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG4gICAgXCJlc2NhcGVkTmFtZVwiOiBcImVsbGlwdGljXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiNi41LjBcIixcbiAgICBcInNhdmVTcGVjXCI6IG51bGwsXG4gICAgXCJmZXRjaFNwZWNcIjogXCI2LjUuMFwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL2Jyb3dzZXJpZnktc2lnblwiLFxuICAgIFwiL2NyZWF0ZS1lY2RoXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTYuNS4wLnRnelwiLFxuICBcIl9zcGVjXCI6IFwiNi41LjBcIixcbiAgXCJfd2hlcmVcIjogXCIvVXNlcnMvbWp5Yy9oY3JsYWIvY3ljbGUtcm9ib3QtZHJpdmVycy9leGFtcGxlcy9kZW1vcy9oYW5kdHJhY2tcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkZlZG9yIEluZHV0bnlcIixcbiAgICBcImVtYWlsXCI6IFwiZmVkb3JAaW5kdXRueS5jb21cIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYm4uanNcIjogXCJeNC40LjBcIixcbiAgICBcImJyb3JhbmRcIjogXCJeMS4wLjFcIixcbiAgICBcImhhc2guanNcIjogXCJeMS4wLjBcIixcbiAgICBcImhtYWMtZHJiZ1wiOiBcIl4xLjAuMFwiLFxuICAgIFwiaW5oZXJpdHNcIjogXCJeMi4wLjFcIixcbiAgICBcIm1pbmltYWxpc3RpYy1hc3NlcnRcIjogXCJeMS4wLjBcIixcbiAgICBcIm1pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHNcIjogXCJeMS4wLjBcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiRUMgY3J5cHRvZ3JhcGh5XCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyZnNcIjogXCJeMS40LjNcIixcbiAgICBcImNvdmVyYWxsc1wiOiBcIl4yLjExLjNcIixcbiAgICBcImdydW50XCI6IFwiXjAuNC41XCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjUuMC4wXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJeMS4yLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY29ubmVjdFwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jb3B5XCI6IFwiXjEuMC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4xLjAuMVwiLFxuICAgIFwiZ3J1bnQtbW9jaGEtaXN0YW5idWxcIjogXCJeMy4wLjFcIixcbiAgICBcImdydW50LXNhdWNlbGFic1wiOiBcIl44LjYuMlwiLFxuICAgIFwiaXN0YW5idWxcIjogXCJeMC40LjJcIixcbiAgICBcImpzY3NcIjogXCJeMi45LjBcIixcbiAgICBcImpzaGludFwiOiBcIl4yLjYuMFwiLFxuICAgIFwibW9jaGFcIjogXCJeMi4xLjBcIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImxpYlwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpY1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIkVDXCIsXG4gICAgXCJFbGxpcHRpY1wiLFxuICAgIFwiY3VydmVcIixcbiAgICBcIkNyeXB0b2dyYXBoeVwiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvZWxsaXB0aWMuanNcIixcbiAgXCJuYW1lXCI6IFwiZWxsaXB0aWNcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJqc2NzXCI6IFwianNjcyBiZW5jaG1hcmtzLyouanMgbGliLyouanMgbGliLyoqLyouanMgbGliLyoqLyoqLyouanMgdGVzdC9pbmRleC5qc1wiLFxuICAgIFwianNoaW50XCI6IFwianNjcyBiZW5jaG1hcmtzLyouanMgbGliLyouanMgbGliLyoqLyouanMgbGliLyoqLyoqLyouanMgdGVzdC9pbmRleC5qc1wiLFxuICAgIFwibGludFwiOiBcIm5wbSBydW4ganNjcyAmJiBucG0gcnVuIGpzaGludFwiLFxuICAgIFwidGVzdFwiOiBcIm5wbSBydW4gbGludCAmJiBucG0gcnVuIHVuaXRcIixcbiAgICBcInVuaXRcIjogXCJpc3RhbmJ1bCB0ZXN0IF9tb2NoYSAtLXJlcG9ydGVyPXNwZWMgdGVzdC9pbmRleC5qc1wiLFxuICAgIFwidmVyc2lvblwiOiBcImdydW50IGRpc3QgJiYgZ2l0IGFkZCBkaXN0L1wiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjYuNS4wXCJcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIE1ENSA9IHJlcXVpcmUoJ21kNS5qcycpXG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuZnVuY3Rpb24gRVZQX0J5dGVzVG9LZXkgKHBhc3N3b3JkLCBzYWx0LCBrZXlCaXRzLCBpdkxlbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsICdiaW5hcnknKVxuICBpZiAoc2FsdCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgJ2JpbmFyeScpXG4gICAgaWYgKHNhbHQubGVuZ3RoICE9PSA4KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2FsdCBzaG91bGQgYmUgQnVmZmVyIHdpdGggOCBieXRlIGxlbmd0aCcpXG4gIH1cblxuICB2YXIga2V5TGVuID0ga2V5Qml0cyAvIDhcbiAgdmFyIGtleSA9IEJ1ZmZlci5hbGxvYyhrZXlMZW4pXG4gIHZhciBpdiA9IEJ1ZmZlci5hbGxvYyhpdkxlbiB8fCAwKVxuICB2YXIgdG1wID0gQnVmZmVyLmFsbG9jKDApXG5cbiAgd2hpbGUgKGtleUxlbiA+IDAgfHwgaXZMZW4gPiAwKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgTUQ1KClcbiAgICBoYXNoLnVwZGF0ZSh0bXApXG4gICAgaGFzaC51cGRhdGUocGFzc3dvcmQpXG4gICAgaWYgKHNhbHQpIGhhc2gudXBkYXRlKHNhbHQpXG4gICAgdG1wID0gaGFzaC5kaWdlc3QoKVxuXG4gICAgdmFyIHVzZWQgPSAwXG5cbiAgICBpZiAoa2V5TGVuID4gMCkge1xuICAgICAgdmFyIGtleVN0YXJ0ID0ga2V5Lmxlbmd0aCAtIGtleUxlblxuICAgICAgdXNlZCA9IE1hdGgubWluKGtleUxlbiwgdG1wLmxlbmd0aClcbiAgICAgIHRtcC5jb3B5KGtleSwga2V5U3RhcnQsIDAsIHVzZWQpXG4gICAgICBrZXlMZW4gLT0gdXNlZFxuICAgIH1cblxuICAgIGlmICh1c2VkIDwgdG1wLmxlbmd0aCAmJiBpdkxlbiA+IDApIHtcbiAgICAgIHZhciBpdlN0YXJ0ID0gaXYubGVuZ3RoIC0gaXZMZW5cbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihpdkxlbiwgdG1wLmxlbmd0aCAtIHVzZWQpXG4gICAgICB0bXAuY29weShpdiwgaXZTdGFydCwgdXNlZCwgdXNlZCArIGxlbmd0aClcbiAgICAgIGl2TGVuIC09IGxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHRtcC5maWxsKDApXG4gIHJldHVybiB7IGtleToga2V5LCBpdjogaXYgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVWUF9CeXRlc1RvS2V5XG4iLCIndXNlIHN0cmljdCdcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIgKHZhbCwgcHJlZml4KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkgJiYgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHByZWZpeCArICcgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gSGFzaEJhc2UgKGJsb2NrU2l6ZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2NrU2l6ZSlcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB0aGlzLl9sZW5ndGggPSBbMCwgMCwgMCwgMF1cblxuICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhIYXNoQmFzZSwgVHJhbnNmb3JtKVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB0aGlzLnVwZGF0ZShjaHVuaywgZW5jb2RpbmcpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuZGlnZXN0KCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIoZGF0YSwgJ0RhdGEnKVxuICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpXG5cbiAgLy8gY29uc3VtZSBkYXRhXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBvZmZzZXQgPSAwXG4gIHdoaWxlICh0aGlzLl9ibG9ja09mZnNldCArIGRhdGEubGVuZ3RoIC0gb2Zmc2V0ID49IHRoaXMuX2Jsb2NrU2l6ZSkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9ibG9ja09mZnNldDsgaSA8IHRoaXMuX2Jsb2NrU2l6ZTspIGJsb2NrW2krK10gPSBkYXRhW29mZnNldCsrXVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cbiAgd2hpbGUgKG9mZnNldCA8IGRhdGEubGVuZ3RoKSBibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IGRhdGFbb2Zmc2V0KytdXG5cbiAgLy8gdXBkYXRlIGxlbmd0aFxuICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBkYXRhLmxlbmd0aCAqIDg7IGNhcnJ5ID4gMDsgKytqKSB7XG4gICAgdGhpcy5fbGVuZ3RoW2pdICs9IGNhcnJ5XG4gICAgY2FycnkgPSAodGhpcy5fbGVuZ3RoW2pdIC8gMHgwMTAwMDAwMDAwKSB8IDBcbiAgICBpZiAoY2FycnkgPiAwKSB0aGlzLl9sZW5ndGhbal0gLT0gMHgwMTAwMDAwMDAwICogY2FycnlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcblxuICB2YXIgZGlnZXN0ID0gdGhpcy5fZGlnZXN0KClcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIGRpZ2VzdCA9IGRpZ2VzdC50b1N0cmluZyhlbmNvZGluZylcblxuICAvLyByZXNldCBzdGF0ZVxuICB0aGlzLl9ibG9jay5maWxsKDApXG4gIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkgdGhpcy5fbGVuZ3RoW2ldID0gMFxuXG4gIHJldHVybiBkaWdlc3Rcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX2RpZ2VzdCBpcyBub3QgaW1wbGVtZW50ZWQnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hCYXNlXG4iLCJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEJsb2NrSGFzaCgpIHtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nVG90YWwgPSAwO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuY29uc3RydWN0b3IuYmxvY2tTaXplO1xuICB0aGlzLm91dFNpemUgPSB0aGlzLmNvbnN0cnVjdG9yLm91dFNpemU7XG4gIHRoaXMuaG1hY1N0cmVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5obWFjU3RyZW5ndGg7XG4gIHRoaXMucGFkTGVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5wYWRMZW5ndGggLyA4O1xuICB0aGlzLmVuZGlhbiA9ICdiaWcnO1xuXG4gIHRoaXMuX2RlbHRhOCA9IHRoaXMuYmxvY2tTaXplIC8gODtcbiAgdGhpcy5fZGVsdGEzMiA9IHRoaXMuYmxvY2tTaXplIC8gMzI7XG59XG5leHBvcnRzLkJsb2NrSGFzaCA9IEJsb2NrSGFzaDtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgLy8gQ29udmVydCBtZXNzYWdlIHRvIGFycmF5LCBwYWQgaXQsIGFuZCBqb2luIGludG8gMzJiaXQgYmxvY2tzXG4gIG1zZyA9IHV0aWxzLnRvQXJyYXkobXNnLCBlbmMpO1xuICBpZiAoIXRoaXMucGVuZGluZylcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2c7XG4gIGVsc2VcbiAgICB0aGlzLnBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuY29uY2F0KG1zZyk7XG4gIHRoaXMucGVuZGluZ1RvdGFsICs9IG1zZy5sZW5ndGg7XG5cbiAgLy8gRW5vdWdoIGRhdGEsIHRyeSB1cGRhdGluZ1xuICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+PSB0aGlzLl9kZWx0YTgpIHtcbiAgICBtc2cgPSB0aGlzLnBlbmRpbmc7XG5cbiAgICAvLyBQcm9jZXNzIHBlbmRpbmcgZGF0YSBpbiBibG9ja3NcbiAgICB2YXIgciA9IG1zZy5sZW5ndGggJSB0aGlzLl9kZWx0YTg7XG4gICAgdGhpcy5wZW5kaW5nID0gbXNnLnNsaWNlKG1zZy5sZW5ndGggLSByLCBtc2cubGVuZ3RoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG5cbiAgICBtc2cgPSB1dGlscy5qb2luMzIobXNnLCAwLCBtc2cubGVuZ3RoIC0gciwgdGhpcy5lbmRpYW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSB0aGlzLl9kZWx0YTMyKVxuICAgICAgdGhpcy5fdXBkYXRlKG1zZywgaSwgaSArIHRoaXMuX2RlbHRhMzIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpO1xuICBhc3NlcnQodGhpcy5wZW5kaW5nID09PSBudWxsKTtcblxuICByZXR1cm4gdGhpcy5fZGlnZXN0KGVuYyk7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBwYWQoKSB7XG4gIHZhciBsZW4gPSB0aGlzLnBlbmRpbmdUb3RhbDtcbiAgdmFyIGJ5dGVzID0gdGhpcy5fZGVsdGE4O1xuICB2YXIgayA9IGJ5dGVzIC0gKChsZW4gKyB0aGlzLnBhZExlbmd0aCkgJSBieXRlcyk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkoayArIHRoaXMucGFkTGVuZ3RoKTtcbiAgcmVzWzBdID0gMHg4MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBrOyBpKyspXG4gICAgcmVzW2ldID0gMDtcblxuICAvLyBBcHBlbmQgbGVuZ3RoXG4gIGxlbiA8PD0gMztcbiAgaWYgKHRoaXMuZW5kaWFuID09PSAnYmlnJykge1xuICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcblxuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG5cbiAgICBmb3IgKHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcbiAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuICB0aGlzLkhhc2ggPSBoYXNoO1xuICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcbiAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcbiAgdGhpcy5pbm5lciA9IG51bGw7XG4gIHRoaXMub3V0ZXIgPSBudWxsO1xuXG4gIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG4gIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcbiAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcbiAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gIGFzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBBZGQgcGFkZGluZyB0byBrZXlcbiAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgIGtleS5wdXNoKDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4MzY7XG4gIHRoaXMuaW5uZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG5cbiAgLy8gMHgzNiBeIDB4NWMgPSAweDZhXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4NmE7XG4gIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG59O1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgdGhpcy5pbm5lci51cGRhdGUobXNnLCBlbmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG4gIHJldHVybiB0aGlzLm91dGVyLmRpZ2VzdChlbmMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl8zID0gdXRpbHMuc3VtMzJfMztcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG5mdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSSVBFTUQxNjApKVxuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuZW5kaWFuID0gJ2xpdHRsZSc7XG59XG51dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuUklQRU1EMTYwLmJsb2NrU2l6ZSA9IDUxMjtcblJJUEVNRDE2MC5vdXRTaXplID0gMTYwO1xuUklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5MjtcblJJUEVNRDE2MC5wYWRMZW5ndGggPSA2NDtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIEEgPSB0aGlzLmhbMF07XG4gIHZhciBCID0gdGhpcy5oWzFdO1xuICB2YXIgQyA9IHRoaXMuaFsyXTtcbiAgdmFyIEQgPSB0aGlzLmhbM107XG4gIHZhciBFID0gdGhpcy5oWzRdO1xuICB2YXIgQWggPSBBO1xuICB2YXIgQmggPSBCO1xuICB2YXIgQ2ggPSBDO1xuICB2YXIgRGggPSBEO1xuICB2YXIgRWggPSBFO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICB2YXIgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcbiAgICAgICAgc1tqXSksXG4gICAgICBFKTtcbiAgICBBID0gRTtcbiAgICBFID0gRDtcbiAgICBEID0gcm90bDMyKEMsIDEwKTtcbiAgICBDID0gQjtcbiAgICBCID0gVDtcbiAgICBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG4gICAgICAgIHNoW2pdKSxcbiAgICAgIEVoKTtcbiAgICBBaCA9IEVoO1xuICAgIEVoID0gRGg7XG4gICAgRGggPSByb3RsMzIoQ2gsIDEwKTtcbiAgICBDaCA9IEJoO1xuICAgIEJoID0gVDtcbiAgfVxuICBUID0gc3VtMzJfMyh0aGlzLmhbMV0sIEMsIERoKTtcbiAgdGhpcy5oWzFdID0gc3VtMzJfMyh0aGlzLmhbMl0sIEQsIEVoKTtcbiAgdGhpcy5oWzJdID0gc3VtMzJfMyh0aGlzLmhbM10sIEUsIEFoKTtcbiAgdGhpcy5oWzNdID0gc3VtMzJfMyh0aGlzLmhbNF0sIEEsIEJoKTtcbiAgdGhpcy5oWzRdID0gc3VtMzJfMyh0aGlzLmhbMF0sIEIsIENoKTtcbiAgdGhpcy5oWzBdID0gVDtcbn07XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdsaXR0bGUnKTtcbn07XG5cbmZ1bmN0aW9uIGYoaiwgeCwgeSwgeikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4geCBeIHkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gKHggfCAofnkpKSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuICBlbHNlXG4gICAgcmV0dXJuIHggXiAoeSB8ICh+eikpO1xufVxuXG5mdW5jdGlvbiBLKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWE4Mjc5OTk7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmVkOWViYTE7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4OGYxYmJjZGM7XG4gIGVsc2VcbiAgICByZXR1cm4gMHhhOTUzZmQ0ZTtcbn1cblxuZnVuY3Rpb24gS2goaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHg1MGEyOGJlNjtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YzRkZDEyNDtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZDcwM2VmMztcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg3YTZkNzZlOTtcbiAgZWxzZVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xufVxuXG52YXIgciA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXTtcblxudmFyIHJoID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dO1xuXG52YXIgcyA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl07XG5cbnZhciBzaCA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhLzEnKTtcbmV4cG9ydHMuc2hhMjI0ID0gcmVxdWlyZSgnLi9zaGEvMjI0Jyk7XG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhLzI1NicpO1xuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYS8zODQnKTtcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGEvNTEyJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgc2hhQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzUgPSB1dGlscy5zdW0zMl81O1xudmFyIGZ0XzEgPSBzaGFDb21tb24uZnRfMTtcbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMV9LID0gW1xuICAweDVBODI3OTk5LCAweDZFRDlFQkExLFxuICAweDhGMUJCQ0RDLCAweENBNjJDMUQ2XG5dO1xuXG5mdW5jdGlvbiBTSEExKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMSkpXG4gICAgcmV0dXJuIG5ldyBTSEExKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLFxuICAgIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5XID0gbmV3IEFycmF5KDgwKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoU0hBMSwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMTtcblxuU0hBMS5ibG9ja1NpemUgPSA1MTI7XG5TSEExLm91dFNpemUgPSAxNjA7XG5TSEExLmhtYWNTdHJlbmd0aCA9IDgwO1xuU0hBMS5wYWRMZW5ndGggPSA2NDtcblxuU0hBMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXG4gIGZvcig7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSByb3RsMzIoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSwgMSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHMgPSB+fihpIC8gMjApO1xuICAgIHZhciB0ID0gc3VtMzJfNShyb3RsMzIoYSwgNSksIGZ0XzEocywgYiwgYywgZCksIGUsIFdbaV0sIHNoYTFfS1tzXSk7XG4gICAgZSA9IGQ7XG4gICAgZCA9IGM7XG4gICAgYyA9IHJvdGwzMihiLCAzMCk7XG4gICAgYiA9IGE7XG4gICAgYSA9IHQ7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xufTtcblxuU0hBMS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgU0hBMjU2ID0gcmVxdWlyZSgnLi8yNTYnKTtcblxuZnVuY3Rpb24gU0hBMjI0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjI0KSlcbiAgICByZXR1cm4gbmV3IFNIQTIyNCgpO1xuXG4gIFNIQTI1Ni5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSxcbiAgICAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEyMjQsIFNIQTI1Nik7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTIyNDtcblxuU0hBMjI0LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTIyNC5vdXRTaXplID0gMjI0O1xuU0hBMjI0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTIyNC5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjI0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICAvLyBKdXN0IHRydW5jYXRlIG91dHB1dFxuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBjaDMyID0gc2hhQ29tbW9uLmNoMzI7XG52YXIgbWFqMzIgPSBzaGFDb21tb24ubWFqMzI7XG52YXIgczBfMjU2ID0gc2hhQ29tbW9uLnMwXzI1NjtcbnZhciBzMV8yNTYgPSBzaGFDb21tb24uczFfMjU2O1xudmFyIGcwXzI1NiA9IHNoYUNvbW1vbi5nMF8yNTY7XG52YXIgZzFfMjU2ID0gc2hhQ29tbW9uLmcxXzI1NjtcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGEyNTZfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMyxcbiAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcbiAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcbiAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcbiAgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXTtcblxuZnVuY3Rpb24gU0hBMjU2KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjU2KSlcbiAgICByZXR1cm4gbmV3IFNIQTI1NigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSxcbiAgICAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG4gIF07XG4gIHRoaXMuayA9IHNoYTI1Nl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoNjQpO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjU2LCBCbG9ja0hhc2gpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEyNTY7XG5cblNIQTI1Ni5ibG9ja1NpemUgPSA1MTI7XG5TSEEyNTYub3V0U2l6ZSA9IDI1NjtcblNIQTI1Ni5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyNTYucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpKyspXG4gICAgV1tpXSA9IHN1bTMyXzQoZzFfMjU2KFdbaSAtIDJdKSwgV1tpIC0gN10sIGcwXzI1NihXW2kgLSAxNV0pLCBXW2kgLSAxNl0pO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcbiAgdmFyIGYgPSB0aGlzLmhbNV07XG4gIHZhciBnID0gdGhpcy5oWzZdO1xuICB2YXIgaCA9IHRoaXMuaFs3XTtcblxuICBhc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBUMSA9IHN1bTMyXzUoaCwgczFfMjU2KGUpLCBjaDMyKGUsIGYsIGcpLCB0aGlzLmtbaV0sIFdbaV0pO1xuICAgIHZhciBUMiA9IHN1bTMyKHMwXzI1NihhKSwgbWFqMzIoYSwgYiwgYykpO1xuICAgIGggPSBnO1xuICAgIGcgPSBmO1xuICAgIGYgPSBlO1xuICAgIGUgPSBzdW0zMihkLCBUMSk7XG4gICAgZCA9IGM7XG4gICAgYyA9IGI7XG4gICAgYiA9IGE7XG4gICAgYSA9IHN1bTMyKFQxLCBUMik7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xuICB0aGlzLmhbNV0gPSBzdW0zMih0aGlzLmhbNV0sIGYpO1xuICB0aGlzLmhbNl0gPSBzdW0zMih0aGlzLmhbNl0sIGcpO1xuICB0aGlzLmhbN10gPSBzdW0zMih0aGlzLmhbN10sIGgpO1xufTtcblxuU0hBMjU2LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vNTEyJyk7XG5cbmZ1bmN0aW9uIFNIQTM4NCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTM4NCkpXG4gICAgcmV0dXJuIG5ldyBTSEEzODQoKTtcblxuICBTSEE1MTIuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsXG4gICAgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyxcbiAgICAweDkxNTkwMTVhLCAweDMwNzBkZDE3LFxuICAgIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSxcbiAgICAweDhlYjQ0YTg3LCAweDY4NTgxNTExLFxuICAgIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsXG4gICAgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMzg0LCBTSEE1MTIpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEzODQ7XG5cblNIQTM4NC5ibG9ja1NpemUgPSAxMDI0O1xuU0hBMzg0Lm91dFNpemUgPSAzODQ7XG5TSEEzODQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMzg0LnBhZExlbmd0aCA9IDEyODtcblxuU0hBMzg0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHJvdHI2NF9oaSA9IHV0aWxzLnJvdHI2NF9oaTtcbnZhciByb3RyNjRfbG8gPSB1dGlscy5yb3RyNjRfbG87XG52YXIgc2hyNjRfaGkgPSB1dGlscy5zaHI2NF9oaTtcbnZhciBzaHI2NF9sbyA9IHV0aWxzLnNocjY0X2xvO1xudmFyIHN1bTY0ID0gdXRpbHMuc3VtNjQ7XG52YXIgc3VtNjRfaGkgPSB1dGlscy5zdW02NF9oaTtcbnZhciBzdW02NF9sbyA9IHV0aWxzLnN1bTY0X2xvO1xudmFyIHN1bTY0XzRfaGkgPSB1dGlscy5zdW02NF80X2hpO1xudmFyIHN1bTY0XzRfbG8gPSB1dGlscy5zdW02NF80X2xvO1xudmFyIHN1bTY0XzVfaGkgPSB1dGlscy5zdW02NF81X2hpO1xudmFyIHN1bTY0XzVfbG8gPSB1dGlscy5zdW02NF81X2xvO1xuXG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTUxMl9LID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBTSEE1MTIoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEE1MTIpKVxuICAgIHJldHVybiBuZXcgU0hBNTEyKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuICAgIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsXG4gICAgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYixcbiAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsXG4gICAgMHg5YjA1Njg4YywgMHgyYjNlNmMxZixcbiAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuICAgIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkgXTtcbiAgdGhpcy5rID0gc2hhNTEyX0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBNTEyLCBCbG9ja0hhc2gpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEE1MTI7XG5cblNIQTUxMi5ibG9ja1NpemUgPSAxMDI0O1xuU0hBNTEyLm91dFNpemUgPSA1MTI7XG5TSEE1MTIuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBNTEyLnBhZExlbmd0aCA9IDEyODtcblxuU0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIC8vIDMyIHggMzJiaXQgd29yZHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuICAgIHZhciBjMF9sbyA9IGcxXzUxMl9sbyhXW2kgLSA0XSwgV1tpIC0gM10pO1xuICAgIHZhciBjMV9oaSA9IFdbaSAtIDE0XTsgIC8vIGkgLSA3XG4gICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuICAgIHZhciBjMl9oaSA9IGcwXzUxMl9oaShXW2kgLSAzMF0sIFdbaSAtIDI5XSk7ICAvLyBpIC0gMTVcbiAgICB2YXIgYzJfbG8gPSBnMF81MTJfbG8oV1tpIC0gMzBdLCBXW2kgLSAyOV0pO1xuICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuICAgIHZhciBjM19sbyA9IFdbaSAtIDMxXTtcblxuICAgIFdbaV0gPSBzdW02NF80X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgICBXW2kgKyAxXSA9IHN1bTY0XzRfbG8oXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8pO1xuICB9XG59O1xuXG5TSEE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdGhpcy5fcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpO1xuXG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIHZhciBhaCA9IHRoaXMuaFswXTtcbiAgdmFyIGFsID0gdGhpcy5oWzFdO1xuICB2YXIgYmggPSB0aGlzLmhbMl07XG4gIHZhciBibCA9IHRoaXMuaFszXTtcbiAgdmFyIGNoID0gdGhpcy5oWzRdO1xuICB2YXIgY2wgPSB0aGlzLmhbNV07XG4gIHZhciBkaCA9IHRoaXMuaFs2XTtcbiAgdmFyIGRsID0gdGhpcy5oWzddO1xuICB2YXIgZWggPSB0aGlzLmhbOF07XG4gIHZhciBlbCA9IHRoaXMuaFs5XTtcbiAgdmFyIGZoID0gdGhpcy5oWzEwXTtcbiAgdmFyIGZsID0gdGhpcy5oWzExXTtcbiAgdmFyIGdoID0gdGhpcy5oWzEyXTtcbiAgdmFyIGdsID0gdGhpcy5oWzEzXTtcbiAgdmFyIGhoID0gdGhpcy5oWzE0XTtcbiAgdmFyIGhsID0gdGhpcy5oWzE1XTtcblxuICBhc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYzBfaGkgPSBoaDtcbiAgICB2YXIgYzBfbG8gPSBobDtcbiAgICB2YXIgYzFfaGkgPSBzMV81MTJfaGkoZWgsIGVsKTtcbiAgICB2YXIgYzFfbG8gPSBzMV81MTJfbG8oZWgsIGVsKTtcbiAgICB2YXIgYzJfaGkgPSBjaDY0X2hpKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjMl9sbyA9IGNoNjRfbG8oZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMzX2hpID0gdGhpcy5rW2ldO1xuICAgIHZhciBjM19sbyA9IHRoaXMua1tpICsgMV07XG4gICAgdmFyIGM0X2hpID0gV1tpXTtcbiAgICB2YXIgYzRfbG8gPSBXW2kgKyAxXTtcblxuICAgIHZhciBUMV9oaSA9IHN1bTY0XzVfaGkoXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8sXG4gICAgICBjNF9oaSwgYzRfbG8pO1xuICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8oXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8sXG4gICAgICBjNF9oaSwgYzRfbG8pO1xuXG4gICAgYzBfaGkgPSBzMF81MTJfaGkoYWgsIGFsKTtcbiAgICBjMF9sbyA9IHMwXzUxMl9sbyhhaCwgYWwpO1xuICAgIGMxX2hpID0gbWFqNjRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG4gICAgYzFfbG8gPSBtYWo2NF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsKTtcblxuICAgIHZhciBUMl9oaSA9IHN1bTY0X2hpKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcbiAgICB2YXIgVDJfbG8gPSBzdW02NF9sbyhjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG5cbiAgICBoaCA9IGdoO1xuICAgIGhsID0gZ2w7XG5cbiAgICBnaCA9IGZoO1xuICAgIGdsID0gZmw7XG5cbiAgICBmaCA9IGVoO1xuICAgIGZsID0gZWw7XG5cbiAgICBlaCA9IHN1bTY0X2hpKGRoLCBkbCwgVDFfaGksIFQxX2xvKTtcbiAgICBlbCA9IHN1bTY0X2xvKGRsLCBkbCwgVDFfaGksIFQxX2xvKTtcblxuICAgIGRoID0gY2g7XG4gICAgZGwgPSBjbDtcblxuICAgIGNoID0gYmg7XG4gICAgY2wgPSBibDtcblxuICAgIGJoID0gYWg7XG4gICAgYmwgPSBhbDtcblxuICAgIGFoID0gc3VtNjRfaGkoVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuICAgIGFsID0gc3VtNjRfbG8oVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuICB9XG5cbiAgc3VtNjQodGhpcy5oLCAwLCBhaCwgYWwpO1xuICBzdW02NCh0aGlzLmgsIDIsIGJoLCBibCk7XG4gIHN1bTY0KHRoaXMuaCwgNCwgY2gsIGNsKTtcbiAgc3VtNjQodGhpcy5oLCA2LCBkaCwgZGwpO1xuICBzdW02NCh0aGlzLmgsIDgsIGVoLCBlbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTAsIGZoLCBmbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTIsIGdoLCBnbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTQsIGhoLCBobCk7XG59O1xuXG5TSEE1MTIucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBjaDY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICgofnhoKSAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBjaDY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoKH54bCkgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbWFqNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDgpO1xuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDgpO1xuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgcm90cjMyID0gdXRpbHMucm90cjMyO1xuXG5mdW5jdGlvbiBmdF8xKHMsIHgsIHksIHopIHtcbiAgaWYgKHMgPT09IDApXG4gICAgcmV0dXJuIGNoMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAxIHx8IHMgPT09IDMpXG4gICAgcmV0dXJuIHAzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDIpXG4gICAgcmV0dXJuIG1hajMyKHgsIHksIHopO1xufVxuZXhwb3J0cy5mdF8xID0gZnRfMTtcblxuZnVuY3Rpb24gY2gzMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKCh+eCkgJiB6KTtcbn1cbmV4cG9ydHMuY2gzMiA9IGNoMzI7XG5cbmZ1bmN0aW9uIG1hajMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KTtcbn1cbmV4cG9ydHMubWFqMzIgPSBtYWozMjtcblxuZnVuY3Rpb24gcDMyKHgsIHksIHopIHtcbiAgcmV0dXJuIHggXiB5IF4gejtcbn1cbmV4cG9ydHMucDMyID0gcDMyO1xuXG5mdW5jdGlvbiBzMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDIpIF4gcm90cjMyKHgsIDEzKSBeIHJvdHIzMih4LCAyMik7XG59XG5leHBvcnRzLnMwXzI1NiA9IHMwXzI1NjtcblxuZnVuY3Rpb24gczFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA2KSBeIHJvdHIzMih4LCAxMSkgXiByb3RyMzIoeCwgMjUpO1xufVxuZXhwb3J0cy5zMV8yNTYgPSBzMV8yNTY7XG5cbmZ1bmN0aW9uIGcwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNykgXiByb3RyMzIoeCwgMTgpIF4gKHggPj4+IDMpO1xufVxuZXhwb3J0cy5nMF8yNTYgPSBnMF8yNTY7XG5cbmZ1bmN0aW9uIGcxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMTcpIF4gcm90cjMyKHgsIDE5KSBeICh4ID4+PiAxMCk7XG59XG5leHBvcnRzLmcxXzI1NiA9IGcxXzI1NjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gaXNTdXJyb2dhdGVQYWlyKG1zZywgaSkge1xuICBpZiAoKG1zZy5jaGFyQ29kZUF0KGkpICYgMHhGQzAwKSAhPT0gMHhEODAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpIDwgMCB8fCBpICsgMSA+PSBtc2cubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAobXNnLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFlbmMpIHtcbiAgICAgIC8vIEluc3BpcmVkIGJ5IHN0cmluZ1RvVXRmOEJ5dGVBcnJheSgpIGluIGNsb3N1cmUtbGlicmFyeSBieSBHb29nbGVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvODU5OGQ4NzI0MmFmNTlhYWMyMzMyNzA3NDJjODk4NGUyYjJiZGJlMC9jbG9zdXJlL2dvb2cvY3J5cHQvY3J5cHQuanMjTDExNy1MMTQzXG4gICAgICAvLyBBcGFjaGUgTGljZW5zZSAyLjBcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3Vycm9nYXRlUGFpcihtc2csIGkpKSB7XG4gICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzRkYpIDw8IDEwKSArIChtc2cuY2hhckNvZGVBdCgrK2kpICYgMHgwM0ZGKTtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG5leHBvcnRzLmh0b25sID0gaHRvbmw7XG5cbmZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuICAgICAgdyA9IGh0b25sKHcpO1xuICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXgzMiA9IHRvSGV4MzI7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm84ID0gemVybzg7XG5cbmZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGFzc2VydChsZW4gJSA0ID09PSAwKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG4gICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG4gICAgZWxzZVxuICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuICAgIHJlc1tpXSA9IHcgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuam9pbjMyID0gam9pbjMyO1xuXG5mdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCAqIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciBtID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgICByZXNba10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2sgKyAzXSA9IG0gJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbayArIDNdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trXSA9IG0gJiAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90cjMyID0gcm90cjMyO1xuXG5mdW5jdGlvbiByb3RsMzIodywgYikge1xuICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RsMzIgPSByb3RsMzI7XG5cbmZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcbiAgcmV0dXJuIChhICsgYikgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzMgPSBzdW0zMl8zO1xuXG5mdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNCA9IHN1bTMyXzQ7XG5cbmZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQgKyBlKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcbiAgdmFyIGJoID0gYnVmW3Bvc107XG4gIHZhciBibCA9IGJ1Zltwb3MgKyAxXTtcblxuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgYnVmW3Bvc10gPSBoaSA+Pj4gMDtcbiAgYnVmW3BvcyArIDFdID0gbG87XG59XG5leHBvcnRzLnN1bTY0ID0gc3VtNjQ7XG5cbmZ1bmN0aW9uIHN1bTY0X2hpKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfbG8gPSBzdW02NF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2hpID0gc3VtNjRfNF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfaGkgPSBzdW02NF81X2hpO1xuXG5mdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2xvID0gc3VtNjRfNV9sbztcblxuZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFsIDw8ICgzMiAtIG51bSkpIHwgKGFoID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG5cbmZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHJldHVybiBhaCA+Pj4gbnVtO1xufVxuZXhwb3J0cy5zaHI2NF9oaSA9IHNocjY0X2hpO1xuXG5mdW5jdGlvbiBzaHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWNyeXB0by11dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKVxuICAgIHJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcbiAgdGhpcy5wcmVkUmVzaXN0ID0gISFvcHRpb25zLnByZWRSZXNpc3Q7XG5cbiAgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZTtcbiAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cbiAgdGhpcy5fcmVzZWVkID0gbnVsbDtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMuSyA9IG51bGw7XG4gIHRoaXMuViA9IG51bGw7XG5cbiAgdmFyIGVudHJvcHkgPSB1dGlscy50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICdoZXgnKTtcbiAgdmFyIG5vbmNlID0gdXRpbHMudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcbiAgdmFyIHBlcnMgPSB1dGlscy50b0FycmF5KG9wdGlvbnMucGVycywgb3B0aW9ucy5wZXJzRW5jIHx8ICdoZXgnKTtcbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcbiAgdGhpcy5faW5pdChlbnRyb3B5LCBub25jZSwgcGVycyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlscy50b0FycmF5KGVudHJvcHksIGVudHJvcHlFbmMpO1xuICBhZGQgPSB1dGlscy50b0FycmF5KGFkZCwgYWRkRW5jKTtcblxuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG4gIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbiwgZW5jLCBhZGQsIGFkZEVuYykge1xuICBpZiAodGhpcy5fcmVzZWVkID4gdGhpcy5yZXNlZWRJbnRlcnZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIE9wdGlvbmFsIGVuY29kaW5nXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuXG4gIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YVxuICBpZiAoYWRkKSB7XG4gICAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5fcmVzZWVkKys7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoQmFzZSA9IHJlcXVpcmUoJ2hhc2gtYmFzZScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEFSUkFZMTYgPSBuZXcgQXJyYXkoMTYpXG5cbmZ1bmN0aW9uIE1ENSAoKSB7XG4gIEhhc2hCYXNlLmNhbGwodGhpcywgNjQpXG5cbiAgLy8gc3RhdGVcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbn1cblxuaW5oZXJpdHMoTUQ1LCBIYXNoQmFzZSlcblxuTUQ1LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgTSA9IEFSUkFZMTZcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBNW2ldID0gdGhpcy5fYmxvY2sucmVhZEludDMyTEUoaSAqIDQpXG5cbiAgdmFyIGEgPSB0aGlzLl9hXG4gIHZhciBiID0gdGhpcy5fYlxuICB2YXIgYyA9IHRoaXMuX2NcbiAgdmFyIGQgPSB0aGlzLl9kXG5cbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzBdLCAweGQ3NmFhNDc4LCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMV0sIDB4ZThjN2I3NTYsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMl0sIDB4MjQyMDcwZGIsIDE3KVxuICBiID0gZm5GKGIsIGMsIGQsIGEsIE1bM10sIDB4YzFiZGNlZWUsIDIyKVxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bNF0sIDB4ZjU3YzBmYWYsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVs1XSwgMHg0Nzg3YzYyYSwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVs2XSwgMHhhODMwNDYxMywgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVs3XSwgMHhmZDQ2OTUwMSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVs4XSwgMHg2OTgwOThkOCwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzldLCAweDhiNDRmN2FmLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzEwXSwgMHhmZmZmNWJiMSwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVsxMV0sIDB4ODk1Y2Q3YmUsIDIyKVxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bMTJdLCAweDZiOTAxMTIyLCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMTNdLCAweGZkOTg3MTkzLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzE0XSwgMHhhNjc5NDM4ZSwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVsxNV0sIDB4NDliNDA4MjEsIDIyKVxuXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxXSwgMHhmNjFlMjU2MiwgNSlcbiAgZCA9IGZuRyhkLCBhLCBiLCBjLCBNWzZdLCAweGMwNDBiMzQwLCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bMTFdLCAweDI2NWU1YTUxLCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzBdLCAweGU5YjZjN2FhLCAyMClcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzVdLCAweGQ2MmYxMDVkLCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMTBdLCAweDAyNDQxNDUzLCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bMTVdLCAweGQ4YTFlNjgxLCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzRdLCAweGU3ZDNmYmM4LCAyMClcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzldLCAweDIxZTFjZGU2LCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMTRdLCAweGMzMzcwN2Q2LCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bM10sIDB4ZjRkNTBkODcsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bOF0sIDB4NDU1YTE0ZWQsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bMTNdLCAweGE5ZTNlOTA1LCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMl0sIDB4ZmNlZmEzZjgsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVs3XSwgMHg2NzZmMDJkOSwgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVsxMl0sIDB4OGQyYTRjOGEsIDIwKVxuXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs1XSwgMHhmZmZhMzk0MiwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzhdLCAweDg3NzFmNjgxLCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzExXSwgMHg2ZDlkNjEyMiwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsxNF0sIDB4ZmRlNTM4MGMsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bMV0sIDB4YTRiZWVhNDQsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVs0XSwgMHg0YmRlY2ZhOSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVs3XSwgMHhmNmJiNGI2MCwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsxMF0sIDB4YmViZmJjNzAsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bMTNdLCAweDI4OWI3ZWM2LCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bMF0sIDB4ZWFhMTI3ZmEsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bM10sIDB4ZDRlZjMwODUsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bNl0sIDB4MDQ4ODFkMDUsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bOV0sIDB4ZDlkNGQwMzksIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVsxMl0sIDB4ZTZkYjk5ZTUsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bMTVdLCAweDFmYTI3Y2Y4LCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzJdLCAweGM0YWM1NjY1LCAyMylcblxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bMF0sIDB4ZjQyOTIyNDQsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVs3XSwgMHg0MzJhZmY5NywgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsxNF0sIDB4YWI5NDIzYTcsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bNV0sIDB4ZmM5M2EwMzksIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bMTJdLCAweDY1NWI1OWMzLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bM10sIDB4OGYwY2NjOTIsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bMTBdLCAweGZmZWZmNDdkLCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzFdLCAweDg1ODQ1ZGQxLCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzhdLCAweDZmYTg3ZTRmLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bMTVdLCAweGZlMmNlNmUwLCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzZdLCAweGEzMDE0MzE0LCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzEzXSwgMHg0ZTA4MTFhMSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVs0XSwgMHhmNzUzN2U4MiwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzExXSwgMHhiZDNhZjIzNSwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsyXSwgMHgyYWQ3ZDJiYiwgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVs5XSwgMHhlYjg2ZDM5MSwgMjEpXG5cbiAgdGhpcy5fYSA9ICh0aGlzLl9hICsgYSkgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYiArIGIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2MgKyBjKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9kICsgZCkgfCAwXG59XG5cbk1ENS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmcgYW5kIGhhbmRsZSBibG9ja3NcbiAgdGhpcy5fYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSAweDgwXG4gIGlmICh0aGlzLl9ibG9ja09mZnNldCA+IDU2KSB7XG4gICAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNjQpXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgfVxuXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFswXSwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzFdLCA2MClcbiAgdGhpcy5fdXBkYXRlKClcblxuICAvLyBwcm9kdWNlIHJlc3VsdFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9jLCA4KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBmbkYgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgYykgfCAoKH5iKSAmIGQpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbmZ1bmN0aW9uIGZuRyAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5IIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gYyBeIGQpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5JIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYyBeIChiIHwgKH5kKSkpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTUQ1XG4iLCJ2YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGJyb3JhbmQgPSByZXF1aXJlKCdicm9yYW5kJyk7XG5cbmZ1bmN0aW9uIE1pbGxlclJhYmluKHJhbmQpIHtcbiAgdGhpcy5yYW5kID0gcmFuZCB8fCBuZXcgYnJvcmFuZC5SYW5kKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IE1pbGxlclJhYmluO1xuXG5NaWxsZXJSYWJpbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocmFuZCkge1xuICByZXR1cm4gbmV3IE1pbGxlclJhYmluKHJhbmQpO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLl9yYW5kYmVsb3cgPSBmdW5jdGlvbiBfcmFuZGJlbG93KG4pIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciBtaW5fYnl0ZXMgPSBNYXRoLmNlaWwobGVuIC8gOCk7XG5cbiAgLy8gR2VuZXJhZ2UgcmFuZG9tIGJ5dGVzIHVudGlsIGEgbnVtYmVyIGxlc3MgdGhhbiBuIGlzIGZvdW5kLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCAwLi5uLTEgaGF2ZSBhbiBlcXVhbCBwcm9iYWJpbGl0eSBvZiBiZWluZyBzZWxlY3RlZC5cbiAgZG9cbiAgICB2YXIgYSA9IG5ldyBibih0aGlzLnJhbmQuZ2VuZXJhdGUobWluX2J5dGVzKSk7XG4gIHdoaWxlIChhLmNtcChuKSA+PSAwKTtcblxuICByZXR1cm4gYTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5fcmFuZHJhbmdlID0gZnVuY3Rpb24gX3JhbmRyYW5nZShzdGFydCwgc3RvcCkge1xuICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHN0YXJ0IGFuZCBsZXNzIHRoYW4gc3RvcC5cbiAgdmFyIHNpemUgPSBzdG9wLnN1YihzdGFydCk7XG4gIHJldHVybiBzdGFydC5hZGQodGhpcy5fcmFuZGJlbG93KHNpemUpKTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdChuLCBrLCBjYikge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICB2YXIgcHJpbWUgPSB0cnVlO1xuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZHJhbmdlKG5ldyBibigyKSwgbjEpO1xuICAgIGlmIChjYilcbiAgICAgIGNiKGEpO1xuXG4gICAgdmFyIHggPSBhLnRvUmVkKHJlZCkucmVkUG93KGQpO1xuICAgIGlmICh4LmNtcChyb25lKSA9PT0gMCB8fCB4LmNtcChybjEpID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7IGkrKykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG5cbiAgICAgIGlmICh4LmNtcChyb25lKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHguY21wKHJuMSkgPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID09PSBzKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHByaW1lO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLmdldERpdmlzb3IgPSBmdW5jdGlvbiBnZXREaXZpc29yKG4sIGspIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciByZWQgPSBibi5tb250KG4pO1xuICB2YXIgcm9uZSA9IG5ldyBibigxKS50b1JlZChyZWQpO1xuXG4gIGlmICghaylcbiAgICBrID0gTWF0aC5tYXgoMSwgKGxlbiAvIDQ4KSB8IDApO1xuXG4gIC8vIEZpbmQgZCBhbmQgcywgKG4gLSAxKSA9ICgyIF4gcykgKiBkO1xuICB2YXIgbjEgPSBuLnN1Ym4oMSk7XG4gIGZvciAodmFyIHMgPSAwOyAhbjEudGVzdG4ocyk7IHMrKykge31cbiAgdmFyIGQgPSBuLnNocm4ocyk7XG5cbiAgdmFyIHJuMSA9IG4xLnRvUmVkKHJlZCk7XG5cbiAgZm9yICg7IGsgPiAwOyBrLS0pIHtcbiAgICB2YXIgYSA9IHRoaXMuX3JhbmRyYW5nZShuZXcgYm4oMiksIG4xKTtcblxuICAgIHZhciBnID0gbi5nY2QoYSk7XG4gICAgaWYgKGcuY21wbigxKSAhPT0gMClcbiAgICAgIHJldHVybiBnO1xuXG4gICAgdmFyIHggPSBhLnRvUmVkKHJlZCkucmVkUG93KGQpO1xuICAgIGlmICh4LmNtcChyb25lKSA9PT0gMCB8fCB4LmNtcChybjEpID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7IGkrKykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG5cbiAgICAgIGlmICh4LmNtcChyb25lKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHguZnJvbVJlZCgpLnN1Ym4oMSkuZ2NkKG4pO1xuICAgICAgaWYgKHguY21wKHJuMSkgPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID09PSBzKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcbiAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbnV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdG9IZXgoYXJyKTtcbiAgZWxzZVxuICAgIHJldHVybiBhcnI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1wiMi4xNi44NDAuMS4xMDEuMy40LjEuMVwiOiBcImFlcy0xMjgtZWNiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjJcIjogXCJhZXMtMTI4LWNiY1wiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4zXCI6IFwiYWVzLTEyOC1vZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNFwiOiBcImFlcy0xMjgtY2ZiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjIxXCI6IFwiYWVzLTE5Mi1lY2JcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjJcIjogXCJhZXMtMTkyLWNiY1wiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yM1wiOiBcImFlcy0xOTItb2ZiXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjI0XCI6IFwiYWVzLTE5Mi1jZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDFcIjogXCJhZXMtMjU2LWVjYlwiLFxuXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40MlwiOiBcImFlcy0yNTYtY2JjXCIsXG5cIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQzXCI6IFwiYWVzLTI1Ni1vZmJcIixcblwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDRcIjogXCJhZXMtMjU2LWNmYlwiXG59IiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9hc24xLmpzXG4vLyBGZWRvciwgeW91IGFyZSBhbWF6aW5nLlxuJ3VzZSBzdHJpY3QnXG5cbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMS5qcycpXG5cbmV4cG9ydHMuY2VydGlmaWNhdGUgPSByZXF1aXJlKCcuL2NlcnRpZmljYXRlJylcblxudmFyIFJTQVByaXZhdGVLZXkgPSBhc24xLmRlZmluZSgnUlNBUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnbW9kdWx1cycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2YXRlRXhwb25lbnQnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaW1lMicpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZXhwb25lbnQyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2NvZWZmaWNpZW50JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuUlNBUHJpdmF0ZUtleSA9IFJTQVByaXZhdGVLZXlcblxudmFyIFJTQVB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdSU0FQdWJsaWNLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuUlNBUHVibGljS2V5ID0gUlNBUHVibGljS2V5XG5cbnZhciBQdWJsaWNLZXkgPSBhc24xLmRlZmluZSgnU3ViamVjdFB1YmxpY0tleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXknKS5iaXRzdHIoKVxuICApXG59KVxuZXhwb3J0cy5QdWJsaWNLZXkgPSBQdWJsaWNLZXlcblxudmFyIEFsZ29yaXRobUlkZW50aWZpZXIgPSBhc24xLmRlZmluZSgnQWxnb3JpdGhtSWRlbnRpZmllcicsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ25vbmUnKS5udWxsXygpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ2N1cnZlJykub2JqaWQoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgncCcpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ3EnKS5pbnQoKSxcbiAgICAgIHRoaXMua2V5KCdnJykuaW50KClcbiAgICApLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFByaXZhdGVLZXlJbmZvID0gYXNuMS5kZWZpbmUoJ1ByaXZhdGVLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQcml2YXRlS2V5Jykub2N0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuUHJpdmF0ZUtleSA9IFByaXZhdGVLZXlJbmZvXG52YXIgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgdGhpcy5rZXkoJ2RlY3J5cHQnKS5zZXEoKS5vYmooXG4gICAgICAgIHRoaXMua2V5KCdrZGUnKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2lkJykub2JqaWQoKSxcbiAgICAgICAgICB0aGlzLmtleSgna2RlcGFyYW1zJykuc2VxKCkub2JqKFxuICAgICAgICAgICAgdGhpcy5rZXkoJ3NhbHQnKS5vY3RzdHIoKSxcbiAgICAgICAgICAgIHRoaXMua2V5KCdpdGVycycpLmludCgpXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICB0aGlzLmtleSgnY2lwaGVyJykuc2VxKCkub2JqKFxuICAgICAgICAgIHRoaXMua2V5KCdhbGdvJykub2JqaWQoKSxcbiAgICAgICAgICB0aGlzLmtleSgnaXYnKS5vY3RzdHIoKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFByaXZhdGVLZXknKS5vY3RzdHIoKVxuICApXG59KVxuXG5leHBvcnRzLkVuY3J5cHRlZFByaXZhdGVLZXkgPSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuXG52YXIgRFNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdEU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3EnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJfa2V5JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZfa2V5JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuRFNBUHJpdmF0ZUtleSA9IERTQVByaXZhdGVLZXlcblxuZXhwb3J0cy5EU0FwYXJhbSA9IGFzbjEuZGVmaW5lKCdEU0FwYXJhbScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbnQoKVxufSlcblxudmFyIEVDUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdFQ1ByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXknKS5vY3RzdHIoKSxcbiAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLm9wdGlvbmFsKCkuZXhwbGljaXQoMCkudXNlKEVDUGFyYW1ldGVycyksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLm9wdGlvbmFsKCkuZXhwbGljaXQoMSkuYml0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuRUNQcml2YXRlS2V5ID0gRUNQcml2YXRlS2V5XG5cbnZhciBFQ1BhcmFtZXRlcnMgPSBhc24xLmRlZmluZSgnRUNQYXJhbWV0ZXJzJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgbmFtZWRDdXJ2ZTogdGhpcy5vYmppZCgpXG4gIH0pXG59KVxuXG5leHBvcnRzLnNpZ25hdHVyZSA9IGFzbjEuZGVmaW5lKCdzaWduYXR1cmUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3MnKS5pbnQoKVxuICApXG59KVxuIiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vUmFudGFuZW4vbm9kZS1kdGxzL2Jsb2IvMjVhN2RjODYxYmRhMzhjZmVhYzkzYTcyMzUwMGVlYTRmMGFjMmU4Ni9DZXJ0aWZpY2F0ZS5qc1xuLy8gdGhhbmtzIHRvIEBSYW50YW5lblxuXG4ndXNlIHN0cmljdCdcblxudmFyIGFzbiA9IHJlcXVpcmUoJ2FzbjEuanMnKVxuXG52YXIgVGltZSA9IGFzbi5kZWZpbmUoJ1RpbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hvaWNlKHtcbiAgICB1dGNUaW1lOiB0aGlzLnV0Y3RpbWUoKSxcbiAgICBnZW5lcmFsVGltZTogdGhpcy5nZW50aW1lKClcbiAgfSlcbn0pXG5cbnZhciBBdHRyaWJ1dGVUeXBlVmFsdWUgPSBhc24uZGVmaW5lKCdBdHRyaWJ1dGVUeXBlVmFsdWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd0eXBlJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgndmFsdWUnKS5hbnkoKVxuICApXG59KVxuXG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbi5kZWZpbmUoJ0FsZ29yaXRobUlkZW50aWZpZXInLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnY3VydmUnKS5vYmppZCgpLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFN1YmplY3RQdWJsaWNLZXlJbmZvID0gYXNuLmRlZmluZSgnU3ViamVjdFB1YmxpY0tleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXknKS5iaXRzdHIoKVxuICApXG59KVxuXG52YXIgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSA9IGFzbi5kZWZpbmUoJ1JlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0b2YoQXR0cmlidXRlVHlwZVZhbHVlKVxufSlcblxudmFyIFJETlNlcXVlbmNlID0gYXNuLmRlZmluZSgnUkROU2VxdWVuY2UnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2Vxb2YoUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSlcbn0pXG5cbnZhciBOYW1lID0gYXNuLmRlZmluZSgnTmFtZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaG9pY2Uoe1xuICAgIHJkblNlcXVlbmNlOiB0aGlzLnVzZShSRE5TZXF1ZW5jZSlcbiAgfSlcbn0pXG5cbnZhciBWYWxpZGl0eSA9IGFzbi5kZWZpbmUoJ1ZhbGlkaXR5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnbm90QmVmb3JlJykudXNlKFRpbWUpLFxuICAgIHRoaXMua2V5KCdub3RBZnRlcicpLnVzZShUaW1lKVxuICApXG59KVxuXG52YXIgRXh0ZW5zaW9uID0gYXNuLmRlZmluZSgnRXh0ZW5zaW9uJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnZXh0bklEJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgnY3JpdGljYWwnKS5ib29sKCkuZGVmKGZhbHNlKSxcbiAgICB0aGlzLmtleSgnZXh0blZhbHVlJykub2N0c3RyKClcbiAgKVxufSlcblxudmFyIFRCU0NlcnRpZmljYXRlID0gYXNuLmRlZmluZSgnVEJTQ2VydGlmaWNhdGUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuZXhwbGljaXQoMCkuaW50KCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnc2VyaWFsTnVtYmVyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnaXNzdWVyJykudXNlKE5hbWUpLFxuICAgIHRoaXMua2V5KCd2YWxpZGl0eScpLnVzZShWYWxpZGl0eSksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3QnKS51c2UoTmFtZSksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXlJbmZvJykudXNlKFN1YmplY3RQdWJsaWNLZXlJbmZvKSxcbiAgICB0aGlzLmtleSgnaXNzdWVyVW5pcXVlSUQnKS5pbXBsaWNpdCgxKS5iaXRzdHIoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0VW5pcXVlSUQnKS5pbXBsaWNpdCgyKS5iaXRzdHIoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdleHRlbnNpb25zJykuZXhwbGljaXQoMykuc2Vxb2YoRXh0ZW5zaW9uKS5vcHRpb25hbCgpXG4gIClcbn0pXG5cbnZhciBYNTA5Q2VydGlmaWNhdGUgPSBhc24uZGVmaW5lKCdYNTA5Q2VydGlmaWNhdGUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd0YnNDZXJ0aWZpY2F0ZScpLnVzZShUQlNDZXJ0aWZpY2F0ZSksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZUFsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc2lnbmF0dXJlVmFsdWUnKS5iaXRzdHIoKVxuICApXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFg1MDlDZXJ0aWZpY2F0ZVxuIiwiLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGF0aWwvcGVtc3RyaXBcbnZhciBmaW5kUHJvYyA9IC9Qcm9jLVR5cGU6IDQsRU5DUllQVEVEW1xcblxccl0rREVLLUluZm86IEFFUy0oKD86MTI4KXwoPzoxOTIpfCg/OjI1NikpLUNCQywoWzAtOUEtSF0rKVtcXG5cXHJdKyhbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspW1xcblxccl0rL21cbnZhciBzdGFydFJlZ2V4ID0gL14tLS0tLUJFR0lOICgoPzouKj8gS0VZKXxDRVJUSUZJQ0FURSktLS0tLS9tXG52YXIgZnVsbFJlZ2V4ID0gL14tLS0tLUJFR0lOICgoPzouKj8gS0VZKXxDRVJUSUZJQ0FURSktLS0tLShbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspLS0tLS1FTkQgXFwxLS0tLS0kL21cbnZhciBldnAgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2tleSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleSA9IG9rZXkudG9TdHJpbmcoKVxuICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZmluZFByb2MpXG4gIHZhciBkZWNyeXB0ZWRcbiAgaWYgKCFtYXRjaCkge1xuICAgIHZhciBtYXRjaDIgPSBrZXkubWF0Y2goZnVsbFJlZ2V4KVxuICAgIGRlY3J5cHRlZCA9IG5ldyBCdWZmZXIobWF0Y2gyWzJdLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKSwgJ2Jhc2U2NCcpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN1aXRlID0gJ2FlcycgKyBtYXRjaFsxXVxuICAgIHZhciBpdiA9IEJ1ZmZlci5mcm9tKG1hdGNoWzJdLCAnaGV4JylcbiAgICB2YXIgY2lwaGVyVGV4dCA9IEJ1ZmZlci5mcm9tKG1hdGNoWzNdLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKSwgJ2Jhc2U2NCcpXG4gICAgdmFyIGNpcGhlcktleSA9IGV2cChwYXNzd29yZCwgaXYuc2xpY2UoMCwgOCksIHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpLmtleVxuICAgIHZhciBvdXQgPSBbXVxuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGNpcGhlcktleSwgaXYpXG4gICAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSlcbiAgICBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KG91dClcbiAgfVxuICB2YXIgdGFnID0ga2V5Lm1hdGNoKHN0YXJ0UmVnZXgpWzFdXG4gIHJldHVybiB7XG4gICAgdGFnOiB0YWcsXG4gICAgZGF0YTogZGVjcnlwdGVkXG4gIH1cbn1cbiIsInZhciBhc24xID0gcmVxdWlyZSgnLi9hc24xJylcbnZhciBhZXNpZCA9IHJlcXVpcmUoJy4vYWVzaWQuanNvbicpXG52YXIgZml4UHJvYyA9IHJlcXVpcmUoJy4vZml4UHJvYycpXG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcbnZhciBjb21wYXQgPSByZXF1aXJlKCdwYmtkZjInKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlS2V5c1xuXG5mdW5jdGlvbiBwYXJzZUtleXMgKGJ1ZmZlcikge1xuICB2YXIgcGFzc3dvcmRcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdvYmplY3QnICYmICFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIHBhc3N3b3JkID0gYnVmZmVyLnBhc3NwaHJhc2VcbiAgICBidWZmZXIgPSBidWZmZXIua2V5XG4gIH1cbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKVxuICB9XG5cbiAgdmFyIHN0cmlwcGVkID0gZml4UHJvYyhidWZmZXIsIHBhc3N3b3JkKVxuXG4gIHZhciB0eXBlID0gc3RyaXBwZWQudGFnXG4gIHZhciBkYXRhID0gc3RyaXBwZWQuZGF0YVxuICB2YXIgc3VidHlwZSwgbmRhdGFcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnQ0VSVElGSUNBVEUnOlxuICAgICAgbmRhdGEgPSBhc24xLmNlcnRpZmljYXRlLmRlY29kZShkYXRhLCAnZGVyJykudGJzQ2VydGlmaWNhdGUuc3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICBjYXNlICdQVUJMSUMgS0VZJzpcbiAgICAgIGlmICghbmRhdGEpIHtcbiAgICAgICAgbmRhdGEgPSBhc24xLlB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICB9XG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgbmRhdGEuc3ViamVjdFByaXZhdGVLZXkgPSBuZGF0YS5zdWJqZWN0UHVibGljS2V5XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlYycsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHViX2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgc3VidHlwZSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgICBjYXNlICdFTkNSWVBURUQgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRW5jcnlwdGVkUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBkYXRhID0gZGVjcnlwdChkYXRhLCBwYXNzd29yZClcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICBjYXNlICdQUklWQVRFIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnZlOiBuZGF0YS5hbGdvcml0aG0uY3VydmUsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKS5wcml2YXRlS2V5XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wcml2X2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBwYXJhbXM6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnUlNBIFBVQkxJQyBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICBjYXNlICdSU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnRFNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICBwYXJhbXM6IGFzbjEuRFNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICB9XG4gICAgY2FzZSAnRUMgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnZlOiBkYXRhLnBhcmFtZXRlcnMudmFsdWUsXG4gICAgICAgIHByaXZhdGVLZXk6IGRhdGEucHJpdmF0ZUtleVxuICAgICAgfVxuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgfVxufVxucGFyc2VLZXlzLnNpZ25hdHVyZSA9IGFzbjEuc2lnbmF0dXJlXG5mdW5jdGlvbiBkZWNyeXB0IChkYXRhLCBwYXNzd29yZCkge1xuICB2YXIgc2FsdCA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5zYWx0XG4gIHZhciBpdGVycyA9IHBhcnNlSW50KGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5pdGVycy50b1N0cmluZygpLCAxMClcbiAgdmFyIGFsZ28gPSBhZXNpZFtkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5hbGdvLmpvaW4oJy4nKV1cbiAgdmFyIGl2ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuaXZcbiAgdmFyIGNpcGhlclRleHQgPSBkYXRhLnN1YmplY3RQcml2YXRlS2V5XG4gIHZhciBrZXlsZW4gPSBwYXJzZUludChhbGdvLnNwbGl0KCctJylbMV0sIDEwKSAvIDhcbiAgdmFyIGtleSA9IGNvbXBhdC5wYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVycywga2V5bGVuLCAnc2hhMScpXG4gIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoYWxnbywga2V5LCBpdilcbiAgdmFyIG91dCA9IFtdXG4gIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpXG4gIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG4iLCJleHBvcnRzLnBia2RmMiA9IHJlcXVpcmUoJy4vbGliL2FzeW5jJylcbmV4cG9ydHMucGJrZGYyU3luYyA9IHJlcXVpcmUoJy4vbGliL3N5bmMnKVxuIiwidmFyIGNoZWNrUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4vcHJlY29uZGl0aW9uJylcbnZhciBkZWZhdWx0RW5jb2RpbmcgPSByZXF1aXJlKCcuL2RlZmF1bHQtZW5jb2RpbmcnKVxudmFyIHN5bmMgPSByZXF1aXJlKCcuL3N5bmMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBaRVJPX0JVRlxudmFyIHN1YnRsZSA9IGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5zdWJ0bGVcbnZhciB0b0Jyb3dzZXIgPSB7XG4gICdzaGEnOiAnU0hBLTEnLFxuICAnc2hhLTEnOiAnU0hBLTEnLFxuICAnc2hhMSc6ICdTSEEtMScsXG4gICdzaGEyNTYnOiAnU0hBLTI1NicsXG4gICdzaGEtMjU2JzogJ1NIQS0yNTYnLFxuICAnc2hhMzg0JzogJ1NIQS0zODQnLFxuICAnc2hhLTM4NCc6ICdTSEEtMzg0JyxcbiAgJ3NoYS01MTInOiAnU0hBLTUxMicsXG4gICdzaGE1MTInOiAnU0hBLTUxMidcbn1cbnZhciBjaGVja3MgPSBbXVxuZnVuY3Rpb24gY2hlY2tOYXRpdmUgKGFsZ28pIHtcbiAgaWYgKGdsb2JhbC5wcm9jZXNzICYmICFnbG9iYWwucHJvY2Vzcy5icm93c2VyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgfVxuICBpZiAoIXN1YnRsZSB8fCAhc3VidGxlLmltcG9ydEtleSB8fCAhc3VidGxlLmRlcml2ZUJpdHMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICB9XG4gIGlmIChjaGVja3NbYWxnb10gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaGVja3NbYWxnb11cbiAgfVxuICBaRVJPX0JVRiA9IFpFUk9fQlVGIHx8IEJ1ZmZlci5hbGxvYyg4KVxuICB2YXIgcHJvbSA9IGJyb3dzZXJQYmtkZjIoWkVST19CVUYsIFpFUk9fQlVGLCAxMCwgMTI4LCBhbGdvKVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSlcbiAgY2hlY2tzW2FsZ29dID0gcHJvbVxuICByZXR1cm4gcHJvbVxufVxuXG5mdW5jdGlvbiBicm93c2VyUGJrZGYyIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywgbGVuZ3RoLCBhbGdvKSB7XG4gIHJldHVybiBzdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLCBwYXNzd29yZCwge25hbWU6ICdQQktERjInfSwgZmFsc2UsIFsnZGVyaXZlQml0cyddXG4gICkudGhlbihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN1YnRsZS5kZXJpdmVCaXRzKHtcbiAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgc2FsdDogc2FsdCxcbiAgICAgIGl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IGFsZ29cbiAgICAgIH1cbiAgICB9LCBrZXksIGxlbmd0aCA8PCAzKVxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZSAocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvdXQpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIG91dClcbiAgICB9KVxuICB9LCBmdW5jdGlvbiAoZSkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZSlcbiAgICB9KVxuICB9KVxufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRpZ2VzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZGlnZXN0XG4gICAgZGlnZXN0ID0gdW5kZWZpbmVkXG4gIH1cblxuICBkaWdlc3QgPSBkaWdlc3QgfHwgJ3NoYTEnXG4gIHZhciBhbGdvID0gdG9Ccm93c2VyW2RpZ2VzdC50b0xvd2VyQ2FzZSgpXVxuXG4gIGlmICghYWxnbyB8fCB0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3V0XG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBzeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBvdXQpXG4gICAgfSlcbiAgfVxuXG4gIGNoZWNrUGFyYW1ldGVycyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuKVxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNhbGxiYWNrIHByb3ZpZGVkIHRvIHBia2RmMicpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZCwgZGVmYXVsdEVuY29kaW5nKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IEJ1ZmZlci5mcm9tKHNhbHQsIGRlZmF1bHRFbmNvZGluZylcblxuICByZXNvbHZlUHJvbWlzZShjaGVja05hdGl2ZShhbGdvKS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgaWYgKHJlc3ApIHJldHVybiBicm93c2VyUGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pXG5cbiAgICByZXR1cm4gc3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpXG4gIH0pLCBjYWxsYmFjaylcbn1cbiIsInZhciBkZWZhdWx0RW5jb2Rpbmdcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gIGRlZmF1bHRFbmNvZGluZyA9ICd1dGYtOCdcbn0gZWxzZSB7XG4gIHZhciBwVmVyc2lvbk1ham9yID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJylbMF0uc2xpY2UoMSksIDEwKVxuXG4gIGRlZmF1bHRFbmNvZGluZyA9IHBWZXJzaW9uTWFqb3IgPj0gNiA/ICd1dGYtOCcgOiAnYmluYXJ5J1xufVxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0RW5jb2RpbmdcbiIsInZhciBNQVhfQUxMT0MgPSBNYXRoLnBvdygyLCAzMCkgLSAxIC8vIGRlZmF1bHQgaW4gaW9qc1xuXG5mdW5jdGlvbiBjaGVja0J1ZmZlciAoYnVmLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgYnVmICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWUgKyAnIG11c3QgYmUgYSBidWZmZXIgb3Igc3RyaW5nJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuKSB7XG4gIGNoZWNrQnVmZmVyKHBhc3N3b3JkLCAnUGFzc3dvcmQnKVxuICBjaGVja0J1ZmZlcihzYWx0LCAnU2FsdCcpXG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdGlvbnMgbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpdGVyYXRpb25zIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBpdGVyYXRpb25zJylcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5bGVuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBsZW5ndGggbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChrZXlsZW4gPCAwIHx8IGtleWxlbiA+IE1BWF9BTExPQyB8fCBrZXlsZW4gIT09IGtleWxlbikgeyAvKiBlc2xpbnQgbm8tc2VsZi1jb21wYXJlOiAwICovXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGtleSBsZW5ndGgnKVxuICB9XG59XG4iLCJ2YXIgbWQ1ID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvbWQ1JylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBjaGVja1BhcmFtZXRlcnMgPSByZXF1aXJlKCcuL3ByZWNvbmRpdGlvbicpXG52YXIgZGVmYXVsdEVuY29kaW5nID0gcmVxdWlyZSgnLi9kZWZhdWx0LWVuY29kaW5nJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcbnZhciBzaXplcyA9IHtcbiAgbWQ1OiAxNixcbiAgc2hhMTogMjAsXG4gIHNoYTIyNDogMjgsXG4gIHNoYTI1NjogMzIsXG4gIHNoYTM4NDogNDgsXG4gIHNoYTUxMjogNjQsXG4gIHJtZDE2MDogMjAsXG4gIHJpcGVtZDE2MDogMjBcbn1cblxuZnVuY3Rpb24gSG1hYyAoYWxnLCBrZXksIHNhbHRMZW4pIHtcbiAgdmFyIGhhc2ggPSBnZXREaWdlc3QoYWxnKVxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gaGFzaChrZXkpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUgKyBzaXplc1thbGddKVxuICB2YXIgb3BhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUgKyBzaXplc1thbGddKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdmFyIGlwYWQxID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNhbHRMZW4gKyA0KVxuICBpcGFkLmNvcHkoaXBhZDEsIDAsIDAsIGJsb2Nrc2l6ZSlcbiAgdGhpcy5pcGFkMSA9IGlwYWQxXG4gIHRoaXMuaXBhZDIgPSBpcGFkXG4gIHRoaXMub3BhZCA9IG9wYWRcbiAgdGhpcy5hbGcgPSBhbGdcbiAgdGhpcy5ibG9ja3NpemUgPSBibG9ja3NpemVcbiAgdGhpcy5oYXNoID0gaGFzaFxuICB0aGlzLnNpemUgPSBzaXplc1thbGddXG59XG5cbkhtYWMucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChkYXRhLCBpcGFkKSB7XG4gIGRhdGEuY29weShpcGFkLCB0aGlzLmJsb2Nrc2l6ZSlcbiAgdmFyIGggPSB0aGlzLmhhc2goaXBhZClcbiAgaC5jb3B5KHRoaXMub3BhZCwgdGhpcy5ibG9ja3NpemUpXG4gIHJldHVybiB0aGlzLmhhc2godGhpcy5vcGFkKVxufVxuXG5mdW5jdGlvbiBnZXREaWdlc3QgKGFsZykge1xuICBmdW5jdGlvbiBzaGFGdW5jIChkYXRhKSB7XG4gICAgcmV0dXJuIHNoYShhbGcpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICB9XG4gIGZ1bmN0aW9uIHJtZDE2MEZ1bmMgKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICB9XG5cbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIHJtZDE2MEZ1bmNcbiAgaWYgKGFsZyA9PT0gJ21kNScpIHJldHVybiBtZDVcbiAgcmV0dXJuIHNoYUZ1bmNcbn1cblxuZnVuY3Rpb24gcGJrZGYyIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpIHtcbiAgY2hlY2tQYXJhbWV0ZXJzKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCBkZWZhdWx0RW5jb2RpbmcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIGRpZ2VzdCA9IGRpZ2VzdCB8fCAnc2hhMSdcblxuICB2YXIgaG1hYyA9IG5ldyBIbWFjKGRpZ2VzdCwgcGFzc3dvcmQsIHNhbHQubGVuZ3RoKVxuXG4gIHZhciBESyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShrZXlsZW4pXG4gIHZhciBibG9jazEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2FsdC5sZW5ndGggKyA0KVxuICBzYWx0LmNvcHkoYmxvY2sxLCAwLCAwLCBzYWx0Lmxlbmd0aClcblxuICB2YXIgZGVzdFBvcyA9IDBcbiAgdmFyIGhMZW4gPSBzaXplc1tkaWdlc3RdXG4gIHZhciBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pXG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbDsgaSsrKSB7XG4gICAgYmxvY2sxLndyaXRlVUludDMyQkUoaSwgc2FsdC5sZW5ndGgpXG5cbiAgICB2YXIgVCA9IGhtYWMucnVuKGJsb2NrMSwgaG1hYy5pcGFkMSlcbiAgICB2YXIgVSA9IFRcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICBVID0gaG1hYy5ydW4oVSwgaG1hYy5pcGFkMilcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaExlbjsgaysrKSBUW2tdIF49IFVba11cbiAgICB9XG5cbiAgICBULmNvcHkoREssIGRlc3RQb3MpXG4gICAgZGVzdFBvcyArPSBoTGVuXG4gIH1cblxuICByZXR1cm4gREtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYmtkZjJcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsImV4cG9ydHMucHVibGljRW5jcnlwdCA9IHJlcXVpcmUoJy4vcHVibGljRW5jcnlwdCcpXG5leHBvcnRzLnByaXZhdGVEZWNyeXB0ID0gcmVxdWlyZSgnLi9wcml2YXRlRGVjcnlwdCcpXG5cbmV4cG9ydHMucHJpdmF0ZUVuY3J5cHQgPSBmdW5jdGlvbiBwcml2YXRlRW5jcnlwdCAoa2V5LCBidWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljRW5jcnlwdChrZXksIGJ1ZiwgdHJ1ZSlcbn1cblxuZXhwb3J0cy5wdWJsaWNEZWNyeXB0ID0gZnVuY3Rpb24gcHVibGljRGVjcnlwdCAoa2V5LCBidWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHJpdmF0ZURlY3J5cHQoa2V5LCBidWYsIHRydWUpXG59XG4iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWVkLCBsZW4pIHtcbiAgdmFyIHQgPSBCdWZmZXIuYWxsb2MoMClcbiAgdmFyIGkgPSAwXG4gIHZhciBjXG4gIHdoaWxlICh0Lmxlbmd0aCA8IGxlbikge1xuICAgIGMgPSBpMm9wcyhpKyspXG4gICAgdCA9IEJ1ZmZlci5jb25jYXQoW3QsIGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc2VlZCkudXBkYXRlKGMpLmRpZ2VzdCgpXSlcbiAgfVxuICByZXR1cm4gdC5zbGljZSgwLCBsZW4pXG59XG5cbmZ1bmN0aW9uIGkyb3BzIChjKSB7XG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgb3V0LndyaXRlVUludDMyQkUoYywgMClcbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKVxudmFyIG1nZiA9IHJlcXVpcmUoJy4vbWdmJylcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgd2l0aFB1YmxpYyA9IHJlcXVpcmUoJy4vd2l0aFB1YmxpYycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcml2YXRlRGVjcnlwdCAocHJpdmF0ZUtleSwgZW5jLCByZXZlcnNlKSB7XG4gIHZhciBwYWRkaW5nXG4gIGlmIChwcml2YXRlS2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHJpdmF0ZUtleS5wYWRkaW5nXG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxXG4gIH0gZWxzZSB7XG4gICAgcGFkZGluZyA9IDRcbiAgfVxuXG4gIHZhciBrZXkgPSBwYXJzZUtleXMocHJpdmF0ZUtleSlcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgaWYgKGVuYy5sZW5ndGggPiBrIHx8IG5ldyBCTihlbmMpLmNtcChrZXkubW9kdWx1cykgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgdmFyIG1zZ1xuICBpZiAocmV2ZXJzZSkge1xuICAgIG1zZyA9IHdpdGhQdWJsaWMobmV3IEJOKGVuYyksIGtleSlcbiAgfSBlbHNlIHtcbiAgICBtc2cgPSBjcnQoZW5jLCBrZXkpXG4gIH1cbiAgdmFyIHpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoayAtIG1zZy5sZW5ndGgpXG4gIG1zZyA9IEJ1ZmZlci5jb25jYXQoW3pCdWZmZXIsIG1zZ10sIGspXG4gIGlmIChwYWRkaW5nID09PSA0KSB7XG4gICAgcmV0dXJuIG9hZXAoa2V5LCBtc2cpXG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHJldHVybiBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSlcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAzKSB7XG4gICAgcmV0dXJuIG1zZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBwYWRkaW5nJylcbiAgfVxufVxuXG5mdW5jdGlvbiBvYWVwIChrZXksIG1zZykge1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgaUhhc2ggPSBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKEJ1ZmZlci5hbGxvYygwKSkuZGlnZXN0KClcbiAgdmFyIGhMZW4gPSBpSGFzaC5sZW5ndGhcbiAgaWYgKG1zZ1swXSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgdmFyIG1hc2tlZFNlZWQgPSBtc2cuc2xpY2UoMSwgaExlbiArIDEpXG4gIHZhciBtYXNrZWREYiA9IG1zZy5zbGljZShoTGVuICsgMSlcbiAgdmFyIHNlZWQgPSB4b3IobWFza2VkU2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSlcbiAgdmFyIGRiID0geG9yKG1hc2tlZERiLCBtZ2Yoc2VlZCwgayAtIGhMZW4gLSAxKSlcbiAgaWYgKGNvbXBhcmUoaUhhc2gsIGRiLnNsaWNlKDAsIGhMZW4pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgdmFyIGkgPSBoTGVuXG4gIHdoaWxlIChkYltpXSA9PT0gMCkge1xuICAgIGkrK1xuICB9XG4gIGlmIChkYltpKytdICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICByZXR1cm4gZGIuc2xpY2UoaSlcbn1cblxuZnVuY3Rpb24gcGtjczEgKGtleSwgbXNnLCByZXZlcnNlKSB7XG4gIHZhciBwMSA9IG1zZy5zbGljZSgwLCAyKVxuICB2YXIgaSA9IDJcbiAgdmFyIHN0YXR1cyA9IDBcbiAgd2hpbGUgKG1zZ1tpKytdICE9PSAwKSB7XG4gICAgaWYgKGkgPj0gbXNnLmxlbmd0aCkge1xuICAgICAgc3RhdHVzKytcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHZhciBwcyA9IG1zZy5zbGljZSgyLCBpIC0gMSlcblxuICBpZiAoKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDInICYmICFyZXZlcnNlKSB8fCAocDEudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAwMScgJiYgcmV2ZXJzZSkpIHtcbiAgICBzdGF0dXMrK1xuICB9XG4gIGlmIChwcy5sZW5ndGggPCA4KSB7XG4gICAgc3RhdHVzKytcbiAgfVxuICBpZiAoc3RhdHVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICByZXR1cm4gbXNnLnNsaWNlKGkpXG59XG5mdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGEgPSBCdWZmZXIuZnJvbShhKVxuICBiID0gQnVmZmVyLmZyb20oYilcbiAgdmFyIGRpZiA9IDBcbiAgdmFyIGxlbiA9IGEubGVuZ3RoXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICBkaWYrK1xuICAgIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgfVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBkaWYgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG4gIHJldHVybiBkaWZcbn1cbiIsInZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIG1nZiA9IHJlcXVpcmUoJy4vbWdmJylcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgd2l0aFB1YmxpYyA9IHJlcXVpcmUoJy4vd2l0aFB1YmxpYycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHVibGljRW5jcnlwdCAocHVibGljS2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmdcbiAgaWYgKHB1YmxpY0tleS5wYWRkaW5nKSB7XG4gICAgcGFkZGluZyA9IHB1YmxpY0tleS5wYWRkaW5nXG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxXG4gIH0gZWxzZSB7XG4gICAgcGFkZGluZyA9IDRcbiAgfVxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHB1YmxpY0tleSlcbiAgdmFyIHBhZGRlZE1zZ1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHBhZGRlZE1zZyA9IG9hZXAoa2V5LCBtc2cpXG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHBhZGRlZE1zZyA9IHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKVxuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDMpIHtcbiAgICBwYWRkZWRNc2cgPSBuZXcgQk4obXNnKVxuICAgIGlmIChwYWRkZWRNc2cuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgdG9vIGxvbmcgZm9yIG1vZHVsdXMnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGFkZGluZycpXG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICByZXR1cm4gY3J0KHBhZGRlZE1zZywga2V5KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aXRoUHVibGljKHBhZGRlZE1zZywga2V5KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9hZXAgKGtleSwgbXNnKSB7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aFxuICB2YXIgaUhhc2ggPSBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKEJ1ZmZlci5hbGxvYygwKSkuZGlnZXN0KClcbiAgdmFyIGhMZW4gPSBpSGFzaC5sZW5ndGhcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW5cbiAgaWYgKG1MZW4gPiBrIC0gaExlbjIgLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlIHRvbyBsb25nJylcbiAgfVxuICB2YXIgcHMgPSBCdWZmZXIuYWxsb2MoayAtIG1MZW4gLSBoTGVuMiAtIDIpXG4gIHZhciBkYmxlbiA9IGsgLSBoTGVuIC0gMVxuICB2YXIgc2VlZCA9IHJhbmRvbUJ5dGVzKGhMZW4pXG4gIHZhciBtYXNrZWREYiA9IHhvcihCdWZmZXIuY29uY2F0KFtpSGFzaCwgcHMsIEJ1ZmZlci5hbGxvYygxLCAxKSwgbXNnXSwgZGJsZW4pLCBtZ2Yoc2VlZCwgZGJsZW4pKVxuICB2YXIgbWFza2VkU2VlZCA9IHhvcihzZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKVxuICByZXR1cm4gbmV3IEJOKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5hbGxvYygxKSwgbWFza2VkU2VlZCwgbWFza2VkRGJdLCBrKSlcbn1cbmZ1bmN0aW9uIHBrY3MxIChrZXksIG1zZywgcmV2ZXJzZSkge1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGhcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgaWYgKG1MZW4gPiBrIC0gMTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKVxuICB9XG4gIHZhciBwc1xuICBpZiAocmV2ZXJzZSkge1xuICAgIHBzID0gQnVmZmVyLmFsbG9jKGsgLSBtTGVuIC0gMywgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBwcyA9IG5vblplcm8oayAtIG1MZW4gLSAzKVxuICB9XG4gIHJldHVybiBuZXcgQk4oQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzAsIHJldmVyc2UgPyAxIDogMl0pLCBwcywgQnVmZmVyLmFsbG9jKDEpLCBtc2ddLCBrKSlcbn1cbmZ1bmN0aW9uIG5vblplcm8gKGxlbikge1xuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcbiAgdmFyIGkgPSAwXG4gIHZhciBjYWNoZSA9IHJhbmRvbUJ5dGVzKGxlbiAqIDIpXG4gIHZhciBjdXIgPSAwXG4gIHZhciBudW1cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoY3VyID09PSBjYWNoZS5sZW5ndGgpIHtcbiAgICAgIGNhY2hlID0gcmFuZG9tQnl0ZXMobGVuICogMilcbiAgICAgIGN1ciA9IDBcbiAgICB9XG4gICAgbnVtID0gY2FjaGVbY3VyKytdXG4gICAgaWYgKG51bSkge1xuICAgICAgb3V0W2krK10gPSBudW1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIHdpdGhQdWJsaWMgKHBhZGRlZE1zZywga2V5KSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShwYWRkZWRNc2dcbiAgICAudG9SZWQoQk4ubW9udChrZXkubW9kdWx1cykpXG4gICAgLnJlZFBvdyhuZXcgQk4oa2V5LnB1YmxpY0V4cG9uZW50KSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLnRvQXJyYXkoKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoUHVibGljXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvciAoYSwgYikge1xuICB2YXIgbGVuID0gYS5sZW5ndGhcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYVtpXSBePSBiW2ldXG4gIH1cbiAgcmV0dXJuIGFcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbWljcm90YXNrKCkge1xuICAgIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIG5vZGVfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgdmFyIHF1ZXVlXzEgPSBbXTtcbiAgICAgICAgdmFyIGlfMSA9IDA7XG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZV8xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlXzEuc2hpZnQoKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5vYnNlcnZlKG5vZGVfMSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZV8xLnB1c2goZm4pO1xuICAgICAgICAgICAgbm9kZV8xLmRhdGEgPSBpXzEgPSAxIC0gaV8xO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2s7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBtaWNyb3Rhc2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCdcblxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlc1xudmFyIE1BWF9CWVRFUyA9IDY1NTM2XG5cbi8vIE5vZGUgc3VwcG9ydHMgcmVxdWVzdGluZyB1cCB0byB0aGlzIG51bWJlciBvZiBieXRlc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9jcnlwdG8vcmFuZG9tLmpzI0w0OFxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG5cbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XG4gIC8vIHBoYW50b21qcyBuZWVkcyB0byB0aHJvd1xuICBpZiAoc2l6ZSA+IE1BWF9VSU5UMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBpZiAoc2l6ZSA+IE1BWF9CWVRFUykgeyAvLyB0aGlzIGlzIHRoZSBtYXggYnl0ZXMgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgLy8gY2FuIGRvIGF0IG9uY2Ugc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xuICAgICAgICAvLyBidWZmZXIuc2xpY2UgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIGVuZCBpcyBwYXN0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBzbyB3ZSBkb24ndCBoYXZlIHRvIGhlcmVcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyXFxudXNlIGNocm9tZSwgRmlyZUZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG52YXIgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJylcbnZhciByYW5kb21ieXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcbnZhciBCdWZmZXIgPSBzYWZlQnVmZmVyLkJ1ZmZlclxudmFyIGtCdWZmZXJNYXhMZW5ndGggPSBzYWZlQnVmZmVyLmtNYXhMZW5ndGhcbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xudmFyIGtNYXhVaW50MzIgPSBNYXRoLnBvdygyLCAzMikgLSAxXG5mdW5jdGlvbiBhc3NlcnRPZmZzZXQgKG9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgIT09IG9mZnNldCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29mZnNldCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPiBrTWF4VWludDMyIHx8IG9mZnNldCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvZmZzZXQgbXVzdCBiZSBhIHVpbnQzMicpXG4gIH1cblxuICBpZiAob2Zmc2V0ID4ga0J1ZmZlck1heExlbmd0aCB8fCBvZmZzZXQgPiBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IG91dCBvZiByYW5nZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJyB8fCBzaXplICE9PSBzaXplKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChzaXplID4ga01heFVpbnQzMiB8fCBzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIHVpbnQzMicpXG4gIH1cblxuICBpZiAoc2l6ZSArIG9mZnNldCA+IGxlbmd0aCB8fCBzaXplID4ga0J1ZmZlck1heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdidWZmZXIgdG9vIHNtYWxsJylcbiAgfVxufVxuaWYgKChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykgfHwgIXByb2Nlc3MuYnJvd3Nlcikge1xuICBleHBvcnRzLnJhbmRvbUZpbGwgPSByYW5kb21GaWxsXG4gIGV4cG9ydHMucmFuZG9tRmlsbFN5bmMgPSByYW5kb21GaWxsU3luY1xufSBlbHNlIHtcbiAgZXhwb3J0cy5yYW5kb21GaWxsID0gb2xkQnJvd3NlclxuICBleHBvcnRzLnJhbmRvbUZpbGxTeW5jID0gb2xkQnJvd3NlclxufVxuZnVuY3Rpb24gcmFuZG9tRmlsbCAoYnVmLCBvZmZzZXQsIHNpemUsIGNiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikgJiYgIShidWYgaW5zdGFuY2VvZiBnbG9iYWwuVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZlwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgb3IgVWludDhBcnJheScpXG4gIH1cblxuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gMFxuICAgIHNpemUgPSBidWYubGVuZ3RoXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IHNpemVcbiAgICBzaXplID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICB9IGVsc2UgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2JcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG4gIGFzc2VydE9mZnNldChvZmZzZXQsIGJ1Zi5sZW5ndGgpXG4gIGFzc2VydFNpemUoc2l6ZSwgb2Zmc2V0LCBidWYubGVuZ3RoKVxuICByZXR1cm4gYWN0dWFsRmlsbChidWYsIG9mZnNldCwgc2l6ZSwgY2IpXG59XG5cbmZ1bmN0aW9uIGFjdHVhbEZpbGwgKGJ1Ziwgb2Zmc2V0LCBzaXplLCBjYikge1xuICBpZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gICAgdmFyIG91ckJ1ZiA9IGJ1Zi5idWZmZXJcbiAgICB2YXIgdWludCA9IG5ldyBVaW50OEFycmF5KG91ckJ1Ziwgb2Zmc2V0LCBzaXplKVxuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModWludClcbiAgICBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYihudWxsLCBidWYpXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfVxuICBpZiAoY2IpIHtcbiAgICByYW5kb21ieXRlcyhzaXplLCBmdW5jdGlvbiAoZXJyLCBieXRlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgICAgYnl0ZXMuY29weShidWYsIG9mZnNldClcbiAgICAgIGNiKG51bGwsIGJ1ZilcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIHZhciBieXRlcyA9IHJhbmRvbWJ5dGVzKHNpemUpXG4gIGJ5dGVzLmNvcHkoYnVmLCBvZmZzZXQpXG4gIHJldHVybiBidWZcbn1cbmZ1bmN0aW9uIHJhbmRvbUZpbGxTeW5jIChidWYsIG9mZnNldCwgc2l6ZSkge1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvZmZzZXQgPSAwXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSAmJiAhKGJ1ZiBpbnN0YW5jZW9mIGdsb2JhbC5VaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBvciBVaW50OEFycmF5JylcbiAgfVxuXG4gIGFzc2VydE9mZnNldChvZmZzZXQsIGJ1Zi5sZW5ndGgpXG5cbiAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkgc2l6ZSA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcblxuICBhc3NlcnRTaXplKHNpemUsIG9mZnNldCwgYnVmLmxlbmd0aClcblxuICByZXR1cm4gYWN0dWFsRmlsbChidWYsIG9mZnNldCwgc2l6ZSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaEJhc2UgPSByZXF1aXJlKCdoYXNoLWJhc2UnKVxuXG52YXIgQVJSQVkxNiA9IG5ldyBBcnJheSgxNilcblxudmFyIHpsID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dXG5cbnZhciB6ciA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXVxuXG52YXIgc2wgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dXG5cbnZhciBzciA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl1cblxudmFyIGhsID0gWzB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGVdXG52YXIgaHIgPSBbMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMF1cblxuZnVuY3Rpb24gUklQRU1EMTYwICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxufVxuXG5pbmhlcml0cyhSSVBFTUQxNjAsIEhhc2hCYXNlKVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3b3JkcyA9IEFSUkFZMTZcbiAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB3b3Jkc1tqXSA9IHRoaXMuX2Jsb2NrLnJlYWRJbnQzMkxFKGogKiA0KVxuXG4gIHZhciBhbCA9IHRoaXMuX2EgfCAwXG4gIHZhciBibCA9IHRoaXMuX2IgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2MgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2UgfCAwXG5cbiAgdmFyIGFyID0gdGhpcy5fYSB8IDBcbiAgdmFyIGJyID0gdGhpcy5fYiB8IDBcbiAgdmFyIGNyID0gdGhpcy5fYyB8IDBcbiAgdmFyIGRyID0gdGhpcy5fZCB8IDBcbiAgdmFyIGVyID0gdGhpcy5fZSB8IDBcblxuICAvLyBjb21wdXRhdGlvblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICB2YXIgdGxcbiAgICB2YXIgdHJcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0bCA9IGZuMShhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMF0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjUoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzBdLCBzcltpXSlcbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdGwgPSBmbjIoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzFdLCBzbFtpXSlcbiAgICAgIHRyID0gZm40KGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclsxXSwgc3JbaV0pXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHRsID0gZm4zKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFsyXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuMyhhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMl0sIHNyW2ldKVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0bCA9IGZuNChhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbM10sIHNsW2ldKVxuICAgICAgdHIgPSBmbjIoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzNdLCBzcltpXSlcbiAgICB9IGVsc2UgeyAvLyBpZiAoaTw4MCkge1xuICAgICAgdGwgPSBmbjUoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzRdLCBzbFtpXSlcbiAgICAgIHRyID0gZm4xKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBocls0XSwgc3JbaV0pXG4gICAgfVxuXG4gICAgYWwgPSBlbFxuICAgIGVsID0gZGxcbiAgICBkbCA9IHJvdGwoY2wsIDEwKVxuICAgIGNsID0gYmxcbiAgICBibCA9IHRsXG5cbiAgICBhciA9IGVyXG4gICAgZXIgPSBkclxuICAgIGRyID0gcm90bChjciwgMTApXG4gICAgY3IgPSBiclxuICAgIGJyID0gdHJcbiAgfVxuXG4gIC8vIHVwZGF0ZSBzdGF0ZVxuICB2YXIgdCA9ICh0aGlzLl9iICsgY2wgKyBkcikgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYyArIGRsICsgZXIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2QgKyBlbCArIGFyKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9lICsgYWwgKyBicikgfCAwXG4gIHRoaXMuX2UgPSAodGhpcy5fYSArIGJsICsgY3IpIHwgMFxuICB0aGlzLl9hID0gdFxufVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gMHg4MFxuICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPiA1Nikge1xuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cblxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFsxXSwgNjApXG4gIHRoaXMuX3VwZGF0ZSgpXG5cbiAgLy8gcHJvZHVjZSByZXN1bHRcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyA/IEJ1ZmZlci5hbGxvYygyMCkgOiBuZXcgQnVmZmVyKDIwKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9jLCA4KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2UsIDE2KVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBmbjEgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiBjIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjIgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgYykgfCAoKH5iKSAmIGQpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuMyAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgfCAofmMpKSBeIGQpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm40IChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGQpIHwgKGMgJiAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjUgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiAoYyB8ICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUklQRU1EMTYwXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuX2Jsb2NrU2l6ZVxuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgdmFyIGFjY3VtID0gdGhpcy5fbGVuXG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOykge1xuICAgIHZhciBhc3NpZ25lZCA9IGFjY3VtICUgYmxvY2tTaXplXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGgubWluKGxlbmd0aCAtIG9mZnNldCwgYmxvY2tTaXplIC0gYXNzaWduZWQpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmRlcjsgaSsrKSB7XG4gICAgICBibG9ja1thc3NpZ25lZCArIGldID0gZGF0YVtvZmZzZXQgKyBpXVxuICAgIH1cblxuICAgIGFjY3VtICs9IHJlbWFpbmRlclxuICAgIG9mZnNldCArPSByZW1haW5kZXJcblxuICAgIGlmICgoYWNjdW0gJSBibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYmxvY2spXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fbGVuICs9IGxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciByZW0gPSB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVcblxuICB0aGlzLl9ibG9ja1tyZW1dID0gMHg4MFxuXG4gIC8vIHplcm8gKHJlbSArIDEpIHRyYWlsaW5nIGJpdHMsIHdoZXJlIChyZW0gKyAxKSBpcyB0aGUgc21hbGxlc3RcbiAgLy8gbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobGVuZ3RoICsgMSArIChyZW0gKyAxKSkgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgcmVtICsgMSlcblxuICBpZiAocmVtID49IHRoaXMuX2ZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICB2YXIgYml0cyA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyB1aW50MzJcbiAgaWYgKGJpdHMgPD0gMHhmZmZmZmZmZikge1xuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoYml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICAvLyB1aW50NjRcbiAgfSBlbHNlIHtcbiAgICB2YXIgbG93Qml0cyA9IChiaXRzICYgMHhmZmZmZmZmZikgPj4+IDBcbiAgICB2YXIgaGlnaEJpdHMgPSAoYml0cyAtIGxvd0JpdHMpIC8gMHgxMDAwMDAwMDBcblxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoaGlnaEJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDgpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShsb3dCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyMjQgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyMjQsIFNoYTI1NilcblxuU2hhMjI0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjMTA1OWVkOFxuICB0aGlzLl9iID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nID0gMHg2NGY5OGZhN1xuICB0aGlzLl9oID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBjaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAyIHwgeCA8PCAzMCkgXiAoeCA+Pj4gMTMgfCB4IDw8IDE5KSBeICh4ID4+PiAyMiB8IHggPDwgMTApXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxufVxuXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA3IHwgeCA8PCAyNSkgXiAoeCA+Pj4gMTggfCB4IDw8IDE0KSBeICh4ID4+PiAzKVxufVxuXG5mdW5jdGlvbiBnYW1tYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAxNyB8IHggPDwgMTUpIF4gKHggPj4+IDE5IHwgeCA8PCAxMykgXiAoeCA+Pj4gMTApXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgKytqKSB7XG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcbiAgICB2YXIgVDIgPSAoc2lnbWEwKGEpICsgbWFqKGEsIGIsIGMpKSB8IDBcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSAoZCArIFQxKSB8IDBcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gKFQxICsgVDIpIHwgMFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZ2gsIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNlbGVjdG9yUGFyc2VyXzEgPSByZXF1aXJlKCcuL3NlbGVjdG9yUGFyc2VyJyk7XG5mdW5jdGlvbiBjbGFzc05hbWVGcm9tVk5vZGUodk5vZGUpIHtcbiAgICB2YXIgX2EgPSBzZWxlY3RvclBhcnNlcl8xLnNlbGVjdG9yUGFyc2VyKHZOb2RlKS5jbGFzc05hbWUsIGNuID0gX2EgPT09IHZvaWQgMCA/ICcnIDogX2E7XG4gICAgaWYgKCF2Tm9kZS5kYXRhKSB7XG4gICAgICAgIHJldHVybiBjbjtcbiAgICB9XG4gICAgdmFyIF9iID0gdk5vZGUuZGF0YSwgZGF0YUNsYXNzID0gX2IuY2xhc3MsIHByb3BzID0gX2IucHJvcHM7XG4gICAgaWYgKGRhdGFDbGFzcykge1xuICAgICAgICB2YXIgYyA9IE9iamVjdC5rZXlzKGRhdGFDbGFzcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNsKSB7IHJldHVybiBkYXRhQ2xhc3NbY2xdOyB9KTtcbiAgICAgICAgY24gKz0gXCIgXCIgKyBjLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgcHJvcHMuY2xhc3NOYW1lKSB7XG4gICAgICAgIGNuICs9IFwiIFwiICsgcHJvcHMuY2xhc3NOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY24gJiYgY24udHJpbSgpO1xufVxuZXhwb3J0cy5jbGFzc05hbWVGcm9tVk5vZGUgPSBjbGFzc05hbWVGcm9tVk5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFzc05hbWVGcm9tVk5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjdXJyeTIoc2VsZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGVjdG9yKHNlbCwgdk5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBzZWxlY3Q7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoX3ZOb2RlKSB7IHJldHVybiBzZWxlY3Qoc2VsLCBfdk5vZGUpOyB9O1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHNlbGVjdChzZWwsIHZOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmN1cnJ5MiA9IGN1cnJ5Mjtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnJ5Mi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBxdWVyeV8xID0gcmVxdWlyZSgnLi9xdWVyeScpO1xudmFyIHBhcmVudF9zeW1ib2xfMSA9IHJlcXVpcmUoJy4vcGFyZW50LXN5bWJvbCcpO1xuZnVuY3Rpb24gZmluZE1hdGNoZXMoY3NzU2VsZWN0b3IsIHZOb2RlKSB7XG4gICAgaWYgKCF2Tm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRyYXZlcnNlVk5vZGUodk5vZGUsIGFkZFBhcmVudCk7IC8vIGFkZCBtYXBwaW5nIHRvIHRoZSBwYXJlbnQgc2VsZWN0b3JQYXJzZXJcbiAgICByZXR1cm4gcXVlcnlfMS5xdWVyeVNlbGVjdG9yKGNzc1NlbGVjdG9yLCB2Tm9kZSk7XG59XG5leHBvcnRzLmZpbmRNYXRjaGVzID0gZmluZE1hdGNoZXM7XG5mdW5jdGlvbiB0cmF2ZXJzZVZOb2RlKHZOb2RlLCBmKSB7XG4gICAgZnVuY3Rpb24gcmVjdXJzZShjdXJyZW50Tm9kZSwgaXNQYXJlbnQsIHBhcmVudFZOb2RlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBjdXJyZW50Tm9kZS5jaGlsZHJlbiAmJiBjdXJyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW5baV0gJiYgdHlwZW9mIGNoaWxkcmVuW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHJlY3Vyc2UoY2hpbGQsIGZhbHNlLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZihjdXJyZW50Tm9kZSwgaXNQYXJlbnQsIGlzUGFyZW50ID8gdm9pZCAwIDogcGFyZW50Vk5vZGUpO1xuICAgIH1cbiAgICByZWN1cnNlKHZOb2RlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFkZFBhcmVudCh2Tm9kZSwgaXNQYXJlbnQsIHBhcmVudCkge1xuICAgIGlmIChpc1BhcmVudCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIXZOb2RlLmRhdGEpIHtcbiAgICAgICAgdk5vZGUuZGF0YSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIXZOb2RlLmRhdGFbcGFyZW50X3N5bWJvbF8xLmRlZmF1bHRdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2Tm9kZS5kYXRhLCBwYXJlbnRfc3ltYm9sXzEuZGVmYXVsdCwge1xuICAgICAgICAgICAgdmFsdWU6IHBhcmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZE1hdGNoZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY3VycnkyXzEgPSByZXF1aXJlKCcuL2N1cnJ5MicpO1xudmFyIGZpbmRNYXRjaGVzXzEgPSByZXF1aXJlKCcuL2ZpbmRNYXRjaGVzJyk7XG5leHBvcnRzLnNlbGVjdCA9IGN1cnJ5Ml8xLmN1cnJ5MihmaW5kTWF0Y2hlc18xLmZpbmRNYXRjaGVzKTtcbnZhciBzZWxlY3RvclBhcnNlcl8xID0gcmVxdWlyZSgnLi9zZWxlY3RvclBhcnNlcicpO1xuZXhwb3J0cy5zZWxlY3RvclBhcnNlciA9IHNlbGVjdG9yUGFyc2VyXzEuc2VsZWN0b3JQYXJzZXI7XG52YXIgY2xhc3NOYW1lRnJvbVZOb2RlXzEgPSByZXF1aXJlKCcuL2NsYXNzTmFtZUZyb21WTm9kZScpO1xuZXhwb3J0cy5jbGFzc05hbWVGcm9tVk5vZGUgPSBjbGFzc05hbWVGcm9tVk5vZGVfMS5jbGFzc05hbWVGcm9tVk5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290O1xuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJvb3QgPSBzZWxmO1xufVxuZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByb290ID0gd2luZG93O1xufVxuZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByb290ID0gZ2xvYmFsO1xufVxuZWxzZSB7XG4gICAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG52YXIgcGFyZW50U3ltYm9sO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwYXJlbnRTeW1ib2wgPSBTeW1ib2woJ3BhcmVudCcpO1xufVxuZWxzZSB7XG4gICAgcGFyZW50U3ltYm9sID0gJ0BAc25hYmJkb20tc2VsZWN0b3ItcGFyZW50Jztcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBhcmVudFN5bWJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmVudC1zeW1ib2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdHJlZV9zZWxlY3Rvcl8xID0gcmVxdWlyZSgndHJlZS1zZWxlY3RvcicpO1xudmFyIHNlbGVjdG9yUGFyc2VyXzEgPSByZXF1aXJlKCcuL3NlbGVjdG9yUGFyc2VyJyk7XG52YXIgY2xhc3NOYW1lRnJvbVZOb2RlXzEgPSByZXF1aXJlKCcuL2NsYXNzTmFtZUZyb21WTm9kZScpO1xudmFyIHBhcmVudF9zeW1ib2xfMSA9IHJlcXVpcmUoJy4vcGFyZW50LXN5bWJvbCcpO1xudmFyIG9wdGlvbnMgPSB7XG4gICAgdGFnOiBmdW5jdGlvbiAodk5vZGUpIHsgcmV0dXJuIHNlbGVjdG9yUGFyc2VyXzEuc2VsZWN0b3JQYXJzZXIodk5vZGUpLnRhZ05hbWU7IH0sXG4gICAgY2xhc3NOYW1lOiBmdW5jdGlvbiAodk5vZGUpIHsgcmV0dXJuIGNsYXNzTmFtZUZyb21WTm9kZV8xLmNsYXNzTmFtZUZyb21WTm9kZSh2Tm9kZSk7IH0sXG4gICAgaWQ6IGZ1bmN0aW9uICh2Tm9kZSkgeyByZXR1cm4gc2VsZWN0b3JQYXJzZXJfMS5zZWxlY3RvclBhcnNlcih2Tm9kZSkuaWQgfHwgJyc7IH0sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uICh2Tm9kZSkgeyByZXR1cm4gdk5vZGUuY2hpbGRyZW4gfHwgW107IH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbiAodk5vZGUpIHsgcmV0dXJuIHZOb2RlLmRhdGFbcGFyZW50X3N5bWJvbF8xLmRlZmF1bHRdIHx8IHZOb2RlOyB9LFxuICAgIGNvbnRlbnRzOiBmdW5jdGlvbiAodk5vZGUpIHsgcmV0dXJuIHZOb2RlLnRleHQgfHwgJyc7IH0sXG4gICAgYXR0cjogZnVuY3Rpb24gKHZOb2RlLCBhdHRyKSB7XG4gICAgICAgIGlmICh2Tm9kZS5kYXRhKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB2Tm9kZS5kYXRhLCBfYiA9IF9hLmF0dHJzLCBhdHRycyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBfYyA9IF9hLnByb3BzLCBwcm9wcyA9IF9jID09PSB2b2lkIDAgPyB7fSA6IF9jLCBfZCA9IF9hLmRhdGFzZXQsIGRhdGFzZXQgPSBfZCA9PT0gdm9pZCAwID8ge30gOiBfZDtcbiAgICAgICAgICAgIGlmIChhdHRyc1thdHRyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wc1thdHRyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1thdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyLmluZGV4T2YoJ2RhdGEtJykgPT09IDAgJiYgZGF0YXNldFthdHRyLnNsaWNlKDUpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhc2V0W2F0dHIuc2xpY2UoNSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG52YXIgbWF0Y2hlcyA9IHRyZWVfc2VsZWN0b3JfMS5jcmVhdGVNYXRjaGVzKG9wdGlvbnMpO1xuZnVuY3Rpb24gY3VzdG9tTWF0Y2hlcyhzZWwsIHZub2RlKSB7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBzZWxlY3RvciA9IG1hdGNoZXMuYmluZChudWxsLCBzZWwpO1xuICAgIGlmIChkYXRhICYmIGRhdGEuZm4pIHtcbiAgICAgICAgdmFyIG4gPSB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuYXJncykpIHtcbiAgICAgICAgICAgIG4gPSBkYXRhLmZuLmFwcGx5KG51bGwsIGRhdGEuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5hcmdzKSB7XG4gICAgICAgICAgICBuID0gZGF0YS5mbi5jYWxsKG51bGwsIGRhdGEuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuID0gZGF0YS5mbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RvcihuKSA/IG4gOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yKHZub2RlKTtcbn1cbmV4cG9ydHMucXVlcnlTZWxlY3RvciA9IHRyZWVfc2VsZWN0b3JfMS5jcmVhdGVRdWVyeVNlbGVjdG9yKG9wdGlvbnMsIGN1c3RvbU1hdGNoZXMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzZWxlY3RvclBhcnNlcihub2RlKSB7XG4gICAgaWYgKCFub2RlLnNlbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFnTmFtZTogJycsXG4gICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgc2VsID0gbm9kZS5zZWw7XG4gICAgdmFyIGhhc2hJZHggPSBzZWwuaW5kZXhPZignIycpO1xuICAgIHZhciBkb3RJZHggPSBzZWwuaW5kZXhPZignLicsIGhhc2hJZHgpO1xuICAgIHZhciBoYXNoID0gaGFzaElkeCA+IDAgPyBoYXNoSWR4IDogc2VsLmxlbmd0aDtcbiAgICB2YXIgZG90ID0gZG90SWR4ID4gMCA/IGRvdElkeCA6IHNlbC5sZW5ndGg7XG4gICAgdmFyIHRhZ05hbWUgPSBoYXNoSWR4ICE9PSAtMSB8fCBkb3RJZHggIT09IC0xID9cbiAgICAgICAgc2VsLnNsaWNlKDAsIE1hdGgubWluKGhhc2gsIGRvdCkpIDpcbiAgICAgICAgc2VsO1xuICAgIHZhciBpZCA9IGhhc2ggPCBkb3QgPyBzZWwuc2xpY2UoaGFzaCArIDEsIGRvdCkgOiB2b2lkIDA7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGRvdElkeCA+IDAgPyBzZWwuc2xpY2UoZG90ICsgMSkucmVwbGFjZSgvXFwuL2csICcgJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICB9O1xufVxuZXhwb3J0cy5zZWxlY3RvclBhcnNlciA9IHNlbGVjdG9yUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0b3JQYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdm5vZGVfMSA9IHJlcXVpcmUoXCIuL3Zub2RlXCIpO1xudmFyIGlzID0gcmVxdWlyZShcIi4vaXNcIik7XG5mdW5jdGlvbiBhZGROUyhkYXRhLCBjaGlsZHJlbiwgc2VsKSB7XG4gICAgZGF0YS5ucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgaWYgKHNlbCAhPT0gJ2ZvcmVpZ25PYmplY3QnICYmIGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkRGF0YSA9IGNoaWxkcmVuW2ldLmRhdGE7XG4gICAgICAgICAgICBpZiAoY2hpbGREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhZGROUyhjaGlsZERhdGEsIGNoaWxkcmVuW2ldLmNoaWxkcmVuLCBjaGlsZHJlbltpXS5zZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaChzZWwsIGIsIGMpIHtcbiAgICB2YXIgZGF0YSA9IHt9LCBjaGlsZHJlbiwgdGV4dCwgaTtcbiAgICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGEgPSBiO1xuICAgICAgICBpZiAoaXMuYXJyYXkoYykpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYykpIHtcbiAgICAgICAgICAgIHRleHQgPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgJiYgYy5zZWwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXMuYXJyYXkoYikpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYikpIHtcbiAgICAgICAgICAgIHRleHQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgJiYgYi5zZWwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2JdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaXMucHJpbWl0aXZlKGNoaWxkcmVuW2ldKSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IHZub2RlXzEudm5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2hpbGRyZW5baV0sIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbFswXSA9PT0gJ3MnICYmIHNlbFsxXSA9PT0gJ3YnICYmIHNlbFsyXSA9PT0gJ2cnICYmXG4gICAgICAgIChzZWwubGVuZ3RoID09PSAzIHx8IHNlbFszXSA9PT0gJy4nIHx8IHNlbFszXSA9PT0gJyMnKSkge1xuICAgICAgICBhZGROUyhkYXRhLCBjaGlsZHJlbiwgc2VsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXzEudm5vZGUoc2VsLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgdW5kZWZpbmVkKTtcbn1cbmV4cG9ydHMuaCA9IGg7XG47XG5leHBvcnRzLmRlZmF1bHQgPSBoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50KHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5mdW5jdGlvbiByZW1vdmVDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG59XG5mdW5jdGlvbiBuZXh0U2libGluZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG59XG5mdW5jdGlvbiB0YWdOYW1lKGVsbSkge1xuICAgIHJldHVybiBlbG0udGFnTmFtZTtcbn1cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50ZXh0Q29udGVudDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDE7XG59XG5mdW5jdGlvbiBpc1RleHQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAzO1xufVxuZnVuY3Rpb24gaXNDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbn1cbmV4cG9ydHMuaHRtbERvbUFwaSA9IHtcbiAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICAgIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICAgIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICAgIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICAgIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gICAgZ2V0VGV4dENvbnRlbnQ6IGdldFRleHRDb250ZW50LFxuICAgIGlzRWxlbWVudDogaXNFbGVtZW50LFxuICAgIGlzVGV4dDogaXNUZXh0LFxuICAgIGlzQ29tbWVudDogaXNDb21tZW50LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuaHRtbERvbUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWxkb21hcGkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFycmF5ID0gQXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIHByaW1pdGl2ZShzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG52YXIgeG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcbnZhciBjb2xvbkNoYXIgPSA1ODtcbnZhciB4Q2hhciA9IDEyMDtcbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBrZXksIGVsbSA9IHZub2RlLmVsbSwgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzLCBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnM7XG4gICAgaWYgKCFvbGRBdHRycyAmJiAhYXR0cnMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAob2xkQXR0cnMgPT09IGF0dHJzKVxuICAgICAgICByZXR1cm47XG4gICAgb2xkQXR0cnMgPSBvbGRBdHRycyB8fCB7fTtcbiAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgIC8vIHVwZGF0ZSBtb2RpZmllZCBhdHRyaWJ1dGVzLCBhZGQgbmV3IGF0dHJpYnV0ZXNcbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICB2YXIgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgICAgdmFyIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgICAgICAgaWYgKGN1ciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmNoYXJDb2RlQXQoMCkgIT09IHhDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoa2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuY2hhckNvZGVBdCgzKSA9PT0gY29sb25DaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB4bWwgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyh4bWxOUywga2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuY2hhckNvZGVBdCg1KSA9PT0gY29sb25DaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB4bGluayBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoa2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgcmVtb3ZlZCBhdHRyaWJ1dGVzXG4gICAgLy8gdXNlIGBpbmAgb3BlcmF0b3Igc2luY2UgdGhlIHByZXZpb3VzIGBmb3JgIGl0ZXJhdGlvbiB1c2VzIGl0ICguaS5lLiBhZGQgZXZlbiBhdHRyaWJ1dGVzIHdpdGggdW5kZWZpbmVkIHZhbHVlKVxuICAgIC8vIHRoZSBvdGhlciBvcHRpb24gaXMgdG8gcmVtb3ZlIGFsbCBhdHRyaWJ1dGVzIHdpdGggdmFsdWUgPT0gdW5kZWZpbmVkXG4gICAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSkge1xuICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5hdHRyaWJ1dGVzTW9kdWxlID0geyBjcmVhdGU6IHVwZGF0ZUF0dHJzLCB1cGRhdGU6IHVwZGF0ZUF0dHJzIH07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmF0dHJpYnV0ZXNNb2R1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gdXBkYXRlQ2xhc3Mob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGN1ciwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBvbGRDbGFzcyA9IG9sZFZub2RlLmRhdGEuY2xhc3MsIGtsYXNzID0gdm5vZGUuZGF0YS5jbGFzcztcbiAgICBpZiAoIW9sZENsYXNzICYmICFrbGFzcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChvbGRDbGFzcyA9PT0ga2xhc3MpXG4gICAgICAgIHJldHVybjtcbiAgICBvbGRDbGFzcyA9IG9sZENsYXNzIHx8IHt9O1xuICAgIGtsYXNzID0ga2xhc3MgfHwge307XG4gICAgZm9yIChuYW1lIGluIG9sZENsYXNzKSB7XG4gICAgICAgIGlmICgha2xhc3NbbmFtZV0pIHtcbiAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBrbGFzcykge1xuICAgICAgICBjdXIgPSBrbGFzc1tuYW1lXTtcbiAgICAgICAgaWYgKGN1ciAhPT0gb2xkQ2xhc3NbbmFtZV0pIHtcbiAgICAgICAgICAgIGVsbS5jbGFzc0xpc3RbY3VyID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNsYXNzTW9kdWxlID0geyBjcmVhdGU6IHVwZGF0ZUNsYXNzLCB1cGRhdGU6IHVwZGF0ZUNsYXNzIH07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmNsYXNzTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ0FQU19SRUdFWCA9IC9bQS1aXS9nO1xuZnVuY3Rpb24gdXBkYXRlRGF0YXNldChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtLCBvbGREYXRhc2V0ID0gb2xkVm5vZGUuZGF0YS5kYXRhc2V0LCBkYXRhc2V0ID0gdm5vZGUuZGF0YS5kYXRhc2V0LCBrZXk7XG4gICAgaWYgKCFvbGREYXRhc2V0ICYmICFkYXRhc2V0KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9sZERhdGFzZXQgPT09IGRhdGFzZXQpXG4gICAgICAgIHJldHVybjtcbiAgICBvbGREYXRhc2V0ID0gb2xkRGF0YXNldCB8fCB7fTtcbiAgICBkYXRhc2V0ID0gZGF0YXNldCB8fCB7fTtcbiAgICB2YXIgZCA9IGVsbS5kYXRhc2V0O1xuICAgIGZvciAoa2V5IGluIG9sZERhdGFzZXQpIHtcbiAgICAgICAgaWYgKCFkYXRhc2V0W2tleV0pIHtcbiAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS0nICsga2V5LnJlcGxhY2UoQ0FQU19SRUdFWCwgJy0kJicpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGRhdGFzZXQpIHtcbiAgICAgICAgaWYgKG9sZERhdGFzZXRba2V5XSAhPT0gZGF0YXNldFtrZXldKSB7XG4gICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgIGRba2V5XSA9IGRhdGFzZXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleS5yZXBsYWNlKENBUFNfUkVHRVgsICctJCYnKS50b0xvd2VyQ2FzZSgpLCBkYXRhc2V0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kYXRhc2V0TW9kdWxlID0geyBjcmVhdGU6IHVwZGF0ZURhdGFzZXQsIHVwZGF0ZTogdXBkYXRlRGF0YXNldCB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5kYXRhc2V0TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YXNldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBrZXksIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5wcm9wcywgcHJvcHMgPSB2bm9kZS5kYXRhLnByb3BzO1xuICAgIGlmICghb2xkUHJvcHMgJiYgIXByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9sZFByb3BzID09PSBwcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIG9sZFByb3BzID0gb2xkUHJvcHMgfHwge307XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICBpZiAoIXByb3BzW2tleV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbG1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgICAgICBvbGQgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICBpZiAob2xkICE9PSBjdXIgJiYgKGtleSAhPT0gJ3ZhbHVlJyB8fCBlbG1ba2V5XSAhPT0gY3VyKSkge1xuICAgICAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnByb3BzTW9kdWxlID0geyBjcmVhdGU6IHVwZGF0ZVByb3BzLCB1cGRhdGU6IHVwZGF0ZVByb3BzIH07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLnByb3BzTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBCaW5kaWcgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgbGlrZSB0aGlzIGZpeGVzIGEgYnVnIGluIElFL0VkZ2UuIFNlZSAjMzYwIGFuZCAjNDA5LlxudmFyIHJhZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkuYmluZCh3aW5kb3cpKSB8fCBzZXRUaW1lb3V0O1xudmFyIG5leHRGcmFtZSA9IGZ1bmN0aW9uIChmbikgeyByYWYoZnVuY3Rpb24gKCkgeyByYWYoZm4pOyB9KTsgfTtcbnZhciByZWZsb3dGb3JjZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldE5leHRGcmFtZShvYmosIHByb3AsIHZhbCkge1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7IG9ialtwcm9wXSA9IHZhbDsgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgY3VyLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIG9sZFN0eWxlID0gb2xkVm5vZGUuZGF0YS5zdHlsZSwgc3R5bGUgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICAgIGlmICghb2xkU3R5bGUgJiYgIXN0eWxlKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9sZFN0eWxlID09PSBzdHlsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIG9sZFN0eWxlID0gb2xkU3R5bGUgfHwge307XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICB2YXIgb2xkSGFzRGVsID0gJ2RlbGF5ZWQnIGluIG9sZFN0eWxlO1xuICAgIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgICAgICBpZiAoIXN0eWxlW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAobmFtZVswXSA9PT0gJy0nICYmIG5hbWVbMV0gPT09ICctJykge1xuICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtuYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgICAgICBjdXIgPSBzdHlsZVtuYW1lXTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdkZWxheWVkJyAmJiBzdHlsZS5kZWxheWVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lMiBpbiBzdHlsZS5kZWxheWVkKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gc3R5bGUuZGVsYXllZFtuYW1lMl07XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRIYXNEZWwgfHwgY3VyICE9PSBvbGRTdHlsZS5kZWxheWVkW25hbWUyXSkge1xuICAgICAgICAgICAgICAgICAgICBzZXROZXh0RnJhbWUoZWxtLnN0eWxlLCBuYW1lMiwgY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ3JlbW92ZScgJiYgY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgICAgICAgaWYgKG5hbWVbMF0gPT09ICctJyAmJiBuYW1lWzFdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBlbG0uc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtuYW1lXSA9IGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RGVzdHJveVN0eWxlKHZub2RlKSB7XG4gICAgdmFyIHN0eWxlLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIHMgPSB2bm9kZS5kYXRhLnN0eWxlO1xuICAgIGlmICghcyB8fCAhKHN0eWxlID0gcy5kZXN0cm95KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgICAgICBlbG0uc3R5bGVbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVJlbW92ZVN0eWxlKHZub2RlLCBybSkge1xuICAgIHZhciBzID0gdm5vZGUuZGF0YS5zdHlsZTtcbiAgICBpZiAoIXMgfHwgIXMucmVtb3ZlKSB7XG4gICAgICAgIHJtKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFyZWZsb3dGb3JjZWQpIHtcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS50cmFuc2Zvcm07XG4gICAgICAgIHJlZmxvd0ZvcmNlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIGkgPSAwLCBjb21wU3R5bGUsIHN0eWxlID0gcy5yZW1vdmUsIGFtb3VudCA9IDAsIGFwcGxpZWQgPSBbXTtcbiAgICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgYXBwbGllZC5wdXNoKG5hbWUpO1xuICAgICAgICBlbG0uc3R5bGVbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICB9XG4gICAgY29tcFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbG0pO1xuICAgIHZhciBwcm9wcyA9IGNvbXBTdHlsZVsndHJhbnNpdGlvbi1wcm9wZXJ0eSddLnNwbGl0KCcsICcpO1xuICAgIGZvciAoOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFwcGxpZWQuaW5kZXhPZihwcm9wc1tpXSkgIT09IC0xKVxuICAgICAgICAgICAgYW1vdW50Kys7XG4gICAgfVxuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldi50YXJnZXQgPT09IGVsbSlcbiAgICAgICAgICAgIC0tYW1vdW50O1xuICAgICAgICBpZiAoYW1vdW50ID09PSAwKVxuICAgICAgICAgICAgcm0oKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICAgIHJlZmxvd0ZvcmNlZCA9IGZhbHNlO1xufVxuZXhwb3J0cy5zdHlsZU1vZHVsZSA9IHtcbiAgICBwcmU6IGZvcmNlUmVmbG93LFxuICAgIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZSxcbiAgICBkZXN0cm95OiBhcHBseURlc3Ryb3lTdHlsZSxcbiAgICByZW1vdmU6IGFwcGx5UmVtb3ZlU3R5bGVcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLnN0eWxlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdm5vZGVfMSA9IHJlcXVpcmUoXCIuL3Zub2RlXCIpO1xudmFyIGlzID0gcmVxdWlyZShcIi4vaXNcIik7XG52YXIgaHRtbGRvbWFwaV8xID0gcmVxdWlyZShcIi4vaHRtbGRvbWFwaVwiKTtcbmZ1bmN0aW9uIGlzVW5kZWYocykgeyByZXR1cm4gcyA9PT0gdW5kZWZpbmVkOyB9XG5mdW5jdGlvbiBpc0RlZihzKSB7IHJldHVybiBzICE9PSB1bmRlZmluZWQ7IH1cbnZhciBlbXB0eU5vZGUgPSB2bm9kZV8xLmRlZmF1bHQoJycsIHt9LCBbXSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuZnVuY3Rpb24gc2FtZVZub2RlKHZub2RlMSwgdm5vZGUyKSB7XG4gICAgcmV0dXJuIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiYgdm5vZGUxLnNlbCA9PT0gdm5vZGUyLnNlbDtcbn1cbmZ1bmN0aW9uIGlzVm5vZGUodm5vZGUpIHtcbiAgICByZXR1cm4gdm5vZGUuc2VsICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICAgIHZhciBpLCBtYXAgPSB7fSwga2V5LCBjaDtcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgICAgICBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAga2V5ID0gY2gua2V5O1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1hcFtrZXldID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95JywgJ3ByZScsICdwb3N0J107XG52YXIgaF8xID0gcmVxdWlyZShcIi4vaFwiKTtcbmV4cG9ydHMuaCA9IGhfMS5oO1xudmFyIHRodW5rXzEgPSByZXF1aXJlKFwiLi90aHVua1wiKTtcbmV4cG9ydHMudGh1bmsgPSB0aHVua18xLnRodW5rO1xuZnVuY3Rpb24gaW5pdChtb2R1bGVzLCBkb21BcGkpIHtcbiAgICB2YXIgaSwgaiwgY2JzID0ge307XG4gICAgdmFyIGFwaSA9IGRvbUFwaSAhPT0gdW5kZWZpbmVkID8gZG9tQXBpIDogaHRtbGRvbWFwaV8xLmRlZmF1bHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBob29rID0gbW9kdWxlc1tqXVtob29rc1tpXV07XG4gICAgICAgICAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKGhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgICAgICB2YXIgaWQgPSBlbG0uaWQgPyAnIycgKyBlbG0uaWQgOiAnJztcbiAgICAgICAgdmFyIGMgPSBlbG0uY2xhc3NOYW1lID8gJy4nICsgZWxtLmNsYXNzTmFtZS5zcGxpdCgnICcpLmpvaW4oJy4nKSA6ICcnO1xuICAgICAgICByZXR1cm4gdm5vZGVfMS5kZWZhdWx0KGFwaS50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSArIGlkICsgYywge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcm1DYigpIHtcbiAgICAgICAgICAgIGlmICgtLWxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IGFwaS5wYXJlbnROb2RlKGNoaWxkRWxtKTtcbiAgICAgICAgICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50XzEsIGNoaWxkRWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgdmFyIGksIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbiwgc2VsID0gdm5vZGUuc2VsO1xuICAgICAgICBpZiAoc2VsID09PSAnIScpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUudGV4dCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUuZWxtID0gYXBpLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHNlbGVjdG9yXG4gICAgICAgICAgICB2YXIgaGFzaElkeCA9IHNlbC5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICB2YXIgZG90SWR4ID0gc2VsLmluZGV4T2YoJy4nLCBoYXNoSWR4KTtcbiAgICAgICAgICAgIHZhciBoYXNoID0gaGFzaElkeCA+IDAgPyBoYXNoSWR4IDogc2VsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkb3QgPSBkb3RJZHggPiAwID8gZG90SWR4IDogc2VsLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0YWcgPSBoYXNoSWR4ICE9PSAtMSB8fCBkb3RJZHggIT09IC0xID8gc2VsLnNsaWNlKDAsIE1hdGgubWluKGhhc2gsIGRvdCkpIDogc2VsO1xuICAgICAgICAgICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLm5zKSA/IGFwaS5jcmVhdGVFbGVtZW50TlMoaSwgdGFnKVxuICAgICAgICAgICAgICAgIDogYXBpLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgICAgIGlmIChoYXNoIDwgZG90KVxuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2lkJywgc2VsLnNsaWNlKGhhc2ggKyAxLCBkb3QpKTtcbiAgICAgICAgICAgIGlmIChkb3RJZHggPiAwKVxuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgc2VsLnNsaWNlKGRvdCArIDEpLnJlcGxhY2UoL1xcLi9nLCAnICcpKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgICAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmFwcGVuZENoaWxkKGVsbSwgY3JlYXRlRWxtKGNoLCBpbnNlcnRlZFZub2RlUXVldWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGFwaS5hcHBlbmRDaGlsZChlbG0sIGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgICAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaS5pbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGUuZWxtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0oY2gsIGluc2VydGVkVm5vZGVRdWV1ZSksIGJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sodm5vZGUpIHtcbiAgICAgICAgdmFyIGksIGosIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgaSh2bm9kZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHZub2RlLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSBudWxsICYmIHR5cGVvZiBpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXMocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgdmFyIGlfMSA9IHZvaWQgMCwgbGlzdGVuZXJzID0gdm9pZCAwLCBybSA9IHZvaWQgMCwgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICAgICAgaWYgKGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2guc2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKGNoLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpXzEgPSAwOyBpXzEgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYnMucmVtb3ZlW2lfMV0oY2gsIHJtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmKGlfMSA9IGNoLmRhdGEpICYmIGlzRGVmKGlfMSA9IGlfMS5ob29rKSAmJiBpc0RlZihpXzEgPSBpXzEucmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaV8xKGNoLCBybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcGkucmVtb3ZlQ2hpbGQocGFyZW50RWxtLCBjaC5lbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIHZhciBvbGRTdGFydElkeCA9IDAsIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgICAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgICAgICB2YXIgb2xkS2V5VG9JZHg7XG4gICAgICAgIHZhciBpZHhJbk9sZDtcbiAgICAgICAgdmFyIGVsbVRvTW92ZTtcbiAgICAgICAgdmFyIGJlZm9yZTtcbiAgICAgICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGRFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEtleVRvSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeEluT2xkID0gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSksIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxtVG9Nb3ZlLnNlbCAhPT0gbmV3U3RhcnRWbm9kZS5zZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCB8fCBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IG5ld0NoW25ld0VuZElkeCArIDFdID09IG51bGwgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICB2YXIgaSwgaG9vaztcbiAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhKSAmJiBpc0RlZihob29rID0gaS5ob29rKSAmJiBpc0RlZihpID0gaG9vay5wcmVwYXRjaCkpIHtcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2bm9kZS5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSlcbiAgICAgICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZENoICE9PSBjaClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgYXBpLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucG9zdHBhdGNoKSkge1xuICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgICAgdmFyIGksIGVsbSwgcGFyZW50O1xuICAgICAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucHJlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY2JzLnByZVtpXSgpO1xuICAgICAgICBpZiAoIWlzVm5vZGUob2xkVm5vZGUpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICAgICAgcGFyZW50ID0gYXBpLnBhcmVudE5vZGUoZWxtKTtcbiAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudCwgdm5vZGUuZWxtLCBhcGkubmV4dFNpYmxpbmcoZWxtKSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudCwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluc2VydGVkVm5vZGVRdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQoaW5zZXJ0ZWRWbm9kZVF1ZXVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnBvc3QubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjYnMucG9zdFtpXSgpO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfTtcbn1cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbmFiYmRvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoXzEgPSByZXF1aXJlKFwiLi9oXCIpO1xuZnVuY3Rpb24gY29weVRvVGh1bmsodm5vZGUsIHRodW5rKSB7XG4gICAgdGh1bmsuZWxtID0gdm5vZGUuZWxtO1xuICAgIHZub2RlLmRhdGEuZm4gPSB0aHVuay5kYXRhLmZuO1xuICAgIHZub2RlLmRhdGEuYXJncyA9IHRodW5rLmRhdGEuYXJncztcbiAgICB0aHVuay5kYXRhID0gdm5vZGUuZGF0YTtcbiAgICB0aHVuay5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHRodW5rLnRleHQgPSB2bm9kZS50ZXh0O1xuICAgIHRodW5rLmVsbSA9IHZub2RlLmVsbTtcbn1cbmZ1bmN0aW9uIGluaXQodGh1bmspIHtcbiAgICB2YXIgY3VyID0gdGh1bmsuZGF0YTtcbiAgICB2YXIgdm5vZGUgPSBjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBjdXIuYXJncyk7XG4gICAgY29weVRvVGh1bmsodm5vZGUsIHRodW5rKTtcbn1cbmZ1bmN0aW9uIHByZXBhdGNoKG9sZFZub2RlLCB0aHVuaykge1xuICAgIHZhciBpLCBvbGQgPSBvbGRWbm9kZS5kYXRhLCBjdXIgPSB0aHVuay5kYXRhO1xuICAgIHZhciBvbGRBcmdzID0gb2xkLmFyZ3MsIGFyZ3MgPSBjdXIuYXJncztcbiAgICBpZiAob2xkLmZuICE9PSBjdXIuZm4gfHwgb2xkQXJncy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVuayk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG9sZEFyZ3NbaV0gIT09IGFyZ3NbaV0pIHtcbiAgICAgICAgICAgIGNvcHlUb1RodW5rKGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLCB0aHVuayk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weVRvVGh1bmsob2xkVm5vZGUsIHRodW5rKTtcbn1cbmV4cG9ydHMudGh1bmsgPSBmdW5jdGlvbiB0aHVuayhzZWwsIGtleSwgZm4sIGFyZ3MpIHtcbiAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZ3MgPSBmbjtcbiAgICAgICAgZm4gPSBrZXk7XG4gICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGhfMS5oKHNlbCwge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgaG9vazogeyBpbml0OiBpbml0LCBwcmVwYXRjaDogcHJlcGF0Y2ggfSxcbiAgICAgICAgZm46IGZuLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy50aHVuaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRodW5rLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZub2RlXzEgPSByZXF1aXJlKFwiLi92bm9kZVwiKTtcbnZhciBodG1sZG9tYXBpXzEgPSByZXF1aXJlKFwiLi9odG1sZG9tYXBpXCIpO1xuZnVuY3Rpb24gdG9WTm9kZShub2RlLCBkb21BcGkpIHtcbiAgICB2YXIgYXBpID0gZG9tQXBpICE9PSB1bmRlZmluZWQgPyBkb21BcGkgOiBodG1sZG9tYXBpXzEuZGVmYXVsdDtcbiAgICB2YXIgdGV4dDtcbiAgICBpZiAoYXBpLmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICB2YXIgaWQgPSBub2RlLmlkID8gJyMnICsgbm9kZS5pZCA6ICcnO1xuICAgICAgICB2YXIgY24gPSBub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgdmFyIGMgPSBjbiA/ICcuJyArIGNuLnNwbGl0KCcgJykuam9pbignLicpIDogJyc7XG4gICAgICAgIHZhciBzZWwgPSBhcGkudGFnTmFtZShub2RlKS50b0xvd2VyQ2FzZSgpICsgaWQgKyBjO1xuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHZhciBuYW1lXzE7XG4gICAgICAgIHZhciBpID0gdm9pZCAwLCBuID0gdm9pZCAwO1xuICAgICAgICB2YXIgZWxtQXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBlbG1DaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGVsbUF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbmFtZV8xID0gZWxtQXR0cnNbaV0ubm9kZU5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZV8xICE9PSAnaWQnICYmIG5hbWVfMSAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGF0dHJzW25hbWVfMV0gPSBlbG1BdHRyc1tpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGVsbUNoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0b1ZOb2RlKGVsbUNoaWxkcmVuW2ldLCBkb21BcGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGVfMS5kZWZhdWx0KHNlbCwgeyBhdHRyczogYXR0cnMgfSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwaS5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdGV4dCA9IGFwaS5nZXRUZXh0Q29udGVudChub2RlKTtcbiAgICAgICAgcmV0dXJuIHZub2RlXzEuZGVmYXVsdCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0ZXh0LCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXBpLmlzQ29tbWVudChub2RlKSkge1xuICAgICAgICB0ZXh0ID0gYXBpLmdldFRleHRDb250ZW50KG5vZGUpO1xuICAgICAgICByZXR1cm4gdm5vZGVfMS5kZWZhdWx0KCchJywge30sIFtdLCB0ZXh0LCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2bm9kZV8xLmRlZmF1bHQoJycsIHt9LCBbXSwgdW5kZWZpbmVkLCBub2RlKTtcbiAgICB9XG59XG5leHBvcnRzLnRvVk5vZGUgPSB0b1ZOb2RlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9WTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvdm5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiB2bm9kZShzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCBlbG0pIHtcbiAgICB2YXIga2V5ID0gZGF0YSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZGF0YS5rZXk7XG4gICAgcmV0dXJuIHsgc2VsOiBzZWwsIGRhdGE6IGRhdGEsIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgdGV4dDogdGV4dCwgZWxtOiBlbG0sIGtleToga2V5IH07XG59XG5leHBvcnRzLnZub2RlID0gdm5vZGU7XG5leHBvcnRzLmRlZmF1bHQgPSB2bm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZub2RlLmpzLm1hcCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BvbnlmaWxsID0gcmVxdWlyZSgnLi9wb255ZmlsbC5qcycpO1xuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbnlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgcm9vdDsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9ICgwLCBfcG9ueWZpbGwyWydkZWZhdWx0J10pKHJvb3QpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVzdWx0OyIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NlbGVjdG9yUGFyc2VyXCIpKTtcbnZhciBtYXRjaGVzXzEgPSByZXF1aXJlKFwiLi9tYXRjaGVzXCIpO1xuZXhwb3J0cy5jcmVhdGVNYXRjaGVzID0gbWF0Y2hlc18xLmNyZWF0ZU1hdGNoZXM7XG52YXIgcXVlcnlTZWxlY3Rvcl8xID0gcmVxdWlyZShcIi4vcXVlcnlTZWxlY3RvclwiKTtcbmV4cG9ydHMuY3JlYXRlUXVlcnlTZWxlY3RvciA9IHF1ZXJ5U2VsZWN0b3JfMS5jcmVhdGVRdWVyeVNlbGVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VsZWN0b3JQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3NlbGVjdG9yUGFyc2VyXCIpO1xuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlcyhvcHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IsIG5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gdHlwZW9mIHNlbGVjdG9yID09PSAnb2JqZWN0JyA/IHNlbGVjdG9yIDogc2VsZWN0b3JQYXJzZXJfMS5wYXJzZVNlbGVjdG9yKHNlbGVjdG9yKSwgdGFnID0gX2EudGFnLCBpZCA9IF9hLmlkLCBjbGFzc0xpc3QgPSBfYS5jbGFzc0xpc3QsIGF0dHJpYnV0ZXMgPSBfYS5hdHRyaWJ1dGVzLCBuZXh0U2VsZWN0b3IgPSBfYS5uZXh0U2VsZWN0b3IsIHBzZXVkb3MgPSBfYS5wc2V1ZG9zO1xuICAgICAgICBpZiAobmV4dFNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF0Y2hlcyBjYW4gb25seSBwcm9jZXNzIHNlbGVjdG9ycyB0aGF0IHRhcmdldCBhIHNpbmdsZSBlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyAmJiB0YWcudG9Mb3dlckNhc2UoKSAhPT0gb3B0cy50YWcobm9kZSkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gb3B0cy5pZChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc2VzID0gb3B0cy5jbGFzc05hbWUobm9kZSkuc3BsaXQoJyAnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NMaXN0W2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gb3B0cy5hdHRyKG5vZGUsIGtleSk7XG4gICAgICAgICAgICB2YXIgdCA9IGF0dHJpYnV0ZXNba2V5XVswXTtcbiAgICAgICAgICAgIHZhciB2ID0gYXR0cmlidXRlc1trZXldWzFdO1xuICAgICAgICAgICAgaWYgKGF0dHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ID09PSAnaGFzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgPT09ICdleGFjdCcgJiYgYXR0ciAhPT0gdikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHQgIT09ICdleGFjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIG5vbi1zdHJpbmcgdmFsdWVzIGhhdmUgdG8gYmUgYW4gZXhhY3QgbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09ICdzdGFydHNXaXRoJyAmJiAhYXR0ci5zdGFydHNXaXRoKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09ICdlbmRzV2l0aCcgJiYgIWF0dHIuZW5kc1dpdGgodikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gJ2NvbnRhaW5zJyAmJiBhdHRyLmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09ICd3aGl0ZXNwYWNlJyAmJiBhdHRyLnNwbGl0KCcgJykuaW5kZXhPZih2KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gJ2Rhc2gnICYmIGF0dHIuc3BsaXQoJy0nKS5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHNldWRvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9iID0gcHNldWRvc1tpXSwgdCA9IF9iWzBdLCBkYXRhID0gX2JbMV07XG4gICAgICAgICAgICBpZiAodCA9PT0gJ2NvbnRhaW5zJyAmJiBkYXRhICE9PSBvcHRzLmNvbnRlbnRzKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgPT09ICdlbXB0eScgJiZcbiAgICAgICAgICAgICAgICAob3B0cy5jb250ZW50cyhub2RlKSB8fCBvcHRzLmNoaWxkcmVuKG5vZGUpLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodCA9PT0gJ3Jvb3QnICYmIG9wdHMucGFyZW50KG5vZGUpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodC5pbmRleE9mKCdjaGlsZCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0cy5wYXJlbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2libGluZ3MgPSBvcHRzLmNoaWxkcmVuKG9wdHMucGFyZW50KG5vZGUpKTtcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gJ2ZpcnN0LWNoaWxkJyAmJiBzaWJsaW5ncy5pbmRleE9mKG5vZGUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09ICdsYXN0LWNoaWxkJyAmJlxuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5pbmRleE9mKG5vZGUpICE9PSBzaWJsaW5ncy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09ICdudGgtY2hpbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleCA9IC8oW1xcKy1dPykoXFxkKikobj8pKFxcK1xcZCspPy87XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHJlZ2V4LmV4ZWMoZGF0YSkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VSZXN1bHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0WzBdID0gJysnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBwYXJzZVJlc3VsdFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChwYXJzZVJlc3VsdFswXSArIHBhcnNlUmVzdWx0WzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGQgPSBwYXJzZUludChwYXJzZVJlc3VsdFszXSB8fCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdFsyXSA9PT0gJ24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAlIGZhY3RvciAhPT0gYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZhY3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VSZXN1bHRbMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgocGFyc2VSZXN1bHRbMF0gPT09ICcrJyAmJiBpbmRleCAtIGFkZCA8IDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnNlUmVzdWx0WzBdID09PSAnLScgJiYgaW5kZXggLSBhZGQgPj0gMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXBhcnNlUmVzdWx0WzJdICYmIGZhY3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggIT09IGZhY3RvciAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVNYXRjaGVzID0gY3JlYXRlTWF0Y2hlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VsZWN0b3JQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3NlbGVjdG9yUGFyc2VyXCIpO1xudmFyIG1hdGNoZXNfMSA9IHJlcXVpcmUoXCIuL21hdGNoZXNcIik7XG5mdW5jdGlvbiBjcmVhdGVRdWVyeVNlbGVjdG9yKG9wdGlvbnMsIG1hdGNoZXMpIHtcbiAgICB2YXIgX21hdGNoZXMgPSBtYXRjaGVzIHx8IG1hdGNoZXNfMS5jcmVhdGVNYXRjaGVzKG9wdGlvbnMpO1xuICAgIGZ1bmN0aW9uIGZpbmRTdWJ0cmVlKHNlbGVjdG9yLCBkZXB0aCwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IF9tYXRjaGVzKHNlbGVjdG9yLCBub2RlKTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBuID8gKHR5cGVvZiBuID09PSAnb2JqZWN0JyA/IFtuXSA6IFtub2RlXSkgOiBbXTtcbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRNYXRjaGVkID0gb3B0aW9uc1xuICAgICAgICAgICAgLmNoaWxkcmVuKG5vZGUpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiB0eXBlb2YgYyAhPT0gJ3N0cmluZyc7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBmaW5kU3VidHJlZShzZWxlY3RvciwgZGVwdGggLSAxLCBjKTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycikgeyByZXR1cm4gYWNjLmNvbmNhdChjdXJyKTsgfSwgW10pO1xuICAgICAgICByZXR1cm4gbWF0Y2hlZC5jb25jYXQoY2hpbGRNYXRjaGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFNpYmxpbmcoc2VsZWN0b3IsIG5leHQsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IG9wdGlvbnMucGFyZW50KG5vZGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgc2libGluZ3MgPSBvcHRpb25zLmNoaWxkcmVuKG9wdGlvbnMucGFyZW50KG5vZGUpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSkgKyAxOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2libGluZ3NbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbiA9IF9tYXRjaGVzKHNlbGVjdG9yLCBzaWJsaW5nc1tpXSk7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNpYmxpbmdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gcXVlcnlTZWxlY3RvcihzZWxlY3Rvciwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsID0gdHlwZW9mIHNlbGVjdG9yID09PSAnb2JqZWN0JyA/IHNlbGVjdG9yIDogc2VsZWN0b3JQYXJzZXJfMS5wYXJzZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbbm9kZV07XG4gICAgICAgIHZhciBjdXJyZW50U2VsZWN0b3IgPSBzZWw7XG4gICAgICAgIHZhciBjdXJyZW50Q29tYmluYXRvciA9ICdzdWJ0cmVlJztcbiAgICAgICAgdmFyIHRhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFpbCA9IGN1cnJlbnRTZWxlY3Rvci5uZXh0U2VsZWN0b3I7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0b3IubmV4dFNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb21iaW5hdG9yID09PSAnc3VidHJlZScgfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29tYmluYXRvciA9PT0gJ2NoaWxkJykge1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aF8xID0gY3VycmVudENvbWJpbmF0b3IgPT09ICdzdWJ0cmVlJyA/IEluZmluaXR5IDogMTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBmaW5kU3VidHJlZShjdXJyZW50U2VsZWN0b3IsIGRlcHRoXzEsIG4pOyB9KVxuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHsgcmV0dXJuIGFjYy5jb25jYXQoY3Vycik7IH0sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0XzEgPSBjdXJyZW50Q29tYmluYXRvciA9PT0gJ25leHRTaWJsaW5nJztcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBmaW5kU2libGluZyhjdXJyZW50U2VsZWN0b3IsIG5leHRfMSwgbik7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycikgeyByZXR1cm4gYWNjLmNvbmNhdChjdXJyKTsgfSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhaWwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3IgPSB0YWlsWzFdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21iaW5hdG9yID0gdGFpbFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9IHdoaWxlICh0YWlsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVRdWVyeVNlbGVjdG9yID0gY3JlYXRlUXVlcnlTZWxlY3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5U2VsZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJREVOVCA9ICdbXFxcXHctXSsnO1xudmFyIFNQQUNFID0gJ1sgXFx0XSonO1xudmFyIFZBTFVFID0gXCJbXlxcXFxdXStcIjtcbnZhciBDTEFTUyA9IFwiKD86XFxcXC5cIiArIElERU5UICsgXCIpXCI7XG52YXIgSUQgPSBcIig/OiNcIiArIElERU5UICsgXCIpXCI7XG52YXIgT1AgPSBcIig/Oj18XFxcXCQ9fFxcXFxePXxcXFxcKj18fj18XFxcXHw9KVwiO1xudmFyIEFUVFIgPSBcIig/OlxcXFxbXCIgKyBTUEFDRSArIElERU5UICsgU1BBQ0UgKyBcIig/OlwiICsgT1AgKyBTUEFDRSArIFZBTFVFICsgU1BBQ0UgKyBcIik/XFxcXF0pXCI7XG52YXIgU1VCVFJFRSA9IFwiKD86WyBcXHRdKylcIjtcbnZhciBDSElMRCA9IFwiKD86XCIgKyBTUEFDRSArIFwiKD4pXCIgKyBTUEFDRSArIFwiKVwiO1xudmFyIE5FWFRfU0lCTElORyA9IFwiKD86XCIgKyBTUEFDRSArIFwiKFxcXFwrKVwiICsgU1BBQ0UgKyBcIilcIjtcbnZhciBTSUJMSU5HID0gXCIoPzpcIiArIFNQQUNFICsgXCIofilcIiArIFNQQUNFICsgXCIpXCI7XG52YXIgQ09NQklOQVRPUiA9IFwiKD86XCIgKyBTVUJUUkVFICsgXCJ8XCIgKyBDSElMRCArIFwifFwiICsgTkVYVF9TSUJMSU5HICsgXCJ8XCIgKyBTSUJMSU5HICsgXCIpXCI7XG52YXIgQ09OVEFJTlMgPSBcImNvbnRhaW5zXFxcXChcXFwiW15cXFwiXSpcXFwiXFxcXClcIjtcbnZhciBGT1JNVUxBID0gXCIoPzpldmVufG9kZHxcXFxcZCooPzotP24oPzpcXFxcK1xcXFxkKyk/KT8pXCI7XG52YXIgTlRIX0NISUxEID0gXCJudGgtY2hpbGRcXFxcKFwiICsgRk9STVVMQSArIFwiXFxcXClcIjtcbnZhciBQU0VVRE8gPSBcIjooPzpmaXJzdC1jaGlsZHxsYXN0LWNoaWxkfFwiICsgTlRIX0NISUxEICsgXCJ8ZW1wdHl8cm9vdHxcIiArIENPTlRBSU5TICsgXCIpXCI7XG52YXIgVEFHID0gXCIoOj9cIiArIElERU5UICsgXCIpP1wiO1xudmFyIFRPS0VOUyA9IENMQVNTICsgXCJ8XCIgKyBJRCArIFwifFwiICsgQVRUUiArIFwifFwiICsgUFNFVURPICsgXCJ8XCIgKyBDT01CSU5BVE9SO1xudmFyIGNvbWJpbmF0b3JSZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBDT01CSU5BVE9SICsgXCIkXCIpO1xuLyoqXG4gKiBQYXJzZXMgYSBjc3Mgc2VsZWN0b3IgaW50byBhIG5vcm1hbGl6ZWQgb2JqZWN0LlxuICogRXhwZWN0cyBhIHNlbGVjdG9yIGZvciBhIHNpbmdsZSBlbGVtZW50IG9ubHksIG5vIGA+YCBvciB0aGUgbGlrZSFcbiAqL1xuZnVuY3Rpb24gcGFyc2VTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciBzZWwgPSBzZWxlY3Rvci50cmltKCk7XG4gICAgdmFyIHRhZ1JlZ2V4ID0gbmV3IFJlZ0V4cChUQUcsICd5Jyk7XG4gICAgdmFyIHRhZyA9IHRhZ1JlZ2V4LmV4ZWMoc2VsKVswXTtcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFRPS0VOUywgJ3knKTtcbiAgICByZWdleC5sYXN0SW5kZXggPSB0YWdSZWdleC5sYXN0SW5kZXg7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgbmV4dFNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgIHZhciBsYXN0Q29tYmluYXRvciA9IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB3aGlsZSAocmVnZXgubGFzdEluZGV4IDwgc2VsLmxlbmd0aCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZWdleC5leGVjKHNlbCk7XG4gICAgICAgIGlmICghbWF0Y2ggJiYgbGFzdENvbWJpbmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBlcnJvciwgaW52YWxpZCBzZWxlY3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoICYmIGNvbWJpbmF0b3JSZWdleC50ZXN0KG1hdGNoWzBdKSkge1xuICAgICAgICAgICAgdmFyIGNvbWIgPSBjb21iaW5hdG9yUmVnZXguZXhlYyhtYXRjaFswXSlbMF07XG4gICAgICAgICAgICBsYXN0Q29tYmluYXRvciA9IGNvbWI7XG4gICAgICAgICAgICBpbmRleCA9IHJlZ2V4Lmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYXN0Q29tYmluYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yID0gW1xuICAgICAgICAgICAgICAgICAgICBnZXRDb21iaW5hdG9yKGxhc3RDb21iaW5hdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTZWxlY3RvcihzZWwuc3Vic3RyaW5nKGluZGV4KSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2xhc3NMaXN0ID0gbWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnN0YXJ0c1dpdGgoJy4nKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zdWJzdHJpbmcoMSk7IH0pO1xuICAgIHZhciBpZHMgPSBtYXRjaGVzLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zdGFydHNXaXRoKCcjJyk7IH0pLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5zdWJzdHJpbmcoMSk7IH0pO1xuICAgIGlmIChpZHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IsIG9ubHkgb25lIGlkIGlzIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgdmFyIHBvc3Rwcm9jZXNzUmVnZXggPSBuZXcgUmVnRXhwKFwiKFwiICsgSURFTlQgKyBcIilcIiArIFNQQUNFICsgXCIoXCIgKyBPUCArIFwiKT9cIiArIFNQQUNFICsgXCIoXCIgKyBWQUxVRSArIFwiKT9cIik7XG4gICAgdmFyIGF0dHJzID0gbWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnN0YXJ0c1dpdGgoJ1snKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcG9zdHByb2Nlc3NSZWdleC5leGVjKHMpLnNsaWNlKDEsIDQpOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgYXR0ciA9IF9hWzBdLCBvcCA9IF9hWzFdLCB2YWwgPSBfYVsyXTtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0ge30sXG4gICAgICAgICAgICBfYlthdHRyXSA9IFtnZXRPcChvcCksIHZhbCA/IHBhcnNlQXR0clZhbHVlKHZhbCkgOiB2YWxdLFxuICAgICAgICAgICAgX2IpO1xuICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycikgeyByZXR1cm4gKF9fYXNzaWduKHt9LCBhY2MsIGN1cnIpKTsgfSwge30pO1xuICAgIHZhciBwc2V1ZG9zID0gbWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnN0YXJ0c1dpdGgoJzonKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcG9zdFByb2Nlc3NQc2V1ZG9zKHMuc3Vic3RyaW5nKDEpKTsgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkc1swXSB8fCAnJyxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGNsYXNzTGlzdDogY2xhc3NMaXN0LFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRycyxcbiAgICAgICAgbmV4dFNlbGVjdG9yOiBuZXh0U2VsZWN0b3IsXG4gICAgICAgIHBzZXVkb3M6IHBzZXVkb3NcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcjtcbmZ1bmN0aW9uIHBhcnNlQXR0clZhbHVlKHYpIHtcbiAgICBpZiAodi5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICAgIHJldHVybiB2LnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgaWYgKHYgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodiA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGYgPSBwYXJzZUZsb2F0KHYpO1xuICAgIGlmIChpc05hTihmKSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG59XG5mdW5jdGlvbiBwb3N0UHJvY2Vzc1BzZXVkb3Moc2VsKSB7XG4gICAgaWYgKHNlbCA9PT0gJ2ZpcnN0LWNoaWxkJyB8fFxuICAgICAgICBzZWwgPT09ICdsYXN0LWNoaWxkJyB8fFxuICAgICAgICBzZWwgPT09ICdyb290JyB8fFxuICAgICAgICBzZWwgPT09ICdlbXB0eScpIHtcbiAgICAgICAgcmV0dXJuIFtzZWwsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGlmIChzZWwuc3RhcnRzV2l0aCgnY29udGFpbnMnKSkge1xuICAgICAgICB2YXIgdGV4dCA9IHNlbC5zbGljZSgxMCwgLTIpO1xuICAgICAgICByZXR1cm4gWydjb250YWlucycsIHRleHRdO1xuICAgIH1cbiAgICB2YXIgY29udGVudCA9IHNlbC5zbGljZSgxMCwgLTEpO1xuICAgIGlmIChjb250ZW50ID09PSAnZXZlbicpIHtcbiAgICAgICAgY29udGVudCA9ICcybic7XG4gICAgfVxuICAgIGlmIChjb250ZW50ID09PSAnb2RkJykge1xuICAgICAgICBjb250ZW50ID0gJzJuKzEnO1xuICAgIH1cbiAgICByZXR1cm4gWydudGgtY2hpbGQnLCBjb250ZW50XTtcbn1cbmZ1bmN0aW9uIGdldE9wKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgIHJldHVybiAnZXhhY3QnO1xuICAgICAgICBjYXNlICdePSc6XG4gICAgICAgICAgICByZXR1cm4gJ3N0YXJ0c1dpdGgnO1xuICAgICAgICBjYXNlICckPSc6XG4gICAgICAgICAgICByZXR1cm4gJ2VuZHNXaXRoJztcbiAgICAgICAgY2FzZSAnKj0nOlxuICAgICAgICAgICAgcmV0dXJuICdjb250YWlucyc7XG4gICAgICAgIGNhc2UgJ349JzpcbiAgICAgICAgICAgIHJldHVybiAnd2hpdGVzcGFjZSc7XG4gICAgICAgIGNhc2UgJ3w9JzpcbiAgICAgICAgICAgIHJldHVybiAnZGFzaCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ2hhcyc7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tYmluYXRvcihjb21iKSB7XG4gICAgc3dpdGNoIChjb21iLnRyaW0oKSkge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnY2hpbGQnO1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV4dFNpYmxpbmcnO1xuICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgIHJldHVybiAnc2libGluZyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3N1YnRyZWUnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdG9yUGFyc2VyLmpzLm1hcCIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsInZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCBpdGVtKSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKGl0ZW0pO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xudmFyIE9iamVjdF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGZuKVxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih4c1tpXSwgaSwgeHMpO1xuICAgIH1cbn07XG5cbnZhciBkZWZpbmVQcm9wID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ18nLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG5cbnZhciBnbG9iYWxzID0gWydBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRXJyb3InLCAnRXZhbEVycm9yJywgJ0Z1bmN0aW9uJyxcbidJbmZpbml0eScsICdKU09OJywgJ01hdGgnLCAnTmFOJywgJ051bWJlcicsICdPYmplY3QnLCAnUmFuZ2VFcnJvcicsXG4nUmVmZXJlbmNlRXJyb3InLCAnUmVnRXhwJywgJ1N0cmluZycsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InLFxuJ2RlY29kZVVSSScsICdkZWNvZGVVUklDb21wb25lbnQnLCAnZW5jb2RlVVJJJywgJ2VuY29kZVVSSUNvbXBvbmVudCcsICdlc2NhcGUnLFxuJ2V2YWwnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLCAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICd1bmRlZmluZWQnLCAndW5lc2NhcGUnXTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5Db250ZXh0LnByb3RvdHlwZSA9IHt9O1xuXG52YXIgU2NyaXB0ID0gZXhwb3J0cy5TY3JpcHQgPSBmdW5jdGlvbiBOb2RlU2NyaXB0IChjb2RlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHJldHVybiBuZXcgU2NyaXB0KGNvZGUpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZWVkcyBhICdjb250ZXh0JyBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIFxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZiAoIWlmcmFtZS5zdHlsZSkgaWZyYW1lLnN0eWxlID0ge307XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICB2YXIgd0V2YWwgPSB3aW4uZXZhbCwgd0V4ZWNTY3JpcHQgPSB3aW4uZXhlY1NjcmlwdDtcblxuICAgIGlmICghd0V2YWwgJiYgd0V4ZWNTY3JpcHQpIHtcbiAgICAgICAgLy8gd2luLmV2YWwoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXZhbCh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuaXNDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQ7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwiaW1wb3J0IHtTdHJlYW0sIEludGVybmFsUHJvZHVjZXIsIEludGVybmFsTGlzdGVuZXIsIE91dFNlbmRlcn0gZnJvbSAnLi4vaW5kZXgnO1xuXG5jbGFzcyBDb25jYXRQcm9kdWNlcjxUPiBpbXBsZW1lbnRzIEludGVybmFsUHJvZHVjZXI8VD4sIEludGVybmFsTGlzdGVuZXI8VD4sIE91dFNlbmRlcjxUPiB7XG4gIHB1YmxpYyB0eXBlID0gJ2NvbmNhdCc7XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxUPiA9IG51bGwgYXMgYW55O1xuICBwcml2YXRlIGk6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHN0cmVhbXM6IEFycmF5PFN0cmVhbTxUPj4pIHtcbiAgfVxuXG4gIF9zdGFydChvdXQ6IFN0cmVhbTxUPik6IHZvaWQge1xuICAgIHRoaXMub3V0ID0gb3V0O1xuICAgIHRoaXMuc3RyZWFtc1t0aGlzLmldLl9hZGQodGhpcyk7XG4gIH1cblxuICBfc3RvcCgpOiB2b2lkIHtcbiAgICBjb25zdCBzdHJlYW1zID0gdGhpcy5zdHJlYW1zO1xuICAgIGlmICh0aGlzLmkgPCBzdHJlYW1zLmxlbmd0aCkge1xuICAgICAgc3RyZWFtc1t0aGlzLmldLl9yZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuaSA9IDA7XG4gICAgdGhpcy5vdXQgPSBudWxsIGFzIGFueTtcbiAgfVxuXG4gIF9uKHQ6IFQpIHtcbiAgICBjb25zdCB1ID0gdGhpcy5vdXQ7XG4gICAgaWYgKCF1KSByZXR1cm47XG4gICAgdS5fbih0KTtcbiAgfVxuXG4gIF9lKGVycjogYW55KSB7XG4gICAgY29uc3QgdSA9IHRoaXMub3V0O1xuICAgIGlmICghdSkgcmV0dXJuO1xuICAgIHUuX2UoZXJyKTtcbiAgfVxuXG4gIF9jKCkge1xuICAgIGNvbnN0IHUgPSB0aGlzLm91dDtcbiAgICBpZiAoIXUpIHJldHVybjtcbiAgICBjb25zdCBzdHJlYW1zID0gdGhpcy5zdHJlYW1zO1xuICAgIHN0cmVhbXNbdGhpcy5pXS5fcmVtb3ZlKHRoaXMpO1xuICAgIGlmICgrK3RoaXMuaSA8IHN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICBzdHJlYW1zW3RoaXMuaV0uX2FkZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdS5fYygpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1dHMgb25lIHN0cmVhbSBhZnRlciB0aGUgb3RoZXIuICpjb25jYXQqIGlzIGEgZmFjdG9yeSB0aGF0IHRha2VzIG11bHRpcGxlXG4gKiBzdHJlYW1zIGFzIGFyZ3VtZW50cywgYW5kIHN0YXJ0cyB0aGUgYG4rMWAtdGggc3RyZWFtIG9ubHkgd2hlbiB0aGUgYG5gLXRoXG4gKiBzdHJlYW0gaGFzIGNvbXBsZXRlZC4gSXQgY29uY2F0ZW5hdGVzIHRob3NlIHN0cmVhbXMgdG9nZXRoZXIuXG4gKlxuICogTWFyYmxlIGRpYWdyYW06XG4gKlxuICogYGBgdGV4dFxuICogLS0xLS0yLS0tMy0tLTQtfFxuICogLi4uLi4uLi4uLi4uLi4uLS1hLWItYy0tZC18XG4gKiAgICAgICAgICAgY29uY2F0XG4gKiAtLTEtLTItLS0zLS0tNC0tLWEtYi1jLS1kLXxcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBjb25jYXQgZnJvbSAneHN0cmVhbS9leHRyYS9jb25jYXQnXG4gKlxuICogY29uc3Qgc3RyZWFtQSA9IHhzLm9mKCdhJywgJ2InLCAnYycpXG4gKiBjb25zdCBzdHJlYW1CID0geHMub2YoMTAsIDIwLCAzMClcbiAqIGNvbnN0IHN0cmVhbUMgPSB4cy5vZignWCcsICdZJywgJ1onKVxuICpcbiAqIGNvbnN0IG91dHB1dFN0cmVhbSA9IGNvbmNhdChzdHJlYW1BLCBzdHJlYW1CLCBzdHJlYW1DKVxuICpcbiAqIG91dHB1dFN0cmVhbS5hZGRMaXN0ZW5lcih7XG4gKiAgIG5leHQ6ICh4KSA9PiBjb25zb2xlLmxvZyh4KSxcbiAqICAgZXJyb3I6IChlcnIpID0+IGNvbnNvbGUuZXJyb3IoZXJyKSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdjb25jYXQgY29tcGxldGVkJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGZhY3RvcnkgdHJ1ZVxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTEgQSBzdHJlYW0gdG8gY29uY2F0ZW5hdGUgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbTIgQSBzdHJlYW0gdG8gY29uY2F0ZW5hdGUgdG9nZXRoZXIgd2l0aCBvdGhlciBzdHJlYW1zLiBUd29cbiAqIG9yIG1vcmUgc3RyZWFtcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnRzLlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25jYXQ8VD4oLi4uc3RyZWFtczogQXJyYXk8U3RyZWFtPFQ+Pik6IFN0cmVhbTxUPiB7XG4gIHJldHVybiBuZXcgU3RyZWFtPFQ+KG5ldyBDb25jYXRQcm9kdWNlcihzdHJlYW1zKSk7XG59XG4iLCJpbXBvcnQge0ludGVybmFsTGlzdGVuZXIsIE9wZXJhdG9yLCBTdHJlYW19IGZyb20gJy4uL2luZGV4JztcblxuZXhwb3J0IGludGVyZmFjZSBTYW1wbGVDb21iaW5lU2lnbmF0dXJlIHtcbiAgKCk6IDxUPihzOiBTdHJlYW08VD4pID0+IFN0cmVhbTxbVF0+O1xuICA8VDE+KHMxOiBTdHJlYW08VDE+KTogPFQ+KHM6IFN0cmVhbTxUPikgPT4gU3RyZWFtPFtULCBUMV0+O1xuICA8VDEsIFQyPihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPik6IDxUPihzOiBTdHJlYW08VD4pID0+IFN0cmVhbTxbVCwgVDEsIFQyXT47XG4gIDxUMSwgVDIsIFQzPihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPik6IDxUPihzOiBTdHJlYW08VD4pID0+IFN0cmVhbTxbVCwgVDEsIFQyLCBUM10+O1xuICA8VDEsIFQyLCBUMywgVDQ+KFxuICAgIHMxOiBTdHJlYW08VDE+LFxuICAgIHMyOiBTdHJlYW08VDI+LFxuICAgIHMzOiBTdHJlYW08VDM+LFxuICAgIHM0OiBTdHJlYW08VDQ+KTogPFQ+KHM6IFN0cmVhbTxUPikgPT4gU3RyZWFtPFtULCBUMSwgVDIsIFQzLCBUNF0+O1xuICA8VDEsIFQyLCBUMywgVDQsIFQ1PihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPixcbiAgICBzNDogU3RyZWFtPFQ0PixcbiAgICBzNTogU3RyZWFtPFQ1Pik6IDxUPihzOiBTdHJlYW08VD4pID0+IFN0cmVhbTxbVCwgVDEsIFQyLCBUMywgVDQsIFQ1XT47XG4gIDxUMSwgVDIsIFQzLCBUNCwgVDUsIFQ2PihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPixcbiAgICBzNDogU3RyZWFtPFQ0PixcbiAgICBzNTogU3RyZWFtPFQ1PixcbiAgICBzNjogU3RyZWFtPFQ2Pik6IDxUPihzOiBTdHJlYW08VD4pID0+IFN0cmVhbTxbVCwgVDEsIFQyLCBUMywgVDQsIFQ1LCBUNl0+O1xuICA8VDEsIFQyLCBUMywgVDQsIFQ1LCBUNiwgVDc+KFxuICAgIHMxOiBTdHJlYW08VDE+LFxuICAgIHMyOiBTdHJlYW08VDI+LFxuICAgIHMzOiBTdHJlYW08VDM+LFxuICAgIHM0OiBTdHJlYW08VDQ+LFxuICAgIHM1OiBTdHJlYW08VDU+LFxuICAgIHM2OiBTdHJlYW08VDY+LFxuICAgIHM3OiBTdHJlYW08VDc+KTogPFQ+KHM6IFN0cmVhbTxUPikgPT4gU3RyZWFtPFtULCBUMSwgVDIsIFQzLCBUNCwgVDUsIFQ2LCBUN10+O1xuICA8VDEsIFQyLCBUMywgVDQsIFQ1LCBUNiwgVDcsIFQ4PihcbiAgICBzMTogU3RyZWFtPFQxPixcbiAgICBzMjogU3RyZWFtPFQyPixcbiAgICBzMzogU3RyZWFtPFQzPixcbiAgICBzNDogU3RyZWFtPFQ0PixcbiAgICBzNTogU3RyZWFtPFQ1PixcbiAgICBzNjogU3RyZWFtPFQ2PixcbiAgICBzNzogU3RyZWFtPFQ3PixcbiAgICBzODogU3RyZWFtPFQ4Pik6IDxUPihzOiBTdHJlYW08VD4pID0+IFN0cmVhbTxbVCwgVDEsIFQyLCBUMywgVDQsIFQ1LCBUNiwgVDcsIFQ4XT47XG4gICguLi5zdHJlYW1zOiBBcnJheTxTdHJlYW08YW55Pj4pOiAoczogU3RyZWFtPGFueT4pID0+IFN0cmVhbTxBcnJheTxhbnk+Pjtcbn1cblxuY29uc3QgTk8gPSB7fTtcblxuZXhwb3J0IGNsYXNzIFNhbXBsZUNvbWJpbmVMaXN0ZW5lcjxUPiBpbXBsZW1lbnRzIEludGVybmFsTGlzdGVuZXI8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGk6IG51bWJlciwgcHJpdmF0ZSBwOiBTYW1wbGVDb21iaW5lT3BlcmF0b3I8YW55Pikge1xuICAgIHAuaWxzW2ldID0gdGhpcztcbiAgfVxuXG4gIF9uKHQ6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBwID0gdGhpcy5wO1xuICAgIGlmIChwLm91dCA9PT0gTk8pIHJldHVybjtcbiAgICBwLnVwKHQsIHRoaXMuaSk7XG4gIH1cblxuICBfZShlcnI6IGFueSk6IHZvaWQge1xuICAgIHRoaXMucC5fZShlcnIpO1xuICB9XG5cbiAgX2MoKTogdm9pZCB7XG4gICAgdGhpcy5wLmRvd24odGhpcy5pLCB0aGlzKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2FtcGxlQ29tYmluZU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgQXJyYXk8YW55Pj4ge1xuICBwdWJsaWMgdHlwZSA9ICdzYW1wbGVDb21iaW5lJztcbiAgcHVibGljIGluczogU3RyZWFtPFQ+O1xuICBwdWJsaWMgb3RoZXJzOiBBcnJheTxTdHJlYW08YW55Pj47XG4gIHB1YmxpYyBvdXQ6IFN0cmVhbTxBcnJheTxhbnk+PjtcbiAgcHVibGljIGlsczogQXJyYXk8U2FtcGxlQ29tYmluZUxpc3RlbmVyPGFueT4+O1xuICBwdWJsaWMgTm46IG51bWJlcjsgLy8gKk4qdW1iZXIgb2Ygc3RyZWFtcyBzdGlsbCB0byBzZW5kICpuKmV4dFxuICBwdWJsaWMgdmFsczogQXJyYXk8YW55PjtcblxuICBjb25zdHJ1Y3RvcihpbnM6IFN0cmVhbTxUPiwgc3RyZWFtczogQXJyYXk8U3RyZWFtPGFueT4+KSB7XG4gICAgdGhpcy5pbnMgPSBpbnM7XG4gICAgdGhpcy5vdGhlcnMgPSBzdHJlYW1zO1xuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPEFycmF5PGFueT4+O1xuICAgIHRoaXMuaWxzID0gW107XG4gICAgdGhpcy5ObiA9IDA7XG4gICAgdGhpcy52YWxzID0gW107XG4gIH1cblxuICBfc3RhcnQob3V0OiBTdHJlYW08QXJyYXk8YW55Pj4pOiB2b2lkIHtcbiAgICB0aGlzLm91dCA9IG91dDtcbiAgICBjb25zdCBzID0gdGhpcy5vdGhlcnM7XG4gICAgY29uc3QgbiA9IHRoaXMuTm4gPSBzLmxlbmd0aDtcbiAgICBjb25zdCB2YWxzID0gdGhpcy52YWxzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YWxzW2ldID0gTk87XG4gICAgICBzW2ldLl9hZGQobmV3IFNhbXBsZUNvbWJpbmVMaXN0ZW5lcjxhbnk+KGksIHRoaXMpKTtcbiAgICB9XG4gICAgdGhpcy5pbnMuX2FkZCh0aGlzKTtcbiAgfVxuXG4gIF9zdG9wKCk6IHZvaWQge1xuICAgIGNvbnN0IHMgPSB0aGlzLm90aGVycztcbiAgICBjb25zdCBuID0gcy5sZW5ndGg7XG4gICAgY29uc3QgaWxzID0gdGhpcy5pbHM7XG4gICAgdGhpcy5pbnMuX3JlbW92ZSh0aGlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgc1tpXS5fcmVtb3ZlKGlsc1tpXSk7XG4gICAgfVxuICAgIHRoaXMub3V0ID0gTk8gYXMgU3RyZWFtPEFycmF5PGFueT4+O1xuICAgIHRoaXMudmFscyA9IFtdO1xuICAgIHRoaXMuaWxzID0gW107XG4gIH1cblxuICBfbih0OiBUKTogdm9pZCB7XG4gICAgY29uc3Qgb3V0ID0gdGhpcy5vdXQ7XG4gICAgaWYgKG91dCA9PT0gTk8pIHJldHVybjtcbiAgICBpZiAodGhpcy5ObiA+IDApIHJldHVybjtcbiAgICBvdXQuX24oW3QsIC4uLnRoaXMudmFsc10pO1xuICB9XG5cbiAgX2UoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBvdXQgPSB0aGlzLm91dDtcbiAgICBpZiAob3V0ID09PSBOTykgcmV0dXJuO1xuICAgIG91dC5fZShlcnIpO1xuICB9XG5cbiAgX2MoKTogdm9pZCB7XG4gICAgY29uc3Qgb3V0ID0gdGhpcy5vdXQ7XG4gICAgaWYgKG91dCA9PT0gTk8pIHJldHVybjtcbiAgICBvdXQuX2MoKTtcbiAgfVxuXG4gIHVwKHQ6IGFueSwgaTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgdiA9IHRoaXMudmFsc1tpXTtcbiAgICBpZiAodGhpcy5ObiA+IDAgJiYgdiA9PT0gTk8pIHtcbiAgICAgIHRoaXMuTm4tLTtcbiAgICB9XG4gICAgdGhpcy52YWxzW2ldID0gdDtcbiAgfVxuXG4gIGRvd24oaTogbnVtYmVyLCBsOiBTYW1wbGVDb21iaW5lTGlzdGVuZXI8YW55Pik6IHZvaWQge1xuICAgIHRoaXMub3RoZXJzW2ldLl9yZW1vdmUobCk7XG4gIH1cbn1cblxubGV0IHNhbXBsZUNvbWJpbmU6IFNhbXBsZUNvbWJpbmVTaWduYXR1cmU7XG5cbi8qKlxuICpcbiAqIENvbWJpbmVzIGEgc291cmNlIHN0cmVhbSB3aXRoIG11bHRpcGxlIG90aGVyIHN0cmVhbXMuIFRoZSByZXN1bHQgc3RyZWFtXG4gKiB3aWxsIGVtaXQgdGhlIGxhdGVzdCBldmVudHMgZnJvbSBhbGwgaW5wdXQgc3RyZWFtcywgYnV0IG9ubHkgd2hlbiB0aGVcbiAqIHNvdXJjZSBzdHJlYW0gZW1pdHMuXG4gKlxuICogSWYgdGhlIHNvdXJjZSwgb3IgYW55IGlucHV0IHN0cmVhbSwgdGhyb3dzIGFuIGVycm9yLCB0aGUgcmVzdWx0IHN0cmVhbVxuICogd2lsbCBwcm9wYWdhdGUgdGhlIGVycm9yLiBJZiBhbnkgaW5wdXQgc3RyZWFtcyBlbmQsIHRoZWlyIGZpbmFsIGVtaXR0ZWRcbiAqIHZhbHVlIHdpbGwgcmVtYWluIGluIHRoZSBhcnJheSBvZiBhbnkgc3Vic2VxdWVudCBldmVudHMgZnJvbSB0aGUgcmVzdWx0XG4gKiBzdHJlYW0uXG4gKlxuICogVGhlIHJlc3VsdCBzdHJlYW0gd2lsbCBvbmx5IGNvbXBsZXRlIHVwb24gY29tcGxldGlvbiBvZiB0aGUgc291cmNlIHN0cmVhbS5cbiAqXG4gKiBNYXJibGUgZGlhZ3JhbTpcbiAqXG4gKiBgYGB0ZXh0XG4gKiAtLTEtLS0tMi0tLS0tMy0tLS0tLS0tNC0tLSAoc291cmNlKVxuICogLS0tLWEtLS0tLWItLS0tLWMtLWQtLS0tLS0gKG90aGVyKVxuICogICAgICBzYW1wbGVDb21iaW5lXG4gKiAtLS0tLS0tMmEtLS0tM2ItLS0tLS0tNGQtLVxuICogYGBgXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBzYW1wbGVDb21iaW5lIGZyb20gJ3hzdHJlYW0vZXh0cmEvc2FtcGxlQ29tYmluZSdcbiAqIGltcG9ydCB4cyBmcm9tICd4c3RyZWFtJ1xuICpcbiAqIGNvbnN0IHNhbXBsZXIgPSB4cy5wZXJpb2RpYygxMDAwKS50YWtlKDMpXG4gKiBjb25zdCBvdGhlciA9IHhzLnBlcmlvZGljKDEwMClcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSBzYW1wbGVyLmNvbXBvc2Uoc2FtcGxlQ29tYmluZShvdGhlcikpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IFswLCA4XVxuICogPiBbMSwgMThdXG4gKiA+IFsyLCAyOF1cbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgc2FtcGxlQ29tYmluZSBmcm9tICd4c3RyZWFtL2V4dHJhL3NhbXBsZUNvbWJpbmUnXG4gKiBpbXBvcnQgeHMgZnJvbSAneHN0cmVhbSdcbiAqXG4gKiBjb25zdCBzYW1wbGVyID0geHMucGVyaW9kaWMoMTAwMCkudGFrZSgzKVxuICogY29uc3Qgb3RoZXIgPSB4cy5wZXJpb2RpYygxMDApLnRha2UoMilcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSBzYW1wbGVyLmNvbXBvc2Uoc2FtcGxlQ29tYmluZShvdGhlcikpXG4gKlxuICogc3RyZWFtLmFkZExpc3RlbmVyKHtcbiAqICAgbmV4dDogaSA9PiBjb25zb2xlLmxvZyhpKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyciksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkJylcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBgYGB0ZXh0XG4gKiA+IFswLCAxXVxuICogPiBbMSwgMV1cbiAqID4gWzIsIDFdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gey4uLlN0cmVhbX0gc3RyZWFtcyBPbmUgb3IgbW9yZSBzdHJlYW1zIHRvIGNvbWJpbmUgd2l0aCB0aGUgc2FtcGxlclxuICogc3RyZWFtLlxuICogQHJldHVybiB7U3RyZWFtfVxuICovXG5zYW1wbGVDb21iaW5lID0gZnVuY3Rpb24gc2FtcGxlQ29tYmluZSguLi5zdHJlYW1zOiBBcnJheTxTdHJlYW08YW55Pj4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNhbXBsZUNvbWJpbmVPcGVyYXRvcihzYW1wbGVyOiBTdHJlYW08YW55Pik6IFN0cmVhbTxBcnJheTxhbnk+PiB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW08QXJyYXk8YW55Pj4obmV3IFNhbXBsZUNvbWJpbmVPcGVyYXRvcihzYW1wbGVyLCBzdHJlYW1zKSk7XG4gIH07XG59IGFzIFNhbXBsZUNvbWJpbmVTaWduYXR1cmU7XG5cbmV4cG9ydCBkZWZhdWx0IHNhbXBsZUNvbWJpbmU7IiwiaW1wb3J0IHhzIGZyb20gXCJ4c3RyZWFtXCI7XG5pbXBvcnQgeyBtYWtlRE9NRHJpdmVyLCBkaXYsIHZpZGVvLCBjYW52YXMgfSBmcm9tIFwiQGN5Y2xlL2RvbVwiO1xuaW1wb3J0IHsgcnVuIH0gZnJvbSBcIkBjeWNsZS9ydW5cIjtcbmltcG9ydCB7IG1ha2VIYW5kVHJhY2tEcml2ZXIgfSBmcm9tIFwiY3ljbGUtaGFuZHRyYWNrLWRyaXZlclwiO1xuXG5mdW5jdGlvbiBtYWluKHNvdXJjZXMpIHtcbiAgc291cmNlcy5IYW5kVHJhY2suYWRkTGlzdGVuZXIoeyBuZXh0OiBjb25zb2xlLmxvZyB9KTtcblxuICBjb25zdCB2ZG9tJCA9IHhzXG4gICAgLm9mKFxuICAgICAgZGl2KFwiLmhhbmR0cmFja1wiLCBbXG4gICAgICAgICxcbiAgICAgICAgdmlkZW8oXCIuaGFuZHRyYWNrLXZpZGVvXCIsIHtcbiAgICAgICAgICBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiwgdHJhbnNmb3JtOiBcInJvdGF0ZVkoMTgwZGVnKVwiIH1cbiAgICAgICAgfSksXG4gICAgICAgIGNhbnZhcyhcIi5oYW5kdHJhY2stY2FudmFzXCIpXG4gICAgICBdKVxuICAgIClcbiAgICAuc3RhcnRXaXRoKFwiXCIpO1xuICBjb25zdCBjb21tYW5kJCA9IHhzXG4gICAgLmNvbWJpbmUoXG4gICAgICBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuaGFuZHRyYWNrLXZpZGVvXCIpXG4gICAgICAgIC5lbGVtZW50KClcbiAgICAgICAgLnRha2UoMSksXG4gICAgICBzb3VyY2VzLkRPTS5zZWxlY3QoXCIuaGFuZHRyYWNrLWNhbnZhc1wiKVxuICAgICAgICAuZWxlbWVudCgpXG4gICAgICAgIC50YWtlKDEpXG4gICAgKVxuICAgIC5tYXAoeCA9PiAoeyB0eXBlOiBcInN0YXJ0XCIsIGVsZW1zOiB4IH0pKTtcbiAgcmV0dXJuIHtcbiAgICBET006IHZkb20kLFxuICAgIEhhbmRUcmFjazogY29tbWFuZCRcbiAgfTtcbn1cblxucnVuKG1haW4sIHtcbiAgRE9NOiBtYWtlRE9NRHJpdmVyKFwiI2FwcFwiKSxcbiAgSGFuZFRyYWNrOiBtYWtlSGFuZFRyYWNrRHJpdmVyKClcbn0pO1xuIl19
